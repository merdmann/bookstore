import { Browser, ChildProperty, Component, Event, EventHandler, L10n, NotifyPropertyChanges, Property, classList, createElement, isBlazor, isNullOrUndefined } from '@syncfusion/ej2-base';
import { Save, StreamWriter, XmlWriter } from '@syncfusion/ej2-file-utils';
import { Button, CheckBox, RadioButton } from '@syncfusion/ej2-buttons';
import { ListView } from '@syncfusion/ej2-lists';
import { Dialog, DialogUtility, Popup, Tooltip, createSpinner, hideSpinner, showSpinner } from '@syncfusion/ej2-popups';
import { ContextMenu, Tab, Toolbar } from '@syncfusion/ej2-navigations';
import { ChartComponent } from '@syncfusion/ej2-office-chart';
import { DropDownButton, SplitButton } from '@syncfusion/ej2-splitbuttons';
import { ZipArchive, ZipArchiveItem } from '@syncfusion/ej2-compression';
import { ComboBox, DropDownList } from '@syncfusion/ej2-dropdowns';
import { ColorPicker, NumericTextBox } from '@syncfusion/ej2-inputs';
import { Query } from '@syncfusion/ej2-data';

/**
 * @private
 */
class Dictionary {
    constructor() {
        this.keysInternal = [];
        this.valuesInternal = [];
    }
    /**
     * @private
     */
    get length() {
        return this.keysInternal.length;
    }
    /**
     * @private
     */
    get keys() {
        return this.keysInternal;
    }
    /**
     * @private
     */
    add(key, value) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key or value is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        // if (index < 0 || index > this.keysInternal.length - 1) {
        if (index < 0) {
            this.keysInternal.push(key);
            this.valuesInternal.push(value);
        }
        return 1;
        // else {
        //     throw new RangeError('An item with the same key has already been added.');
        // }
    }
    /**
     * @private
     */
    get(key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            return this.valuesInternal[index];
        }
    }
    /**
     * @private
     */
    set(key, value) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            this.valuesInternal[index] = value;
        }
    }
    /**
     * @private
     */
    remove(key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            throw new RangeError('No item with the specified key has been added.');
        }
        else {
            this.keysInternal.splice(index, 1);
            this.valuesInternal.splice(index, 1);
            return true;
        }
    }
    /**
     * @private
     */
    containsKey(key) {
        if (isNullOrUndefined(key)) {
            throw new ReferenceError('Provided key is not valid.');
        }
        let index = this.keysInternal.indexOf(key);
        if (index < 0 || index > this.keysInternal.length - 1) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    clear() {
        this.keysInternal = [];
        this.valuesInternal = [];
    }
    /**
     * @private
     */
    destroy() {
        this.clear();
        this.keysInternal = undefined;
        this.valuesInternal = undefined;
    }
}

/**
 * @private
 */
class WUniqueFormat {
    constructor(type) {
        this.referenceCount = 0;
        this.uniqueFormatType = type;
        this.propertiesHash = new Dictionary();
    }
    /**
     * @private
     */
    isEqual(source, property, modifiedValue) {
        let isEqual = false;
        switch (this.uniqueFormatType) {
            case 1:
                isEqual = this.isBorderEqual(source, property, modifiedValue);
                break;
            case 2:
                isEqual = this.isCharacterFormatEqual(source, property, modifiedValue);
                break;
            case 3:
                isEqual = this.isParagraphFormatEqual(source, property, modifiedValue);
                break;
            case 4:
                isEqual = this.isCellFormatEqual(source, property, modifiedValue);
                break;
            case 5:
                isEqual = this.isShadingEqual(source, property, modifiedValue);
                break;
            case 6:
                isEqual = this.isRowFormatEqual(source, property, modifiedValue);
                break;
            case 7:
                isEqual = this.isListFormatEqual(source, property, modifiedValue);
                break;
            case 8:
                isEqual = this.isTableFormatEqual(source, property, modifiedValue);
                break;
            case 9:
                isEqual = this.isListLevelEqual(source, property, modifiedValue);
                break;
            case 10:
                isEqual = this.isSectionFormatEqual(source, property, modifiedValue);
                break;
            default:
                break;
        }
        return isEqual;
    }
    // tslint:disable-next-line:max-line-length
    isNotEqual(property, source, modifiedProperty, modifiedValue, uniqueFormatType) {
        let targetValue = undefined;
        let propertyType = WUniqueFormat.getPropertyType(uniqueFormatType, property);
        if (this.propertiesHash.containsKey(propertyType)) {
            targetValue = this.propertiesHash.get(propertyType);
        }
        let sourceValue = undefined;
        if (property === modifiedProperty) {
            sourceValue = modifiedValue;
        }
        else if (source.containsKey(propertyType)) {
            sourceValue = source.get(propertyType);
        }
        // tslint:disable-next-line:max-line-length
        if (!(targetValue === sourceValue || (!isNullOrUndefined(targetValue) && !isNullOrUndefined(sourceValue) && targetValue === sourceValue))) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    static getPropertyType(uniqueFormatType, property) {
        let type = 0;
        switch (uniqueFormatType) {
            case 1:
                type = this.getBorderPropertyType(property);
                break;
            case 2:
                type = this.getCharacterFormatPropertyType(property);
                break;
            case 3:
                type = this.getParaFormatPropertyType(property);
                break;
            case 4:
                type = this.getCellFormatPropertyType(property);
                break;
            case 5:
                type = this.getShadingPropertyType(property);
                break;
            case 6:
                type = this.getRowFormatType(property);
                break;
            case 7:
                type = this.getListFormatType(property);
                break;
            case 8:
                type = this.getTableFormatType(property);
                break;
            case 9:
                type = this.getListLevelType(property);
                break;
            case 10:
                type = this.getSectionFormatType(property);
                break;
            default:
                break;
        }
        return type;
    }
    static getRowFormatType(property) {
        if (property === 'allowBreakAcrossPages') {
            return 1;
        }
        if (property === 'isHeader') {
            return 2;
        }
        if (property === 'height') {
            return 3;
        }
        if (property === 'heightType') {
            return 4;
        }
        if (property === 'gridBefore') {
            return 5;
        }
        if (property === 'gridBeforeWidth') {
            return 6;
        }
        if (property === 'gridBeforeWidthType') {
            return 7;
        }
        if (property === 'gridAfter') {
            return 8;
        }
        if (property === 'gridAfterWidth') {
            return 9;
        }
        if (property === 'gridAfterWidthType') {
            return 10;
        }
        if (property === 'leftMargin') {
            return 11;
        }
        if (property === 'topMargin') {
            return 12;
        }
        if (property === 'bottomMargin') {
            return 13;
        }
        if (property === 'rightMargin') {
            return 14;
        }
        if (property === 'leftIndent') {
            return 15;
        }
        return 0;
    }
    static getListFormatType(property) {
        if (property === 'listId') {
            return 1;
        }
        if (property === 'listLevelNumber') {
            return 2;
        }
        return 0;
    }
    static getTableFormatType(property) {
        if (property === 'leftMargin') {
            return 1;
        }
        if (property === 'rightMargin') {
            return 2;
        }
        if (property === 'topMargin') {
            return 3;
        }
        if (property === 'bottomMargin') {
            return 4;
        }
        if (property === 'cellSpacing') {
            return 5;
        }
        if (property === 'leftIndent') {
            return 6;
        }
        if (property === 'tableAlignment') {
            return 7;
        }
        if (property === 'preferredWidth') {
            return 8;
        }
        if (property === 'preferredWidthType') {
            return 9;
        }
        if (property === 'bidi') {
            return 10;
        }
        if (property === 'allowAutoFit') {
            return 11;
        }
        return 0;
    }
    static getListLevelType(property) {
        if (property === 'listLevelPattern') {
            return 1;
        }
        if (property === 'startAt') {
            return 2;
        }
        if (property === 'followCharacter') {
            return 3;
        }
        if (property === 'numberFormat') {
            return 4;
        }
        if (property === 'restartLevel') {
            return 5;
        }
        return 0;
    }
    static getShadingPropertyType(property) {
        if (property === 'backgroundColor') {
            return 1;
        }
        if (property === 'foregroundColor') {
            return 2;
        }
        if (property === 'textureStyle') {
            return 3;
        }
        return 0;
    }
    static getCellFormatPropertyType(property) {
        if (property === 'leftMargin') {
            return 1;
        }
        if (property === 'rightMargin') {
            return 2;
        }
        if (property === 'topMargin') {
            return 3;
        }
        if (property === 'bottomMargin') {
            return 4;
        }
        if (property === 'columnSpan') {
            return 5;
        }
        if (property === 'rowSpan') {
            return 6;
        }
        if (property === 'verticalAlignment') {
            return 7;
        }
        if (property === 'preferredWidthType') {
            return 8;
        }
        if (property === 'preferredWidth') {
            return 9;
        }
        if (property === 'cellWidth') {
            return 10;
        }
        return 0;
    }
    static getBorderPropertyType(property) {
        if (property === 'color') {
            return 1;
        }
        if (property === 'lineStyle') {
            return 2;
        }
        if (property === 'lineWidth') {
            return 3;
        }
        if (property === 'shadow') {
            return 4;
        }
        if (property === 'space') {
            return 5;
        }
        if (property === 'hasNoneStyle') {
            return 6;
        }
        return 0;
    }
    static getCharacterFormatPropertyType(property) {
        if (property === 'fontColor') {
            return 1;
        }
        if (property === 'fontFamily') {
            return 2;
        }
        if (property === 'fontSize') {
            return 3;
        }
        if (property === 'bold') {
            return 4;
        }
        if (property === 'italic') {
            return 5;
        }
        if (property === 'underline') {
            return 6;
        }
        if (property === 'strikethrough') {
            return 7;
        }
        if (property === 'baselineAlignment') {
            return 8;
        }
        if (property === 'highlightColor') {
            return 9;
        }
        if (property === 'bidi') {
            return 10;
        }
        if (property === 'bdo') {
            return 11;
        }
        if (property === 'boldBidi') {
            return 12;
        }
        if (property === 'italicBidi') {
            return 13;
        }
        if (property === 'fontFamilyBidi') {
            return 14;
        }
        if (property === 'fontSizeBidi') {
            return 15;
        }
        return 0;
    }
    static getParaFormatPropertyType(property) {
        if (property === 'leftIndent') {
            return 1;
        }
        if (property === 'rightIndent') {
            return 2;
        }
        if (property === 'firstLineIndent') {
            return 3;
        }
        if (property === 'textAlignment') {
            return 4;
        }
        if (property === 'beforeSpacing') {
            return 5;
        }
        if (property === 'afterSpacing') {
            return 6;
        }
        if (property === 'lineSpacing') {
            return 7;
        }
        if (property === 'lineSpacingType') {
            return 8;
        }
        if (property === 'outlineLevel') {
            return 9;
        }
        if (property === 'bidi') {
            return 10;
        }
        if (property === 'contextualSpacing') {
            return 11;
        }
        return 0;
    }
    static getSectionFormatType(property) {
        if (property === 'headerDistance') {
            return 1;
        }
        if (property === 'footerDistance') {
            return 2;
        }
        if (property === 'differentFirstPage') {
            return 3;
        }
        if (property === 'differentOddAndEvenPages') {
            return 4;
        }
        if (property === 'pageWidth') {
            return 5;
        }
        if (property === 'pageHeight') {
            return 6;
        }
        if (property === 'leftMargin') {
            return 7;
        }
        if (property === 'topMargin') {
            return 8;
        }
        if (property === 'rightMargin') {
            return 9;
        }
        if (property === 'bottomMargin') {
            return 10;
        }
        if (property === 'bidi') {
            return 11;
        }
        if (property === 'restartPageNumbering') {
            return 12;
        }
        if (property === 'pageStartingNumber') {
            return 13;
        }
        return 0;
    }
    /**
     * @private
     */
    isBorderEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('color', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('lineStyle', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('lineWidth', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('shadow', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('space', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        if (this.isNotEqual('hasNoneStyle', source, modifiedProperty, modifiedValue, 1)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isCharacterFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('fontColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontFamily', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontSize', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('bold', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('italic', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('underline', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('strikethrough', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('baselineAlignment', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('highlightColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('bdo', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontColor', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontFamilyBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('fontSizeBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('boldBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        if (this.isNotEqual('italicBidi', source, modifiedProperty, modifiedValue, 2)) {
            return false;
        }
        return true;
    }
    isParagraphFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('rightIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('firstLineIndent', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('textAlignment', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('beforeSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('afterSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('lineSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('lineSpacingType', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('outlineLevel', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        if (this.isNotEqual('contextualSpacing', source, modifiedProperty, modifiedValue, 3)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isCellFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('columnSpan', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('rowSpan', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('verticalAlignment', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('preferredWidthType', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('preferredWidth', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        if (this.isNotEqual('cellWidth', source, modifiedProperty, modifiedValue, 4)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isShadingEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('backgroundColor', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        if (this.isNotEqual('foregroundColor', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        if (this.isNotEqual('textureStyle', source, modifiedProperty, modifiedValue, 5)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isRowFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('allowBreakAcrossPages', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('isHeader', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('height', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('heightType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBefore', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBeforeWidth', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridBeforeWidthType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfter', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfterWidth', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('gridAfterWidthType', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 6)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isListFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('listId', source, modifiedProperty, modifiedValue, 7)) {
            return false;
        }
        if (this.isNotEqual('listLevelNumber', source, modifiedProperty, modifiedValue, 7)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isTableFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('cellSpacing', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('leftIndent', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('tableAlignment', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('preferredWidth', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('preferredWidthType', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        if (this.isNotEqual('allowAutoFit', source, modifiedProperty, modifiedValue, 8)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isListLevelEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('listLevelPattern', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('startAt', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('followCharacter', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('numberFormat', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        if (this.isNotEqual('restartLevel', source, modifiedProperty, modifiedValue, 9)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    isSectionFormatEqual(source, modifiedProperty, modifiedValue) {
        if (this.isNotEqual('headerDistance', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('footerDistance', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('differentFirstPage', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('differentOddAndEvenPages', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageWidth', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageHeight', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('leftMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('topMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('rightMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('bottomMargin', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('bidi', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('restartPageNumbering', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        if (this.isNotEqual('pageStartingNumber', source, modifiedProperty, modifiedValue, 10)) {
            return false;
        }
        return true;
    }
    /**
     * @private
     */
    cloneItems(format, property, value, uniqueFormatType) {
        let propertyType = WUniqueFormat.getPropertyType(uniqueFormatType, property);
        let keys = format.propertiesHash.keys;
        for (let i = 0; i < keys.length; i++) {
            if (keys[i] === propertyType) {
                this.propertiesHash.add(propertyType, value);
            }
            else {
                this.propertiesHash.add(keys[i], format.propertiesHash.get(keys[i]));
            }
        }
        if (!format.propertiesHash.containsKey(propertyType)) {
            this.propertiesHash.add(propertyType, value);
        }
    }
    /**
     * @private
     */
    mergeProperties(format) {
        let hash = format.cloneProperties();
        let keys = this.propertiesHash.keys;
        for (let i = 0; i < keys.length; i++) {
            if (!hash.containsKey(keys[i])) {
                hash.add(keys[i], this.propertiesHash.get(keys[i]));
            }
        }
        return hash;
    }
    /**
     * @private
     */
    cloneProperties() {
        let hash = new Dictionary();
        let keys = this.propertiesHash.keys;
        for (let i = 0; i < keys.length; i++) {
            hash.add(keys[i], this.propertiesHash.get(keys[i]));
        }
        return hash;
    }
    // public cloneItemsInternal(format: WUniqueFormat): void {
    //     let keys: number[] = format.propertiesHash.getItem();
    //     for (let i: number = 0; i < keys.length; i++) {
    //         this.propertiesHash.add(keys[i], format.propertiesHash.get(keys[i]));
    //     }
    //     this.referenceCount = format.referenceCount;
    // }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.propertiesHash)) {
            this.propertiesHash.destroy();
        }
        this.propertiesHash = undefined;
        this.referenceCount = undefined;
        this.uniqueFormatType = undefined;
    }
}

/**
 * @private
 */
class WUniqueFormats {
    constructor() {
        this.items = [];
    }
    /**
     * @private
     */
    addUniqueFormat(format, type) {
        let matchedFormat = undefined;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].isEqual(format, undefined, undefined)) {
                matchedFormat = this.items[i];
                break;
            }
        }
        if (isNullOrUndefined(matchedFormat)) {
            matchedFormat = new WUniqueFormat(type);
            matchedFormat.propertiesHash = format;
            matchedFormat.referenceCount = 1;
            this.items.push(matchedFormat);
        }
        else {
            matchedFormat.referenceCount++;
        }
        return matchedFormat;
    }
    /**
     * @private
     */
    updateUniqueFormat(uniqueFormat, property, value) {
        let matchedFormat = undefined;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].isEqual(uniqueFormat.propertiesHash, property, value)) {
                matchedFormat = this.items[i];
                break;
            }
        }
        if (isNullOrUndefined(matchedFormat)) {
            matchedFormat = new WUniqueFormat(uniqueFormat.uniqueFormatType);
            matchedFormat.cloneItems(uniqueFormat, property, value, uniqueFormat.uniqueFormatType);
            matchedFormat.referenceCount = 1;
            this.items.push(matchedFormat);
        }
        else {
            matchedFormat.referenceCount++;
        }
        this.remove(uniqueFormat);
        uniqueFormat = undefined;
        return matchedFormat;
    }
    /**
     * @private
     */
    remove(uniqueFormat) {
        uniqueFormat.referenceCount--;
        if (uniqueFormat.referenceCount <= 0) {
            this.items.splice(this.items.indexOf(uniqueFormat), 1);
            uniqueFormat.destroy();
            uniqueFormat = undefined;
        }
    }
    /**
     * @private
     */
    clear() {
        if (isNullOrUndefined(this.items)) {
            for (let i = 0; i < this.items.length; i++) {
                this.items[i].destroy();
            }
        }
        this.items = [];
    }
    /**
     * @private
     */
    destroy() {
        this.clear();
        this.items = undefined;
    }
}

/**
 * @private
 */
class XmlHttpRequestHandler {
    constructor() {
        /**
         * A boolean value indicating whether the request should be sent asynchronous or not.
         * @default true
         */
        this.mode = true;
    }
    /**
     * Send the request to server
     * @param  {object} jsonObject - To send to service
     */
    send(jsonObject) {
        this.xmlHttpRequest = new XMLHttpRequest();
        this.xmlHttpRequest.onreadystatechange = () => { this.stateChange(this); };
        this.xmlHttpRequest.onerror = () => { this.error(this); };
        if (!this.mode) {
            setTimeout(() => { this.sendRequest(jsonObject); });
        }
        else {
            this.sendRequest(jsonObject);
        }
    }
    sendRequest(jsonObj) {
        this.xmlHttpRequest.open('POST', this.url, true);
        if (this.contentType) {
            this.xmlHttpRequest.setRequestHeader('Content-Type', this.contentType);
        }
        this.setCustomAjaxHeaders();
        if (this.responseType) {
            this.xmlHttpRequest.responseType = this.responseType;
        }
        let data = jsonObj instanceof FormData ? jsonObj : JSON.stringify(jsonObj);
        this.xmlHttpRequest.send(data); // jshint ignore:line
    }
    stateChange(proxyReq) {
        if (proxyReq.xmlHttpRequest.readyState === 4 && proxyReq.xmlHttpRequest.status === 200) {
            // tslint:disable-next-line
            let data;
            if (this.responseType) {
                data = proxyReq.xmlHttpRequest.response;
            }
            else {
                data = proxyReq.xmlHttpRequest.responseText;
            }
            // tslint:disable-next-line
            let result = {
                name: 'onSuccess',
                data: data,
                readyState: proxyReq.xmlHttpRequest.readyState,
                status: proxyReq.xmlHttpRequest.status
            };
            proxyReq.successHandler(result);
        }
        else if (proxyReq.xmlHttpRequest.readyState === 4 && proxyReq.xmlHttpRequest.status === 400) { // jshint ignore:line)
            // tslint:disable-next-line
            let result = {
                name: 'onFailure',
                status: proxyReq.xmlHttpRequest.status,
                statusText: proxyReq.xmlHttpRequest.statusText
            };
            proxyReq.failureHandler(result);
        }
    }
    error(proxyReq) {
        // tslint:disable-next-line
        let result = {
            name: 'onError',
            status: this.xmlHttpRequest.status,
            statusText: this.xmlHttpRequest.statusText
        };
        proxyReq.errorHandler(result);
    }
    // tslint:disable-next-line
    successHandler(response) {
        if (this.onSuccess) {
            this.onSuccess(response);
        }
        return response;
    }
    // tslint:disable-next-line
    failureHandler(response) {
        if (this.onFailure) {
            this.onFailure(response);
        }
        return response;
    }
    // tslint:disable-next-line
    errorHandler(response) {
        if (this.onError) {
            this.onError(response);
        }
        return response;
    }
    setCustomAjaxHeaders() {
        for (let i = 0; i < this.customHeaders.length; i++) {
            let header = this.customHeaders[i];
            for (let key of Object.keys(header)) {
                this.xmlHttpRequest.setRequestHeader(key, header[key]);
            }
        }
    }
}

/**
 * @private
 */
class WSectionFormat {
    constructor(node) {
        this.uniqueSectionFormat = undefined;
        this.ownerBase = node;
    }
    get headerDistance() {
        return this.getPropertyValue('headerDistance');
    }
    set headerDistance(value) {
        this.setPropertyValue('headerDistance', value);
    }
    get footerDistance() {
        return this.getPropertyValue('footerDistance');
    }
    set footerDistance(value) {
        this.setPropertyValue('footerDistance', value);
    }
    get differentFirstPage() {
        return this.getPropertyValue('differentFirstPage');
    }
    set differentFirstPage(value) {
        this.setPropertyValue('differentFirstPage', value);
    }
    get differentOddAndEvenPages() {
        return this.getPropertyValue('differentOddAndEvenPages');
    }
    set differentOddAndEvenPages(value) {
        this.setPropertyValue('differentOddAndEvenPages', value);
    }
    get pageHeight() {
        return this.getPropertyValue('pageHeight');
    }
    set pageHeight(value) {
        this.setPropertyValue('pageHeight', value);
    }
    get rightMargin() {
        return this.getPropertyValue('rightMargin');
    }
    set rightMargin(value) {
        this.setPropertyValue('rightMargin', value);
    }
    get pageWidth() {
        return this.getPropertyValue('pageWidth');
    }
    set pageWidth(value) {
        this.setPropertyValue('pageWidth', value);
    }
    get leftMargin() {
        return this.getPropertyValue('leftMargin');
    }
    set leftMargin(value) {
        this.setPropertyValue('leftMargin', value);
    }
    get bottomMargin() {
        return this.getPropertyValue('bottomMargin');
    }
    set bottomMargin(value) {
        this.setPropertyValue('bottomMargin', value);
    }
    get topMargin() {
        return this.getPropertyValue('topMargin');
    }
    set topMargin(value) {
        this.setPropertyValue('topMargin', value);
    }
    get bidi() {
        return this.getPropertyValue('bidi');
    }
    set bidi(value) {
        this.setPropertyValue('bidi', value);
    }
    get restartPageNumbering() {
        return this.getPropertyValue('restartPageNumbering');
    }
    set restartPageNumbering(value) {
        this.setPropertyValue('restartPageNumbering', value);
    }
    get pageStartingNumber() {
        return this.getPropertyValue('pageStartingNumber');
    }
    set pageStartingNumber(value) {
        this.setPropertyValue('pageStartingNumber', value);
    }
    destroy() {
        if (!isNullOrUndefined(this.uniqueSectionFormat)) {
            WSectionFormat.uniqueSectionFormats.remove(this.uniqueSectionFormat);
        }
        this.uniqueSectionFormat = undefined;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueSectionFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueSectionFormat.uniqueFormatType, property);
            return this.uniqueSectionFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'headerDistance':
                value = 36;
                break;
            case 'footerDistance':
                value = 36;
                break;
            case 'differentFirstPage':
                value = false;
                break;
            case 'differentOddAndEvenPages':
                value = false;
                break;
            case 'pageWidth':
                value = 612;
                break;
            case 'pageHeight':
                value = 792;
                break;
            case 'leftMargin':
                value = 72;
                break;
            case 'topMargin':
                value = 72;
                break;
            case 'rightMargin':
                value = 72;
                break;
            case 'bottomMargin':
                value = 72;
                break;
            case 'bidi':
                value = false;
                break;
            case 'restartPageNumbering':
                value = false;
                break;
            case 'pageStartingNumber':
                value = 0;
                break;
        }
        return value;
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WSectionFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueSectionFormat) && this.uniqueSectionFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueSectionFormat.propertiesHash.get(propertyType);
            }
        }
        return WSectionFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WSectionFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueSectionFormat)) {
            this.initializeUniqueSectionFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueSectionFormat.uniqueFormatType, property);
            if (this.uniqueSectionFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueSectionFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.updateUniqueFormat(this.uniqueSectionFormat, property, value);
        }
    }
    initializeUniqueSectionFormat(property, propValue) {
        let uniqueSectionFormatTemp = new Dictionary();
        this.addUniqueSectionFormat('headerDistance', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('footerDistance', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('differentFirstPage', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('differentOddAndEvenPages', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageWidth', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageHeight', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('leftMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('topMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('rightMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('bottomMargin', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('bidi', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('restartPageNumbering', property, propValue, uniqueSectionFormatTemp);
        this.addUniqueSectionFormat('pageStartingNumber', property, propValue, uniqueSectionFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.addUniqueFormat(uniqueSectionFormatTemp, WSectionFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueSectionFormat(property, modifiedProperty, propValue, uniqueSectionFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WSectionFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueSectionFormatTemp.add(propertyType, propValue);
        }
        else {
            uniqueSectionFormatTemp.add(propertyType, WSectionFormat.getPropertyDefaultValue(property));
        }
    }
    copyFormat(format, history) {
        if (history && (history.isUndoing || history.isRedoing)) {
            this.uniqueSectionFormat = format.uniqueSectionFormat;
        }
        else {
            if (!isNullOrUndefined(format)) {
                if (!isNullOrUndefined(format.uniqueSectionFormat) && format.uniqueSectionFormat.propertiesHash) {
                    this.updateUniqueSectionFormat(format);
                }
            }
        }
    }
    updateUniqueSectionFormat(format) {
        let hash = undefined;
        if (this.uniqueSectionFormat) {
            hash = this.uniqueSectionFormat.mergeProperties(format.uniqueSectionFormat);
            if (this.uniqueSectionFormat.referenceCount === 0) {
                WSectionFormat.uniqueSectionFormats.remove(this.uniqueSectionFormat);
                this.uniqueSectionFormat = undefined;
            }
        }
        this.uniqueSectionFormat = new WUniqueFormat(WSectionFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueSectionFormat.mergeProperties(format.uniqueSectionFormat);
        }
        this.uniqueSectionFormat = WSectionFormat.uniqueSectionFormats.addUniqueFormat(hash, WSectionFormat.uniqueFormatType);
    }
    cloneFormat() {
        let format = new WSectionFormat();
        format.uniqueSectionFormat = this.uniqueSectionFormat;
        return format;
    }
    static clear() {
        this.uniqueSectionFormats.clear();
    }
}
WSectionFormat.uniqueSectionFormats = new WUniqueFormats();
WSectionFormat.uniqueFormatType = 10;

/**
 * @private
 */
class WLevelOverride {
    destroy() {
        if (!isNullOrUndefined(this.overrideListLevel)) {
            this.overrideListLevel.destroy();
        }
        this.levelNumber = undefined;
        this.startAt = undefined;
        this.overrideListLevel = undefined;
    }
}

/**
 * @private
 */
class WList {
    constructor() {
        this.listId = -1;
        this.sourceListId = -1;
        this.abstractListId = -1;
        this.abstractList = undefined;
        this.levelOverrides = [];
    }
    getListLevel(levelNumber) {
        let listLevel = undefined;
        let levelOverride = this.getLevelOverride(levelNumber);
        if (!isNullOrUndefined(levelOverride) && !isNullOrUndefined(levelOverride.overrideListLevel)) {
            listLevel = levelOverride.overrideListLevel;
        }
        else {
            listLevel = this.abstractList.levels[levelNumber];
        }
        return listLevel;
    }
    getLevelOverride(levelNumber) {
        for (let i = 0; i < this.levelOverrides.length; i++) {
            if (this.levelOverrides[i] instanceof WLevelOverride) {
                let levelOverride = this.levelOverrides[i];
                if (levelOverride.levelNumber === levelNumber) {
                    return levelOverride;
                }
            }
        }
        return undefined;
    }
    destroy() {
        if (!isNullOrUndefined(this.levelOverrides)) {
            this.levelOverrides = [];
        }
        this.abstractListId = undefined;
        this.listId = undefined;
        this.sourceListId = undefined;
        this.levelOverrides = undefined;
    }
    mergeList(list) {
        if (!isNullOrUndefined(this.abstractListId) && this.abstractListId !== -1) {
            this.abstractListId = list.abstractListId;
        }
        if (!isNullOrUndefined(this.listId) && this.listId !== -1) {
            this.listId = list.listId;
        }
        if (!isNullOrUndefined(this.sourceListId) && this.sourceListId !== -1) {
            this.sourceListId = list.sourceListId;
        }
        if (!isNullOrUndefined(this.levelOverrides) && this.levelOverrides.length !== 0) {
            this.levelOverrides = list.levelOverrides;
        }
    }
}

/**
 * @private
 */
class WListFormat {
    constructor(node) {
        this.uniqueListFormat = undefined;
        this.ownerBase = undefined;
        this.baseStyle = undefined;
        this.list = undefined;
        this.ownerBase = node;
    }
    get listId() {
        return this.getPropertyValue('listId');
    }
    set listId(listId) {
        this.setPropertyValue('listId', listId);
    }
    get listLevelNumber() {
        return this.getPropertyValue('listLevelNumber');
    }
    set listLevelNumber(value) {
        this.setPropertyValue('listLevelNumber', value);
    }
    get listLevel() {
        let list = undefined;
        if (!isNullOrUndefined(this.list)) {
            list = this.list;
        }
        else {
            /* tslint:disable-next-line:no-any */
            let baseListStyle = this.baseStyle;
            while (!isNullOrUndefined(baseListStyle)) {
                if (baseListStyle.paragraphFormat.listFormat.list) {
                    list = baseListStyle.paragraphFormat.listFormat.list;
                    break;
                }
                else {
                    baseListStyle = baseListStyle.basedOn;
                }
            }
        }
        if (!isNullOrUndefined(list)) {
            return list.getListLevel(this.listLevelNumber);
        }
        else {
            return undefined;
        }
    }
    getPropertyValue(property) {
        if (!this.hasValue(property)) {
            if (this.baseStyle instanceof WParagraphStyle) {
                /* tslint:disable-next-line:no-any */
                let baseStyle = this.baseStyle;
                while (!isNullOrUndefined(baseStyle)) {
                    if (baseStyle.paragraphFormat.listFormat.hasValue(property)) {
                        break;
                    }
                    else {
                        baseStyle = baseStyle.basedOn;
                    }
                }
                if (!isNullOrUndefined(baseStyle)) {
                    let propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
                    return baseStyle.paragraphFormat.listFormat.uniqueListFormat.propertiesHash.get(propertyType);
                }
            }
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueListFormat) && this.uniqueListFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueListFormat.propertiesHash.get(propertyType);
            }
        }
        return WListFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WListFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueListFormat)) {
            this.initializeUniqueListFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueListFormat.uniqueFormatType, property);
            if (this.uniqueListFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueListFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueListFormat = WListFormat.uniqueListFormats.updateUniqueFormat(this.uniqueListFormat, property, value);
        }
    }
    initializeUniqueListFormat(property, propValue) {
        let uniqueListFormatTemp = new Dictionary();
        this.addUniqueListFormat('listId', property, propValue, uniqueListFormatTemp);
        this.addUniqueListFormat('listLevelNumber', property, propValue, uniqueListFormatTemp);
        this.uniqueListFormat = WListFormat.uniqueListFormats.addUniqueFormat(uniqueListFormatTemp, WListFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueListFormat(property, modifiedProperty, propValue, uniqueListFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WListFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueListFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'listId':
                value = -1;
                break;
            case 'listLevelNumber':
                value = 0;
                break;
        }
        return value;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueListFormat)) {
                this.listId = format.listId;
                this.listLevelNumber = format.listLevelNumber;
            }
            if (!isNullOrUndefined(format.baseStyle)) {
                this.baseStyle = format.baseStyle;
            }
            if (!isNullOrUndefined(format.list)) {
                this.list = format.list;
            }
        }
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueListFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueListFormat.uniqueFormatType, property);
            return this.uniqueListFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    clearFormat() {
        if (!isNullOrUndefined(this.uniqueListFormat) && this.uniqueListFormat.referenceCount === 0) {
            WListFormat.uniqueListFormats.remove(this.uniqueListFormat);
        }
        this.uniqueListFormat = undefined;
        this.list = undefined;
    }
    destroy() {
        this.clearFormat();
    }
    static clear() {
        this.uniqueListFormats.clear();
    }
    ApplyStyle(baseStyle) {
        this.baseStyle = baseStyle;
    }
    /**
     * For internal use
     * @private
     */
    getValue(property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    }
    /**
     * For internal use
     * @private
     */
    mergeFormat(format) {
        if (isNullOrUndefined(this.getValue('listId'))) {
            this.listId = format.getValue('listId');
        }
        if (isNullOrUndefined(this.getValue('listLevelNumber'))) {
            this.listLevelNumber = format.getValue('listLevelNumber');
        }
        if (!isNullOrUndefined(format.list)) {
            if (isNullOrUndefined(this.list)) {
                this.list = new WList();
            }
            this.list.mergeList(format.list);
        }
    }
}
WListFormat.uniqueListFormats = new WUniqueFormats();
WListFormat.uniqueFormatType = 7;

/**
 * @private
 */
class WTabStop {
    get position() {
        return this.positionIn;
    }
    set position(value) {
        this.positionIn = value;
    }
    get deletePosition() {
        return this.deletePositionIn;
    }
    set deletePosition(value) {
        this.deletePositionIn = value;
    }
    get tabJustification() {
        return this.justification;
    }
    set tabJustification(value) {
        this.justification = value;
    }
    get tabLeader() {
        return this.leader;
    }
    set tabLeader(value) {
        this.leader = value;
    }
    destroy() {
        this.position = undefined;
        this.deletePosition = undefined;
        this.tabJustification = undefined;
        this.leader = undefined;
    }
}
/**
 * @private
 */
class WParagraphFormat {
    constructor(node) {
        this.uniqueParagraphFormat = undefined;
        this.ownerBase = undefined;
        this.baseStyle = undefined;
        this.tabs = undefined;
        this.ownerBase = node;
        this.listFormat = new WListFormat(this);
        this.tabs = [];
    }
    getUpdatedTabs() {
        let inTabs = [];
        if (!isNullOrUndefined(this.baseStyle)) {
            /* tslint:disable-next-line:no-any */
            let baseStyle = this.baseStyle;
            let tabStops = new Dictionary();
            while (!isNullOrUndefined(baseStyle)) {
                for (let tab of baseStyle.paragraphFormat.tabs) {
                    if (!tabStops.containsKey(tab.position)) {
                        tabStops.add(tab.position, tab);
                    }
                }
                baseStyle = baseStyle.basedOn;
            }
            for (let key of tabStops.keys) {
                if (!this.hasTabStop(parseFloat(key.toFixed(4)))) {
                    inTabs.push(tabStops.get(key));
                }
            }
            inTabs = inTabs.concat(this.tabs.filter((a) => (a.position !== 0 && a.deletePosition === 0)));
            inTabs = inTabs.sort((a, b) => a.position - b.position);
        }
        return inTabs;
    }
    hasTabStop(position) {
        for (let i = 0; i < this.tabs.length; i++) {
            if (parseFloat(this.tabs[i].position.toFixed(4)) === position ||
                parseFloat(this.tabs[i].deletePosition.toFixed(4)) === position) {
                return true;
            }
        }
        return false;
    }
    get leftIndent() {
        return this.getPropertyValue('leftIndent');
    }
    set leftIndent(value) {
        this.setPropertyValue('leftIndent', value);
    }
    get rightIndent() {
        return this.getPropertyValue('rightIndent');
    }
    set rightIndent(value) {
        this.setPropertyValue('rightIndent', value);
    }
    get firstLineIndent() {
        return this.getPropertyValue('firstLineIndent');
    }
    set firstLineIndent(value) {
        this.setPropertyValue('firstLineIndent', value);
    }
    get beforeSpacing() {
        return this.getPropertyValue('beforeSpacing');
    }
    set beforeSpacing(value) {
        this.setPropertyValue('beforeSpacing', value);
    }
    get afterSpacing() {
        return this.getPropertyValue('afterSpacing');
    }
    set afterSpacing(value) {
        this.setPropertyValue('afterSpacing', value);
    }
    get lineSpacing() {
        return this.getPropertyValue('lineSpacing');
    }
    set lineSpacing(value) {
        this.setPropertyValue('lineSpacing', value);
    }
    get lineSpacingType() {
        return this.getPropertyValue('lineSpacingType');
    }
    set lineSpacingType(value) {
        this.setPropertyValue('lineSpacingType', value);
    }
    get textAlignment() {
        return this.getPropertyValue('textAlignment');
    }
    set textAlignment(value) {
        this.setPropertyValue('textAlignment', value);
    }
    get outlineLevel() {
        return this.getPropertyValue('outlineLevel');
    }
    set outlineLevel(value) {
        this.setPropertyValue('outlineLevel', value);
    }
    get bidi() {
        return this.getPropertyValue('bidi');
    }
    set bidi(value) {
        if (this.bidi !== value) {
            if (this.textAlignment === 'Left') {
                this.textAlignment = 'Right';
            }
            else if (this.textAlignment === 'Right') {
                this.textAlignment = 'Left';
            }
        }
        this.setPropertyValue('bidi', value);
    }
    get contextualSpacing() {
        return this.getPropertyValue('contextualSpacing');
    }
    set contextualSpacing(value) {
        this.setPropertyValue('contextualSpacing', value);
    }
    getListFormatParagraphFormat(property) {
        let paragraphFormat = this.getListPargaraphFormat(property);
        if (!isNullOrUndefined(paragraphFormat)) {
            // tslint:disable-next-line:max-line-length
            return paragraphFormat.uniqueParagraphFormat.propertiesHash.get(WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property));
        }
        return undefined;
    }
    getListPargaraphFormat(property) {
        if (this.listFormat.listId > -1 && this.listFormat.listLevelNumber > -1) {
            let level = this.listFormat.listLevel;
            let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(level) && !isNullOrUndefined(level.paragraphFormat.uniqueParagraphFormat) &&
                level.paragraphFormat.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
                return level.paragraphFormat;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    getPropertyValue(property) {
        if (!this.hasValue(property)) {
            let formatInList = this.getListFormatParagraphFormat(property);
            if (this.baseStyle instanceof WParagraphStyle) {
                let currentFormat = this;
                /* tslint:disable-next-line:no-any */
                let baseStyle = this.baseStyle;
                while (!isNullOrUndefined(baseStyle)) {
                    let listParaFormat = baseStyle.paragraphFormat.getListPargaraphFormat(property);
                    if (baseStyle.paragraphFormat.hasValue(property)) {
                        currentFormat = baseStyle.paragraphFormat;
                        break;
                    }
                    else if (!isNullOrUndefined(listParaFormat) && listParaFormat.hasValue(property)) {
                        currentFormat = listParaFormat;
                        break;
                    }
                    else {
                        baseStyle = baseStyle.basedOn;
                    }
                }
                if (!isNullOrUndefined(baseStyle)) {
                    if (!isNullOrUndefined(formatInList) && this.listFormat.listId !== -1
                        && currentFormat.listFormat.listId === -1
                        || !isNullOrUndefined(formatInList) && this.listFormat.listId !== currentFormat.listFormat.listId) {
                        return formatInList;
                    }
                    let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
                    return currentFormat.uniqueParagraphFormat.propertiesHash.get(propertyType);
                }
            }
            if (!isNullOrUndefined(formatInList)) {
                return formatInList;
            }
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueParagraphFormat) && this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueParagraphFormat.propertiesHash.get(propertyType);
            }
        }
        return this.getDefaultValue(property);
    }
    getDefaultValue(property) {
        let propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
        let docParagraphFormat = this.documentParagraphFormat();
        let isInsideBodyWidget = true;
        if (this.ownerBase && this.ownerBase instanceof ParagraphWidget) {
            isInsideBodyWidget = this.ownerBase.containerWidget instanceof BodyWidget;
        }
        if (isInsideBodyWidget && !isNullOrUndefined(docParagraphFormat) && !isNullOrUndefined(docParagraphFormat.uniqueParagraphFormat) &&
            docParagraphFormat.uniqueParagraphFormat.propertiesHash.containsKey(propertyType)) {
            return docParagraphFormat.uniqueParagraphFormat.propertiesHash.get(propertyType);
        }
        else {
            return WParagraphFormat.getPropertyDefaultValue(property);
        }
    }
    documentParagraphFormat() {
        let docParagraphFormat;
        if (!isNullOrUndefined(this.ownerBase)) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.ownerBase.bodyWidget) && !isNullOrUndefined(this.ownerBase.bodyWidget.page)) {
                docParagraphFormat = this.ownerBase.bodyWidget.page.viewer.paragraphFormat;
            }
        }
        return docParagraphFormat;
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WParagraphFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueParagraphFormat)) {
            this.initializeUniqueParagraphFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueParagraphFormat.uniqueFormatType, property);
            if (this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueParagraphFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.updateUniqueFormat(this.uniqueParagraphFormat, property, value);
        }
    }
    initializeUniqueParagraphFormat(property, propValue) {
        let uniqueParaFormatTemp = new Dictionary();
        this.addUniqueParaFormat('leftIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('rightIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('firstLineIndent', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('textAlignment', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('beforeSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('afterSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('lineSpacing', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('lineSpacingType', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('outlineLevel', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('bidi', property, propValue, uniqueParaFormatTemp);
        this.addUniqueParaFormat('contextualSpacing', property, propValue, uniqueParaFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.addUniqueFormat(uniqueParaFormatTemp, WParagraphFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueParaFormat(property, modifiedProperty, propValue, uniqueParaFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WParagraphFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueParaFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'leftIndent':
                value = 0;
                break;
            case 'rightIndent':
                value = 0;
                break;
            case 'firstLineIndent':
                value = 0;
                break;
            case 'textAlignment':
                value = 'Left';
                break;
            case 'beforeSpacing':
                value = 0;
                break;
            case 'afterSpacing':
                value = 0;
                break;
            case 'lineSpacing':
                value = 1;
                break;
            case 'lineSpacingType':
                value = 'Multiple';
                break;
            case 'styleName':
                value = 'Normal';
                break;
            case 'outlineLevel':
                value = 'BodyText';
                break;
            case 'bidi':
                value = false;
                break;
            case 'contextualSpacing':
                value = false;
                break;
        }
        return value;
    }
    clearFormat() {
        if (!isNullOrUndefined(this.listFormat)) {
            this.listFormat.clearFormat();
        }
        if (!isNullOrUndefined(this.uniqueParagraphFormat) && this.uniqueParagraphFormat.referenceCount === 0) {
            WParagraphFormat.uniqueParagraphFormats.remove(this.uniqueParagraphFormat);
        }
        this.uniqueParagraphFormat = undefined;
        this.baseStyle = undefined;
    }
    destroy() {
        this.clearFormat();
        if (!isNullOrUndefined(this.listFormat)) {
            this.listFormat.destroy();
        }
        this.listFormat = undefined;
        if (this.tabs !== undefined) {
            for (let i = 0; i < this.tabs.length; i++) {
                this.tabs[i].destroy();
            }
            this.tabs = undefined;
        }
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueParagraphFormat)) {
                this.updateUniqueParagraphFormat(format);
            }
            if (!isNullOrUndefined(format.listFormat)) {
                this.listFormat.copyFormat(format.listFormat);
            }
            if (!isNullOrUndefined(format.baseStyle)) {
                this.baseStyle = format.baseStyle;
            }
            if (!isNullOrUndefined(format.tabs)) {
                for (let i = 0; i < format.tabs.length; i++) {
                    this.tabs[i] = format.tabs[i];
                }
            }
        }
    }
    updateUniqueParagraphFormat(format) {
        let hash = undefined;
        if (this.uniqueParagraphFormat) {
            hash = this.uniqueParagraphFormat.mergeProperties(format.uniqueParagraphFormat);
            if (this.uniqueParagraphFormat.referenceCount === 0) {
                WParagraphFormat.uniqueParagraphFormats.remove(this.uniqueParagraphFormat);
                this.uniqueParagraphFormat = undefined;
            }
        }
        this.uniqueParagraphFormat = new WUniqueFormat(WParagraphFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueParagraphFormat.mergeProperties(format.uniqueParagraphFormat);
        }
        this.uniqueParagraphFormat = WParagraphFormat.uniqueParagraphFormats.addUniqueFormat(hash, WParagraphFormat.uniqueFormatType);
    }
    cloneFormat() {
        let format = new WParagraphFormat(undefined);
        format.uniqueParagraphFormat = this.uniqueParagraphFormat;
        format.baseStyle = this.baseStyle;
        if (isNullOrUndefined(this.listFormat)) {
            format.listFormat = undefined;
        }
        else {
            format.listFormat = new WListFormat();
            format.listFormat.listId = this.listFormat.listId;
            format.listFormat.listLevelNumber = this.listFormat.listLevelNumber;
        }
        return format;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueParagraphFormat) && !isNullOrUndefined(this.uniqueParagraphFormat.propertiesHash)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueParagraphFormat.uniqueFormatType, property);
            return this.uniqueParagraphFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    static clear() {
        this.uniqueParagraphFormats.clear();
    }
    ApplyStyle(baseStyle) {
        this.baseStyle = baseStyle;
        this.listFormat.ApplyStyle(this.baseStyle);
    }
    /**
     * For internal use
     * @private
     */
    getValue(property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    }
    /**
     * For internal use
     * @private
     */
    mergeFormat(format, isStyle) {
        isStyle = isNullOrUndefined(isStyle) ? false : isStyle;
        if (isNullOrUndefined(this.getValue('leftIndent'))) {
            this.leftIndent = format.getValue('leftIndent');
        }
        if (isNullOrUndefined(this.getValue('rightIndent'))) {
            this.rightIndent = format.getValue('rightIndent');
        }
        if (isNullOrUndefined(this.getValue('firstLineIndent'))) {
            this.firstLineIndent = format.getValue('firstLineIndent');
        }
        if (isNullOrUndefined(this.getValue('beforeSpacing'))) {
            this.beforeSpacing = format.getValue('beforeSpacing');
        }
        if (isNullOrUndefined(this.getValue('afterSpacing'))) {
            this.afterSpacing = format.getValue('afterSpacing');
        }
        if (isNullOrUndefined(this.getValue('lineSpacing'))) {
            this.lineSpacing = format.getValue('lineSpacing');
        }
        if (isNullOrUndefined(this.getValue('lineSpacingType'))) {
            this.lineSpacingType = format.getValue('lineSpacingType');
        }
        if (isNullOrUndefined(this.getValue('textAlignment'))) {
            this.textAlignment = format.getValue('textAlignment');
        }
        if (isNullOrUndefined(this.getValue('outlineLevel'))) {
            this.outlineLevel = format.getValue('outlineLevel');
        }
        if (!isStyle && isNullOrUndefined(this.getValue('bidi'))) {
            this.bidi = format.getValue('bidi');
        }
        if (isNullOrUndefined(this.getValue('contextualSpacing'))) {
            this.contextualSpacing = format.getValue('contextualSpacing');
        }
        if (isNullOrUndefined(this.listFormat)) {
            this.listFormat.mergeFormat(format.listFormat);
        }
    }
}
WParagraphFormat.uniqueParagraphFormats = new WUniqueFormats();
WParagraphFormat.uniqueFormatType = 3;

/**
 * @private
 */
class WCharacterFormat {
    constructor(node) {
        this.uniqueCharacterFormat = undefined;
        this.ownerBase = undefined;
        this.baseCharStyle = undefined;
        this.ownerBase = node;
    }
    get bold() {
        return this.getPropertyValue('bold');
    }
    set bold(value) {
        this.setPropertyValue('bold', value);
    }
    get italic() {
        return this.getPropertyValue('italic');
    }
    set italic(value) {
        this.setPropertyValue('italic', value);
    }
    get fontSize() {
        return this.getPropertyValue('fontSize');
    }
    set fontSize(value) {
        this.setPropertyValue('fontSize', value);
    }
    get fontFamily() {
        return this.getPropertyValue('fontFamily');
    }
    set fontFamily(value) {
        this.setPropertyValue('fontFamily', value);
    }
    get underline() {
        return this.getPropertyValue('underline');
    }
    set underline(value) {
        this.setPropertyValue('underline', value);
    }
    get strikethrough() {
        return this.getPropertyValue('strikethrough');
    }
    set strikethrough(value) {
        this.setPropertyValue('strikethrough', value);
    }
    get baselineAlignment() {
        return this.getPropertyValue('baselineAlignment');
    }
    set baselineAlignment(value) {
        this.setPropertyValue('baselineAlignment', value);
    }
    get highlightColor() {
        return this.getPropertyValue('highlightColor');
    }
    set highlightColor(value) {
        this.setPropertyValue('highlightColor', value);
    }
    get fontColor() {
        return this.getPropertyValue('fontColor');
    }
    set fontColor(value) {
        this.setPropertyValue('fontColor', value);
    }
    get bidi() {
        return this.getPropertyValue('bidi');
    }
    set bidi(value) {
        this.setPropertyValue('bidi', value);
    }
    get bdo() {
        return this.getPropertyValue('bdo');
    }
    set bdo(value) {
        this.setPropertyValue('bdo', value);
    }
    get boldBidi() {
        return this.getPropertyValue('boldBidi');
    }
    set boldBidi(value) {
        this.setPropertyValue('boldBidi', value);
    }
    get italicBidi() {
        return this.getPropertyValue('italicBidi');
    }
    set italicBidi(value) {
        this.setPropertyValue('italicBidi', value);
    }
    get fontSizeBidi() {
        return this.getPropertyValue('fontSizeBidi');
    }
    set fontSizeBidi(value) {
        this.setPropertyValue('fontSizeBidi', value);
    }
    get fontFamilyBidi() {
        return this.getPropertyValue('fontFamilyBidi');
    }
    set fontFamilyBidi(value) {
        this.setPropertyValue('fontFamilyBidi', value);
    }
    getPropertyValue(property) {
        if (!this.hasValue(property)) {
            let charStyleValue = this.checkCharacterStyle(property);
            if (!isNullOrUndefined(charStyleValue)) {
                return charStyleValue;
            }
            else {
                if (!isNullOrUndefined(this.baseCharStyle)) {
                    /* tslint:disable-next-line:no-any */
                    let paragraph = this.ownerBase.paragraph;
                    let line = this.ownerBase.line;
                    if (!isNullOrUndefined(paragraph) && !isNullOrUndefined(line)) {
                        let length = line.children.length;
                        for (let i = 0; i < length; i++) {
                            /* tslint:disable-next-line:no-any */
                            let element = this.ownerBase.line.children[i];
                            if (element instanceof TextElementBox) {
                                /* tslint:disable-next-line:no-any */
                                let text = element.text;
                                if (text.startsWith('HYPERLINK')) {
                                    let index = text.indexOf('_Toc');
                                    if (index !== -1) {
                                        this.baseCharStyle = this.ownerBase.paragraph.paragraphFormat.baseStyle;
                                    }
                                }
                            }
                        }
                    }
                }
                let baseStyleValue = this.checkBaseStyle(property);
                if (!isNullOrUndefined(baseStyleValue)) {
                    return baseStyleValue;
                }
            }
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueCharacterFormat) && this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueCharacterFormat.propertiesHash.get(propertyType);
            }
        }
        return this.getDefaultValue(property);
    }
    getDefaultValue(property) {
        let propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
        let docCharacterFormat = this.documentCharacterFormat();
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(docCharacterFormat) && !isNullOrUndefined(docCharacterFormat.uniqueCharacterFormat) && docCharacterFormat.uniqueCharacterFormat.propertiesHash.containsKey(propertyType)) {
            return docCharacterFormat.uniqueCharacterFormat.propertiesHash.get(propertyType);
        }
        else {
            return WCharacterFormat.getPropertyDefaultValue(property);
        }
    }
    documentCharacterFormat() {
        let docCharacterFormat;
        if (!isNullOrUndefined(this.ownerBase)) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.ownerBase.paragraph) && !isNullOrUndefined(this.ownerBase.paragraph.bodyWidget)) {
                docCharacterFormat = this.ownerBase.paragraph.bodyWidget.page.viewer.characterFormat;
            }
            else {
                if (!isNullOrUndefined(this.ownerBase.bodyWidget)) {
                    docCharacterFormat = this.ownerBase.bodyWidget.page.viewer.characterFormat;
                }
            }
        }
        return docCharacterFormat;
    }
    checkBaseStyle(property) {
        /* tslint:disable-next-line:no-any */
        let baseStyle;
        if (!isNullOrUndefined(this.ownerBase)) {
            if (!isNullOrUndefined(this.ownerBase.paragraph)) {
                baseStyle = this.ownerBase.paragraph.paragraphFormat.baseStyle;
            }
            else {
                // tslint:disable-next-line:max-line-length
                if ((this.ownerBase instanceof ParagraphWidget) && !isNullOrUndefined(this.ownerBase.paragraphFormat)) {
                    baseStyle = this.ownerBase.paragraphFormat.baseStyle;
                }
                else {
                    if (!isNullOrUndefined(this.ownerBase instanceof WParagraphStyle)) {
                        baseStyle = this.ownerBase.basedOn;
                    }
                }
            }
        }
        while (!isNullOrUndefined(baseStyle)) {
            if (baseStyle.characterFormat.hasValue(property)) {
                break;
            }
            else {
                baseStyle = baseStyle.basedOn;
            }
        }
        if (!isNullOrUndefined(baseStyle)) {
            let propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
            return baseStyle.characterFormat.uniqueCharacterFormat.propertiesHash.get(propertyType);
        }
        return undefined;
    }
    checkCharacterStyle(property) {
        /* tslint:disable-next-line:no-any */
        let baseStyle = this.baseCharStyle;
        if (!isNullOrUndefined(baseStyle)) {
            while (!isNullOrUndefined(baseStyle) && baseStyle.name !== 'Default Paragraph Font') {
                let hasKey = baseStyle.characterFormat.hasValue(property);
                if (hasKey) {
                    let returnPropertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
                    return baseStyle.characterFormat.uniqueCharacterFormat.propertiesHash.get(returnPropertyType);
                }
                else {
                    baseStyle = baseStyle.basedOn;
                }
            }
        }
        return undefined;
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WCharacterFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueCharacterFormat)) {
            this.initializeUniqueCharacterFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCharacterFormat.uniqueFormatType, property);
            if (this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType) &&
                // tslint:disable-next-line:max-line-length
                this.uniqueCharacterFormat.propertiesHash.get(propertyType) === value) { //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.updateUniqueFormat(this.uniqueCharacterFormat, property, value);
        }
    }
    initializeUniqueCharacterFormat(property, propValue) {
        let uniqueCharFormatTemp = new Dictionary();
        this.addUniqueCharacterFormat('fontColor', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontFamily', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontSize', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('bold', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('italic', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('underline', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('strikethrough', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('baselineAlignment', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('highlightColor', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('styleName', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('bidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('bdo', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontFamilyBidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('fontSizeBidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('boldBidi', property, propValue, uniqueCharFormatTemp);
        this.addUniqueCharacterFormat('italicBidi', property, propValue, uniqueCharFormatTemp);
        // tslint:disable-next-line:max-line-length
        this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.addUniqueFormat(uniqueCharFormatTemp, WCharacterFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueCharacterFormat(property, modifiedProperty, propValue, uniqueCharFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WCharacterFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCharFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'bold':
                value = false;
                break;
            case 'italic':
                value = false;
                break;
            case 'fontSize':
                value = 11;
                break;
            case 'underline':
                value = 'None';
                break;
            case 'strikethrough':
                value = 'None';
                break;
            case 'baselineAlignment':
                value = 'Normal';
                break;
            case 'highlightColor':
                value = 'NoColor';
                break;
            case 'fontColor':
                value = '#000000';
                break;
            case 'fontFamily':
                value = 'Calibri';
                break;
            case 'styleName':
                value = 'Default Paragraph Font';
                break;
            case 'bidi':
                value = false;
                break;
            case 'bdo':
                value = 'None';
                break;
            case 'boldBidi':
                value = false;
                break;
            case 'italicBidi':
                value = false;
                break;
            case 'fontSizeBidi':
                value = 11;
                break;
            case 'fontFamilyBidi':
                value = 'Calibri';
                break;
        }
        return value;
    }
    isEqualFormat(format) {
        return (this.fontSize === format.fontSize
            && this.fontFamily === format.fontFamily
            && this.bold === format.bold
            && this.italic === format.italic
            && this.baselineAlignment === format.baselineAlignment
            && this.underline === format.underline
            && this.fontColor === format.fontColor
            && this.strikethrough === format.strikethrough
            && this.highlightColor === format.highlightColor && this.bidi === format.bidi
            && this.bdo === format.bdo);
    }
    isSameFormat(format) {
        return this.baseCharStyle === format.baseCharStyle &&
            this.uniqueCharacterFormat === format.uniqueCharacterFormat;
    }
    cloneFormat() {
        let format = new WCharacterFormat(undefined);
        format.uniqueCharacterFormat = this.uniqueCharacterFormat;
        format.baseCharStyle = this.baseCharStyle;
        return format;
    }
    /**
     * @private
     */
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueCharacterFormat) && !isNullOrUndefined(this.uniqueCharacterFormat.propertiesHash)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCharacterFormat.uniqueFormatType, property);
            return this.uniqueCharacterFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    clearFormat() {
        if (!isNullOrUndefined(this.uniqueCharacterFormat) && this.uniqueCharacterFormat.referenceCount === 0) {
            WCharacterFormat.uniqueCharacterFormats.remove(this.uniqueCharacterFormat);
        }
        this.uniqueCharacterFormat = undefined;
        this.baseCharStyle = undefined;
    }
    destroy() {
        this.clearFormat();
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueCharacterFormat) && format.uniqueCharacterFormat.propertiesHash) {
                this.updateUniqueCharacterFormat(format);
            }
            if (!isNullOrUndefined(format.baseCharStyle)) {
                this.baseCharStyle = format.baseCharStyle;
            }
        }
    }
    updateUniqueCharacterFormat(format) {
        let hash = undefined;
        if (this.uniqueCharacterFormat) {
            hash = this.uniqueCharacterFormat.mergeProperties(format.uniqueCharacterFormat);
            if (this.uniqueCharacterFormat.referenceCount === 0) {
                WCharacterFormat.uniqueCharacterFormats.remove(this.uniqueCharacterFormat);
                this.uniqueCharacterFormat = undefined;
            }
        }
        this.uniqueCharacterFormat = new WUniqueFormat(WCharacterFormat.uniqueFormatType);
        if (isNullOrUndefined(hash)) {
            hash = this.uniqueCharacterFormat.mergeProperties(format.uniqueCharacterFormat);
        }
        this.uniqueCharacterFormat = WCharacterFormat.uniqueCharacterFormats.addUniqueFormat(hash, WCharacterFormat.uniqueFormatType);
    }
    static clear() {
        this.uniqueCharacterFormats.clear();
    }
    ApplyStyle(baseCharStyle) {
        this.baseCharStyle = baseCharStyle;
    }
    /**
     * For internal use
     * @private
     */
    getValue(property) {
        return this.hasValue(property) ? this.getPropertyValue(property) : undefined;
    }
    /**
     * For internal use
     * @private
     */
    mergeFormat(format) {
        if (isNullOrUndefined(this.getValue('bold'))) {
            this.bold = format.getValue('bold');
        }
        if (isNullOrUndefined(this.getValue('italic'))) {
            this.italic = format.getValue('italic');
        }
        if (isNullOrUndefined(this.getValue('fontSize'))) {
            this.fontSize = format.getValue('fontSize');
        }
        if (isNullOrUndefined(this.getValue('fontFamily'))) {
            this.fontFamily = format.getValue('fontFamily');
        }
        if (isNullOrUndefined(this.getValue('underline'))) {
            this.underline = format.getValue('underline');
        }
        if (isNullOrUndefined(this.getValue('strikethrough'))) {
            this.strikethrough = format.getValue('strikethrough');
        }
        if (isNullOrUndefined(this.getValue('baselineAlignment'))) {
            this.baselineAlignment = format.getValue('baselineAlignment');
        }
        if (isNullOrUndefined(this.getValue('highlightColor'))) {
            this.highlightColor = format.getValue('highlightColor');
        }
        if (isNullOrUndefined(this.getValue('fontColor'))) {
            this.fontColor = format.getValue('fontColor');
        }
        if (isNullOrUndefined(this.getValue('bidi'))) {
            this.bidi = format.getValue('bidi');
        }
        if (isNullOrUndefined(this.getValue('bdo'))) {
            this.bdo = format.getValue('bdo');
        }
    }
}
WCharacterFormat.uniqueCharacterFormats = new WUniqueFormats();
WCharacterFormat.uniqueFormatType = 2;

/**
 * @private
 */
class HelperMethods {
    /**
     * Inserts text at specified index in string.
     * @param {string} spanText
     * @param {number} index
     * @param {string} text
     * @private
     */
    static insert(spanText, index, text) {
        if (index >= 0) {
            return [spanText.slice(0, index) + text + spanText.slice(index)].join('');
        }
        else {
            return text + this;
        }
    }
    /**
     * Removes text from specified index in string.
     * @param {string} text
     * @param {number} index
     * @param {number} length
     * @private
     */
    static remove(text, index, length) {
        if (index === 0) {
            return text.substring(index + 1, text.length);
        }
        else {
            return text.substring(0, index) + text.substring(index + 1, text.length);
        }
    }
    /**
     * Returns the index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @private
     */
    /* tslint:disable:no-any */
    static indexOfAny(text, wordSplitCharacter) {
        let index = undefined;
        for (let j = 0; j < wordSplitCharacter.length; j++) {
            let temp = text.indexOf(wordSplitCharacter[j]);
            if (temp !== -1 && isNullOrUndefined(index)) {
                index = temp;
            }
            else if (temp !== -1 && temp < index) {
                index = temp;
            }
        }
        return isNullOrUndefined(index) ? -1 : index;
    }
    /**
     * Returns the last index of word split character in a string.
     * @param {string} text
     * @param {string[]} wordSplitCharacter
     * @private
     */
    static lastIndexOfAny(text, wordSplitCharacter) {
        for (let i = text.length - 1; i >= 0; i--) {
            for (let j = 0; j <= wordSplitCharacter.length - 1; j++) {
                if (text[i] === wordSplitCharacter[j]) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * Adds css styles to document header.
     * @param {string} css
     * @private
     */
    static addCssStyle(css) {
        let style = document.createElement('style');
        if (style.style.cssText) {
            style.style.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }
        document.getElementsByTagName('head')[0].appendChild(style);
    }
    /**
     * Gets highlight color code.
     * @param {HighlightColor} highlightColor
     * @private
     */
    static getHighlightColorCode(highlightColor) {
        let color = '#ffffff';
        switch (highlightColor) {
            case 'Yellow':
                color = '#ffff00';
                break;
            case 'BrightGreen':
                color = '#00ff00';
                break;
            case 'Turquoise':
                color = '#00ffff';
                break;
            case 'Pink':
                color = '#ff00ff';
                break;
            case 'Blue':
                color = '#0000ff';
                break;
            case 'Red':
                color = '#ff0000';
                break;
            case 'DarkBlue':
                color = '#000080';
                break;
            case 'Teal':
                color = '#008080';
                break;
            case 'Green':
                color = '#008000';
                break;
            case 'Violet':
                color = '#800080';
                break;
            case 'DarkRed':
                color = '#800000';
                break;
            case 'DarkYellow':
                color = '#808000';
                break;
            case 'Gray50':
                color = '#808080';
                break;
            case 'Gray25':
                color = '#c0c0c0';
                break;
            case 'Black':
                color = '#000000';
                break;
        }
        return color;
    }
    /**
     * Converts point to pixel.
     * @param {number} point
     * @private
     */
    static convertPointToPixel(point) {
        let pixel = HelperMethods.round((point * 96 / 72), 5);
        return pixel;
    }
    /**
     * Converts pixel to point.
     * @param {number} pixel
     * @private
     */
    static convertPixelToPoint(pixel) {
        let point = HelperMethods.round((pixel * 72 / 96), 5);
        return point;
    }
    /**
     * Return true if field linked
     * @private
     */
    static isLinkedFieldCharacter(inline) {
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            return !isNullOrUndefined(inline.fieldEnd);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            return !isNullOrUndefined(inline.fieldBegin) && !isNullOrUndefined(inline.fieldEnd);
        }
        else {
            return !isNullOrUndefined(inline.fieldBegin);
        }
    }
    /**
     * Removes white space in a string.
     * @param {string} text
     * @private
     */
    static removeSpace(text) {
        if (!isNullOrUndefined(text) && text.length !== 0) {
            for (let i = 0; i < text.length; i++) {
                if (text.charAt(i) === ' ') {
                    //replace the space by empty string in string
                    text = text.replace(' ', '');
                }
            }
        }
        return text;
    }
    /**
     * Trims white space at start of the string.
     * @param {string} text
     * @private
     */
    static trimStart(text) {
        let i = 0;
        for (i; i < text.length; i++) {
            if (text[i] !== ' ') {
                break;
            }
        }
        return text.substring(i, text.length);
    }
    /**
     * Trims white space at end of the string.
     * @param {string} text
     * @private
     */
    static trimEnd(text) {
        let i = text.length - 1;
        for (i; i >= 0; i--) {
            if (text[i] !== ' ') {
                break;
            }
        }
        return text.substring(0, i + 1);
    }
    /**
     * Checks whether string ends with whitespace.
     * @param {string} text
     * @private
     */
    static endsWith(text) {
        if (!isNullOrUndefined(text) && text.length !== 0) {
            return text[text.length - 1] === ' ';
        }
        return false;
    }
    /**
     * Return specified number of string count
     * @private
     */
    static addSpace(length) {
        let str = '';
        if (length > 0) {
            for (let i = 0; i < length; i++) {
                str += ' ';
            }
        }
        return str;
    }
    /**
     * @private
     * Write Characterformat
     * @param {any} characterFormat
     * @param {boolean} isInline
     * @param {WCharacterFormat} format
     */
    static writeCharacterFormat(characterFormat, isInline, format) {
        characterFormat.bold = isInline ? format.bold : format.getValue('bold');
        characterFormat.italic = isInline ? format.italic : format.getValue('italic');
        characterFormat.fontSize = isInline ? format.fontSize : format.getValue('fontSize');
        characterFormat.fontFamily = isInline ? format.fontFamily : format.getValue('fontFamily');
        characterFormat.underline = isInline ? format.underline : format.getValue('underline');
        characterFormat.strikethrough = isInline ? format.strikethrough : format.getValue('strikethrough');
        characterFormat.baselineAlignment = isInline ? format.baselineAlignment : format.getValue('baselineAlignment');
        characterFormat.highlightColor = isInline ? format.highlightColor : format.getValue('highlightColor');
        characterFormat.fontColor = isInline ? format.fontColor : format.getValue('fontColor');
        characterFormat.styleName = !isNullOrUndefined(format.baseCharStyle) ? format.baseCharStyle.name : undefined;
        characterFormat.bidi = isInline ? format.bidi : format.getValue('bidi');
        characterFormat.bdo = isInline ? format.bdo : format.getValue('bdo');
        characterFormat.boldBidi = isInline ? format.boldBidi : format.getValue('boldBidi');
        characterFormat.italicBidi = isInline ? format.italicBidi : format.getValue('italicBidi');
        characterFormat.fontSizeBidi = isInline ? format.fontSizeBidi : format.getValue('fontSizeBidi');
        characterFormat.fontFamilyBidi = isInline ? format.fontFamilyBidi : format.getValue('fontFamilyBidi');
    }
    /* tslint:enable:no-any */
    /**
     * Rounds the values with specified decimal digits.
     * @param {number} value
     * @param {number} decimalDigits
     * @private
     */
    static round(value, decimalDigits) {
        let temp = value;
        for (let i = 0; i < decimalDigits; i++) {
            temp = temp * 10;
        }
        temp = Math.round(temp);
        for (let i = 0; i < decimalDigits; i++) {
            temp = temp / 10;
        }
        return temp;
    }
    static ReverseString(text) {
        if (!isNullOrUndefined(text) && text !== '') {
            // return a new array
            let splitString = text.split('');
            // reverse the new created array
            let reverseString = splitString.reverse();
            // join all elements of the array into a string
            text = reverseString.join('');
        }
        return text;
    }
    /**
     * @private
     */
    static formatClippedString(base64ImageString) {
        let extension = '';
        let formatClippedString = '';
        if (this.startsWith(base64ImageString, 'data:image/bmp;base64,')) {
            extension = '.bmp';
            formatClippedString = base64ImageString.replace('data:image/bmp;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/x-emf;base64,')) {
            extension = '.emf';
            formatClippedString = base64ImageString.replace('data:image/x-emf;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/exif;base64,')) {
            extension = '.exif';
            formatClippedString = base64ImageString.replace('data:image/exif;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/gif;base64,')) {
            extension = '.gif';
            formatClippedString = base64ImageString.replace('data:image/gif;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/icon;base64,')) {
            extension = '.ico';
            formatClippedString = base64ImageString.replace('data:image/icon;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/jpeg;base64,')) {
            extension = '.jpeg';
            formatClippedString = base64ImageString.replace('data:image/jpeg;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/jpg;base64,')) {
            extension = '.jpg';
            formatClippedString = base64ImageString.replace('data:image/jpg;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/png;base64,')) {
            extension = '.png';
            formatClippedString = base64ImageString.replace('data:image/png;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/tiff;base64,')) {
            extension = '.tif';
            formatClippedString = base64ImageString.replace('data:image/tiff;base64,', '');
        }
        else if (this.startsWith(base64ImageString, 'data:image/x-wmf;base64,')) {
            extension = '.wmf';
            formatClippedString = base64ImageString.replace('data:image/x-wmf;base64,', '');
        }
        else {
            extension = '.jpeg';
        }
        return { 'extension': extension, 'formatClippedString': formatClippedString };
    }
    static startsWith(sourceString, startString) {
        return startString.length > 0 && sourceString.substring(0, startString.length) === startString;
    }
}
/**
 * @private
 */
HelperMethods.wordBefore = '\\b';
/**
 * @private
 */
HelperMethods.wordAfter = '\\b';
/**
 * @private
 */
HelperMethods.wordSplitCharacters = [' ', ',', '.', ':', ';', '<', '>', '=',
    '+', '-', '_', '{', '}', '[', ']', '`', '~', '!', '@', '#', '$', '%', '^', '&',
    '*', '(', ')', '"', '?', '/', '|', '\\', '”', '　', '،', '؟', '؛', '’', '‘'];
/**
 * @private
 */
class Point {
    constructor(xPosition, yPosition) {
        this.xIn = 0;
        this.yIn = 0;
        this.xIn = xPosition;
        this.yIn = yPosition;
    }
    /**
     * Gets or sets x value.
     * @private
     */
    get x() {
        return this.xIn;
    }
    set x(value) {
        this.xIn = value;
    }
    /**
     * Gets or sets y value.
     * @private
     */
    get y() {
        return this.yIn;
    }
    set y(value) {
        this.yIn = value;
    }
    /**
     * @private
     */
    copy(point) {
        this.xIn = point.xIn;
        this.yIn = point.yIn;
    }
    /**
     * Destroys the internal objects maintained.
     * @returns void
     */
    destroy() {
        this.xIn = undefined;
        this.yIn = undefined;
    }
}
/**
 * @private
 */
class Base64 {
    constructor() {
        this.keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    }
    // public method for encoding
    encodeString(input) {
        let output = '';
        let chr1;
        let chr2;
        let chr3;
        let enc1;
        let enc2;
        let enc3;
        let enc4;
        let i = 0;
        input = this.unicodeEncode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            }
            else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output +
                this.keyStr.charAt(enc1) + this.keyStr.charAt(enc2) +
                this.keyStr.charAt(enc3) + this.keyStr.charAt(enc4);
        }
        return output;
    }
    // private method for UTF-8 encoding
    unicodeEncode(input) {
        let tempInput = input.replace(/\r\n/g, '\n');
        let utftext = '';
        for (let n = 0; n < tempInput.length; n++) {
            let c = tempInput.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if ((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
        }
        return utftext;
    }
    /**
     * @private
     */
    decodeString(input) {
        let chr1;
        let chr2;
        let chr3;
        let enc1;
        let enc2;
        let enc3;
        let enc4;
        let i = 0;
        let resultIndex = 0;
        /*let dataUrlPrefix: string = 'data:';*/
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        let totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === this.keyStr.charAt(64)) {
            totalLength--;
        }
        if (input.charAt(input.length - 2) === this.keyStr.charAt(64)) {
            totalLength--;
        }
        if (totalLength % 1 !== 0) {
            // totalLength is not an integer, the length does not match a valid
            // base64 content. That can happen if:
            // - the input is not a base64 content
            // - the input is *almost* a base64 content, with a extra chars at the
            // beginning or at the end
            // - the input uses a base64 variant (base64url for example)
            throw new Error('Invalid base64 input, bad content length.');
        }
        let output = new Uint8Array(totalLength | 0);
        while (i < input.length) {
            enc1 = this.keyStr.indexOf(input.charAt(i++));
            enc2 = this.keyStr.indexOf(input.charAt(i++));
            enc3 = this.keyStr.indexOf(input.charAt(i++));
            enc4 = this.keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output[resultIndex++] = chr1;
            if (enc3 !== 64) {
                output[resultIndex++] = chr2;
            }
            if (enc4 !== 64) {
                output[resultIndex++] = chr3;
            }
        }
        return output;
    }
}

/**
 * @private
 */
class WStyle {
}
/**
 * @private
 */
class WParagraphStyle extends WStyle {
    constructor(node) {
        super();
        this.ownerBase = node;
        this.paragraphFormat = new WParagraphFormat(this);
        this.characterFormat = new WCharacterFormat(this);
    }
    destroy() {
        this.characterFormat.destroy();
        this.paragraphFormat.destroy();
    }
    copyStyle(paraStyle) {
        this.name = paraStyle.name;
        this.ownerBase = paraStyle.ownerBase;
        this.type = paraStyle.type;
        this.next = paraStyle.next;
        this.basedOn = paraStyle.basedOn;
        this.link = paraStyle.link;
        this.characterFormat.copyFormat(paraStyle.characterFormat);
        this.paragraphFormat.copyFormat(paraStyle.paragraphFormat);
    }
}
/**
 * @private
 */
class WCharacterStyle extends WStyle {
    constructor(node) {
        super();
        this.ownerBase = node;
        this.characterFormat = new WCharacterFormat(this);
    }
    destroy() {
        this.characterFormat.destroy();
    }
    copyStyle(charStyle) {
        this.name = charStyle.name;
        this.ownerBase = charStyle.ownerBase;
        this.type = charStyle.type;
        this.next = charStyle.next;
        this.basedOn = charStyle.basedOn;
        this.characterFormat.copyFormat(charStyle.characterFormat);
    }
}
/**
 * @private
 */
class WStyles {
    constructor() {
        this.collection = [];
        /* tslint:enable:no-any */
    }
    get length() {
        return this.collection.length;
    }
    remove(item) {
        this.collection = this.collection.filter((a) => (a.name !== item.name));
    }
    push(item) {
        if (item != null && item !== undefined) {
            this.collection.push(item);
        }
        return 1;
    }
    getItem(index) {
        if (this.collection.length > index) {
            return this.collection[index];
        }
        return null;
    }
    indexOf(item) {
        return this.collection.indexOf(item);
    }
    contains(item) {
        let index = this.collection.indexOf(item);
        return index > -1 && index < this.collection.length;
    }
    clear() {
        while (this.collection.length > 0) {
            this.collection.pop();
        }
    }
    findByName(name, type) {
        let returnStyle;
        for (let value of this.collection) {
            if (value.name === name) {
                returnStyle = value;
                if (!isNullOrUndefined(type) && value.type === type) {
                    returnStyle = value;
                }
            }
        }
        return returnStyle;
    }
    getStyleNames(type) {
        return this.collection.filter((a) => (a.type === type)).map((a) => { return a.name; });
    }
    /* tslint:disable:no-any */
    getStyles(type) {
        let styles = this.collection.filter((a) => (a.type === type)).map((a) => { return a; });
        let styleObjects = [];
        for (let style of styles) {
            let returnStyle = {};
            let returnStyleObject = {};
            returnStyleObject.characterFormat = {};
            HelperMethods.writeCharacterFormat(returnStyleObject.characterFormat, true, style.characterFormat);
            returnStyle.name = style.name;
            returnStyle.style = JSON.stringify(returnStyleObject);
            styleObjects.push(returnStyle);
        }
        return styleObjects;
    }
}

/**
 * @private
 */
class WBorder {
    constructor(node) {
        this.uniqueBorderFormat = undefined;
        this.ownerBase = undefined;
        this.ownerBase = node;
    }
    get color() {
        return this.getPropertyValue('color');
    }
    set color(value) {
        this.setPropertyValue('color', value);
    }
    get lineStyle() {
        return this.getPropertyValue('lineStyle');
    }
    set lineStyle(value) {
        this.setPropertyValue('lineStyle', value);
    }
    get lineWidth() {
        return this.getPropertyValue('lineWidth');
    }
    set lineWidth(value) {
        this.setPropertyValue('lineWidth', value);
    }
    get shadow() {
        return this.getPropertyValue('shadow');
    }
    set shadow(value) {
        this.setPropertyValue('shadow', value);
    }
    get space() {
        return this.getPropertyValue('space');
    }
    set space(value) {
        this.setPropertyValue('space', value);
    }
    get hasNoneStyle() {
        return this.getPropertyValue('hasNoneStyle');
    }
    set hasNoneStyle(value) {
        this.setPropertyValue('hasNoneStyle', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WBorder.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueBorderFormat) && this.uniqueBorderFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueBorderFormat.propertiesHash.get(propertyType);
            }
        }
        return WBorder.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WBorder.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueBorderFormat)) {
            this.initializeUniqueBorder(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueBorderFormat.uniqueFormatType, property);
            if (this.uniqueBorderFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueBorderFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueBorderFormat = WBorder.uniqueBorderFormats.updateUniqueFormat(this.uniqueBorderFormat, property, value);
        }
    }
    initializeUniqueBorder(property, propValue) {
        let uniqueBorderFormatTemp = new Dictionary();
        this.addUniqueBorderFormat('color', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('lineStyle', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('lineWidth', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('shadow', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('space', property, propValue, uniqueBorderFormatTemp);
        this.addUniqueBorderFormat('hasNoneStyle', property, propValue, uniqueBorderFormatTemp);
        this.uniqueBorderFormat = WBorder.uniqueBorderFormats.addUniqueFormat(uniqueBorderFormatTemp, WBorder.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueBorderFormat(property, modifiedProperty, propValue, uniqueBorderFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WBorder.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueBorderFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'color':
                value = '#000000';
                break;
            case 'lineStyle':
                value = 'None';
                break;
            case 'lineWidth':
                value = 0;
                break;
            case 'shadow':
                value = false;
                break;
            case 'space':
                value = 0;
                break;
            case 'hasNoneStyle':
                value = false;
                break;
        }
        return value;
    }
    getLineWidth() {
        /* tslint:disable */
        switch (this.lineStyle) {
            case 'None':
            case 'Cleared':
                return 0;
            case 'Triple':
            case 'Double':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
            case 'Emboss3D':
            case 'Engrave3D':
                {
                    let lineArray = this.getBorderLineWidthArray(this.lineStyle, this.lineWidth);
                    let width = 0;
                    for (let i = 0; i < lineArray.length; i++) {
                        width += lineArray[i];
                    }
                    return width;
                }
            case 'Single':
            case 'DashLargeGap':
            case 'DashSmallGap':
            case 'Dot':
            case 'DashDot':
            case 'DashDotDot':
            case 'Thick':
                return this.lineWidth;
            case 'SingleWavy':
                return (this.lineWidth === 1.5 ? 3 : 2.5); //Double wave border only draw with the fixed width
            case 'DoubleWavy':
                return (6.75); //Double wave border only draw with the fixed width
            case 'DashDotStroked':
            case 'Outset':
                return this.lineWidth;
        }
        return this.lineWidth;
        /* tslint:enable */
    }
    getBorderLineWidthArray(lineStyle, lineWidth) {
        let borderLineArray = [lineWidth];
        switch (lineStyle) {
            case 'Double':
                borderLineArray = [1, 1, 1];
                break;
            case 'ThinThickSmallGap':
                borderLineArray = [1, -0.75, -0.75];
                break;
            case 'ThickThinSmallGap':
                borderLineArray = [-0.75, -0.75, 1];
                break;
            case 'ThinThickMediumGap':
                borderLineArray = [1, 0.5, 0.5];
                break;
            case 'ThickThinMediumGap':
                borderLineArray = [0.5, 0.5, 1];
                break;
            case 'ThinThickLargeGap':
                borderLineArray = [-1.5, 1, -0.75];
                break;
            case 'ThickThinLargeGap':
                borderLineArray = [-0.75, 1, -1.5];
                break;
            case 'Triple':
                borderLineArray = [1, 1, 1, 1, 1];
                break;
            case 'ThinThickThinSmallGap':
                borderLineArray = [-0.75, -0.75, 1, -0.75, -0.75];
                break;
            case 'ThinThickThinMediumGap':
                borderLineArray = [0.5, 0.5, 1, 0.5, 0.5];
                break;
            case 'ThinThickThinLargeGap':
                borderLineArray = [-0.75, 1, -1.5, 1, -0.75];
                break;
            case 'Emboss3D':
            case 'Engrave3D':
                borderLineArray = [0.25, 0, 1, 0, 0.25];
                break;
        }
        if (borderLineArray.length === 1) {
            return [lineWidth];
        }
        for (let i = 0; i < borderLineArray.length; i++) {
            if (borderLineArray[i] >= 0) {
                borderLineArray[i] = borderLineArray[i] * lineWidth;
            }
            else {
                borderLineArray[i] = Math.abs(borderLineArray[i]);
            }
        }
        return borderLineArray;
    }
    getBorderWeight() {
        let weight = 0;
        let numberOfLines = this.getNumberOfLines();
        let borderNumber = this.getBorderNumber();
        switch (this.lineStyle) {
            case 'Single':
            case 'DashSmallGap':
            case 'DashDot':
            case 'DashDotDot':
            case 'Double':
            case 'Triple':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
            case 'SingleWavy':
            case 'DoubleWavy':
            case 'DashDotStroked':
            case 'Emboss3D':
            case 'Engrave3D':
            case 'Outset':
            case 'Inset':
            case 'Thick':
                weight = numberOfLines * borderNumber;
                break;
            case 'Dot':
            case 'DashLargeGap':
                weight = 1;
                break;
        }
        return weight;
    }
    getBorderNumber() {
        let borderNumber = 0;
        switch (this.lineStyle) {
            case 'Single':
                borderNumber = 1;
                break;
            case 'Thick':
                borderNumber = 2;
                break;
            case 'Double':
                borderNumber = 3;
                break;
            case 'Dot':
                borderNumber = 4;
                break;
            case 'DashLargeGap': //dashed.
                borderNumber = 5;
                break;
            case 'DashDot':
                borderNumber = 6;
                break;
            case 'DashDotDot':
                borderNumber = 7;
                break;
            case 'Triple':
                borderNumber = 8;
                break;
            case 'ThinThickSmallGap':
                borderNumber = 9;
                break;
            case 'ThickThinSmallGap':
                borderNumber = 10;
                break;
            case 'ThinThickThinSmallGap':
                borderNumber = 11;
                break;
            case 'ThinThickMediumGap':
                borderNumber = 12;
                break;
            case 'ThickThinMediumGap':
                borderNumber = 13;
                break;
            case 'ThinThickThinMediumGap':
                borderNumber = 14;
                break;
            case 'ThinThickLargeGap':
                borderNumber = 15;
                break;
            case 'ThickThinLargeGap':
                borderNumber = 16;
                break;
            case 'ThinThickThinLargeGap':
                borderNumber = 17;
                break;
            case 'SingleWavy': //wave.
                borderNumber = 18;
                break;
            case 'DoubleWavy':
                borderNumber = 19;
                break;
            case 'DashSmallGap':
                borderNumber = 20;
                break;
            case 'DashDotStroked':
                borderNumber = 21;
                break;
            case 'Emboss3D':
                borderNumber = 22;
                break;
            case 'Engrave3D':
                borderNumber = 23;
                break;
            case 'Outset':
                borderNumber = 24;
                break;
            case 'Inset':
                borderNumber = 25;
                break;
        }
        return borderNumber;
    }
    getNumberOfLines() {
        //ToDo: Need to analyze more on this.
        let value = 0;
        switch (this.lineStyle) {
            case 'Single':
            case 'Dot':
            case 'DashSmallGap':
            case 'DashLargeGap':
            case 'DashDot':
            case 'DashDotDot':
                value = 1;
                break;
            case 'Double':
                value = 3;
                break;
            case 'Triple':
                value = 5;
                break;
            case 'ThinThickSmallGap':
                value = 3;
                break;
            case 'ThickThinSmallGap':
                value = 3;
                break;
            case 'ThinThickThinSmallGap':
                value = 5;
                break;
            case 'ThinThickMediumGap':
                value = 3;
                break;
            case 'ThickThinMediumGap':
                value = 3;
                break;
            case 'ThinThickThinMediumGap':
                value = 5;
                break;
            case 'ThinThickLargeGap':
                value = 3;
                break;
            case 'ThickThinLargeGap':
                value = 3;
                break;
            case 'ThinThickThinLargeGap':
                value = 5;
                break;
            case 'SingleWavy':
                value = 1;
                break;
            case 'DoubleWavy':
                value = 2;
                break;
            case 'DashDotStroked':
                value = 1;
                break;
            case 'Emboss3D':
            case 'Engrave3D':
                value = 3;
                break;
            case 'Outset':
            case 'Inset':
            case 'Thick':
                value = 1;
                break;
        }
        return value;
    }
    getPrecedence() {
        let value = 0;
        switch (this.lineStyle) {
            case 'Single':
                value = 1;
                break;
            case 'Thick':
                value = 2;
                break;
            case 'Double':
                value = 3;
                break;
            case 'Dot':
                value = 4;
                break;
            case 'DashLargeGap': //dashed.
                value = 5;
                break;
            case 'DashDot':
                value = 6;
                break;
            case 'DashDotDot':
                value = 7;
                break;
            case 'Triple':
                value = 8;
                break;
            case 'ThinThickSmallGap':
                value = 9;
                break;
            case 'ThickThinSmallGap':
                value = 10;
                break;
            case 'ThinThickThinSmallGap':
                value = 11;
                break;
            case 'ThinThickMediumGap':
                value = 12;
                break;
            case 'ThickThinMediumGap':
                value = 13;
                break;
            case 'ThinThickThinMediumGap':
                value = 14;
                break;
            case 'ThinThickLargeGap':
                value = 15;
                break;
            case 'ThickThinLargeGap':
                value = 16;
                break;
            case 'ThinThickThinLargeGap':
                value = 17;
                break;
            case 'SingleWavy': //wave.
                value = 18;
                break;
            case 'DoubleWavy':
                value = 19;
                break;
            case 'DashSmallGap':
                value = 20;
                break;
            case 'DashDotStroked':
                value = 21;
                break;
            case 'Emboss3D':
                value = 22;
                break;
            case 'Engrave3D':
                value = 23;
                break;
            case 'Outset':
                value = 24;
                break;
            case 'Inset':
                value = 25;
                break;
        }
        return value;
    }
    /**
     * @private
     */
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueBorderFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueBorderFormat.uniqueFormatType, property);
            return this.uniqueBorderFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    cloneFormat() {
        let border = new WBorder(undefined);
        border.color = this.color;
        border.lineStyle = this.lineStyle;
        border.lineWidth = this.lineWidth;
        border.shadow = this.shadow;
        border.space = this.space;
        return border;
    }
    destroy() {
        if (!isNullOrUndefined(this.uniqueBorderFormat)) {
            WBorder.uniqueBorderFormats.remove(this.uniqueBorderFormat);
        }
        this.uniqueBorderFormat = undefined;
    }
    copyFormat(border) {
        if (!isNullOrUndefined(border) && !isNullOrUndefined(border.uniqueBorderFormat)) {
            if (border.hasValue('color')) {
                this.color = border.color;
            }
            if (border.hasValue('lineStyle')) {
                this.lineStyle = border.lineStyle;
            }
            if (border.hasValue('lineWidth')) {
                this.lineWidth = border.lineWidth;
            }
            if (border.hasValue('shadow')) {
                this.shadow = border.shadow;
            }
            if (border.hasValue('space')) {
                this.space = border.space;
            }
        }
    }
    static clear() {
        this.uniqueBorderFormats.clear();
    }
}
WBorder.uniqueBorderFormats = new WUniqueFormats();
WBorder.uniqueFormatType = 1;

/**
 * @private
 */
class WBorders {
    constructor(node) {
        this.leftIn = new WBorder(this);
        this.rightIn = new WBorder(this);
        this.topIn = new WBorder(this);
        this.bottomIn = new WBorder(this);
        this.horizontalIn = new WBorder(this);
        this.verticalIn = new WBorder(this);
        this.diagonalUpIn = new WBorder(this);
        this.diagonalDownIn = new WBorder(this);
        this.lineWidthIn = 0;
        this.ownerBase = node;
    }
    get left() {
        return this.leftIn;
    }
    set left(value) {
        this.leftIn = value;
    }
    get right() {
        return this.rightIn;
    }
    set right(value) {
        this.rightIn = value;
    }
    get top() {
        return this.topIn;
    }
    set top(value) {
        this.topIn = value;
    }
    get bottom() {
        return this.bottomIn;
    }
    set bottom(value) {
        this.bottomIn = value;
    }
    get horizontal() {
        return this.horizontalIn;
    }
    set horizontal(value) {
        this.horizontalIn = value;
    }
    get vertical() {
        return this.verticalIn;
    }
    set vertical(value) {
        this.verticalIn = value;
    }
    get diagonalUp() {
        return this.diagonalUpIn;
    }
    set diagonalUp(value) {
        this.diagonalUpIn = value;
    }
    get diagonalDown() {
        return this.diagonalDownIn;
    }
    set diagonalDown(value) {
        this.diagonalDownIn = value;
    }
    destroy() {
        if (!isNullOrUndefined(this.left)) {
            this.left.destroy();
        }
        if (!isNullOrUndefined(this.top)) {
            this.top.destroy();
        }
        if (!isNullOrUndefined(this.bottom)) {
            this.bottom.destroy();
        }
        if (!isNullOrUndefined(this.right)) {
            this.right.destroy();
        }
        if (!isNullOrUndefined(this.horizontal)) {
            this.horizontal.destroy();
        }
        if (!isNullOrUndefined(this.vertical)) {
            this.vertical.destroy();
        }
        if (!isNullOrUndefined(this.diagonalDown)) {
            this.diagonalDown.destroy();
        }
        if (!isNullOrUndefined(this.diagonalUp)) {
            this.diagonalUp.destroy();
        }
        this.topIn = undefined;
        this.bottomIn = undefined;
        this.leftIn = undefined;
        this.rightIn = undefined;
        this.horizontalIn = undefined;
        this.verticalIn = undefined;
        this.diagonalDownIn = undefined;
        this.diagonalUpIn = undefined;
        this.lineWidthIn = undefined;
        this.valueIn = undefined;
    }
    cloneFormat() {
        let borders = new WBorders(undefined);
        borders.top = isNullOrUndefined(this.top) ? undefined : this.top.cloneFormat();
        borders.bottom = isNullOrUndefined(this.bottom) ? undefined : this.bottom.cloneFormat();
        borders.left = isNullOrUndefined(this.left) ? undefined : this.left.cloneFormat();
        borders.right = isNullOrUndefined(this.right) ? undefined : this.right.cloneFormat();
        borders.horizontal = isNullOrUndefined(this.horizontal) ? undefined : this.horizontal.cloneFormat();
        borders.vertical = isNullOrUndefined(this.vertical) ? undefined : this.vertical.cloneFormat();
        borders.diagonalUp = isNullOrUndefined(this.diagonalUp) ? undefined : this.diagonalUp.cloneFormat();
        borders.diagonalDown = isNullOrUndefined(this.diagonalDown) ? undefined : this.diagonalDown.cloneFormat();
        return borders;
    }
    copyFormat(borders) {
        if (!isNullOrUndefined(borders.left) && borders.left instanceof WBorder) {
            this.left = new WBorder(this);
            this.left.copyFormat(borders.left);
        }
        if (!isNullOrUndefined(borders.right) && borders.right instanceof WBorder) {
            this.right = new WBorder(this);
            this.right.copyFormat(borders.right);
        }
        if (!isNullOrUndefined(borders.top) && borders.top instanceof WBorder) {
            this.top = new WBorder(this);
            this.top.copyFormat(borders.top);
        }
        if (!isNullOrUndefined(borders.bottom) && borders.bottom instanceof WBorder) {
            this.bottom = new WBorder(this);
            this.bottom.copyFormat(borders.bottom);
        }
        if (!isNullOrUndefined(borders.horizontal) && borders.horizontal instanceof WBorder) {
            this.horizontal = new WBorder(this);
            this.horizontal.copyFormat(borders.horizontal);
        }
        if (!isNullOrUndefined(borders.vertical) && borders.vertical instanceof WBorder) {
            this.vertical = new WBorder(this);
            this.vertical.copyFormat(borders.vertical);
        }
        if (!isNullOrUndefined(borders.diagonalDown) && borders.diagonalDown instanceof WBorder) {
            this.diagonalDown = new WBorder(this);
            this.diagonalDown.copyFormat(borders.diagonalDown);
        }
        if (!isNullOrUndefined(borders.diagonalUp) && borders.diagonalUp instanceof WBorder) {
            this.diagonalUp = new WBorder(this);
            this.diagonalUp.copyFormat(borders.diagonalUp);
        }
    }
}

/**
 * @private
 */
class WShading {
    constructor(node) {
        this.uniqueShadingFormat = undefined;
        this.ownerBase = undefined;
        this.ownerBase = node;
    }
    get backgroundColor() {
        return this.getPropertyValue('backgroundColor');
    }
    set backgroundColor(value) {
        this.setPropertyValue('backgroundColor', value);
    }
    get foregroundColor() {
        return this.getPropertyValue('foregroundColor');
    }
    set foregroundColor(value) {
        this.setPropertyValue('foregroundColor', value);
    }
    get textureStyle() {
        return this.getPropertyValue('textureStyle');
    }
    set textureStyle(value) {
        this.setPropertyValue('textureStyle', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WShading.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueShadingFormat) && this.uniqueShadingFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueShadingFormat.propertiesHash.get(propertyType);
            }
        }
        return WShading.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WShading.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueShadingFormat)) {
            this.initializeUniqueShading(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueShadingFormat.uniqueFormatType, property);
            if (this.uniqueShadingFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueShadingFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueShadingFormat = WShading.uniqueShadingFormats.updateUniqueFormat(this.uniqueShadingFormat, property, value);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'backgroundColor':
                value = '#ffffff';
                break;
            case 'foregroundColor':
                value = 'empty';
                break;
            case 'textureStyle':
                value = 'TextureNone';
                break;
        }
        return value;
    }
    initializeUniqueShading(property, propValue) {
        let uniqueShadingTemp = new Dictionary();
        this.addUniqueShading('backgroundColor', property, propValue, uniqueShadingTemp);
        this.addUniqueShading('foregroundColor', property, propValue, uniqueShadingTemp);
        this.addUniqueShading('textureStyle', property, propValue, uniqueShadingTemp);
        // tslint:disable-next-line:max-line-length        
        this.uniqueShadingFormat = WShading.uniqueShadingFormats.addUniqueFormat(uniqueShadingTemp, WShading.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueShading(property, modifiedProperty, propValue, uniqueShadingTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WShading.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueShadingTemp.add(propertyType, propValue);
        }
        else {
            uniqueShadingTemp.add(propertyType, WShading.getPropertyDefaultValue(property));
        }
    }
    destroy() {
        if (!isNullOrUndefined(this.uniqueShadingFormat)) {
            WShading.uniqueShadingFormats.remove(this.uniqueShadingFormat);
        }
        this.uniqueShadingFormat = undefined;
    }
    cloneFormat() {
        let shading = new WShading(undefined);
        shading.backgroundColor = this.backgroundColor;
        shading.foregroundColor = this.foregroundColor;
        shading.textureStyle = this.textureStyle;
        return shading;
    }
    copyFormat(shading) {
        if (!isNullOrUndefined(shading) && !isNullOrUndefined(shading.uniqueShadingFormat)) {
            this.backgroundColor = shading.backgroundColor;
            this.foregroundColor = shading.foregroundColor;
            this.textureStyle = shading.textureStyle;
        }
    }
    /**
     * @private
     */
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueShadingFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueShadingFormat.uniqueFormatType, property);
            return this.uniqueShadingFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    static clear() {
        this.uniqueShadingFormats.clear();
    }
}
WShading.uniqueShadingFormats = new WUniqueFormats();
WShading.uniqueFormatType = 5;

/**
 * @private
 */
class WTableFormat {
    constructor(owner) {
        this.uniqueTableFormat = undefined;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
        this.ownerBase = undefined;
        this.ownerBase = owner;
        this.assignTableMarginValue(5.4, 0, 5.4, 0);
    }
    get allowAutoFit() {
        return this.getPropertyValue('allowAutoFit');
    }
    set allowAutoFit(value) {
        this.setPropertyValue('allowAutoFit', value);
    }
    get cellSpacing() {
        return this.getPropertyValue('cellSpacing');
    }
    set cellSpacing(value) {
        if (value < 0 || value > 264.6) {
            throw new RangeError('The measurement must be between 0 px and 264.6 px.');
        }
        this.setPropertyValue('cellSpacing', value);
    }
    get leftMargin() {
        return this.getPropertyValue('leftMargin');
    }
    set leftMargin(value) {
        this.setPropertyValue('leftMargin', value);
    }
    get topMargin() {
        return this.getPropertyValue('topMargin');
    }
    set topMargin(value) {
        this.setPropertyValue('topMargin', value);
    }
    get rightMargin() {
        return this.getPropertyValue('rightMargin');
    }
    set rightMargin(value) {
        this.setPropertyValue('rightMargin', value);
    }
    get bottomMargin() {
        return this.getPropertyValue('bottomMargin');
    }
    set bottomMargin(value) {
        this.setPropertyValue('bottomMargin', value);
    }
    get leftIndent() {
        return this.getPropertyValue('leftIndent');
    }
    set leftIndent(value) {
        if (value < -1440 || value > 1440) {
            throw new RangeError('The measurement must be between -1440 px and 1440 px.');
        }
        this.setPropertyValue('leftIndent', value);
    }
    get tableAlignment() {
        return this.getPropertyValue('tableAlignment');
    }
    set tableAlignment(value) {
        this.setPropertyValue('tableAlignment', value);
    }
    get preferredWidth() {
        return this.getPropertyValue('preferredWidth');
    }
    set preferredWidth(value) {
        this.setPropertyValue('preferredWidth', value);
    }
    get preferredWidthType() {
        return this.getPropertyValue('preferredWidthType');
    }
    set preferredWidthType(value) {
        this.setPropertyValue('preferredWidthType', value);
    }
    get bidi() {
        return this.getPropertyValue('bidi');
    }
    set bidi(value) {
        this.setPropertyValue('bidi', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WTableFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueTableFormat) && this.uniqueTableFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueTableFormat.propertiesHash.get(propertyType);
            }
        }
        return WTableFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WTableFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueTableFormat)) {
            this.initializeUniqueTableFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueTableFormat.uniqueFormatType, property);
            if (this.uniqueTableFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueTableFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueTableFormat = WTableFormat.uniqueTableFormats.updateUniqueFormat(this.uniqueTableFormat, property, value);
        }
    }
    initializeUniqueTableFormat(property, propValue) {
        let uniqueTableFormatTemp = new Dictionary();
        this.addUniqueTableFormat('allowAutoFit', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('cellSpacing', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('leftMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('topMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('bottomMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('rightMargin', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('leftIndent', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('tableAlignment', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('preferredWidth', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('preferredWidthType', property, propValue, uniqueTableFormatTemp);
        this.addUniqueTableFormat('bidi', property, propValue, uniqueTableFormatTemp);
        this.uniqueTableFormat = WTableFormat.uniqueTableFormats.addUniqueFormat(uniqueTableFormatTemp, WTableFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueTableFormat(property, modifiedProperty, propValue, uniqueTableFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WTableFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueTableFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'allowAutoFit':
                value = false;
                break;
            case 'cellSpacing':
                value = 0;
                break;
            case 'leftMargin':
                value = 5.4;
                break;
            case 'topMargin':
                value = 0;
                break;
            case 'bottomMargin':
                value = 0;
                break;
            case 'rightMargin':
                value = 5.4;
                break;
            case 'leftIndent':
                value = 0;
                break;
            case 'tableAlignment':
                value = 'Left';
                break;
            case 'preferredWidth':
                value = 0;
                break;
            case 'preferredWidthType':
                value = 'Point';
                break;
            case 'bidi':
                value = false;
                break;
        }
        return value;
    }
    assignTableMarginValue(left, top, right, bottom) {
        this.leftMargin = left;
        this.topMargin = top;
        this.rightMargin = right;
        this.bottomMargin = bottom;
    }
    initializeTableBorders() {
        this.borders.left.lineStyle = 'Single';
        this.borders.left.lineWidth = 0.5;
        this.borders.right.lineStyle = 'Single';
        this.borders.right.lineWidth = 0.5;
        this.borders.top.lineStyle = 'Single';
        this.borders.top.lineWidth = 0.5;
        this.borders.bottom.lineStyle = 'Single';
        this.borders.bottom.lineWidth = 0.5;
        this.borders.horizontal.lineStyle = 'Single';
        this.borders.horizontal.lineWidth = 0.5;
        this.borders.vertical.lineStyle = 'Single';
        this.borders.vertical.lineWidth = 0.5;
    }
    destroy() {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.shading)) {
            this.shading.destroy();
        }
        if (!isNullOrUndefined(this.uniqueTableFormat)) {
            WTableFormat.uniqueTableFormats.remove(this.uniqueTableFormat);
        }
        this.uniqueTableFormat = undefined;
        this.borders = undefined;
        this.shading = undefined;
    }
    cloneFormat() {
        let tableFormat = new WTableFormat(undefined);
        tableFormat.leftIndent = this.leftIndent;
        tableFormat.tableAlignment = this.tableAlignment;
        tableFormat.cellSpacing = this.cellSpacing;
        tableFormat.leftMargin = this.leftMargin;
        tableFormat.rightMargin = this.rightMargin;
        tableFormat.topMargin = this.topMargin;
        tableFormat.bottomMargin = this.bottomMargin;
        tableFormat.preferredWidth = this.preferredWidth;
        tableFormat.preferredWidthType = this.preferredWidthType;
        tableFormat.borders = isNullOrUndefined(this.borders) ? undefined : this.borders.cloneFormat();
        tableFormat.shading = isNullOrUndefined(this.shading) ? undefined : this.shading.cloneFormat();
        tableFormat.bidi = this.bidi;
        tableFormat.allowAutoFit = this.allowAutoFit;
        return tableFormat;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueTableFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueTableFormat.uniqueFormatType, property);
            return this.uniqueTableFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueTableFormat)) {
                this.cellSpacing = format.cellSpacing;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.leftIndent = format.leftIndent;
                this.tableAlignment = format.tableAlignment;
                this.preferredWidth = format.preferredWidth;
                this.preferredWidthType = format.preferredWidthType;
                this.bidi = format.bidi;
                this.allowAutoFit = format.allowAutoFit;
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.copyFormat(format.borders);
            }
            if (!isNullOrUndefined(format.shading)) {
                this.shading = new WShading(this);
                this.shading.copyFormat(format.shading);
            }
        }
    }
    static clear() {
        this.uniqueTableFormats.clear();
    }
}
WTableFormat.uniqueTableFormats = new WUniqueFormats();
WTableFormat.uniqueFormatType = 8;

/**
 * @private
 */
class WRowFormat {
    constructor(node) {
        this.uniqueRowFormat = undefined;
        /**
         * @private
         */
        this.borders = new WBorders(this);
        /**
         * @private
         */
        this.ownerBase = undefined;
        /**
         * @private
         */
        this.beforeWidth = 0;
        /**
         * @private
         */
        this.afterWidth = 0;
        this.ownerBase = node;
    }
    get gridBefore() {
        return this.getPropertyValue('gridBefore');
    }
    set gridBefore(value) {
        this.setPropertyValue('gridBefore', value);
    }
    get gridBeforeWidth() {
        return this.getPropertyValue('gridBeforeWidth');
    }
    set gridBeforeWidth(value) {
        this.setPropertyValue('gridBeforeWidth', value);
    }
    get gridBeforeWidthType() {
        return this.getPropertyValue('gridBeforeWidthType');
    }
    set gridBeforeWidthType(value) {
        this.setPropertyValue('gridBeforeWidthType', value);
    }
    get gridAfter() {
        return this.getPropertyValue('gridAfter');
    }
    set gridAfter(value) {
        this.setPropertyValue('gridAfter', value);
    }
    get gridAfterWidth() {
        return this.getPropertyValue('gridAfterWidth');
    }
    set gridAfterWidth(value) {
        this.setPropertyValue('gridAfterWidth', value);
    }
    get gridAfterWidthType() {
        return this.getPropertyValue('gridAfterWidthType');
    }
    set gridAfterWidthType(value) {
        this.setPropertyValue('gridAfterWidthType', value);
    }
    get allowBreakAcrossPages() {
        return this.getPropertyValue('allowBreakAcrossPages');
    }
    set allowBreakAcrossPages(value) {
        this.setPropertyValue('allowBreakAcrossPages', value);
    }
    get isHeader() {
        return this.getPropertyValue('isHeader');
    }
    set isHeader(value) {
        this.setPropertyValue('isHeader', value);
    }
    get rightMargin() {
        return this.getPropertyValue('rightMargin');
    }
    set rightMargin(value) {
        this.setPropertyValue('rightMargin', value);
    }
    get height() {
        return this.getPropertyValue('height');
    }
    set height(value) {
        if (value === 0 && (this.heightType === 'AtLeast' || this.heightType === 'Exactly')) {
            value = 1;
        }
        else if (this.heightType === 'Auto') {
            value = 0;
        }
        this.setPropertyValue('height', value);
    }
    get heightType() {
        return this.getPropertyValue('heightType');
    }
    set heightType(value) {
        if (value === 'AtLeast' || value === 'Exactly') {
            this.height = 1;
        }
        else {
            this.height = 0;
        }
        this.setPropertyValue('heightType', value);
    }
    get bottomMargin() {
        return this.getPropertyValue('bottomMargin');
    }
    set bottomMargin(value) {
        this.setPropertyValue('bottomMargin', value);
    }
    get leftIndent() {
        return this.getPropertyValue('leftIndent');
    }
    set leftIndent(value) {
        this.setPropertyValue('leftIndent', value);
    }
    get topMargin() {
        return this.getPropertyValue('topMargin');
    }
    set topMargin(value) {
        this.setPropertyValue('topMargin', value);
    }
    get leftMargin() {
        return this.getPropertyValue('leftMargin');
    }
    set leftMargin(value) {
        this.setPropertyValue('leftMargin', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WRowFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueRowFormat) && this.uniqueRowFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueRowFormat.propertiesHash.get(propertyType);
            }
        }
        return WRowFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WRowFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueRowFormat)) {
            this.initializeUniqueRowFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueRowFormat.uniqueFormatType, property);
            if (this.uniqueRowFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueRowFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueRowFormat = WRowFormat.uniqueRowFormats.updateUniqueFormat(this.uniqueRowFormat, property, value);
        }
    }
    initializeUniqueRowFormat(property, propValue) {
        let uniqueRowFormatTemp = new Dictionary();
        this.addUniqueRowFormat('allowBreakAcrossPages', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('isHeader', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('height', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('heightType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBefore', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidthType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridAfter', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridAfterWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridgridAfterWidth', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('gridBeforeWidthType', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('leftMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('rightMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('topMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('bottomMargin', property, propValue, uniqueRowFormatTemp);
        this.addUniqueRowFormat('leftIndent', property, propValue, uniqueRowFormatTemp);
        this.uniqueRowFormat = WRowFormat.uniqueRowFormats.addUniqueFormat(uniqueRowFormatTemp, WRowFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueRowFormat(property, modifiedProperty, propValue, uniqueRowFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WRowFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueRowFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'allowBreakAcrossPages':
                value = true;
                break;
            case 'isHeader':
                value = false;
                break;
            case 'height':
                value = 0;
                break;
            case 'heightType':
                value = 'Auto';
                break;
            case 'gridBefore':
                value = 0;
                break;
            case 'gridBeforeWidth':
                value = 0;
                break;
            case 'gridBeforeWidthType':
                value = 'Point';
                break;
            case 'gridAfter':
                value = 0;
                break;
            case 'gridAfterWidth':
                value = 0;
                break;
            case 'gridAfterWidthType':
                value = 'Point';
                break;
            case 'leftMargin':
                value = undefined;
                break;
            case 'topMargin':
                value = undefined;
                break;
            case 'bottomMargin':
                value = undefined;
                break;
            case 'rightMargin':
                value = undefined;
                break;
            case 'leftIndent':
                value = 0;
                break;
        }
        return value;
    }
    containsMargins() {
        return (!isNullOrUndefined(this.leftMargin)
            || !isNullOrUndefined(this.rightMargin)
            || !isNullOrUndefined(this.bottomMargin)
            || !isNullOrUndefined(this.topMargin));
    }
    cloneFormat() {
        let format = new WRowFormat();
        format.allowBreakAcrossPages = this.allowBreakAcrossPages;
        format.heightType = this.heightType;
        format.height = this.height;
        format.isHeader = this.isHeader;
        format.gridBefore = this.gridBefore;
        format.gridBeforeWidth = this.gridBeforeWidth;
        format.gridBeforeWidthType = this.gridBeforeWidthType;
        format.gridAfter = this.gridAfter;
        format.gridAfterWidth = this.gridAfterWidth;
        format.gridAfterWidthType = this.gridAfterWidthType;
        format.leftMargin = this.leftMargin;
        format.rightMargin = this.rightMargin;
        format.topMargin = this.topMargin;
        format.bottomMargin = this.bottomMargin;
        format.leftIndent = this.leftIndent;
        return format;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueRowFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueRowFormat.uniqueFormatType, property);
            return this.uniqueRowFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueRowFormat)) {
                this.allowBreakAcrossPages = format.allowBreakAcrossPages;
                this.isHeader = format.isHeader;
                this.heightType = format.heightType;
                this.height = format.height;
                this.gridBefore = format.gridBefore;
                this.gridBeforeWidth = format.gridBeforeWidth;
                this.gridBeforeWidthType = format.gridBeforeWidthType;
                this.gridAfter = format.gridAfter;
                this.gridAfterWidth = format.gridAfterWidth;
                this.gridAfterWidthType = format.gridAfterWidthType;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.leftIndent = format.leftIndent;
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.ownerBase = format;
                this.borders.copyFormat(format.borders);
            }
        }
    }
    destroy() {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.uniqueRowFormat)) {
            WRowFormat.uniqueRowFormats.remove(this.uniqueRowFormat);
        }
        this.beforeWidth = undefined;
        this.afterWidth = undefined;
        this.borders = undefined;
        this.uniqueRowFormat = undefined;
    }
    static clear() {
        this.uniqueRowFormats.clear();
    }
}
WRowFormat.uniqueRowFormats = new WUniqueFormats();
WRowFormat.uniqueFormatType = 6;

/**
 * @private
 */
class WCellFormat {
    constructor(node) {
        this.uniqueCellFormat = undefined;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
        this.ownerBase = node;
        this.borders = new WBorders(this);
        this.shading = new WShading(this);
    }
    get leftMargin() {
        return this.getPropertyValue('leftMargin');
    }
    set leftMargin(value) {
        this.setPropertyValue('leftMargin', value);
    }
    get rightMargin() {
        return this.getPropertyValue('rightMargin');
    }
    set rightMargin(value) {
        this.setPropertyValue('rightMargin', value);
    }
    get topMargin() {
        return this.getPropertyValue('topMargin');
    }
    set topMargin(value) {
        this.setPropertyValue('topMargin', value);
    }
    get bottomMargin() {
        return this.getPropertyValue('bottomMargin');
    }
    set bottomMargin(value) {
        this.setPropertyValue('bottomMargin', value);
    }
    get cellWidth() {
        return this.getPropertyValue('cellWidth');
    }
    set cellWidth(value) {
        this.setPropertyValue('cellWidth', value);
    }
    get columnSpan() {
        return this.getPropertyValue('columnSpan');
    }
    set columnSpan(value) {
        this.setPropertyValue('columnSpan', value);
    }
    get rowSpan() {
        return this.getPropertyValue('rowSpan');
    }
    set rowSpan(value) {
        this.setPropertyValue('rowSpan', value);
    }
    get preferredWidth() {
        return this.getPropertyValue('preferredWidth');
    }
    set preferredWidth(value) {
        this.setPropertyValue('preferredWidth', value);
    }
    get verticalAlignment() {
        return this.getPropertyValue('verticalAlignment');
    }
    set verticalAlignment(value) {
        this.setPropertyValue('verticalAlignment', value);
    }
    get preferredWidthType() {
        return this.getPropertyValue('preferredWidthType');
    }
    set preferredWidthType(value) {
        this.setPropertyValue('preferredWidthType', value);
    }
    getPropertyValue(property) {
        let hasValue = this.hasValue(property);
        if (hasValue) {
            let propertyType = WUniqueFormat.getPropertyType(WCellFormat.uniqueFormatType, property);
            if (!isNullOrUndefined(this.uniqueCellFormat) && this.uniqueCellFormat.propertiesHash.containsKey(propertyType)) {
                return this.uniqueCellFormat.propertiesHash.get(propertyType);
            }
        }
        return WCellFormat.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WCellFormat.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueCellFormat)) {
            this.initializeUniqueCellFormat(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCellFormat.uniqueFormatType, property);
            if (this.uniqueCellFormat.propertiesHash.containsKey(propertyType) &&
                this.uniqueCellFormat.propertiesHash.get(propertyType) === value) {
                //Do nothing, since no change in property value and return
                return;
            }
            this.uniqueCellFormat = WCellFormat.uniqueCellFormats.updateUniqueFormat(this.uniqueCellFormat, property, value);
        }
    }
    initializeUniqueCellFormat(property, propValue) {
        let uniqueCellFormatTemp = new Dictionary();
        this.addUniqueCellFormat('leftMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('topMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('bottomMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('rightMargin', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('cellWidth', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('columnSpan', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('rowSpan', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('preferredWidth', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('verticalAlignment', property, propValue, uniqueCellFormatTemp);
        this.addUniqueCellFormat('preferredWidthType', property, propValue, uniqueCellFormatTemp);
        this.uniqueCellFormat = WCellFormat.uniqueCellFormats.addUniqueFormat(uniqueCellFormatTemp, WCellFormat.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueCellFormat(property, modifiedProperty, propValue, uniqueCellFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WCellFormat.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCellFormatTemp.add(propertyType, propValue);
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'leftMargin':
                value = undefined;
                break;
            case 'topMargin':
                value = undefined;
                break;
            case 'bottomMargin':
                value = undefined;
                break;
            case 'rightMargin':
                value = undefined;
                break;
            case 'cellWidth':
                value = 0;
                break;
            case 'columnSpan':
                value = 1;
                break;
            case 'rowSpan':
                value = 1;
                break;
            case 'preferredWidth':
                value = 0;
                break;
            case 'verticalAlignment':
                value = 'Top';
                break;
            case 'preferredWidthType':
                value = 'Point';
                break;
        }
        return value;
    }
    containsMargins() {
        return (!isNullOrUndefined(this.leftMargin)
            || !isNullOrUndefined(this.rightMargin)
            || !isNullOrUndefined(this.bottomMargin)
            || !isNullOrUndefined(this.topMargin));
    }
    destroy() {
        if (!isNullOrUndefined(this.borders)) {
            this.borders.destroy();
        }
        if (!isNullOrUndefined(this.shading)) {
            this.shading.destroy();
        }
        if (!isNullOrUndefined(this.uniqueCellFormat)) {
            WCellFormat.uniqueCellFormats.remove(this.uniqueCellFormat);
        }
        this.uniqueCellFormat = undefined;
        this.borders = undefined;
        this.shading = undefined;
    }
    cloneFormat() {
        let format = new WCellFormat(undefined);
        format.verticalAlignment = this.verticalAlignment;
        format.leftMargin = this.leftMargin;
        format.rightMargin = this.rightMargin;
        format.topMargin = this.topMargin;
        format.bottomMargin = this.bottomMargin;
        format.preferredWidth = this.preferredWidth;
        format.preferredWidthType = this.preferredWidthType;
        format.cellWidth = this.cellWidth;
        format.borders = isNullOrUndefined(this.borders) ? undefined : this.borders.cloneFormat();
        format.shading = isNullOrUndefined(this.shading) ? undefined : this.shading.cloneFormat();
        return format;
    }
    hasValue(property) {
        if (!isNullOrUndefined(this.uniqueCellFormat)) {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueCellFormat.uniqueFormatType, property);
            return this.uniqueCellFormat.propertiesHash.containsKey(propertyType);
        }
        return false;
    }
    copyFormat(format) {
        if (!isNullOrUndefined(format)) {
            if (!isNullOrUndefined(format.uniqueCellFormat)) {
                this.cellWidth = format.cellWidth;
                this.leftMargin = format.leftMargin;
                this.topMargin = format.topMargin;
                this.rightMargin = format.rightMargin;
                this.bottomMargin = format.bottomMargin;
                this.preferredWidth = format.preferredWidth;
                this.columnSpan = format.columnSpan;
                this.rowSpan = format.rowSpan;
                this.preferredWidthType = format.preferredWidthType;
                this.verticalAlignment = format.verticalAlignment;
            }
            if (!isNullOrUndefined(format.shading)) {
                this.shading = new WShading(this);
                this.shading.copyFormat(format.shading);
            }
            if (!isNullOrUndefined(format.borders)) {
                this.borders = new WBorders(this);
                this.borders.copyFormat(format.borders);
            }
        }
    }
    static clear() {
        this.uniqueCellFormats.clear();
    }
}
WCellFormat.uniqueCellFormats = new WUniqueFormats();
WCellFormat.uniqueFormatType = 4;

/**
 * Formats Modules
 */

/**
 * @private
 */
class Rect {
    /**
     * @private
     */
    get right() {
        return this.x + this.width;
    }
    /**
     * @private
     */
    get bottom() {
        return this.y + this.height;
    }
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
}
/**
 * @private
 */
class Margin {
    constructor(leftMargin, topMargin, rightMargin, bottomMargin) {
        this.left = leftMargin;
        this.top = topMargin;
        this.right = rightMargin;
        this.bottom = bottomMargin;
    }
    /**
     * @private
     */
    clone() {
        return new Margin(this.left, this.top, this.right, this.bottom);
    }
    /**
     * @private
     */
    destroy() {
        this.left = undefined;
        this.right = undefined;
        this.top = undefined;
        this.bottom = undefined;
    }
}
/**
 * @private
 */
class Widget {
    constructor() {
        /**
         * @private
         */
        this.childWidgets = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.index = 0;
    }
    /**
     * @private
     */
    get indexInOwner() {
        if (this instanceof BodyWidget && this.page) {
            return this.page.bodyWidgets.indexOf(this);
        }
        else if (this.containerWidget && this.containerWidget.childWidgets) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get firstChild() {
        return this.childWidgets.length > 0 ? this.childWidgets[0] : undefined;
    }
    /**
     * @private
     */
    get lastChild() {
        if (this.childWidgets) {
            return this.childWidgets.length > 0 ?
                this.childWidgets[this.childWidgets.length - 1] : undefined;
        }
        return undefined;
    }
    /**
     * @private
     */
    get previousWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (widget instanceof BodyWidget) {
            widget = index > 0 ? widget.page.bodyWidgets[index - 1] : undefined;
        }
        else {
            widget = index > 0 ? widget.containerWidget.childWidgets[index - 1] : undefined;
        }
        return widget;
    }
    /**
     * @private
     */
    get nextWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (index === -1) {
            return undefined;
        }
        if (widget instanceof BodyWidget) {
            widget = index < widget.page.bodyWidgets.length - 1 ?
                widget.page.bodyWidgets[index + 1] : undefined;
        }
        else {
            widget = index < widget.containerWidget.childWidgets.length - 1 ?
                widget.containerWidget.childWidgets[index + 1] : undefined;
        }
        return widget;
    }
    /**
     * @private
     */
    get previousRenderedWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (index < 0) {
            return undefined;
        }
        if (widget instanceof BodyWidget) {
            if (index > 0) {
                widget = widget.page.bodyWidgets[index - 1];
            }
            else {
                let page = widget.page.previousPage;
                widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[page.bodyWidgets.length - 1] : undefined;
            }
        }
        else {
            if (index > 0) {
                widget = widget.containerWidget.childWidgets[index - 1];
            }
            else {
                let previousContainer = undefined;
                if (widget.containerWidget instanceof TableCellWidget) {
                    previousContainer = widget.containerWidget.getPreviousSplitWidget();
                }
                else if (!(widget.containerWidget instanceof TableRowWidget
                    || widget.containerWidget instanceof HeaderFooterWidget)) {
                    // Since cells are lay outed left to right, we should not navigate to previous row.
                    previousContainer = widget.containerWidget.previousRenderedWidget;
                }
                while (previousContainer && previousContainer.childWidgets.length === 0) {
                    previousContainer = previousContainer.previousRenderedWidget;
                    if (isNullOrUndefined(previousContainer)) {
                        break;
                    }
                }
                widget = previousContainer && previousContainer.constructor === widget.containerWidget.constructor ?
                    previousContainer.lastChild : undefined;
            }
        }
        return widget;
    }
    /**
     * @private
     */
    get nextRenderedWidget() {
        let widget = this;
        let index = this.indexInOwner;
        if (index < 0) {
            return undefined;
        }
        if (widget instanceof BodyWidget) {
            if (index < widget.page.bodyWidgets.length - 1) {
                widget = widget.page.bodyWidgets[index + 1];
            }
            else if (widget.page.allowNextPageRendering) {
                let page = widget.page.nextPage;
                widget = page && page.bodyWidgets.length > 0 ? page.bodyWidgets[0] : undefined;
            }
            else {
                widget = undefined;
            }
        }
        else {
            if (index < widget.containerWidget.childWidgets.length - 1) {
                widget = widget.containerWidget.childWidgets[index + 1];
            }
            else {
                let nextContainer = undefined;
                if (widget.containerWidget instanceof TableCellWidget) {
                    nextContainer = widget.containerWidget.getNextSplitWidget();
                }
                else if (!(widget.containerWidget instanceof TableRowWidget
                    || widget.containerWidget instanceof HeaderFooterWidget)) {
                    // Since cells are lay outed left to right, we should not navigate to next row.
                    nextContainer = widget.containerWidget.nextRenderedWidget;
                }
                while (nextContainer && nextContainer.childWidgets.length === 0 && !(nextContainer instanceof TableCellWidget)) {
                    nextContainer = nextContainer.nextRenderedWidget;
                    if (isNullOrUndefined(nextContainer)) {
                        break;
                    }
                }
                widget = nextContainer && nextContainer.constructor === widget.containerWidget.constructor ?
                    nextContainer.firstChild : undefined;
            }
        }
        return widget;
    }
    /**
     * @private
     */
    get previousSplitWidget() {
        let widget = this;
        if (widget instanceof TableCellWidget) {
            return widget.getPreviousSplitWidget();
        }
        else {
            let previous = widget.previousRenderedWidget;
            if (widget instanceof BodyWidget && previous instanceof BodyWidget && widget.equals(previous)) {
                return previous;
            }
            else if (previous instanceof BlockWidget && widget.index === previous.index && widget.equals(previous)) {
                return previous;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextSplitWidget() {
        let widget = this;
        if (widget instanceof TableCellWidget) {
            return widget.getNextSplitWidget();
        }
        else {
            let next = widget.nextRenderedWidget;
            if (widget instanceof BodyWidget && next instanceof BodyWidget && widget.equals(next)) {
                return next;
            }
            else if (next instanceof BlockWidget && widget.index === next.index && widget.equals(next)) {
                return next;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getPreviousSplitWidgets() {
        let widgets = [];
        let widget = this.previousSplitWidget;
        while (widget) {
            widgets.unshift(widget);
            widget = widget.previousSplitWidget;
        }
        return widgets;
    }
    /**
     * @private
     */
    getSplitWidgets() {
        let widgets = this.getPreviousSplitWidgets();
        let widget = this;
        while (widget) {
            widgets.push(widget);
            widget = widget.nextSplitWidget;
        }
        return widgets;
    }
    /**
     * @private
     */
    combineWidget(viewer) {
        let root = this;
        let widgets = this.getSplitWidgets();
        if (widgets.length > 1) {
            root = widgets.shift();
            while (widgets.length > 0) {
                let splitWidget = widgets.shift();
                root.combine(splitWidget, viewer);
            }
        }
        if (root instanceof TableWidget) {
            root.combineRows(viewer);
        }
        return root;
    }
    combine(widget, viewer) {
        if (widget.childWidgets.length > 0) {
            let lastChild = this.lastChild;
            if (lastChild instanceof TableWidget) {
                lastChild.combineWidget(viewer);
            }
            else {
                let firstChild = widget.firstChild;
                if (!(widget instanceof TableWidget) && lastChild instanceof Widget && firstChild instanceof Widget &&
                    lastChild.index === firstChild.index) {
                    lastChild.combine(widget.childWidgets.shift(), viewer);
                }
            }
            this.addWidgets(widget.childWidgets);
            widget.childWidgets = [];
        }
        widget.destroyInternal(viewer);
    }
    /**
     * @private
     */
    addWidgets(childWidgets) {
        while (childWidgets.length > 0) {
            let widget = childWidgets.shift();
            if (widget instanceof LineWidget && this instanceof ParagraphWidget) {
                widget.paragraph = this;
                this.height += widget.height;
            }
            else if (widget instanceof Widget) {
                let lastChild = this.lastChild;
                widget.containerWidget = this;
                widget.y = lastChild instanceof Widget ? lastChild.y + lastChild.height : this.y;
                this.height += widget.height;
            }
            this.childWidgets.push(widget);
        }
    }
    /**
     * @private
     */
    removeChild(index) {
        if (index > -1 && index < this.childWidgets.length) {
            this.childWidgets.splice(index, 1);
        }
    }
    /**
     * @private
     */
    destroy() {
        if (this.childWidgets) {
            while (this.childWidgets.length > 0) {
                let child = this.childWidgets.pop();
                if (child instanceof LineWidget || child instanceof Widget) {
                    child.destroy();
                }
            }
        }
        this.childWidgets = undefined;
        if (this.containerWidget) {
            this.containerWidget.removeChild(this.indexInOwner);
        }
        this.containerWidget = undefined;
        // if (this.margin) {
        //     this.margin.destroy();
        // }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
        this.index = undefined;
    }
}
/**
 * @private
 */
class BlockContainer extends Widget {
    constructor() {
        super(...arguments);
        /**
         * @private
         */
        this.sectionFormatIn = undefined;
    }
    /**
     * @private
     */
    get sectionFormat() {
        let container = this;
        if (container instanceof BodyWidget) {
            return container.sectionFormatIn;
        }
        else if (container.page) {
            return container.page.bodyWidgets[0].sectionFormat;
        }
        return undefined;
    }
    /**
     * @private
     */
    set sectionFormat(value) {
        if (this instanceof BodyWidget) {
            this.sectionFormatIn = value;
        }
    }
    /**
     * @private
     */
    get sectionIndex() {
        let container = this;
        let index = 0;
        if (container instanceof BodyWidget) {
            index = container.index;
        }
        else if (container.page) {
            index = container.page.bodyWidgets[0].index;
        }
        return index;
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let viewer = undefined;
        let node = this;
        if (node instanceof BodyWidget) {
            hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        }
        else {
            if (node.headerFooterType.indexOf('Header') !== -1) {
                hierarchicalIndex = 'H' + ';' + hierarchicalIndex;
            }
            else {
                hierarchicalIndex = 'F' + ';' + hierarchicalIndex;
            }
        }
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            let pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    }
}
/**
 * @private
 */
class BodyWidget extends BlockContainer {
    /**
     * Initialize the constructor of BodyWidget
     */
    constructor() {
        super();
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof BodyWidget && widget.sectionFormat === this.sectionFormat;
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let viewer = undefined;
        let node = this;
        hierarchicalIndex = node.index + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.page)) {
            viewer = this.page.viewer;
            let pageIndex = viewer.pages.indexOf(this.page);
            return pageIndex + ';' + hierarchicalIndex;
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    getTableCellWidget(touchPoint) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= touchPoint.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= touchPoint.y) {
                return this.childWidgets[i].getTableCellWidget(touchPoint);
            }
        }
        let tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= touchPoint.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(touchPoint);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(touchPoint);
            }
        }
        return tableCellWidget;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let n = 0; n < this.childWidgets.length; n++) {
                let chilgWidget = this.childWidgets[n];
                if (chilgWidget instanceof ParagraphWidget) {
                    chilgWidget.destroyInternal(viewer);
                }
                else {
                    chilgWidget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                n--;
            }
            this.childWidgets = undefined;
        }
        // if (this instanceof HeaderFooterWidget && ((this as HeaderFooterWidget).currentNode ))) {
        //     if (((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets )) {
        //         let index: number = ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.indexOf(this);
        //         ((this as HeaderFooterWidget).currentNode as WHeaderFooter).layoutedWidgets.splice(index, 1);
        //     }
        //     this.currentNode = undefined;
        /* tslint:disable: one-line */
        if (!isNullOrUndefined(this.page)) {
            let index = this.indexInOwner;
            if (this.indexInOwner > -1) {
                this.page.bodyWidgets.splice(index, 1);
                if (this.page.bodyWidgets.length === 0) {
                    this.page.destroy();
                    // }
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.headerWidget === this) {
                    this.page.headerWidget = undefined;
                }
                else if ((this instanceof HeaderFooterWidget)
                    && this.page.footerWidget === this) {
                    this.page.footerWidget = undefined;
                }
                this.page = undefined;
            }
        }
        this.destroy();
    }
    /**
     * @private
     */
    destroy() {
        // if (this.sectionFormat) {
        //     this.sectionFormat.destroy();
        // }
        this.sectionFormat = undefined;
        this.page = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class HeaderFooterWidget extends BlockContainer {
    constructor(type) {
        super();
        /**
         * @private
         */
        this.isEmpty = false;
        this.headerFooterType = type;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        return undefined;
    }
    /**
     * @private
     */
    equals(widget) {
        // Todo: Need to work
        return widget instanceof HeaderFooterWidget
            && widget.containerWidget === this.containerWidget;
    }
    /**
     * @private
     */
    clone() {
        let headerFooter = new HeaderFooterWidget(this.headerFooterType);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let block = this.childWidgets[i].clone();
            headerFooter.childWidgets.push(block);
            block.index = i;
            block.containerWidget = headerFooter;
        }
        headerFooter.isEmpty = this.isEmpty;
        headerFooter.x = this.x;
        headerFooter.y = this.y;
        headerFooter.height = 0;
        headerFooter.width = 0;
        return headerFooter;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        this.page = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class BlockWidget extends Widget {
    /**
     * @private
     */
    get bodyWidget() {
        let widget = this;
        while (widget.containerWidget) {
            if (widget.containerWidget instanceof BlockContainer) {
                return widget.containerWidget;
            }
            widget = widget.containerWidget;
        }
        return undefined;
    }
    /**
     * @private
     */
    get leftIndent() {
        let blockAdv = this;
        if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
            return blockAdv.paragraphFormat.leftIndent;
        }
        else if (blockAdv instanceof TableWidget && blockAdv.tableFormat instanceof WTableFormat) {
            return blockAdv.tableFormat.leftIndent;
        }
        return 0;
    }
    /**
     * @private
     */
    get rightIndent() {
        let blockAdv = this;
        if (blockAdv instanceof ParagraphWidget && blockAdv.paragraphFormat instanceof WParagraphFormat) {
            return blockAdv.paragraphFormat.rightIndent;
        }
        return 0;
    }
    /**
     * @private
     */
    get isInsideTable() {
        return this.containerWidget instanceof TableCellWidget;
    }
    /**
     * @private
     */
    get isInHeaderFooter() {
        return this.bodyWidget instanceof HeaderFooterWidget;
    }
    /**
     * @private
     */
    get associatedCell() {
        if (this.containerWidget instanceof TableCellWidget) {
            return this.containerWidget;
        }
        return undefined;
    }
    /**
     * Check whether the paragraph contains only page break.
     * @private
     */
    isPageBreak() {
        let isPageBreak = false;
        if (this instanceof ParagraphWidget) {
            let paragraph = this;
            if (paragraph != null && paragraph.childWidgets.length === 1 &&
                paragraph.firstChild.children.length === 1) {
                let pageBreak = paragraph.firstChild.children[0];
                isPageBreak = pageBreak.isPageBreak;
            }
        }
        return isPageBreak;
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let node = this;
        hierarchicalIndex = node.containerWidget.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (!isNullOrUndefined(node.containerWidget)) {
            if (node.containerWidget instanceof BlockWidget) {
                return node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
            else if (node.containerWidget instanceof BlockContainer) {
                hierarchicalIndex = node.containerWidget.getHierarchicalIndex(hierarchicalIndex);
            }
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    getIndex() {
        if (this instanceof ParagraphWidget || this instanceof TableWidget) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        else if (this instanceof TableRowWidget) {
            return this.ownerTable.childWidgets.indexOf(this);
        }
        else if (this instanceof TableCellWidget) {
            return this.ownerRow.childWidgets.indexOf(this);
        }
        return 0;
    }
    /**
     * @private
     */
    getContainerWidth() {
        if (this.isInsideTable) {
            return this.associatedCell.getCellWidth();
        }
        else {
            let bodyWidget = this.bodyWidget;
            let sectionFormat = bodyWidget.sectionFormat;
            return sectionFormat.pageWidth - (sectionFormat.leftMargin + sectionFormat.rightMargin);
        }
    }
    /**
     * @private
     */
    get bidi() {
        if (this instanceof ParagraphWidget && this.paragraphFormat instanceof WParagraphFormat) {
            return this.paragraphFormat.bidi;
        }
        if (this instanceof TableWidget && this.tableFormat instanceof WTableFormat) {
            return this.tableFormat.bidi;
        }
        return false;
    }
}
/**
 * @private
 */
class ParagraphWidget extends BlockWidget {
    /**
     * Initialize the constructor of ParagraphWidget
     */
    constructor() {
        super();
        /**
         * @private
         */
        this.isChangeDetected = false;
        this.paragraphFormat = new WParagraphFormat(this);
        this.characterFormat = new WCharacterFormat(this);
    }
    /**
     * @private
     */
    get isEndsWithPageBreak() {
        if (this.childWidgets.length > 0) {
            return this.lastChild.isEndsWithPageBreak;
        }
        return false;
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof ParagraphWidget && widget.paragraphFormat === this.paragraphFormat;
    }
    /**
     * @private
     */
    isEmpty() {
        if (isNullOrUndefined(this.childWidgets) || this.childWidgets.length === 0) {
            return true;
        }
        for (let j = 0; j < this.childWidgets.length; j++) {
            let inlineElement = this.childWidgets[j];
            for (let i = 0; i < inlineElement.children.length; i++) {
                let inline = inlineElement.children[i];
                if (inline.length === 0) {
                    continue;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox || inline instanceof BookmarkElementBox
                    || inline instanceof EditRangeEndElementBox || inline instanceof EditRangeStartElementBox
                    || inline instanceof ChartElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * @private
     */
    getInline(offset, indexInInline) {
        let inline = undefined;
        let count = 0;
        let isStarted = false;
        let splittedWidget = this.getSplitWidgets();
        for (let k = 0; k < splittedWidget.length; k++) {
            let widget = splittedWidget[k];
            for (let j = 0; j < widget.childWidgets.length; j++) {
                let line = widget.childWidgets[j];
                for (let i = 0; i < line.children.length; i++) {
                    inline = line.children[i];
                    if (inline instanceof ListTextElementBox) {
                        continue;
                    }
                    if (!isStarted && (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || inline instanceof BookmarkElementBox || inline instanceof FieldElementBox
                        && HelperMethods.isLinkedFieldCharacter(inline))
                        || inline instanceof ChartElementBox) {
                        isStarted = true;
                    }
                    if (isStarted && offset <= count + inline.length) {
                        indexInInline = (offset - count);
                        return { 'element': inline, 'index': indexInInline };
                    }
                    count += inline.length;
                }
            }
        }
        if (offset > count) {
            indexInInline = isNullOrUndefined(inline) ? offset : inline.length;
        }
        return { 'element': inline, 'index': indexInInline };
    }
    /**
     * @private
     */
    getLength() {
        let length = 0;
        for (let j = 0; j < this.childWidgets.length; j++) {
            let line = this.childWidgets[j];
            for (let i = 0; i < line.children.length; i++) {
                let element = line.children[i];
                if (element instanceof ListTextElementBox) {
                    continue;
                }
                length += element.length;
            }
        }
        return length;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        return undefined;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    getMinimumAndMaximumWordWidth(minimumWordWidth, maximumWordWidth) {
        minimumWordWidth = HelperMethods.convertPointToPixel(minimumWordWidth);
        maximumWordWidth = HelperMethods.convertPointToPixel(maximumWordWidth);
        if (this.childWidgets.length > 0) {
            let element = this.childWidgets[0].children[0];
            let text = '';
            let elements = new Dictionary();
            let imageWidths = [];
            // tslint:disable-next-line:no-constant-condition
            do {
                if (element instanceof TextElementBox && element.text !== '') {
                    elements.add(element, text.length);
                    text += (element.text);
                }
                else if (element instanceof FieldElementBox && element.fieldType === 0) {
                    let fieldBegin = element;
                    // tslint:disable-next-line:max-line-length
                    if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
                        element = isNullOrUndefined(fieldBegin.fieldSeparator) ? fieldBegin.fieldEnd : fieldBegin.fieldSeparator;
                    }
                }
                else if (element instanceof ImageElementBox) {
                    imageWidths.push(element.width);
                }
                if (isNullOrUndefined(element) || isNullOrUndefined(element.nextNode)) {
                    break;
                }
                element = element.nextNode;
            } while (true);
            let pattern = new RegExp('\\b\\w+\\b', 'g');
            let matches = [];
            let matchInfo;
            //tslint:disable no-conditional-assignment
            while (!isNullOrUndefined(matchInfo = pattern.exec(text))) {
                matches.push(matchInfo);
            }
            for (let i = 0; i < matches.length; i++) {
                let match = matches[i];
                let width = 0;
                text = '';
                let matchedValue = '';
                let wordStartIndex = 0;
                let wordEndIndex = match.index;
                let index = match.index;
                for (let j = 0; j < elements.keys.length; j++) {
                    let span = elements.keys[j];
                    let startIndex = elements.get(span);
                    let spanLength = span.length;
                    if (index <= startIndex + spanLength) {
                        wordStartIndex = index - startIndex;
                        if (match.index + match[0].length <= startIndex + spanLength) {
                            wordEndIndex = (match.index + match[0].length) - (startIndex + wordStartIndex);
                        }
                        else {
                            wordEndIndex = spanLength - wordStartIndex;
                            index += wordEndIndex;
                        }
                        text = span.text.substring(wordStartIndex, wordStartIndex + wordEndIndex);
                        matchedValue = matchedValue + text;
                    }
                    if (text !== '') {
                        width += this.bodyWidget.page.viewer.textHelper.getWidth(text, span.characterFormat);
                    }
                    if (matchedValue === match[0]) {
                        break;
                    }
                }
                if (width !== 0) {
                    if (minimumWordWidth === 0 || width > minimumWordWidth) {
                        minimumWordWidth = width;
                    }
                }
            }
            // Check the image widths present in the paragraph. Consider the maximum image width as minimum word width.
            let imageWidth = 0;
            if (imageWidths.length > 0) {
                imageWidth = Math.max.apply(null, imageWidths);
            }
            if (minimumWordWidth === 0 || imageWidth > minimumWordWidth) {
                minimumWordWidth = imageWidth;
            }
            let maximum = this.measureParagraph();
            if (maximumWordWidth === 0 || maximum > maximumWordWidth) {
                maximumWordWidth = maximum;
            }
        }
        return {
            'maximumWordWidth': HelperMethods.convertPixelToPoint(maximumWordWidth),
            'minimumWordWidth': HelperMethods.convertPixelToPoint(minimumWordWidth)
        };
    }
    measureParagraph() {
        let width = 0;
        let element = this.childWidgets[0].children[0];
        // tslint:disable-next-line:no-constant-condition
        do {
            if (element instanceof TextElementBox && element.text !== '') {
                width += this.bodyWidget.page.viewer.textHelper.getWidth(element.text, element.characterFormat);
            }
            else if (element instanceof FieldElementBox && element.fieldType === 0) {
                let fieldBegin = element;
                if (fieldBegin.fieldEnd != null) {
                    element = isNullOrUndefined(fieldBegin.fieldSeparator) ? fieldBegin.fieldEnd : fieldBegin.fieldSeparator;
                }
            }
            else if (element instanceof ImageElementBox) {
                width += element.width;
            }
            if (isNullOrUndefined(element) || isNullOrUndefined(element.nextNode)) {
                break;
            }
            element = element.nextNode;
        } while (true);
        // Considered the left and right indent.
        if (this.leftIndent > 0) {
            width += this.leftIndent;
        }
        if (this.rightIndent > 0) {
            width += this.rightIndent;
        }
        return width;
    }
    /**
     * @private
     */
    clone() {
        let paragraph = new ParagraphWidget();
        paragraph.paragraphFormat.copyFormat(this.paragraphFormat);
        paragraph.characterFormat.copyFormat(this.characterFormat);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let line = this.childWidgets[i];
            let cloneLine = line.clone();
            paragraph.childWidgets.push(cloneLine);
            cloneLine.paragraph = paragraph;
        }
        paragraph.x = this.x;
        paragraph.y = this.y;
        paragraph.height = this.height;
        paragraph.width = this.width;
        return paragraph;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let i = 0; i < this.childWidgets.length; i++) {
                let widget = this.childWidgets[i];
                widget.destroy();
                if (this.childWidgets.length === 1 && isNullOrUndefined(this.childWidgets[0].children)) {
                    this.childWidgets = undefined;
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget) && !isNullOrUndefined(this.containerWidget.childWidgets)
            && this.containerWidget.childWidgets.indexOf(this) !== -1) {
            this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
            this.containerWidget.height -= height;
            // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
            //     && this.containerWidget instanceof BodyWidget) {
            //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
            // }
            this.containerWidget = undefined;
        }
        this.destroy();
    }
    /**
     * @private
     */
    destroy() {
        // if (this.paragraphFormat) {
        //     this.paragraphFormat.destroy();
        // }
        this.paragraphFormat = undefined;
        // if (this.characterFormat) {
        //     this.characterFormat.destroy();
        // }
        this.characterFormat = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TableWidget extends BlockWidget {
    constructor() {
        super();
        this.flags = 0;
        /**
         * @private
         */
        this.leftMargin = 0;
        /**
         * @private
         */
        this.topMargin = 0;
        /**
         * @private
         */
        this.rightMargin = 0;
        /**
         * @private
         */
        this.bottomMargin = 0;
        /**
         * @private
         */
        this.isDefaultFormatUpdated = false;
        this.margin = new Margin(this.leftMargin, this.topMargin, this.rightMargin, this.bottomMargin);
        this.leftBorderWidth = 0;
        this.rightBorderWidth = 0;
        this.topBorderWidth = 0;
        this.bottomBorderWidth = 0;
        this.tableFormat = new WTableFormat(this);
        this.tableHolder = new WTableHolder();
        this.spannedRowCollection = new Dictionary();
    }
    /**
     * @private
     */
    get isGridUpdated() {
        return ((this.flags & 0x4) >> 2) !== 0;
    }
    /**
     * @private
     */
    set isGridUpdated(value) {
        this.flags = ((this.flags & 0xFB) | ((value ? 1 : 0) << 2));
    }
    /**
     * @private
     */
    get continueHeader() {
        return ((this.flags & 0x2) >> 1) !== 0;
    }
    /**
     * @private
     */
    set continueHeader(value) {
        this.flags = ((this.flags & 0xFD) | ((value ? 1 : 0) << 1));
    }
    /**
     * @private
     */
    get header() {
        return (this.flags & 0x1) !== 0;
    }
    /**
     * @private
     */
    set header(value) {
        this.flags = ((this.flags & 0xFE) | (value ? 1 : 0));
    }
    get isBidiTable() {
        return ((this.flags & 0x10) >> 4) !== 0;
    }
    set isBidiTable(value) {
        this.flags = ((this.flags & 0xEF) | ((value ? 1 : 0) << 4));
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof TableWidget && widget.tableFormat === this.tableFormat;
    }
    /**
     * @private
     */
    combineRows(viewer) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            if (row.childWidgets.length === 0) {
                row.destroy();
                i--;
            }
            else {
                row.combineCells(viewer);
            }
        }
    }
    /**
     * @private
     */
    contains(tableCell) {
        if (this.equals(tableCell.ownerTable)) {
            return true;
        }
        while (tableCell.ownerTable.isInsideTable) {
            if (this.equals(tableCell.ownerTable)) {
                return true;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return this.equals(tableCell.ownerTable);
    }
    /**
     * @private
     */
    getOwnerWidth(isBasedOnViewer) {
        let width = this.getContainerWidth();
        // Left and right indents should be neglected.
        width = width - this.leftIndent - this.rightIndent;
        return width >= 0 ? width : 0;
    }
    /**
     * @private
     */
    getTableWidth() {
        let width = 0;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let rowWidth = 0;
            let row = this.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                rowWidth += row.childWidgets[j].cellFormat.cellWidth;
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    /**
     * @private
     */
    getTableClientWidth(clientWidth) {
        let tableWidth = clientWidth;
        if (this.tableFormat.preferredWidthType === 'Point'
            && this.tableFormat.preferredWidth > 0) {
            tableWidth = this.tableFormat.preferredWidth;
        }
        else {
            if (this.tableFormat.preferredWidthType === 'Percent'
                && this.tableFormat.preferredWidth > 0) {
                tableWidth = tableWidth * this.tableFormat.preferredWidth / 100;
            }
        }
        return tableWidth;
    }
    /**
     * @private
     */
    getCellWidth(preferredWidth, preferredWidthType, containerWidth, cell) {
        let cellWidth = preferredWidth;
        if (preferredWidthType === 'Percent') {
            cellWidth = (preferredWidth * containerWidth) / 100;
        }
        else if (preferredWidthType === 'Point') {
            cellWidth = preferredWidth;
        }
        // For grid before and grid after with auto width, no need to calculate minimum preferred width.
        else if (!isNullOrUndefined(cell)) {
            cellWidth = cell.getMinimumPreferredWidth();
        }
        return cellWidth;
    }
    /**
     * @private
     */
    fitCellsToClientArea(clientWidth) {
        let tableWidth = this.getTableWidth();
        let factor = clientWidth / tableWidth;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            row.rowFormat.gridAfterWidth *= factor;
            row.rowFormat.gridBeforeWidth *= factor;
            for (let j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].cellFormat.cellWidth *= factor;
            }
        }
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        let tableCellWidget = undefined;
        for (let i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                tableCellWidget = this.childWidgets[i].getTableCellWidget(point);
                break;
            }
        }
        return tableCellWidget;
    }
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    calculateGrid() {
        let tempGrid = [];
        let spannedCells = [];
        let containerWidth = this.getOwnerWidth(true);
        let tableWidth = this.getTableClientWidth(containerWidth);
        this.tableCellInfo = new Dictionary();
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            let rowCellInfo = new Dictionary();
            let rowFormat = row.rowFormat;
            let cellWidth = 0;
            let columnSpan = row.rowFormat.gridBefore;
            let currOffset = 0;
            if (tempGrid.indexOf(currOffset) < 0) {
                tempGrid.push(currOffset);
            }
            //Converts the row grid before width from point to twips point by 15 factor.
            cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, tableWidth, null);
            currOffset += cellWidth;
            let startOffset = parseFloat(currOffset.toFixed(2));
            if (tempGrid.indexOf(startOffset) < 0) {
                tempGrid.push(startOffset);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                for (let k = 0; k < spannedCells.length; k++) {
                    if (spannedCells[k].columnIndex < columnSpan) {
                        continue;
                    }
                    let rowSpan = spannedCells[k].cellFormat.rowSpan;
                    let removeSpannedCell = true;
                    if (spannedCells[k].columnIndex > columnSpan) {
                        {
                            removeSpannedCell = false;
                            // If the cell is the last cell in the row and the row has grid after value..
                            if (j === row.childWidgets.length - 1 && row.rowFormat.gridAfter > 0) {
                                // tslint:disable-next-line:max-line-length
                                cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                                currOffset += cellWidth;
                            }
                        }
                    }
                    else {
                        // If the table gird alone calculted then column index of the rowspanned cell will be directly taken. 
                        // If the gird calculation is done from the UI level opearations such as resizing then table holder 
                        // will have the columns at that time we can get the column index from the table holder.
                        //Converts the cell width from point to twips point by 15 factor.
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(spannedCells[k].cellFormat.preferredWidth, spannedCells[k].cellFormat.preferredWidthType, tableWidth, null);
                        currOffset += cellWidth;
                        columnSpan = spannedCells[k].columnIndex + spannedCells[k].cellFormat.columnSpan;
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - spannedCells[k].ownerRow.rowIndex === rowSpan - 1) {
                        spannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (spannedCells.length === 0 || spannedCells[spannedCells.length - 1].columnIndex <= columnSpan) {
                        spannedCells.push(cell);
                    }
                    else {
                        for (let m = spannedCells.length; m > 0; m--) {
                            if (spannedCells[m - 1].columnIndex > columnSpan) {
                                spannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                // Add start offset of each cell based on its index
                if (!rowCellInfo.containsKey(cell.cellIndex)) {
                    rowCellInfo.add(cell.cellIndex, parseFloat((currOffset - startOffset).toFixed(2)));
                }
                columnSpan += cell.cellFormat.columnSpan;
                //Converts the cell width from pixel to twips point by 15 factor.
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, null);
                currOffset += cellWidth;
                let offset = parseFloat(currOffset.toFixed(2));
                if (tempGrid.indexOf(offset) < 0) {
                    tempGrid.push(offset);
                }
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfter > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    currOffset += cellWidth;
                    if (tempGrid.indexOf(parseFloat(currOffset.toFixed(2))) < 0) {
                        tempGrid.push(parseFloat(currOffset.toFixed(2)));
                    }
                    columnSpan += rowFormat.gridAfter;
                }
                // Add rowindex and its cells info for each row
                if (!this.tableCellInfo.containsKey(row.rowIndex)) {
                    this.tableCellInfo.add(row.rowIndex, rowCellInfo);
                }
            }
        }
        tempGrid.sort((a, b) => { return a - b; });
        if (this.tableHolder.columns.length > 0 && tempGrid.length - 1 !== this.tableHolder.columns.length) {
            this.updateColumnSpans(tempGrid, tableWidth);
        }
        this.tableCellInfo.clear();
        this.tableCellInfo = undefined;
    }
    updateColumnSpans(tempGrid, containerWidth) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            if (row.rowFormat.gridBeforeWidth >= 0) {
                row.rowFormat.gridBefore = row.getGridCount(tempGrid, undefined, -1, containerWidth);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let columnSpan = row.getGridCount(tempGrid, cell, cell.getIndex(), containerWidth);
                if (columnSpan > 0 && cell.cellFormat.columnSpan !== columnSpan) {
                    cell.cellFormat.columnSpan = columnSpan;
                }
            }
            if (row.rowFormat.gridAfterWidth >= 0) {
                row.rowFormat.gridAfter = row.getGridCount(tempGrid, undefined, row.childWidgets.length, containerWidth);
            }
        }
    }
    /**
     * @private
     */
    getMinimumAndMaximumWordWidth(minimumWordWidth, maximumWordWidth) {
        this.checkTableColumns();
        let tableWidth = this.tableHolder.getTotalWidth(0);
        if (tableWidth > minimumWordWidth) {
            minimumWordWidth = tableWidth;
        }
        if (tableWidth > maximumWordWidth) {
            maximumWordWidth = tableWidth;
        }
        return { 'minimumWordWidth': minimumWordWidth, 'maximumWordWidth': maximumWordWidth };
    }
    /**
     * @private
     */
    checkTableColumns() {
        if (this.isGridUpdated) {
            return;
        }
        let isAutoFit = this.isAutoFit();
        if (isAutoFit || this.tableHolder.columns.length === 0) {
            this.buildTableColumns();
        }
        this.isGridUpdated = true;
    }
    /**
     * @private
     */
    isAutoFit() {
        let bodyWidget = this.bodyWidget;
        if (!isNullOrUndefined(bodyWidget) && !isNullOrUndefined(bodyWidget.page)) {
            return bodyWidget.page.viewer.layout.getParentTable(this).tableFormat.allowAutoFit;
        }
        return false;
    }
    /**
     * @private
     */
    buildTableColumns() {
        if (this.isGridUpdated) {
            return;
        }
        // Clear existing columns in order to start creating columns freshly.
        this.tableHolder.resetColumns();
        let containerWidth = 0;
        let tableWidth = 0;
        let rowSpannedCells = [];
        let isAutoWidth = this.tableFormat.preferredWidthType === 'Auto';
        let isAutoFit = this.tableFormat.allowAutoFit;
        // For continuous layout, window width should be considered. 
        // If preferred width exceeds this limit, it can take upto maximum of 2112 pixels (1584 points will be assigned by Microsoft Word).
        containerWidth = this.getOwnerWidth(true);
        let isZeroWidth = (isAutoWidth && this.tableFormat.preferredWidth === 0 && !isAutoFit);
        tableWidth = this.getTableClientWidth(containerWidth);
        if (isZeroWidth && !this.isDefaultFormatUpdated) {
            this.splitWidthToTableCells(tableWidth, isZeroWidth);
        }
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            let rowFormat = row.rowFormat;
            let columnSpan = 0;
            let cellWidth = 0;
            let sizeInfo = new ColumnSizeInfo();
            let offset = 0;
            if (rowFormat.gridBefore > 0) {
                cellWidth = this.getCellWidth(rowFormat.gridBeforeWidth, row.rowFormat.gridAfterWidthType, tableWidth, null);
                sizeInfo.minimumWidth = cellWidth;
                this.tableHolder.addColumns(columnSpan, columnSpan = rowFormat.gridBefore, cellWidth, sizeInfo, offset = cellWidth);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                if (rowSpannedCells.length === 0) {
                    cell.columnIndex = columnSpan;
                }
                for (let k = 0; k < rowSpannedCells.length; k++) {
                    let rowSpannedCell = rowSpannedCells[k];
                    if (rowSpannedCell.columnIndex < columnSpan) {
                        cell.columnIndex = columnSpan;
                        continue;
                    }
                    let rowSpan = 1;
                    let removeSpannedCell = true;
                    rowSpan = rowSpannedCell.cellFormat.rowSpan;
                    if (rowSpannedCell.columnIndex > columnSpan) {
                        cell.columnIndex = columnSpan;
                        removeSpannedCell = false;
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        cellWidth = this.getCellWidth(rowSpannedCell.cellFormat.preferredWidth, rowSpannedCell.cellFormat.preferredWidthType, tableWidth, rowSpannedCell);
                        sizeInfo = rowSpannedCell.getCellSizeInfo(isAutoFit);
                        // If the table gird alone calculated then column index of the rowspanned cell will be directly taken. 
                        // tslint:disable-next-line:max-line-length
                        // If the gird calculation is done from the UI level operations such as resizing then table holder will have the columns at that time we can get the column index from the table holder.
                        // tslint:disable-next-line:max-line-length
                        if (this.tableHolder.columns.length > 0) {
                            this.tableHolder.addColumns(columnSpan, columnSpan = this.tableHolder.columns.indexOf(rowSpannedCell.ownerColumn) + rowSpannedCell.cellFormat.columnSpan, cellWidth, sizeInfo, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                        else {
                            // tslint:disable-next-line:max-line-length
                            this.tableHolder.addColumns(columnSpan, columnSpan = rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan, cellWidth, sizeInfo, offset += cellWidth);
                            cell.columnIndex = columnSpan;
                        }
                    }
                    if (!removeSpannedCell && j === row.childWidgets.length - 1) {
                        removeSpannedCell = true;
                    }
                    if (removeSpannedCell && i - rowSpannedCell.ownerRow.rowIndex === rowSpan - 1) {
                        rowSpannedCells.splice(k, 1);
                        k--;
                    }
                }
                // At the start of each row, we will process the row spanned cells to get the start column index.
                // To calculate grid properly, we need the items in the spanned cells collection in the order of their column index
                if (cell.cellFormat.rowSpan > 1) {
                    if (rowSpannedCells.length === 0 || rowSpannedCells[rowSpannedCells.length - 1].columnIndex <= columnSpan) {
                        rowSpannedCells.push(cell);
                    }
                    else {
                        for (let m = rowSpannedCells.length; m > 0; m--) {
                            if (rowSpannedCells[m - 1].columnIndex > columnSpan) {
                                rowSpannedCells.splice(m - 1, 0, cell);
                            }
                        }
                    }
                }
                let newCellFormat = new WCellFormat();
                if (isZeroWidth && !this.isDefaultFormatUpdated) {
                    cell.cellFormat.copyFormat(newCellFormat);
                }
                cellWidth = this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, tableWidth, cell);
                sizeInfo = cell.getCellSizeInfo(isAutoFit);
                this.tableHolder.addColumns(columnSpan, columnSpan += cell.cellFormat.columnSpan, cellWidth, sizeInfo, offset += cellWidth);
                if (j === row.childWidgets.length - 1 && rowFormat.gridAfterWidth > 0) {
                    cellWidth = this.getCellWidth(rowFormat.gridAfterWidth, 'Point', tableWidth, null);
                    this.tableHolder.addColumns(columnSpan, columnSpan += rowFormat.gridAfter, cellWidth, sizeInfo, offset += cellWidth);
                }
            }
        }
        if (isZeroWidth && !this.isDefaultFormatUpdated) {
            this.isDefaultFormatUpdated = true;
        }
        this.tableHolder.validateColumnWidths();
        if (isAutoFit) {
            // Fits the column width automatically based on contents.
            this.tableHolder.autoFitColumn(containerWidth, tableWidth, isAutoWidth, this.isInsideTable);
        }
        else {
            // Fits the column width based on preferred width. i.e. Fixed layout.
            this.tableHolder.fitColumns(containerWidth, tableWidth, isAutoWidth, this.leftIndent + this.rightIndent);
        }
        //Sets the width to cells
        this.setWidthToCells(tableWidth, isAutoWidth);
    }
    /**
     * @private
     */
    setWidthToCells(tableWidth, isAutoWidth) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let rw = this.childWidgets[i];
            let rowFormat = rw.rowFormat;
            if (rowFormat.gridBefore > 0) {
                rowFormat.beforeWidth = this.tableHolder.getCellWidth(0, rowFormat.gridBefore, tableWidth);
            }
            for (let j = 0; j < rw.childWidgets.length; j++) {
                let cell = rw.childWidgets[j];
                // tslint:disable-next-line:max-line-length
                cell.cellFormat.cellWidth = this.tableHolder.getCellWidth(cell.columnIndex, cell.cellFormat.columnSpan, tableWidth);
                //By default, if cell preferred widthType is auto , width set based on table width and type is changed to 'Point'
            }
            if (rowFormat.gridAfter > 0) {
                rowFormat.afterWidth = this.tableHolder.getCellWidth(0, rowFormat.gridAfter, tableWidth);
            }
        }
    }
    /**
     * @private
     */
    updateProperties(updateAllowAutoFit, currentSelectedTable, autoFitBehavior) {
        if (updateAllowAutoFit) {
            this.tableFormat.allowAutoFit = autoFitBehavior !== 'FixedColumnWidth';
        }
        if (this !== currentSelectedTable) {
            currentSelectedTable.updateProperties(false, currentSelectedTable, autoFitBehavior);
            return;
        }
        if (autoFitBehavior === 'FixedColumnWidth') {
            // Clear the table widths and set the preferred width for cells.
            this.tableFormat.preferredWidth = 0;
            this.tableFormat.preferredWidthType = 'Auto';
            this.childWidgets.forEach((row) => {
                row.childWidgets.forEach((cell) => {
                    cell.cellFormat.preferredWidthType = 'Point';
                    cell.cellFormat.preferredWidth = cell.cellFormat.cellWidth;
                });
            });
        }
        else if (autoFitBehavior === 'FitToWindow') {
            // Set the preferred width for table and cells in percentage.
            let tableWidth = this.tableHolder.getTotalWidth(0);
            this.tableFormat.leftIndent = 0;
            this.tableFormat.preferredWidth = 100;
            this.tableFormat.preferredWidthType = 'Percent';
            this.childWidgets.forEach((row) => {
                row.childWidgets.forEach((cell) => {
                    if (cell.cellFormat.preferredWidthType !== 'Percent') {
                        cell.cellFormat.preferredWidthType = 'Percent';
                        cell.cellFormat.preferredWidth = (cell.cellFormat.cellWidth / tableWidth) * 100;
                    }
                });
            });
        }
        else {
            // Clear the preferred width for table and cells.
            this.tableFormat.preferredWidth = 0;
            this.tableFormat.preferredWidthType = 'Auto';
            this.childWidgets.forEach((row) => {
                row.rowFormat.beforeWidth = 0;
                row.rowFormat.gridBefore = 0;
                row.rowFormat.gridBeforeWidth = 0;
                row.rowFormat.gridBeforeWidthType = 'Auto';
                row.rowFormat.afterWidth = 0;
                row.rowFormat.gridAfter = 0;
                row.rowFormat.gridAfterWidth = 0;
                row.rowFormat.gridAfterWidthType = 'Auto';
                row.childWidgets.forEach((cell) => {
                    cell.cellFormat.preferredWidth = 0;
                    cell.cellFormat.preferredWidthType = 'Auto';
                });
            });
        }
    }
    /**
     * @private
     */
    getMaxRowWidth(clientWidth) {
        let width = 0;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            let rowWidth = 0;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                rowWidth += this.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, clientWidth, cell);
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    /**
     * @private
     */
    updateWidth(dragValue) {
        let totalPreferredWidth = this.tableHolder.getTotalWidth(0);
        let ownerWidth = this.getOwnerWidth(true);
        let containerWidth = this.getTableClientWidth(ownerWidth);
        if (containerWidth <= totalPreferredWidth) {
            if (this.tableFormat.preferredWidthType === 'Auto') {
                this.tableFormat.preferredWidthType = 'Point';
            }
        }
        if (this.tableFormat.preferredWidthType !== 'Auto') {
            if (this.tableFormat.preferredWidthType === 'Point') {
                this.tableFormat.preferredWidth = this.getMaxRowWidth(containerWidth);
            }
            else { //ToDo:Need to analyze more the Percentage calculation for table width.
                let value = (totalPreferredWidth / ownerWidth) * 100;
                this.tableFormat.preferredWidth = value;
            }
        }
    }
    /**
     * @private
     */
    convertPointToPercent(tablePreferredWidth, ownerWidth) {
        let value = 0;
        value = (tablePreferredWidth / ownerWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    }
    updateChildWidgetLeft(left) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let rowWidget = this.childWidgets[i];
            rowWidget.x = left;
            rowWidget.updateChildWidgetLeft(left);
        }
    }
    /**
     * Shift the widgets for right to left aligned table.
     * @private
     */
    shiftWidgetsForRtlTable(clientArea, tableWidget) {
        let clientAreaX = tableWidget.x;
        let clientAreaRight = clientArea.right;
        let cellSpace = 0;
        if (tableWidget.tableFormat && tableWidget.tableFormat.cellSpacing > 0) {
            cellSpace = tableWidget.tableFormat.cellSpacing;
        }
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = tableWidget.childWidgets[i];
            let rowX = rowWidget.x;
            let left = clientAreaRight - (rowX - clientAreaX);
            for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                let cellWidget = rowWidget.childWidgets[j];
                left = left -
                    (cellWidget.width + cellWidget.margin.left + cellWidget.margin.right - cellWidget.rightBorderWidth + cellSpace);
                cellWidget.updateWidgetLeft(left + cellWidget.margin.left);
            }
        }
    }
    /**
     * @private
     */
    clone() {
        let table = new TableWidget();
        table.tableHolder = this.tableHolder.clone();
        table.tableFormat.copyFormat(this.tableFormat);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i].clone();
            table.childWidgets.push(row);
            row.containerWidget = table;
            row.index = i;
        }
        table.x = this.x;
        table.y = this.y;
        table.height = this.height;
        table.width = this.width;
        table.containerWidget = this.containerWidget;
        return table;
    }
    /**
     * @private
     */
    static getTableOf(node) {
        if (node instanceof WBorders) {
            let row = TableRowWidget.getRowOf(node);
            if (!isNullOrUndefined(row)) {
                return row.ownerTable;
            }
            else if (node.ownerBase instanceof WTableFormat && node.ownerBase.ownerBase instanceof TableWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    fitChildToClientArea() {
        let clientWidth = this.getContainerWidth();
        if (Math.round(clientWidth) < Math.round(this.getTableWidth())) {
            this.fitCellsToClientArea(clientWidth);
        }
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                for (let k = 0; k < cell.childWidgets.length; k++) {
                    if (cell.childWidgets[k] instanceof TableWidget) {
                        cell.childWidgets[k].fitChildToClientArea();
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    getColumnCellsForSelection(startCell, endCell) {
        let cells = [];
        let start = startCell.columnIndex;
        let end = endCell.columnIndex + endCell.cellFormat.columnSpan;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let columnIndex = cell.columnIndex;
                let columnSpan = cell.cellFormat.columnSpan;
                if ((columnIndex + columnSpan > start && columnIndex + columnSpan < end) || (columnIndex > start && columnIndex < end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if ((columnIndex > start && columnIndex < end && columnIndex + columnSpan < end)
                    || (columnIndex < start && columnIndex + columnSpan > end)) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
                else if (columnIndex === start || columnIndex + columnSpan === end) {
                    if (cells.indexOf(cell) < 0) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    }
    /**
     * Splits width equally for all the cells.
     * @param tableClientWidth
     * @private
     */
    splitWidthToTableCells(tableClientWidth, isZeroWidth) {
        for (let row = 0; row < this.childWidgets.length; row++) {
            this.childWidgets[row].splitWidthToRowCells(tableClientWidth, isZeroWidth);
        }
    }
    /**
     * @private
     */
    insertTableRowsInternal(tableRows, startIndex) {
        for (let i = tableRows.length - 1; i >= 0; i--) {
            let row = tableRows.splice(i, 1)[0];
            row.containerWidget = this;
            this.childWidgets.splice(startIndex, 0, row);
        }
        this.updateRowIndex(startIndex);
        this.isGridUpdated = false;
        this.buildTableColumns();
        this.isGridUpdated = true;
    }
    /**
     * @private
     */
    updateRowIndex(startIndex) {
        for (let i = startIndex; i < this.childWidgets.length; i++) {
            let row = this.childWidgets[i];
            row.index = i;
            for (let j = 0; j < row.childWidgets.length; j++) {
                row.childWidgets[j].index = j;
                row.childWidgets[j].rowIndex = row.rowIndex;
            }
            startIndex++;
        }
    }
    /**
     * @private
     */
    getCellStartOffset(cell) {
        let offset = 0;
        if (cell && this.tableCellInfo) {
            if (this.tableCellInfo.containsKey(cell.ownerRow.rowIndex)) {
                let rowCellInfo = this.tableCellInfo.get(cell.ownerRow.rowIndex);
                if (rowCellInfo.containsKey(cell.cellIndex)) {
                    offset = rowCellInfo.get(cell.cellIndex);
                }
            }
        }
        return offset;
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let j = 0; j < this.childWidgets.length; j++) {
                let widget = undefined;
                let childWidget = this.childWidgets[j];
                widget = childWidget;
                if (!isNullOrUndefined(widget)) {
                    widget.destroyInternal(viewer);
                }
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                j--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                if (this.containerWidget.childWidgets.indexOf(this) !== -1) {
                    this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                }
                this.containerWidget.height -= height;
                // if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                //     && this.containerWidget instanceof BodyWidget) {
                //     // (this.containerWidget as BodyWidget).destroyInternal(viewer);
                // }
            }
            this.containerWidget = undefined;
        }
        this.destroy();
    }
    /**
     * @private
     */
    destroy() {
        // if (this.tableFormat) {
        //     this.tableFormat.destroy();
        // }
        this.tableFormat = undefined;
        if (this.spannedRowCollection) {
            this.spannedRowCollection.destroy();
        }
        this.spannedRowCollection = undefined;
        // if (this.tableHolder) {
        //     this.tableHolder.destroy();
        // }
        this.tableHolder = undefined;
        this.flags = undefined;
        this.leftMargin = undefined;
        this.topMargin = undefined;
        this.rightMargin = undefined;
        this.bottomMargin = undefined;
        this.headerHeight = undefined;
        this.description = undefined;
        this.title = undefined;
        this.isDefaultFormatUpdated = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TableRowWidget extends BlockWidget {
    /**
     * @private
     */
    get rowIndex() {
        if (this.containerWidget) {
            return this.containerWidget.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get ownerTable() {
        if (this.containerWidget instanceof TableWidget) {
            return this.containerWidget;
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextRow() {
        let index = this.indexInOwner;
        if (index > -1 && index < this.ownerTable.childWidgets.length - 1) {
            return this.ownerTable.childWidgets[index + 1];
        }
        return undefined;
    }
    constructor() {
        super();
        this.topBorderWidth = 0;
        this.bottomBorderWidth = 0;
        this.rowFormat = new WRowFormat(this);
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof TableRowWidget && widget.rowFormat === this.rowFormat;
    }
    /**
     * @private
     */
    combineCells(viewer) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cell = this.childWidgets[i];
            cell.combineWidget(viewer);
            if (cell.cellFormat.rowSpan === 1) {
                let cellHeight = cell.height + cell.margin.top + cell.margin.bottom;
                if ((this.height - this.ownerTable.tableFormat.cellSpacing) < cell.height) {
                    this.height = this.ownerTable.tableFormat.cellSpacing + cell.height;
                }
            }
        }
    }
    /**
     * @private
     */
    static getRowOf(node) {
        if (node instanceof WBorders) {
            let cell = TableCellWidget.getCellOf(node);
            if (!isNullOrUndefined(cell)) {
                return cell.ownerRow;
            }
            else if (node.ownerBase instanceof WRowFormat && node.ownerBase.ownerBase instanceof TableRowWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getCell(rowIndex, cellIndex) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cell = this.childWidgets[i];
            if (cell.rowIndex === rowIndex && cell.index === cellIndex) {
                return cell;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    splitWidthToRowCells(tableClientWidth, isZeroWidth) {
        let cells = this.childWidgets;
        let cellWidth = tableClientWidth / cells.length;
        for (let cell = 0; cell < cells.length; cell++) {
            if (isZeroWidth && cells[cell].cellFormat.preferredWidth === 0) {
                cells[cell].cellFormat.preferredWidth = cellWidth;
                this.ownerTable.isDefaultFormatUpdated = false;
            }
            else if (isZeroWidth) {
                this.ownerTable.isDefaultFormatUpdated = true;
                break;
            }
            else {
                cells[cell].cellFormat.preferredWidth = cellWidth;
            }
        }
    }
    /**
     * @private
     */
    getGridCount(tableGrid, cell, index, containerWidth) {
        let prevOffset = 0;
        let width = 0;
        let ownerTable = this.ownerTable;
        let rowFormat = this.rowFormat;
        if (index === -1) {
            width = ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
        }
        else {
            prevOffset += ownerTable.getCellWidth(rowFormat.gridBeforeWidth, rowFormat.gridBeforeWidthType, containerWidth, null);
            if (index >= 0) {
                prevOffset += ownerTable.getCellStartOffset(cell);
            }
            if (index < this.childWidgets.length) {
                width = ownerTable.getCellWidth(cell.cellFormat.preferredWidth, cell.cellFormat.preferredWidthType, containerWidth, null);
            }
            else {
                width = ownerTable.getCellWidth(rowFormat.gridAfterWidth, rowFormat.gridAfterWidthType, containerWidth, null);
            }
        }
        let gridStartIndex = this.getOffsetIndex(tableGrid, prevOffset);
        let gridEndIndex = this.getOffsetIndex(tableGrid, prevOffset + width);
        return gridEndIndex - gridStartIndex;
    }
    getOffsetIndex(tableGrid, offset) {
        offset = parseFloat(offset.toFixed(2));
        let index = 0;
        if (tableGrid.indexOf(offset) >= 0) {
            index = tableGrid.indexOf(offset);
        }
        else {
            for (let i = 0; i < tableGrid.length; i++) {
                if (tableGrid[i] > offset) {
                    return i;
                }
            }
            index = tableGrid.length - 1;
        }
        return index;
    }
    getCellOffset(index, containerWidth) {
        let prevOffset = 0;
        let ownerTable = this.ownerTable;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cellFormat = this.childWidgets[i].cellFormat;
            if (i === index) {
                break;
            }
            prevOffset += ownerTable.getCellWidth(cellFormat.preferredWidth, cellFormat.preferredWidthType, containerWidth, null);
        }
        return prevOffset;
    }
    /**
     * @private
     */
    updateRowBySpannedCells() {
        let rowSpannedCells = this.getPreviousRowSpannedCells();
        let currentRowIndex = this.rowIndex;
        for (let i = 0; i < rowSpannedCells.length; i++) {
            let spannedCell = rowSpannedCells[i];
            let rowSpanEnd = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;
            // If current row is row span end or includes spanned cells. then, decrease the rowspan
            if (rowSpanEnd >= currentRowIndex) {
                spannedCell.cellFormat.rowSpan -= 1;
            }
        }
    }
    /**
     * @private
     */
    getPreviousRowSpannedCells(include) {
        let rowSpannedCells = [];
        let row = include ? this : this.previousWidget;
        while (!isNullOrUndefined(row)) {
            for (let i = 0; i < row.childWidgets.length; i++) {
                let cell = row.childWidgets[i];
                if (cell.cellFormat.rowSpan > 1) {
                    rowSpannedCells.splice(0, 0, cell);
                }
            }
            row = row.previousWidget;
        }
        return rowSpannedCells;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let x = Math.round(this.childWidgets[i].x);
            if (x - this.childWidgets[i].margin.left - 1 <= point.x
                && (x + this.childWidgets[i].width) >= point.x) {
                return this.childWidgets[i];
            }
            else if (i === this.childWidgets.length - 1
                && (this.childWidgets[i].x + this.childWidgets[i].width) + 1 <= point.x) {
                return this.childWidgets[i];
            }
        }
        let cellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].x <= point.x) {
                cellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                cellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return cellWidget;
    }
    /**
     * @private
     */
    getMinimumAndMaximumWordWidth(minimumWordWidth, maximumWordWidth) {
        return { 'minimumWordWidth': minimumWordWidth, 'maximumWordWidth': maximumWordWidth };
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        let height = this.height;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let i = 0; i < this.childWidgets.length; i++) {
                let widget = this.childWidgets[i];
                widget.destroyInternal(viewer);
                if (isNullOrUndefined(this.childWidgets)) {
                    break;
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        if (!isNullOrUndefined(this.containerWidget)) {
            if (!isNullOrUndefined(this.containerWidget.childWidgets)) {
                this.containerWidget.childWidgets.splice(this.containerWidget.childWidgets.indexOf(this), 1);
                if ((isNullOrUndefined(this.containerWidget.childWidgets) || this.containerWidget.childWidgets.length === 0)
                    && this.containerWidget instanceof TableWidget) {
                    this.containerWidget.destroyInternal(viewer);
                }
                else if (this.containerWidget.containerWidget instanceof BodyWidget) {
                    this.containerWidget.containerWidget.height -= height;
                }
                this.containerWidget.height -= height;
            }
        }
        this.destroy();
    }
    /**
     * @private
     */
    clone() {
        let row = new TableRowWidget();
        row.rowFormat.copyFormat(this.rowFormat);
        row.topBorderWidth = this.topBorderWidth;
        row.bottomBorderWidth = this.bottomBorderWidth;
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cell = this.childWidgets[i].clone();
            row.childWidgets.push(cell);
            cell.containerWidget = row;
            cell.index = i;
            cell.rowIndex = this.rowIndex;
        }
        row.x = this.x;
        row.y = this.y;
        row.height = this.height;
        row.width = this.width;
        return row;
    }
    /**
     * Updates the child widgets left.
     * @param left
     * @private
     */
    updateChildWidgetLeft(left) {
        // TODO: Cell spacing calculation.
        let spacing = 0;
        if (this.ownerTable.tableFormat.cellSpacing > 0) {
            spacing = this.ownerTable.tableFormat.cellSpacing;
        }
        for (let i = 0; i < this.childWidgets.length; i++) {
            let cellWidget = this.childWidgets[i];
            left += spacing + cellWidget.margin.left;
            cellWidget.x = left;
            cellWidget.updateChildWidgetLeft(cellWidget.x);
            left += cellWidget.width + cellWidget.margin.right;
        }
    }
    /**
     * Shift the widgets for RTL table.
     * @param clientArea
     * @param tableWidget
     * @param rowWidget
     * @private
     */
    shiftWidgetForRtlTable(clientArea, tableWidget, rowWidget) {
        let clientAreaX = tableWidget.x;
        let cellSpace = 0;
        let tableWidth = 0;
        if (tableWidget.tableFormat != null && tableWidget.tableFormat.cellSpacing > 0) {
            cellSpace = tableWidget.tableFormat.cellSpacing;
        }
        tableWidth = HelperMethods.convertPointToPixel(tableWidget.getTableWidth());
        let rowX = rowWidget.x;
        let clientAreaRight = clientAreaX + tableWidth;
        let left = clientAreaRight - (rowX - clientAreaX);
        for (let j = 0; j < rowWidget.childWidgets.length; j++) {
            let cellWidget = rowWidget.childWidgets[j];
            left = left - (cellWidget.width + cellWidget.margin.left + cellWidget.margin.right - cellWidget.rightBorderWidth + cellSpace);
            cellWidget.updateWidgetLeft(left + cellWidget.margin.left);
        }
    }
    /**
     * @private
     */
    destroy() {
        // if (this.rowFormat) {
        //     this.rowFormat.destroy();
        // }
        this.rowFormat = undefined;
        this.rowFormat = undefined;
        this.topBorderWidth = undefined;
        this.bottomBorderWidth = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TableCellWidget extends BlockWidget {
    constructor() {
        super();
        /**
         * @private
         */
        this.rowIndex = -1;
        this.sizeInfoInternal = new ColumnSizeInfo();
        this.margin = new Margin(this.leftMargin, this.topMargin, this.rightMargin, this.bottomMargin);
        this.leftBorderWidth = 0;
        this.rightBorderWidth = 0;
        this.cellFormat = new WCellFormat(this);
    }
    /**
     * @private
     */
    get ownerColumn() {
        return this.ownerTable.tableHolder.columns[this.columnIndex];
    }
    /**
     * @private
     */
    get leftMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.leftMargin;
        }
        else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('leftMargin')) {
            return this.ownerRow.rowFormat.leftMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.leftMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get topMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.topMargin;
        }
        else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('topMargin')) {
            return this.ownerRow.rowFormat.topMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.topMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get rightMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.rightMargin;
        }
        else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('rightMargin')) {
            return this.ownerRow.rowFormat.rightMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.rightMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get bottomMargin() {
        if (this.cellFormat && this.cellFormat.containsMargins()) {
            return this.cellFormat.bottomMargin;
        }
        else if (!isNullOrUndefined(this.ownerRow) && this.ownerRow.rowFormat.hasValue('bottomMargin')) {
            return this.ownerRow.rowFormat.bottomMargin;
        }
        else if (!isNullOrUndefined(this.ownerTable) && !isNullOrUndefined(this.ownerTable.tableFormat)) {
            return this.ownerTable.tableFormat.bottomMargin;
        }
        else {
            return 0;
        }
    }
    /**
     * @private
     */
    get cellIndex() {
        if (this.ownerRow) {
            return this.ownerRow.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get ownerTable() {
        if (this.containerWidget instanceof TableRowWidget) {
            return this.containerWidget.ownerTable;
        }
        return undefined;
    }
    /**
     * @private
     */
    get ownerRow() {
        return this.containerWidget;
    }
    /**
     * @private
     */
    get sizeInfo() {
        return this.sizeInfoInternal;
    }
    /**
     * @private
     */
    equals(widget) {
        return widget instanceof TableCellWidget && widget.cellFormat === this.cellFormat;
    }
    /**
     * @private
     */
    getContainerTable() {
        let table = this.ownerTable;
        while (table instanceof TableWidget && table.associatedCell instanceof TableCellWidget) {
            table = table.associatedCell.getContainerTable();
        }
        return table;
    }
    /**
     * @private
     */
    getPreviousSplitWidget() {
        if (this.containerWidget instanceof TableRowWidget) {
            let row = this.containerWidget;
            do {
                row = row.previousRenderedWidget;
                if (isNullOrUndefined(row) || row.index < this.rowIndex) {
                    break;
                }
                let previousCell = row.getCell(this.rowIndex, this.index);
                if (previousCell && this.equals(previousCell)) {
                    return previousCell;
                }
            } while (row);
        }
        return undefined;
    }
    /**
     * @private
     */
    getNextSplitWidget() {
        let rowSpan = this.cellFormat.rowSpan;
        if (this.containerWidget instanceof TableRowWidget) {
            let row = this.containerWidget;
            do {
                row = row.nextRenderedWidget;
                if (isNullOrUndefined(row) || row.index > this.rowIndex + rowSpan) {
                    break;
                }
                let nextCell = row.getCell(this.rowIndex, this.index);
                if (nextCell && this.equals(nextCell)) {
                    return nextCell;
                }
            } while (row);
        }
        return undefined;
    }
    /**
     * @private
     */
    getTableCellWidget(point) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            if (this.childWidgets[i].y <= point.y
                && (this.childWidgets[i].y + this.childWidgets[i].height) >= point.y) {
                return this.childWidgets[i].getTableCellWidget(point);
            }
        }
        let tableCellWidget = undefined;
        if (this.childWidgets.length > 0) {
            if (this.childWidgets[0].y <= point.y) {
                tableCellWidget = this.childWidgets[this.childWidgets.length - 1].getTableCellWidget(point);
            }
            else {
                tableCellWidget = this.childWidgets[0].getTableCellWidget(point);
            }
        }
        return tableCellWidget;
    }
    /**
     * @private
     */
    updateWidth(preferredWidth) {
        if (this.cellFormat.preferredWidthType === 'Point') {
            this.cellFormat.preferredWidth = preferredWidth;
        }
        else if (this.cellFormat.preferredWidthType === 'Percent') {
            this.cellFormat.preferredWidth = this.convertPointToPercent(preferredWidth);
        }
        this.cellFormat.cellWidth = preferredWidth;
    }
    /**
     * @private
     */
    getCellWidth() {
        let ownerTable = this.ownerTable;
        let containerWidth = ownerTable ? ownerTable.getTableClientWidth(ownerTable.getOwnerWidth(true)) : 0;
        let cellWidth = containerWidth;
        if (ownerTable && ownerTable.tableFormat.preferredWidthType === 'Auto' && ownerTable.tableFormat.allowAutoFit) {
            cellWidth = containerWidth;
        }
        else if (this.cellFormat.preferredWidthType === 'Percent') {
            cellWidth = (this.cellFormat.preferredWidth * containerWidth) / 100 - this.leftMargin - this.rightMargin;
        }
        else if (this.cellFormat.preferredWidthType === 'Point') {
            cellWidth = this.cellFormat.preferredWidth - this.leftMargin - this.rightMargin;
        }
        // For grid before and grid after with auto width, no need to calculate minimum preferred width.
        return cellWidth;
    }
    /**
     * @private
     */
    convertPointToPercent(cellPreferredWidth) {
        let value = 0;
        let clientWidth = this.ownerTable.getOwnerWidth(true);
        let tableWidth = this.ownerTable.getTableClientWidth(clientWidth);
        value = (cellPreferredWidth / tableWidth) * 100;
        value = Math.round(value);
        return value < 100 ? value : 100; // The value should be lesser than or equal to 100%;
    }
    /**
     * @private
     */
    static getCellLeftBorder(tableCell) {
        let leftBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.left)) {
            leftBorder = cellBorder.left;
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            leftBorder = tableCell.getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders);
        }
        else {
            let prevCell = undefined;
            if (!isNullOrUndefined(tableCell.previousWidget)) {
                // if the border is shared then choose the border based on Conflict Resolution algorithm.
                prevCell = tableCell.previousWidget;
            }
            else if ((tableCell.cellFormat.columnSpan > 1 || tableCell.columnIndex > 1) && tableCell.ownerRow.rowIndex > 0) {
                let previousRow = tableCell.ownerRow.previousWidget;
                while (!isNullOrUndefined(previousRow) && previousRow.childWidgets.length > 0) {
                    for (let i = 0; i < previousRow.childWidgets.length; i++) {
                        let prevRowCell = previousRow.childWidgets[i];
                        if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan === tableCell.columnIndex) {
                            prevCell = previousRow.childWidgets[i];
                            break;
                        }
                    }
                    if (!isNullOrUndefined(prevCell)) {
                        break;
                    }
                    previousRow = previousRow.previousWidget;
                }
            }
            leftBorder = tableCell.getPreviousCellLeftBorder(leftBorder, prevCell);
        }
        if (isNullOrUndefined(leftBorder)) {
            leftBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return leftBorder;
    }
    /**
     * @private
     */
    getLeftBorderWidth() {
        let borderWidth = 0;
        // Added null condition check for asynchronous loading.
        if (this.cellFormat !== null && this.cellFormat.borders !== null) {
            // update the margins values respect to layouting of borders.
            // For normal table cells only left border is rendered. for last cell left and right border is rendered.
            // this border widths are not included in margins.
            borderWidth = TableCellWidget.getCellLeftBorder(this).getLineWidth();
            // tslint:disable-next-line:max-line-length
            // need to render rightBorder specifically for all the cells when the cellSpacing is greater than zero or for last cell of each row.
        }
        return borderWidth;
    }
    /**
     * @private
     */
    getRightBorderWidth() {
        let borderWidth = 0;
        let ownerTable = this.ownerTable;
        //Added null condition check for asynchronous loading.
        if (this.cellFormat !== null && this.cellFormat.borders !== null) {
            borderWidth = TableCellWidget.getCellRightBorder(this).getLineWidth();
        }
        return borderWidth;
    }
    /**
     * @private
     */
    getCellSpacing() {
        let actualCellSpacing = this.ownerTable && this.ownerTable.tableFormat ? this.ownerTable.tableFormat.cellSpacing : 0;
        let cellSpacingToLayout = actualCellSpacing;
        // Considers the left, right margins and border widths(only available for Layouted table) for Minimum width.
        if (this.ownerRow.childWidgets.length === 1) {
            cellSpacingToLayout = actualCellSpacing * 2;
        }
        else if (this.cellIndex === 0 || this.cellIndex === this.ownerRow.childWidgets.length - 1) {
            cellSpacingToLayout = actualCellSpacing + (actualCellSpacing / 2);
        }
        else {
            cellSpacingToLayout = actualCellSpacing;
        }
        return cellSpacingToLayout;
    }
    /**
     * @private
     */
    getCellSizeInfo(isAutoFit) {
        let contentChanged = false;
        // Gets the minimum preferred width for the table cell.
        if (!this.sizeInfo.hasMinimumWidth) {
            this.sizeInfo.minimumWidth = this.getMinimumPreferredWidth();
        }
        // Gets the minimum and maximum word widths.
        if (isAutoFit) {
            if (!this.sizeInfo.hasMinimumWordWidth || contentChanged) {
                let size = this.getMinimumAndMaximumWordWidth(0, 0);
                this.sizeInfo.minimumWordWidth = size.minimumWordWidth + this.sizeInfo.minimumWidth;
                this.sizeInfo.maximumWordWidth = size.maximumWordWidth + this.sizeInfo.minimumWidth;
                // if minimum and maximum width values are equal, set value as zero.
                // later, preferred width value is considered for all width values.
                if (this.sizeInfo.minimumWidth === this.sizeInfo.minimumWordWidth
                    && this.sizeInfo.minimumWordWidth === this.sizeInfo.maximumWordWidth) {
                    this.sizeInfo.minimumWordWidth = 0;
                    this.sizeInfo.maximumWordWidth = 0;
                    this.sizeInfo.minimumWidth = 0;
                }
            }
        }
        let sizeInfo = new ColumnSizeInfo();
        sizeInfo.minimumWidth = this.sizeInfo.minimumWidth;
        sizeInfo.minimumWordWidth = this.sizeInfo.minimumWordWidth;
        sizeInfo.maximumWordWidth = this.sizeInfo.maximumWordWidth;
        return sizeInfo;
    }
    /**
     * @private
     */
    getMinimumPreferredWidth() {
        let defaultWidth = 0;
        if (this.cellFormat.preferredWidth > 0) {
            return this.cellFormat.preferredWidth;
        }
        defaultWidth = this.leftMargin + this.rightMargin + this.getLeftBorderWidth() + this.getRightBorderWidth() + this.getCellSpacing();
        return defaultWidth;
    }
    /**
     * @private
     */
    getPreviousCellLeftBorder(leftBorder, previousCell) {
        // tslint:disable-next-line:max-line-length
        if ((isNullOrUndefined(previousCell) || (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle === 'None' && !leftBorder.hasNoneStyle)))) {
            if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                leftBorder = this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(previousCell)) {
            return leftBorder;
        }
        else {
            let prevCellRightBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousCell.cellFormat.borders) && !isNullOrUndefined(previousCell.cellFormat.borders.right) && previousCell.cellFormat.borders.right.lineStyle !== 'None') {
                prevCellRightBorder = previousCell.cellFormat.borders.right;
            }
            if (!isNullOrUndefined(prevCellRightBorder) && prevCellRightBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(prevCellRightBorder, leftBorder);
            }
            else if (!isNullOrUndefined(leftBorder) && !(leftBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getLeftBorderToRenderByHierarchy(leftBorder, TableRowWidget.getRowOf(leftBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(leftBorder.ownerBase).tableFormat.borders);
            }
        }
        return leftBorder;
    }
    /**
     * @private
     */
    getBorderBasedOnPriority(border, adjacentBorder) {
        // If the cell and its adjacent cell defined different borders then based on this algorithm the border choose to render.
        // Reference link :https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.wordprocessing.tablecellborders.aspx
        if (isNullOrUndefined(border)) {
            return adjacentBorder;
        }
        else if (isNullOrUndefined(adjacentBorder)) {
            return border;
        }
        let borderWeight = border.getBorderWeight();
        let adjacentBorderWeight = adjacentBorder.getBorderWeight();
        //the border with higher wight  shall be displayed.
        if (borderWeight === adjacentBorderWeight) {
            //if the border is equal weight the based on the priority the border will be choosen to render.
            let borderPriority = border.getPrecedence();
            let adjacentBorderPriority = adjacentBorder.getPrecedence();
            if (borderPriority === adjacentBorderPriority) {
                //The color with the smaller brightness value shall be displayed.
                let borderColInRGB = this.convertHexToRGB(border.color);
                let R1 = borderColInRGB.r;
                let G1 = borderColInRGB.g;
                let B1 = borderColInRGB.b;
                let adjacentBorderColInRGB = this.convertHexToRGB(adjacentBorder.color);
                let R2 = adjacentBorderColInRGB.r;
                let G2 = adjacentBorderColInRGB.g;
                let B2 = adjacentBorderColInRGB.b;
                let borderBrightness = (R1 + B1 + (2 * G1));
                let adjacentBorderBrightness = (R2 + B2 + (2 * G2));
                if (borderBrightness === adjacentBorderBrightness) {
                    borderBrightness = (B1 + (2 * G1));
                    adjacentBorderBrightness = (B2 + (2 * G2));
                    if (borderBrightness === adjacentBorderBrightness) {
                        if (G1 === G2) {
                            return border;
                        }
                        else if (G1 > G2) {
                            return adjacentBorder;
                        }
                        else {
                            return border;
                        }
                    }
                    else if (borderBrightness > adjacentBorderBrightness) {
                        return adjacentBorder;
                    }
                    else {
                        return border;
                    }
                }
                else if (borderBrightness > adjacentBorderBrightness) {
                    return adjacentBorder;
                }
                else {
                    return border;
                }
            }
            else if (borderPriority > adjacentBorderPriority) {
                return border;
            }
            else {
                return adjacentBorder;
            }
        }
        else if (borderWeight > adjacentBorderWeight) {
            return border;
        }
        else {
            return adjacentBorder;
        }
    }
    /**
     * @private
     */
    getLeftBorderToRenderByHierarchy(leftBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(leftBorder) && (leftBorder.lineStyle !== 'None' || (leftBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(leftBorder.lineStyle === 'None' && leftBorder.lineWidth === 0 && leftBorder.color === '#000000')))) {
            return leftBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(leftBorder) && (leftBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(leftBorder.ownerBase).columnIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.left)) {
                leftBorder = tableBorders.left;
            }
            return leftBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return leftBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return leftBorder = tableBorders.vertical;
        }
        else {
            return leftBorder;
        }
    }
    /**
     * @private
     */
    static getCellRightBorder(tableCell) {
        let rightBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.right)) {
            rightBorder = cellBorder.right;
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            rightBorder = tableCell.getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders);
        }
        else {
            let nextCell = undefined;
            if (!isNullOrUndefined(tableCell.nextWidget)) {
                nextCell = tableCell.nextWidget;
            }
            // if the border is shared then choose the border based on Conflict Resolution algorithm.
            rightBorder = tableCell.getAdjacentCellRightBorder(rightBorder, nextCell);
        }
        if (isNullOrUndefined(rightBorder)) {
            rightBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return rightBorder;
    }
    /**
     * @private
     */
    getAdjacentCellRightBorder(rightBorder, nextCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextCell) || (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle === 'None' && !rightBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                rightBorder = this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(nextCell)) {
            return rightBorder;
        }
        else {
            let nextCellLeftBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextCell.cellFormat.borders) && !isNullOrUndefined(nextCell.cellFormat.borders.left) && nextCell.cellFormat.borders.left.lineStyle !== 'None') {
                nextCellLeftBorder = nextCell.cellFormat.borders.left;
            }
            if (!isNullOrUndefined(nextCellLeftBorder) && nextCellLeftBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(rightBorder, nextCellLeftBorder);
            }
            else if (!isNullOrUndefined(rightBorder) && !(rightBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getRightBorderToRenderByHierarchy(rightBorder, TableRowWidget.getRowOf(rightBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(rightBorder.ownerBase).tableFormat.borders);
            }
        }
        return rightBorder;
    }
    /**
     * @private
     */
    getRightBorderToRenderByHierarchy(rightBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(rightBorder) && (rightBorder.lineStyle !== 'None' || (rightBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(rightBorder.lineStyle === 'None' && rightBorder.lineWidth === 0 && rightBorder.color === '#000000')))) {
            return rightBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(rightBorder) && (rightBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(rightBorder.ownerBase).columnIndex === TableCellWidget.getCellOf(rightBorder.ownerBase).ownerRow.childWidgets.length - 1) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.right)) {
                rightBorder = tableBorders.right;
            }
            return rightBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.vertical) && rowBorders.vertical.lineStyle !== 'None') {
            return rightBorder = rowBorders.vertical;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.vertical) && tableBorders.vertical.lineStyle !== 'None') {
            return rightBorder = tableBorders.vertical;
        }
        else {
            return rightBorder;
        }
    }
    /**
     * @private
     */
    static getCellTopBorder(tableCell) {
        let topBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.top)) {
            topBorder = cellBorder.top;
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            topBorder = tableCell.getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders);
        }
        else {
            let prevTopCell = undefined;
            //ToDo: Need to analyze more to get the previous cell.
            let prevRow = tableCell.ownerRow.previousWidget;
            while (!isNullOrUndefined(prevRow) && prevRow.childWidgets.length > 0) {
                for (let i = 0; i < prevRow.childWidgets.length; i++) {
                    let prevRowCell = prevRow.childWidgets[i];
                    if (prevRowCell.columnIndex + prevRowCell.cellFormat.columnSpan - 1 >= tableCell.columnIndex) {
                        prevTopCell = prevRow.childWidgets[i];
                        break;
                    }
                }
                if (!isNullOrUndefined(prevTopCell)) {
                    break;
                }
                prevRow = prevRow.previousWidget;
                //If all the previous rows checked and the previous top cell is null
                // then TableCell previus row matched column index cell is taken for border calculation.
                if (isNullOrUndefined(prevRow) && isNullOrUndefined(prevTopCell)) {
                    prevRow = tableCell.ownerRow.previousWidget;
                    if (tableCell.columnIndex < prevRow.childWidgets.length) {
                        for (let i = 0; i < prevRow.childWidgets.length; i++) {
                            let prevRowCell = prevRow.childWidgets[i];
                            if (prevRowCell.columnIndex === tableCell.columnIndex) {
                                prevTopCell = prevRow.childWidgets[i];
                                break;
                            }
                        }
                        //If table cell Column index is greater than previous row cells count then last cell is taken as previous top cell.
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        prevTopCell = tableCell.ownerRow.previousWidget.childWidgets[tableCell.ownerRow.previousWidget.childWidgets.length - 1];
                    }
                }
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            topBorder = tableCell.getPreviousCellTopBorder(topBorder, prevTopCell);
        }
        if (isNullOrUndefined(topBorder)) {
            topBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return topBorder;
    }
    /**
     * @private
     */
    getPreviousCellTopBorder(topBorder, previousTopCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(previousTopCell) || (!isNullOrUndefined(topBorder) && (topBorder.lineStyle === 'None' && !topBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                topBorder = this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(previousTopCell)) {
            return topBorder;
        }
        else {
            let prevTopCellBottomBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(previousTopCell.cellFormat.borders) && !isNullOrUndefined(previousTopCell.cellFormat.borders.bottom) && previousTopCell.cellFormat.borders.bottom.lineStyle !== 'None') {
                prevTopCellBottomBorder = previousTopCell.cellFormat.borders.bottom;
            }
            if (!isNullOrUndefined(prevTopCellBottomBorder) && prevTopCellBottomBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(topBorder, prevTopCellBottomBorder);
            }
            else if (!isNullOrUndefined(topBorder) && !(topBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getTopBorderToRenderByHierarchy(topBorder, TableRowWidget.getRowOf(topBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(topBorder.ownerBase).tableFormat.borders);
            }
        }
        return topBorder;
    }
    /**
     * @private
     */
    getTopBorderToRenderByHierarchy(topBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(topBorder) && (topBorder.lineStyle !== 'None' || (topBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(topBorder.lineStyle === 'None' && topBorder.lineWidth === 0 && topBorder.color === '#000000')))) {
            return topBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(topBorder) && (topBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(topBorder.ownerBase).ownerRow.rowIndex === 0) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.top)) {
                topBorder = tableBorders.top;
            }
            return topBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return topBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return topBorder = tableBorders.horizontal;
        }
        else {
            return topBorder;
        }
    }
    /**
     * @private
     */
    static getCellBottomBorder(tableCell) {
        let bottomBorder = undefined;
        let cellBorder = tableCell.cellFormat.borders;
        let rowBorders = !isNullOrUndefined(tableCell.ownerRow) ? tableCell.ownerRow.rowFormat.borders : undefined;
        let tableBorders = !isNullOrUndefined(tableCell.ownerTable) ? tableCell.ownerTable.tableFormat.borders : undefined;
        if (!isNullOrUndefined(cellBorder.bottom)) {
            bottomBorder = cellBorder.bottom;
        }
        if (isNullOrUndefined(bottomBorder)) {
            // tslint:disable-next-line:max-line-length
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders); // select the left border based on heirarchy.
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0) {
            bottomBorder = tableCell.getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders);
        }
        else {
            let nextBottomCell = undefined;
            let nextRow = tableCell.ownerRow.nextWidget;
            if (!isNullOrUndefined(nextRow) && tableCell.columnIndex < nextRow.childWidgets.length) {
                nextBottomCell = nextRow.childWidgets[tableCell.columnIndex];
            }
            //If the border is shared then choose the border based on Conflict Resolution algorithm.
            bottomBorder = tableCell.getAdjacentCellBottomBorder(bottomBorder, nextBottomCell);
        }
        if (isNullOrUndefined(bottomBorder)) {
            bottomBorder = new WBorder(tableCell.cellFormat.borders);
        }
        return bottomBorder;
    }
    /**
     * @private
     */
    getAdjacentCellBottomBorder(bottomBorder, nextBottomCell) {
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(nextBottomCell) || (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle === 'None' && !bottomBorder.hasNoneStyle))) {
            if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                bottomBorder = this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        if (isNullOrUndefined(nextBottomCell)) {
            return bottomBorder;
        }
        else {
            let prevBottomCellTopBorder = undefined;
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(nextBottomCell.cellFormat.borders) && !isNullOrUndefined(nextBottomCell.cellFormat.borders.top) && nextBottomCell.cellFormat.borders.top.lineStyle !== 'None') {
                prevBottomCellTopBorder = nextBottomCell.cellFormat.borders.top;
            }
            if (!isNullOrUndefined(prevBottomCellTopBorder) && prevBottomCellTopBorder.lineStyle !== 'None') {
                return this.getBorderBasedOnPriority(bottomBorder, prevBottomCellTopBorder);
            }
            else if (!isNullOrUndefined(bottomBorder) && !(bottomBorder.ownerBase.ownerBase instanceof WTableFormat)) {
                // tslint:disable-next-line:max-line-length
                return this.getBottomBorderToRenderByHierarchy(bottomBorder, TableRowWidget.getRowOf(bottomBorder.ownerBase).rowFormat.borders, TableWidget.getTableOf(bottomBorder.ownerBase).tableFormat.borders);
            }
        }
        return bottomBorder;
    }
    /**
     * @private
     */
    getBottomBorderToRenderByHierarchy(bottomBorder, rowBorders, tableBorders) {
        if (!isNullOrUndefined(bottomBorder) && (bottomBorder.lineStyle !== 'None' || (bottomBorder.hasNoneStyle &&
            //If border defined with default values then border drawn based on hierarchy. 
            !(bottomBorder.lineStyle === 'None' && bottomBorder.lineWidth === 0 && bottomBorder.color === '#000000')))) {
            return bottomBorder;
            // tslint:disable-next-line:max-line-length
        }
        else if (!isNullOrUndefined(bottomBorder) && (bottomBorder.ownerBase instanceof WBorders) && TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerRow.rowIndex + TableCellWidget.getCellOf(bottomBorder.ownerBase).cellFormat.rowSpan === TableCellWidget.getCellOf(bottomBorder.ownerBase).ownerTable.childWidgets.length) {
            if (!isNullOrUndefined(tableBorders) && !isNullOrUndefined(tableBorders.bottom)) {
                bottomBorder = tableBorders.bottom;
            }
            return bottomBorder;
        }
        else if (!isNullOrUndefined(rowBorders)
            && !isNullOrUndefined(rowBorders.horizontal) && rowBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = rowBorders.horizontal;
        }
        else if (!isNullOrUndefined(tableBorders)
            && !isNullOrUndefined(tableBorders.horizontal) && tableBorders.horizontal.lineStyle !== 'None') {
            return bottomBorder = tableBorders.horizontal;
        }
        else {
            return bottomBorder;
        }
    }
    convertHexToRGB(colorCode) {
        if (colorCode) {
            colorCode = colorCode.replace(/[^0-9A-â€Œâ€‹F]/gi, ''); // To remove # from color code string.
            let colCodeNo = parseInt(colorCode, 16);
            let r = (colCodeNo >> 16) & 255;
            let g = (colCodeNo >> 8) & 255;
            let b = colCodeNo & 255;
            return { 'r': r, 'g': g, 'b': b };
        }
        return undefined;
    }
    /**
     * @private
     */
    static getCellOf(node) {
        if (node instanceof WBorders) {
            if (node.ownerBase instanceof WCellFormat && node.ownerBase.ownerBase instanceof TableCellWidget) {
                return node.ownerBase.ownerBase;
            }
            else {
                return undefined;
            }
        }
        return undefined;
    }
    /**
     * Updates the Widget left.
     * @private
     */
    updateWidgetLeft(x) {
        this.x = x;
        this.updateChildWidgetLeft(x);
    }
    /**
     * @private
     */
    updateChildWidgetLeft(left) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            this.childWidgets[i].x = left;
            if (this.childWidgets[i] instanceof TableWidget) {
                let tableWidget = this.childWidgets[i];
                tableWidget.updateChildWidgetLeft(left);
                if (tableWidget.isBidiTable) {
                    let clientArea = new Rect(tableWidget.x, tableWidget.y, tableWidget.width, tableWidget.height);
                    tableWidget.shiftWidgetsForRtlTable(clientArea, tableWidget);
                }
            }
        }
    }
    /**
     * @private
     */
    getMinimumAndMaximumWordWidth(minimumWordWidth, maximumWordWidth) {
        for (let i = 0; i < this.childWidgets.length; i++) {
            let block = this.childWidgets[i];
            let widthInfo = block.getMinimumAndMaximumWordWidth(minimumWordWidth, maximumWordWidth);
            minimumWordWidth = widthInfo.minimumWordWidth;
            maximumWordWidth = widthInfo.maximumWordWidth;
        }
        return { 'minimumWordWidth': minimumWordWidth, 'maximumWordWidth': maximumWordWidth };
    }
    /**
     * @private
     */
    destroyInternal(viewer) {
        // let viewer: LayoutViewer = undefined;
        // let page: Page = this.getPage();
        // if (!isNullOrUndefined(page ))
        //     viewer = page.viewer;
        if (!isNullOrUndefined(this.childWidgets)) {
            for (let i = 0; i < this.childWidgets.length; i++) {
                let widget = this.childWidgets[i];
                if (widget instanceof ParagraphWidget) {
                    widget.destroyInternal(viewer);
                }
                else {
                    widget.destroyInternal(viewer);
                }
                i--;
            }
            this.childWidgets = undefined;
        }
        this.destroy();
    }
    /**
     * @private
     */
    clone() {
        let cell = new TableCellWidget();
        cell.cellFormat.copyFormat(this.cellFormat);
        for (let i = 0; i < this.childWidgets.length; i++) {
            let block = this.childWidgets[i].clone();
            cell.childWidgets.push(block);
            block.containerWidget = cell;
            block.index = i;
        }
        cell.leftBorderWidth = this.leftBorderWidth;
        cell.rightBorderWidth = this.rightBorderWidth;
        if (this.margin) {
            cell.margin = this.margin.clone();
        }
        cell.columnIndex = this.columnIndex;
        cell.x = this.x;
        cell.y = this.y;
        cell.height = this.height;
        cell.width = this.width;
        return cell;
    }
    /**
     * @private
     */
    destroy() {
        // if (this.cellFormat) {
        //     this.cellFormat.destroy();
        // }
        this.cellFormat = undefined;
        this.rowIndex = undefined;
        this.columnIndex = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class LineWidget {
    /**
     * Initialize the constructor of LineWidget
     */
    constructor(paragraphWidget) {
        /**
         * @private
         */
        this.children = [];
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        this.paragraph = paragraphWidget;
    }
    /**
     * @private
     */
    get indexInOwner() {
        if (this.paragraph && this.paragraph.childWidgets) {
            return this.paragraph.childWidgets.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get nextLine() {
        let paragraph = this.paragraph;
        let lineIndex = this.indexInOwner;
        if (lineIndex <= paragraph.childWidgets.length - 2) {
            return paragraph.childWidgets[lineIndex + 1];
        }
        else if (paragraph.nextSplitWidget) {
            let line = paragraph.nextSplitWidget.firstChild;
            if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                return line;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get previousLine() {
        let paragraph = this.paragraph;
        let lineIndex = this.indexInOwner;
        let splitParagraph = paragraph.previousSplitWidget;
        if (lineIndex > 0) {
            return paragraph.childWidgets[lineIndex - 1];
        }
        else if (splitParagraph instanceof ParagraphWidget) {
            let line = splitParagraph.lastChild;
            if (line instanceof LineWidget && line.paragraph.equals(this.paragraph)) {
                return line;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get isEndsWithPageBreak() {
        if (this.children.length > 0) {
            let lastElement = this.children[this.children.length - 1];
            if (lastElement instanceof TextElementBox) {
                return lastElement.isPageBreak;
            }
        }
        return false;
    }
    /**
     * @private
     */
    isFirstLine() {
        let index = this.indexInOwner;
        // tslint:disable-next-line:max-line-length
        if (index > -1 && (this.paragraph.previousSplitWidget === undefined || (this.paragraph.previousSplitWidget instanceof ParagraphWidget && this.paragraph.previousSplitWidget.isEndsWithPageBreak))) {
            return index === 0;
        }
        return false;
    }
    /**
     * @private
     */
    isLastLine() {
        let index = this.indexInOwner;
        if (index > -1 && this.paragraph.nextSplitWidget === undefined) {
            return index === this.paragraph.childWidgets.length - 1;
        }
        return false;
    }
    /**
     * @private
     */
    getOffset(inline, index) {
        if (isNullOrUndefined(inline)) {
            return index;
        }
        let textIndex = index;
        let line = inline.line;
        let lineIndex = inline.line.paragraph.childWidgets.indexOf(inline.line);
        let bidi = line.paragraph.bidi;
        if (!bidi) {
            for (let i = 0; i < line.children.length; i++) {
                let inlineElement = line.children[i];
                if (inline === inlineElement) {
                    break;
                }
                if (inlineElement instanceof ListTextElementBox) {
                    continue;
                }
                textIndex += inlineElement.length;
            }
        }
        else {
            let elementInfo = this.getInlineForOffset(textIndex, true, inline);
            textIndex = elementInfo.index;
        }
        return textIndex;
    }
    /**
     * @private
     */
    getEndOffset() {
        let startOffset = 0;
        let count = 0;
        // let line: LineWidget = this.line as LineWidget;
        // let lineIndex: number = thtis.line.paragraph.childWidgets.indexOf(inline.line);
        let bidi = this.paragraph.bidi;
        if (!bidi) {
            for (let i = 0; i < this.children.length; i++) {
                let inlineElement = this.children[i];
                if (inlineElement.length === 0) {
                    continue;
                }
                if (inlineElement instanceof ListTextElementBox) {
                    continue;
                }
                if (inlineElement instanceof TextElementBox || inlineElement instanceof EditRangeStartElementBox
                    || inlineElement instanceof ImageElementBox || inlineElement instanceof EditRangeEndElementBox
                    || inlineElement instanceof BookmarkElementBox || (inlineElement instanceof FieldElementBox
                    && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                    startOffset = count + inlineElement.length;
                }
                count += inlineElement.length;
            }
        }
        else {
            let elementInfo = this.getInlineForOffset(startOffset, false, this.children[0], true);
            startOffset = elementInfo.index;
        }
        return startOffset;
    }
    /**
     * @private
     * @param offset
     * @param isOffset
     * @param inline
     * @param isEndOffset
     */
    // tslint:disable-next-line:max-line-length
    getInlineForOffset(offset, isOffset, inline, isEndOffset, isPrevOffset, isNxtOffset) {
        let startElement = this.children[this.children.length - 1];
        let endElement;
        let element = startElement;
        let viewer = this.paragraph.bodyWidget.page.viewer;
        let textHelper = viewer.textHelper;
        let isApplied = false;
        let count = 0;
        let lineLength = viewer.selection.getLineLength(this);
        let validOffset = 0;
        while (element) {
            if (!endElement && !(element instanceof TabElementBox && element.text === '\t') &&
                (element instanceof TextElementBox && !textHelper.isRTLText(element.text)
                    || !(element instanceof TextElementBox))) {
                while (element.previousElement && (element.previousElement instanceof TextElementBox
                    && !textHelper.isRTLText(element.previousElement.text) || element.previousElement instanceof FieldElementBox
                    || element.previousElement instanceof BookmarkElementBox
                        && !isNullOrUndefined(element.previousElement.previousElement) &&
                        !(element.previousElement.previousElement instanceof BookmarkElementBox)
                    || element.previousElement instanceof BookmarkElementBox
                        && element.previousElement.previousElement instanceof BookmarkElementBox
                        && !isNullOrUndefined(element.previousElement.previousElement.previousElement)
                    || element instanceof BookmarkElementBox && element.previousElement instanceof BookmarkElementBox
                        && !isNullOrUndefined(element.previousElement.previousElement)
                    || element.previousElement instanceof ListTextElementBox
                    || element.previousElement instanceof EditRangeEndElementBox
                    || element.previousElement instanceof EditRangeStartElementBox
                    || element instanceof ImageElementBox)) {
                    isApplied = true;
                    element = element.previousElement;
                    continue;
                }
                if (element.previousElement && (isApplied
                    || (element.previousElement instanceof TextElementBox && textHelper.isRTLText(element.previousElement.text)))) {
                    endElement = element.previousElement;
                }
                else if (!element.previousElement) {
                    if (element instanceof ListTextElementBox) {
                        break;
                    }
                    endElement = element;
                }
                if (element instanceof ListTextElementBox && endElement) {
                    element = endElement;
                    endElement = undefined;
                }
            }
            if (isOffset && !isNullOrUndefined(inline)) {
                if (inline === element) {
                    return { 'element': element, 'index': offset };
                }
                offset += element.length;
            }
            else if (isEndOffset) {
                offset += element.length;
                if (offset === lineLength) {
                    return { 'element': element, 'index': offset };
                }
            }
            else if (isNxtOffset) {
                if (offset < count + element.length) {
                    if (element instanceof TextElementBox || element instanceof ImageElementBox
                        || (element instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(element))) {
                        return { 'element': element, 'index': (offset > count ? offset : count) + 1 };
                    }
                }
                count += element.length;
            }
            else {
                if (offset <= count + element.length) {
                    return {
                        'element': element, 'index': isPrevOffset ? (offset - 1 === count ? validOffset : offset - 1) : offset - count
                    };
                }
                if (isPrevOffset && (element instanceof TextElementBox || element instanceof ImageElementBox
                    || (element instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(element)))) {
                    validOffset = count + element.length;
                }
                count += element.length;
            }
            if (element.previousElement && (element instanceof TextElementBox && textHelper.isRTLText(element.text) ||
                (element instanceof TabElementBox && element.text === '\t' || (element instanceof BookmarkElementBox
                    && (element instanceof BookmarkElementBox && element.previousElement instanceof BookmarkElementBox
                        && !element.previousElement.previousElement
                        || element.bookmarkType === 1 && !element.previousElement))))) {
                if ((offset === count + 1 || offset > count + 1) && count === lineLength && !element.previousElement) {
                    break;
                }
                element = element.previousElement;
            }
            else {
                if (endElement && (!element.nextElement || element === startElement || element.nextElement instanceof TextElementBox
                    && textHelper.isRTLText(element.nextElement.text) || element.nextElement instanceof ListTextElementBox)) {
                    if (offset === count + 1 && count === lineLength) {
                        break;
                    }
                    element = endElement;
                    endElement = undefined;
                    isApplied = false;
                }
                else {
                    if ((endElement === element || offset === count + 1) && !element.previousElement && count === lineLength) {
                        break;
                    }
                    element = element.nextElement;
                }
            }
        }
        if (isNxtOffset) {
            return { 'element': element, 'index': offset };
        }
        else if (isPrevOffset) {
            return { 'element': element, 'index': -1 };
        }
        else {
            return { 'element': element, 'index': isEndOffset ? offset : 0 };
        }
    }
    /**
     * @private
     */
    getInline(offset, indexInInline, bidi, isInsert) {
        bidi = isNullOrUndefined(bidi) ? this.paragraph.bidi : bidi;
        let inlineElement = undefined;
        let count = 0;
        let isStarted = false;
        if (this.children.length === 0) {
            if (this.previousLine) {
                let elementBox = this.previousLine.children[this.previousLine.children.length - 1];
                if (elementBox instanceof TextElementBox && elementBox.text === '\v') {
                    inlineElement = this.previousLine.children[this.previousLine.children.length - 1];
                    indexInInline = 1;
                    return { 'element': inlineElement, 'index': indexInInline };
                }
            }
        }
        if (!bidi) {
            for (let i = 0; i < this.children.length; i++) {
                inlineElement = this.children[i];
                if (inlineElement instanceof ListTextElementBox) {
                    continue;
                }
                if (!isStarted && (inlineElement instanceof TextElementBox || inlineElement instanceof ImageElementBox
                    || inlineElement instanceof BookmarkElementBox || inlineElement instanceof EditRangeEndElementBox
                    || inlineElement instanceof EditRangeStartElementBox
                    || inlineElement instanceof FieldElementBox
                        && HelperMethods.isLinkedFieldCharacter(inlineElement))) {
                    isStarted = true;
                }
                if (isStarted && offset <= count + inlineElement.length) {
                    // if (inlineElement instanceof BookmarkElementBox) {
                    //     offset += inlineElement.length;
                    //     count += inlineElement.length;
                    //     continue;
                    // }
                    // tslint:disable-next-line:max-line-length
                    if (inlineElement instanceof TextElementBox && (inlineElement.text === ' ' && isInsert)) {
                        let currentElement = this.getNextTextElement(this, i + 1);
                        inlineElement = !isNullOrUndefined(currentElement) ? currentElement : inlineElement;
                        indexInInline = isNullOrUndefined(currentElement) ? (offset - count) : 0;
                        return { 'element': inlineElement, 'index': indexInInline };
                    }
                    else {
                        indexInInline = (offset - count);
                    }
                    return { 'element': inlineElement, 'index': indexInInline };
                }
                count += inlineElement.length;
            }
            if (offset > count) {
                indexInInline = isNullOrUndefined(inlineElement) ? offset : inlineElement.length;
            }
        }
        else {
            let elementInfo = this.getInlineForOffset(offset);
            inlineElement = elementInfo.element;
            indexInInline = elementInfo.index;
        }
        return { 'element': inlineElement, 'index': indexInInline };
    }
    /**
     * Method to retrieve next element
     * @param line
     * @param index
     */
    getNextTextElement(line, index) {
        if (index < line.children.length - 1 && line.children[index]) {
            return line.children[index];
        }
        return null;
    }
    /**
     * @private
     */
    getHierarchicalIndex(hierarchicalIndex) {
        let node = this;
        hierarchicalIndex = node.paragraph.childWidgets.indexOf(node) + ';' + hierarchicalIndex;
        if (node.paragraph instanceof BlockWidget) {
            return node.paragraph.getHierarchicalIndex(hierarchicalIndex);
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    clone() {
        let line = new LineWidget(undefined);
        for (let j = 0; j < this.children.length; j++) {
            let element = this.children[j];
            let clone = element.clone();
            line.children.push(clone);
            clone.line = line;
        }
        line.width = this.width;
        line.height = this.height;
        return line;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.children)) {
            for (let i = 0; i < this.children.length; i++) {
                this.children[i].destroy();
            }
            this.children = [];
        }
        this.children = undefined;
        if (this.paragraph) {
            this.paragraph.removeChild(this.indexInOwner);
        }
        this.paragraph = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    }
}
/**
 * @private
 */
class ElementBox {
    /**
     * Initialize the constructor of ElementBox
     */
    constructor() {
        /**
         * @private
         */
        this.x = 0;
        /**
         * @private
         */
        this.y = 0;
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        /**
         * @private
         */
        this.margin = new Margin(0, 0, 0, 0);
        /**
         * @private
         */
        this.characterFormat = undefined;
        /**
         * @private
         */
        this.isRightToLeft = false;
        /**
         * @private
         */
        this.canTrigger = false;
        /**
         * @private
         */
        this.ischangeDetected = false;
        /**
         * @private
         */
        this.isVisible = false;
        /**
         * @private
         */
        this.isSpellChecked = false;
        this.characterFormat = new WCharacterFormat(this);
        this.margin = new Margin(0, 0, 0, 0);
    }
    /**
     * @private
     */
    get isPageBreak() {
        if (this instanceof TextElementBox) {
            return this.text === '\f';
        }
        return false;
    }
    /**
     * @private
     */
    linkFieldCharacter(viewer) {
        if (!(this instanceof FieldElementBox)) {
            return;
        }
        if (this.fieldType === 0) {
            let fieldBegin = this;
            if (isNullOrUndefined(fieldBegin.fieldEnd)) {
                this.linkFieldTraversingForward(this.line, fieldBegin, fieldBegin);
                if (viewer.fields.indexOf(fieldBegin) === -1) {
                    viewer.fields.push(fieldBegin);
                }
            }
        }
        else if (this.fieldType === 2) {
            let fieldSeparator = this;
            //Links the field begin for the current separator.
            if (isNullOrUndefined(fieldSeparator.fieldBegin)) {
                this.linkFieldTraversingBackwardSeparator(this.line, fieldSeparator, fieldSeparator);
            }
            if (!isNullOrUndefined(fieldSeparator.fieldBegin)) {
                fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
                //Links to field end traversing from field separator.
                let isFieldEnd = this.linkFieldTraversingForward(this.line, fieldSeparator.fieldBegin, fieldSeparator);
                if (isNullOrUndefined(fieldSeparator.fieldEnd) && isFieldEnd) {
                    fieldSeparator.fieldEnd = fieldSeparator.fieldBegin.fieldEnd;
                }
                if (fieldSeparator.fieldEnd) {
                    fieldSeparator.fieldEnd.fieldSeparator = fieldSeparator;
                }
            }
        }
        else {
            let fieldEnd = this;
            //Links the field begin and separator for the current end.
            if (isNullOrUndefined(fieldEnd.fieldBegin)) {
                this.linkFieldTraversingBackward(this.line, fieldEnd, fieldEnd);
            }
        }
    }
    /**
     * @private
     */
    linkFieldTraversingBackward(line, fieldEnd, previousNode) {
        let k = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            k = line.children.indexOf(previousNode) - 1;
        }
        for (let j = k; j >= 0; j--) {
            let childNode = line.children[j];
            if (childNode instanceof FieldElementBox) {
                if (childNode.fieldType === 0) {
                    if (isNullOrUndefined(childNode.fieldEnd)) {
                        fieldEnd.fieldBegin = childNode;
                        if (isNullOrUndefined(childNode.fieldEnd)) {
                            childNode.fieldEnd = fieldEnd;
                        }
                        if (fieldEnd.fieldSeparator && isNullOrUndefined(fieldEnd.fieldSeparator.fieldBegin)) {
                            fieldEnd.fieldSeparator.fieldBegin = childNode;
                            if (isNullOrUndefined(childNode.fieldSeparator)) {
                                childNode.fieldSeparator = fieldEnd.fieldSeparator;
                            }
                        }
                    }
                    return !isNullOrUndefined(fieldEnd.fieldBegin);
                }
                else if (childNode.fieldType === 2 && isNullOrUndefined(childNode.fieldEnd)) {
                    fieldEnd.fieldSeparator = childNode;
                    childNode.fieldEnd = fieldEnd;
                    if (!isNullOrUndefined(childNode.fieldBegin)) {
                        fieldEnd.fieldBegin = childNode.fieldBegin;
                    }
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackward(line.previousLine, fieldEnd, this);
        }
        else if (line.paragraph.previousRenderedWidget instanceof ParagraphWidget
            && line.paragraph.previousRenderedWidget.childWidgets.length > 0) {
            let prevParagraph = line.paragraph.previousRenderedWidget;
            // tslint:disable-next-line:max-line-length
            this.linkFieldTraversingBackward(prevParagraph.childWidgets[prevParagraph.childWidgets.length - 1], fieldEnd, this);
        }
        return true;
    }
    /**
     * @private
     */
    linkFieldTraversingForward(line, fieldBegin, previousNode) {
        let i = 0;
        if (line.children.indexOf(previousNode) > -1) {
            i = line.children.indexOf(previousNode) + 1;
        }
        for (let j = i; j < line.children.length; j++) {
            let node = line.children[j];
            if (node instanceof FieldElementBox) {
                if (node.fieldType === 1) {
                    if (isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldEnd = node;
                    }
                    if (fieldBegin.fieldEnd && isNullOrUndefined(fieldBegin.fieldEnd.fieldBegin)) {
                        fieldBegin.fieldEnd.fieldBegin = fieldBegin;
                    }
                    return true;
                }
                else if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    if (node.fieldType === 2 && isNullOrUndefined(node.fieldBegin)) {
                        fieldBegin.fieldSeparator = node;
                        if (!isNullOrUndefined(node.fieldEnd)) {
                            fieldBegin.fieldEnd = node.fieldEnd;
                            return true;
                        }
                    }
                    else {
                        return false;
                    }
                }
            }
        }
        if (line.nextLine) {
            this.linkFieldTraversingForward(line.nextLine, fieldBegin, this);
        }
        else if (line.paragraph.nextRenderedWidget instanceof ParagraphWidget
            && line.paragraph.nextRenderedWidget.childWidgets.length > 0) {
            this.linkFieldTraversingForward(line.paragraph.nextRenderedWidget.childWidgets[0], fieldBegin, this);
        }
        return true;
    }
    /**
     * @private
     */
    linkFieldTraversingBackwardSeparator(line, fieldSeparator, previousNode) {
        let index = line.children.length - 1;
        if (line.children.indexOf(previousNode) > -1) {
            index = line.children.indexOf(previousNode) - 1;
        }
        for (let i = index; i >= 0; i--) {
            let childElement = line.children[i];
            if (childElement instanceof FieldElementBox) {
                if (childElement instanceof FieldElementBox && childElement.fieldType === 0) {
                    if (isNullOrUndefined(childElement.fieldSeparator)) {
                        fieldSeparator.fieldBegin = childElement;
                    }
                    return !isNullOrUndefined(fieldSeparator.fieldBegin);
                }
            }
        }
        if (line.previousLine) {
            this.linkFieldTraversingBackwardSeparator(line.previousLine, fieldSeparator, this);
        }
        else if (line.paragraph.previousRenderedWidget instanceof ParagraphWidget
            && line.paragraph.previousRenderedWidget.childWidgets.length > 0) {
            // tslint:disable-next-line:max-line-length
            line = line.paragraph.previousRenderedWidget.childWidgets[line.paragraph.previousRenderedWidget.childWidgets.length - 1];
            this.linkFieldTraversingBackwardSeparator(line, fieldSeparator, this);
        }
        else {
            return true;
        }
        return true;
    }
    /**
     * @private
     */
    get length() {
        return this.getLength();
    }
    /**
     * @private
     */
    get indexInOwner() {
        return this.line instanceof LineWidget && this.line.children ? this.line.children.indexOf(this) : -1;
    }
    /**
     * @private
     */
    get previousElement() {
        let index = this.indexInOwner;
        if (index > 0 && index < this.line.children.length) {
            return this.line.children[index - 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextElement() {
        let index = this.indexInOwner;
        if (index > -1 && index < this.line.children.length - 1) {
            return this.line.children[index + 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextNode() {
        let index = this.line.children.indexOf(this);
        let lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
        if (index < this.line.children.length - 1) {
            return this.line.children[index + 1];
        }
        else if (lineIndex < this.line.paragraph.childWidgets.length - 1) {
            return this.line.paragraph.childWidgets[lineIndex + 1].children[0];
        }
        return undefined;
    }
    /**
     * @private
     */
    get previousNode() {
        let index = this.line.children.indexOf(this);
        let lineIndex = this.line.paragraph.childWidgets.indexOf(this.line);
        if (index > 0) {
            return this.line.children[index - 1];
        }
        else if (lineIndex > 0) {
            let lineWidget = this.line.paragraph.childWidgets[lineIndex - 1];
            return lineWidget.children[lineWidget.children.length - 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get paragraph() {
        if (this.line) {
            return this.line.paragraph;
        }
        return undefined;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.line) && this.line.children && this.line.children.indexOf(this) > -1) {
            let index = this.line.children.indexOf(this);
            this.line.children.splice(index, 1);
        }
        this.line = undefined;
        if (this.characterFormat) {
            this.characterFormat.destroy();
        }
        this.characterFormat = undefined;
        if (this.margin) {
            this.margin.destroy();
        }
        this.margin = undefined;
        this.x = undefined;
        this.y = undefined;
        this.width = undefined;
        this.height = undefined;
    }
}
/**
 * @private
 */
ElementBox.objectCharacter = String.fromCharCode(65532);
/**
 * @private
 */
class FieldElementBox extends ElementBox {
    constructor(type) {
        super();
        /**
         * @private
         */
        this.fieldType = 0;
        /**
         * @private
         */
        this.fieldCodeType = '';
        /**
         * @private
         */
        this.hasFieldEnd = false;
        this.fieldBeginInternal = undefined;
        this.fieldSeparatorInternal = undefined;
        this.fieldEndInternal = undefined;
        this.fieldType = type;
    }
    get fieldBegin() {
        return this.fieldBeginInternal;
    }
    set fieldBegin(field) {
        this.fieldBeginInternal = field;
    }
    get fieldSeparator() {
        return this.fieldSeparatorInternal;
    }
    set fieldSeparator(field) {
        this.fieldSeparatorInternal = field;
    }
    get fieldEnd() {
        return this.fieldEndInternal;
    }
    set fieldEnd(field) {
        this.fieldEndInternal = field;
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    clone() {
        let field = new FieldElementBox(this.fieldType);
        field.characterFormat.copyFormat(this.characterFormat);
        if (this.margin) {
            field.margin = this.margin.clone();
        }
        field.width = this.width;
        field.height = this.height;
        field.fieldCodeType = this.fieldCodeType;
        return field;
    }
    /**
     * @private
     */
    destroy() {
        this.fieldType = undefined;
        this.hasFieldEnd = undefined;
        this.fieldBeginInternal = undefined;
        this.fieldEndInternal = undefined;
        this.fieldSeparatorInternal = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class TextElementBox extends ElementBox {
    constructor() {
        super();
        /**
         * @private
         */
        this.baselineOffset = 0;
        /**
         * @private
         */
        this.text = '';
        /**
         * @private
         */
        this.ignoreOnceItems = [];
        /**
         * @private
         */
        this.istextCombined = false;
        this.errorCollection = [];
    }
    /**
     * @private
     */
    getLength() {
        return this.text ? this.text.length : 0;
    }
    /**
     * @private
     */
    clone() {
        let span = new TextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.baselineOffset = this.baselineOffset;
        span.width = this.width;
        span.height = this.height;
        return span;
    }
    /**
     * @private
     */
    destroy() {
        this.text = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class ErrorTextElementBox extends TextElementBox {
    constructor() {
        super();
        this.startIn = undefined;
        this.endIn = undefined;
    }
    get start() {
        return this.startIn;
    }
    set start(value) {
        this.startIn = value;
    }
    get end() {
        return this.endIn;
    }
    set end(value) {
        this.endIn = value;
    }
    destroy() {
        this.start = undefined;
        this.end = undefined;
    }
}
/**
 * @private
 */
class FieldTextElementBox extends TextElementBox {
    constructor() {
        super();
        this.fieldText = '';
    }
    get text() {
        return this.fieldText;
    }
    set text(value) {
        this.fieldText = value;
    }
    /**
     * @private
     */
    clone() {
        let span = new FieldTextElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.fieldBegin = this.fieldBegin;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    }
}
/**
 * @private
 */
class TabElementBox extends TextElementBox {
    constructor() {
        super();
        /**
         * @private
         */
        this.tabText = '';
        /**
         * @private
         */
        this.tabLeader = 'None';
    }
    /**
     * @private
     */
    destroy() {
        this.tabText = undefined;
        this.tabLeader = undefined;
    }
    /**
     * @private
     */
    clone() {
        let span = new TabElementBox();
        span.characterFormat.copyFormat(this.characterFormat);
        span.tabText = this.tabText;
        span.tabLeader = this.tabLeader;
        span.text = this.text;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    }
}
/**
 * @private
 */
class BookmarkElementBox extends ElementBox {
    constructor(type) {
        super();
        this.bookmarkTypeIn = 0;
        this.refereneceIn = undefined;
        this.nameIn = '';
        this.bookmarkTypeIn = type;
    }
    /**
     * @private
     */
    get bookmarkType() {
        return this.bookmarkTypeIn;
    }
    /**
     * @private
     */
    get name() {
        return this.nameIn;
    }
    /**
     * @private
     */
    set name(name) {
        this.nameIn = name;
    }
    /**
     * @private
     */
    get reference() {
        return this.refereneceIn;
    }
    /**
     * @private
     */
    set reference(reference) {
        this.refereneceIn = reference;
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    destroy() {
        this.name = undefined;
        this.reference = undefined;
        this.bookmarkTypeIn = undefined;
    }
    /**
     * Clones the bookmark element box.
     * @param element - book mark element
     */
    /**
     * @private
     */
    clone() {
        let span = new BookmarkElementBox(this.bookmarkType);
        span.name = this.name;
        span.reference = this.reference;
        if (this.margin) {
            span.margin = this.margin.clone();
        }
        span.width = this.width;
        span.height = this.height;
        return span;
    }
}
/**
 * @private
 */
class ImageElementBox extends ElementBox {
    constructor(isInlineImage) {
        super();
        this.imageStr = '';
        this.imgElement = undefined;
        this.isInlineImageIn = true;
        /**
         * @private
         */
        this.isMetaFile = false;
        this.isInlineImageIn = isInlineImage;
    }
    /**
     * @private
     */
    get isInlineImage() {
        return this.isInlineImageIn;
    }
    /**
     * @private
     */
    get element() {
        if (isNullOrUndefined(this.imgElement)) {
            this.imgElement = document.createElement('img');
        }
        return this.imgElement;
    }
    /**
     * @private
     */
    get length() {
        return 1;
    }
    /**
     * @private
     */
    get imageString() {
        return this.imageStr;
    }
    /**
     * @private
     */
    set imageString(value) {
        this.imageStr = value;
        if (!isNullOrUndefined(value)) {
            this.element.src = this.imageStr;
        }
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    clone() {
        let image = new ImageElementBox(this.isInlineImage);
        image.characterFormat.copyFormat(this.characterFormat);
        image.imageString = this.imageString;
        image.isMetaFile = this.isMetaFile;
        image.width = this.width;
        image.height = this.height;
        if (this.margin) {
            image.margin = this.margin.clone();
        }
        return image;
    }
    /**
     * @private
     */
    destroy() {
        this.imgElement = undefined;
        this.imageString = undefined;
        this.isInlineImageIn = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class ListTextElementBox extends ElementBox {
    constructor(listLevel, isListFollowCharacter) {
        super();
        /**
         * @private
         */
        this.baselineOffset = 0;
        /**
         * @private
         */
        this.isFollowCharacter = false;
        this.listLevel = listLevel;
        this.isFollowCharacter = isListFollowCharacter;
    }
    /**
     * @private
     */
    getLength() {
        return this.text ? this.text.length : 0;
    }
    /**
     * @private
     */
    clone() {
        let list = new ListTextElementBox(this.listLevel, this.isFollowCharacter);
        list.text = this.text;
        list.baselineOffset = this.baselineOffset;
        if (this.margin) {
            list.margin = this.margin.clone();
        }
        list.width = this.width;
        list.height = this.height;
        return list;
    }
    /**
     * @private
     */
    destroy() {
        this.text = undefined;
        super.destroy();
    }
}
/**
 * @private
 */
class EditRangeEndElementBox extends ElementBox {
    constructor() {
        super();
        /**
         * @private
         */
        this.editRangeStart = undefined;
        this.editRangeId = -1;
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    destroy() {
        this.editRangeStart = undefined;
    }
    /**
     * @private
     */
    clone() {
        let end = new EditRangeEndElementBox();
        end.editRangeStart = this.editRangeStart;
        end.editRangeId = this.editRangeId;
        return end;
    }
}
/**
 * @private
 */
class EditRangeStartElementBox extends ElementBox {
    constructor() {
        super();
        /**
         * @private
         */
        this.columnFirst = -1;
        /**
         * @private
         */
        this.columnLast = -1;
        /**
         * @private
         */
        this.user = '';
        /**
         * @private
         */
        this.group = '';
        this.editRangeId = -1;
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    destroy() {
        this.user = undefined;
        this.columnFirst = undefined;
        this.columnLast = undefined;
    }
    /**
     * @private
     */
    clone() {
        let start = new EditRangeStartElementBox();
        start.columnFirst = this.columnFirst;
        start.columnLast = this.columnLast;
        start.user = this.user;
        start.group = this.group;
        start.editRangeEnd = this.editRangeEnd;
        start.editRangeId = this.editRangeId;
        return start;
    }
}
/**
 * @private
 */
class ChartElementBox extends ImageElementBox {
    /**
     * @private
     */
    constructor() {
        super();
        /**
         * @private
         */
        this.chartTitle = '';
        /**
         * @private
         */
        this.chartType = '';
        /**
         * @private
         */
        this.chartElement = undefined;
        /**
         * @private
         */
        this.chartCategory = [];
        /**
         * @private
         */
        this.chartSeries = [];
        this.chartArea = new ChartArea();
        this.chartPlotArea = new ChartArea();
        this.chartTitleArea = new ChartTitleArea();
        this.chartLegend = new ChartLegend();
        this.chartPrimaryCategoryAxis = new ChartCategoryAxis();
        this.chartPrimaryValueAxis = new ChartCategoryAxis();
        this.chartDataTable = new ChartDataTable();
    }
    /**
     * @private
     */
    getLength() {
        return 1;
    }
    /**
     * @private
     */
    get title() {
        return this.chartTitle;
    }
    /**
     * @private
     */
    set title(value) {
        this.chartTitle = value;
    }
    /**
     * @private
     */
    get type() {
        return this.chartType;
    }
    /**
     * @private
     */
    set type(value) {
        this.chartType = value;
    }
    /**
     * @private
     */
    get chartGapWidth() {
        return this.gapWidth;
    }
    /**
     * @private
     */
    set chartGapWidth(value) {
        this.gapWidth = value;
    }
    /**
     * @private
     */
    get chartOverlap() {
        return this.overlap;
    }
    /**
     * @private
     */
    set chartOverlap(value) {
        this.overlap = value;
    }
    /**
     * @private
     */
    get targetElement() {
        if (isNullOrUndefined(this.div)) {
            this.div = createElement('div');
        }
        return this.div;
    }
    /**
     * @private
     */
    get officeChart() {
        return this.officeChartInternal;
    }
    /**
     * @private
     */
    set officeChart(value) {
        if (value) {
            this.officeChartInternal = value;
            this.officeChartInternal.chart.loaded = this.onChartLoaded.bind(this);
        }
    }
    onChartLoaded() {
        this.officeChart.convertChartToImage(this.officeChart.chart, this.width, this.height).then((dataURL) => {
            this.imageString = dataURL;
        });
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartElementBox();
        chart.chartTitle = this.chartTitle;
        chart.chartType = this.chartType;
        chart.height = this.height;
        chart.width = this.width;
        chart.gapWidth = this.gapWidth;
        chart.overlap = this.overlap;
        for (let i = 0; i < this.chartCategory.length; i++) {
            let chartCategory = this.chartCategory[i].clone();
            chart.chartCategory.push(chartCategory);
        }
        for (let i = 0; i < this.chartSeries.length; i++) {
            let series = this.chartSeries[i].clone();
            chart.chartSeries.push(series);
        }
        chart.chartArea = this.chartArea.clone();
        chart.chartPlotArea = this.chartPlotArea.clone();
        chart.chartLegend = this.chartLegend.clone();
        chart.chartTitleArea = this.chartTitleArea.clone();
        chart.chartPrimaryCategoryAxis = this.chartPrimaryCategoryAxis.clone();
        chart.chartPrimaryValueAxis = this.chartPrimaryValueAxis.clone();
        chart.chartDataTable = this.chartDataTable.clone();
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        super.destroy();
        if (this.officeChartInternal) {
            this.officeChartInternal.chart.loaded = undefined;
            this.officeChartInternal.destroy();
            this.officeChartInternal = undefined;
        }
        if (this.div) {
            this.div = undefined;
        }
        this.chartTitle = undefined;
        this.chartType = undefined;
        this.chartArea = undefined;
        this.chartPlotArea = undefined;
        this.chartCategory = [];
        this.chartSeries = [];
        this.chartTitleArea = undefined;
        this.chartLegend = undefined;
        this.chartPrimaryCategoryAxis = undefined;
        this.chartPrimaryValueAxis = undefined;
        this.chartDataTable = undefined;
        this.chartElement = undefined;
    }
}
/**
 * @private
 */
class ChartArea {
    /**
     * @private
     */
    get chartForeColor() {
        return this.foreColor;
    }
    /**
     * @private
     */
    set chartForeColor(value) {
        this.foreColor = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartArea();
        chart.foreColor = this.foreColor;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.foreColor = undefined;
    }
}
/**
 * @private
 */
class ChartCategory {
    constructor() {
        /**
         * @private
         */
        this.categoryXName = '';
        /**
         * @private
         */
        this.chartData = [];
    }
    /**
     * @private
     */
    get xName() {
        return this.categoryXName;
    }
    /**
     * @private
     */
    set xName(value) {
        this.categoryXName = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartCategory();
        chart.categoryXName = this.categoryXName;
        for (let i = 0; i < this.chartData.length; i++) {
            let chartData = this.chartData[i].clone();
            chart.chartData.push(chartData);
        }
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.categoryXName = undefined;
        this.chartData = [];
    }
}
/**
 * @private
 */
class ChartData {
    /**
     * @private
     */
    get yAxisValue() {
        return this.yValue;
    }
    /**
     * @private
     */
    set yAxisValue(value) {
        this.yValue = value;
    }
    /**
     * @private
     */
    get xAxisValue() {
        return this.xValue;
    }
    /**
     * @private
     */
    set xAxisValue(value) {
        this.xValue = value;
    }
    /**
     * @private
     */
    get bubbleSize() {
        return this.size;
    }
    /**
     * @private
     */
    set bubbleSize(value) {
        this.size = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartData();
        chart.yValue = this.yValue;
        chart.xValue = this.xValue;
        chart.size = this.size;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.xValue = undefined;
        this.yValue = undefined;
        this.size = undefined;
    }
}
/**
 * @private
 */
class ChartLegend {
    /**
     * @private
     */
    get chartLegendPostion() {
        return this.legendPostion;
    }
    /**
     * @private
     */
    set chartLegendPostion(value) {
        this.legendPostion = value;
    }
    /**
     * @private
     */
    constructor() {
        this.chartTitleArea = new ChartTitleArea();
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartLegend();
        chart.legendPostion = this.legendPostion;
        chart.chartTitleArea = this.chartTitleArea.clone();
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.legendPostion = undefined;
        this.chartTitleArea = undefined;
    }
}
/**
 * @private
 */
class ChartSeries {
    constructor() {
        /**
         * @private
         */
        this.chartDataFormat = [];
        /**
         * @private
         */
        this.trendLines = [];
        this.errorBar = new ChartErrorBar();
        this.dataLabels = new ChartDataLabels();
        this.seriesFormat = new ChartSeriesFormat();
    }
    /**
     * @private
     */
    get seriesName() {
        return this.name;
    }
    /**
     * @private
     */
    set seriesName(value) {
        this.name = value;
    }
    /**
     * @private
     */
    get firstSliceAngle() {
        return this.sliceAngle;
    }
    /**
     * @private
     */
    set firstSliceAngle(value) {
        this.sliceAngle = value;
    }
    /**
     * @private
     */
    get doughnutHoleSize() {
        return this.holeSize;
    }
    /**
     * @private
     */
    set doughnutHoleSize(value) {
        this.holeSize = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartSeries();
        chart.name = this.name;
        chart.sliceAngle = this.sliceAngle;
        chart.holeSize = this.holeSize;
        chart.errorBar = this.errorBar.clone();
        chart.dataLabels = this.dataLabels.clone();
        chart.seriesFormat = this.seriesFormat.clone();
        for (let i = 0; i < this.chartDataFormat.length; i++) {
            let format = (this.chartDataFormat[i].clone());
            chart.chartDataFormat.push(format);
        }
        for (let i = 0; i < this.trendLines.length; i++) {
            let trendLine = (this.trendLines[i].clone());
            chart.trendLines.push(trendLine);
        }
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.name = undefined;
        this.errorBar = undefined;
        this.trendLines = undefined;
        this.chartDataFormat = [];
    }
}
/**
 * @private
 */
class ChartErrorBar {
    /**
     * @private
     */
    get errorType() {
        return this.type;
    }
    /**
     * @private
     */
    set errorType(value) {
        this.type = value;
    }
    /**
     * @private
     */
    get errorDirection() {
        return this.direction;
    }
    /**
     * @private
     */
    set errorDirection(value) {
        this.direction = value;
    }
    /**
     * @private
     */
    get errorEndStyle() {
        return this.endStyle;
    }
    /**
     * @private
     */
    set errorEndStyle(value) {
        this.endStyle = value;
    }
    get numberValue() {
        return this.errorValue;
    }
    /**
     * @private
     */
    set numberValue(value) {
        this.errorValue = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartErrorBar();
        chart.type = this.type;
        chart.errorDirection = this.errorDirection;
        chart.endStyle = this.endStyle;
        chart.errorValue = this.errorValue;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.type = undefined;
        this.errorDirection = undefined;
        this.endStyle = undefined;
    }
}
/**
 * @private
 */
class ChartSeriesFormat {
    /**
     * @private
     */
    get markerStyle() {
        return this.style;
    }
    /**
     * @private
     */
    set markerStyle(value) {
        this.style = value;
    }
    /**
     * @private
     */
    get markerColor() {
        return this.color;
    }
    /**
     * @private
     */
    set markerColor(value) {
        this.color = value;
    }
    /**
     * @private
     */
    get numberValue() {
        return this.size;
    }
    /**
     * @private
     */
    set numberValue(value) {
        this.size = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartSeriesFormat();
        chart.style = this.style;
        chart.color = this.color;
        chart.size = this.size;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.style = undefined;
        this.color = undefined;
        this.size = undefined;
    }
}
/**
 * @private
 */
class ChartDataLabels {
    /**
     * @private
     */
    get labelPosition() {
        return this.position;
    }
    /**
     * @private
     */
    set labelPosition(value) {
        this.position = value;
    }
    /**
     * @private
     */
    get fontName() {
        return this.name;
    }
    /**
     * @private
     */
    set fontName(value) {
        this.name = value;
    }
    /**
     * @private
     */
    get fontColor() {
        return this.color;
    }
    /**
     * @private
     */
    set fontColor(value) {
        this.color = value;
    }
    /**
     * @private
     */
    get fontSize() {
        return this.size;
    }
    /**
     * @private
     */
    set fontSize(value) {
        this.size = value;
    }
    /**
     * @private
     */
    get isLegendKey() {
        return this.isLegend;
    }
    /**
     * @private
     */
    set isLegendKey(value) {
        this.isLegend = value;
    }
    /**
     * @private
     */
    get isBubbleSize() {
        return this.isBubble;
    }
    /**
     * @private
     */
    set isBubbleSize(value) {
        this.isBubble = value;
    }
    /**
     * @private
     */
    get isCategoryName() {
        return this.isCategory;
    }
    /**
     * @private
     */
    set isCategoryName(value) {
        this.isCategory = value;
    }
    /**
     * @private
     */
    get isSeriesName() {
        return this.isSeries;
    }
    /**
     * @private
     */
    set isSeriesName(value) {
        this.isSeries = value;
    }
    /**
     * @private
     */
    get isValue() {
        return this.isValueEnabled;
    }
    /**
     * @private
     */
    set isValue(value) {
        this.isValueEnabled = value;
    }
    /**
     * @private
     */
    get isPercentage() {
        return this.isPercentageEnabled;
    }
    /**
     * @private
     */
    set isPercentage(value) {
        this.isPercentageEnabled = value;
    }
    /**
     * @private
     */
    get isLeaderLines() {
        return this.showLeaderLines;
    }
    /**
     * @private
     */
    set isLeaderLines(value) {
        this.showLeaderLines = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartDataLabels();
        chart.position = this.position;
        chart.name = this.name;
        chart.color = this.color;
        chart.size = this.size;
        chart.isBubble = this.isBubble;
        chart.isLegend = this.isLegend;
        chart.isCategory = this.isCategory;
        chart.isSeries = this.isSeries;
        chart.isValueEnabled = this.isValueEnabled;
        chart.isPercentageEnabled = this.isPercentageEnabled;
        chart.showLeaderLines = this.showLeaderLines;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.position = undefined;
    }
}
/**
 * @private
 */
class ChartTrendLines {
    /**
     * @private
     */
    get trendLineType() {
        return this.type;
    }
    /**
     * @private
     */
    set trendLineType(value) {
        this.type = value;
    }
    /**
     * @private
     */
    get trendLineName() {
        return this.name;
    }
    /**
     * @private
     */
    set trendLineName(value) {
        this.name = value;
    }
    /**
     * @private
     */
    get interceptValue() {
        return this.intercept;
    }
    /**
     * @private
     */
    set interceptValue(value) {
        this.intercept = value;
    }
    /**
     * @private
     */
    get forwardValue() {
        return this.forward;
    }
    /**
     * @private
     */
    set forwardValue(value) {
        this.forward = value;
    }
    /**
     * @private
     */
    get backwardValue() {
        return this.backward;
    }
    /**
     * @private
     */
    set backwardValue(value) {
        this.backward = value;
    }
    /**
     * @private
     */
    get isDisplayRSquared() {
        return this.displayRSquared;
    }
    /**
     * @private
     */
    set isDisplayRSquared(value) {
        this.displayRSquared = value;
    }
    /**
     * @private
     */
    get isDisplayEquation() {
        return this.displayEquation;
    }
    /**
     * @private
     */
    set isDisplayEquation(value) {
        this.displayEquation = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartTrendLines();
        chart.type = this.type;
        chart.name = this.name;
        chart.forward = this.forward;
        chart.backward = this.backward;
        chart.intercept = this.intercept;
        chart.displayEquation = this.displayEquation;
        chart.displayRSquared = this.displayRSquared;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.type = undefined;
        this.name = undefined;
        this.forward = undefined;
        this.backward = undefined;
    }
}
/**
 * @private
 */
class ChartTitleArea {
    /**
     * @private
     */
    get chartfontName() {
        return this.fontName;
    }
    /**
     * @private
     */
    set chartfontName(value) {
        this.fontName = value;
    }
    /**
     * @private
     */
    get chartFontSize() {
        return this.fontSize;
    }
    /**
     * @private
     */
    set chartFontSize(value) {
        this.fontSize = value;
    }
    /**
     * @private
     */
    constructor() {
        this.dataFormat = new ChartDataFormat();
        this.layout = new ChartLayout();
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartTitleArea();
        chart.fontName = this.fontName;
        chart.fontSize = this.fontSize;
        chart.dataFormat = this.dataFormat.clone();
        chart.layout = this.layout.clone();
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.fontName = undefined;
        this.fontSize = undefined;
        this.dataFormat = undefined;
        this.layout = undefined;
    }
}
/**
 * @private
 */
class ChartDataFormat {
    /**
     * @private
     */
    constructor() {
        this.fill = new ChartFill();
        this.line = new ChartFill();
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartDataFormat();
        chart.fill = this.fill.clone();
        chart.line = this.line.clone();
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.fill = undefined;
        this.line = undefined;
    }
}
/**
 * @private
 */
class ChartFill {
    /**
     * @private
     */
    get color() {
        return this.fillColor;
    }
    /**
     * @private
     */
    set color(value) {
        this.fillColor = value;
    }
    /**
     * @private
     */
    get rgb() {
        return this.fillRGB;
    }
    /**
     * @private
     */
    set rgb(value) {
        this.fillRGB = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartFill();
        chart.fillColor = this.fillColor;
        chart.fillRGB = this.fillRGB;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.fillColor = undefined;
        this.fillRGB = undefined;
    }
}
/**
 * @private
 */
class ChartLayout {
    /**
     * @private
     */
    get chartLayoutLeft() {
        return this.layoutX;
    }
    /**
     * @private
     */
    set chartLayoutLeft(value) {
        this.layoutX = value;
    }
    /**
     * @private
     */
    get chartLayoutTop() {
        return this.layoutY;
    }
    /**
     * @private
     */
    set chartLayoutTop(value) {
        this.layoutY = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartLayout();
        chart.layoutX = this.layoutX;
        chart.layoutY = this.layoutY;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.layoutX = undefined;
        this.layoutY = undefined;
    }
}
/**
 * @private
 */
class ChartCategoryAxis {
    /**
     * @private
     */
    get majorTick() {
        return this.majorTickMark;
    }
    /**
     * @private
     */
    set majorTick(value) {
        this.majorTickMark = value;
    }
    /**
     * @private
     */
    get minorTick() {
        return this.minorTickMark;
    }
    /**
     * @private
     */
    set minorTick(value) {
        this.minorTickMark = value;
    }
    /**
     * @private
     */
    get tickPosition() {
        return this.tickLabelPostion;
    }
    /**
     * @private
     */
    set tickPosition(value) {
        this.tickLabelPostion = value;
    }
    /**
     * @private
     */
    get minorGridLines() {
        return this.hasMinorGridLines;
    }
    /**
     * @private
     */
    set minorGridLines(value) {
        this.hasMinorGridLines = value;
    }
    /**
     * @private
     */
    get majorGridLines() {
        return this.hasMajorGridLines;
    }
    /**
     * @private
     */
    set majorGridLines(value) {
        this.hasMajorGridLines = value;
    }
    /**
     * @private
     */
    get interval() {
        return this.majorUnit;
    }
    /**
     * @private
     */
    set interval(value) {
        this.majorUnit = value;
    }
    /**
     * @private
     */
    get max() {
        return this.maximumValue;
    }
    /**
     * @private
     */
    set max(value) {
        this.maximumValue = value;
    }
    /**
     * @private
     */
    get min() {
        return this.minimumValue;
    }
    /**
     * @private
     */
    set min(value) {
        this.minimumValue = value;
    }
    /**
     * @private
     */
    get categoryAxisTitle() {
        return this.title;
    }
    /**
     * @private
     */
    set categoryAxisTitle(value) {
        this.title = value;
    }
    /**
     * @private
     */
    get categoryAxisType() {
        return this.categoryType;
    }
    /**
     * @private
     */
    set categoryAxisType(value) {
        this.categoryType = value;
    }
    /**
     * @private
     */
    get categoryNumberFormat() {
        return this.numberFormat;
    }
    /**
     * @private
     */
    set categoryNumberFormat(value) {
        this.numberFormat = value;
    }
    /**
     * @private
     */
    get axisFontSize() {
        return this.fontSize;
    }
    /**
     * @private
     */
    set axisFontSize(value) {
        this.fontSize = value;
    }
    /**
     * @private
     */
    get axisFontName() {
        return this.fontName;
    }
    /**
     * @private
     */
    set axisFontName(value) {
        this.fontName = value;
    }
    constructor() {
        this.chartTitleArea = new ChartTitleArea();
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartCategoryAxis();
        chart.title = this.title;
        chart.categoryType = this.categoryType;
        chart.numberFormat = this.numberFormat;
        chart.fontSize = this.fontSize;
        chart.fontName = this.fontName;
        chart.hasMajorGridLines = this.hasMajorGridLines;
        chart.hasMinorGridLines = this.hasMinorGridLines;
        chart.minimumValue = this.minimumValue;
        chart.maximumValue = this.maximumValue;
        chart.majorUnit = this.majorUnit;
        chart.majorTickMark = this.majorTickMark;
        chart.minorTickMark = this.minorTickMark;
        chart.tickLabelPostion = this.tickLabelPostion;
        chart.chartTitleArea = this.chartTitleArea.clone();
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.title = undefined;
        this.categoryType = undefined;
        this.numberFormat = undefined;
        this.chartTitleArea = undefined;
        this.minimumValue = undefined;
        this.maximumValue = undefined;
        this.fontSize = undefined;
        this.fontName = undefined;
        this.majorUnit = undefined;
        this.majorTickMark = undefined;
        this.minorTickMark = undefined;
        this.tickLabelPostion = undefined;
    }
}
/**
 * @private
 */
class ChartDataTable {
    /**
     * @private
     */
    get showSeriesKeys() {
        return this.isSeriesKeys;
    }
    /**
     * @private
     */
    set showSeriesKeys(value) {
        this.isSeriesKeys = value;
    }
    /**
     * @private
     */
    get hasHorzBorder() {
        return this.isHorzBorder;
    }
    /**
     * @private
     */
    set hasHorzBorder(value) {
        this.isHorzBorder = value;
    }
    /**
     * @private
     */
    get hasVertBorder() {
        return this.isVertBorder;
    }
    /**
     * @private
     */
    set hasVertBorder(value) {
        this.isVertBorder = value;
    }
    /**
     * @private
     */
    get hasBorders() {
        return this.isBorders;
    }
    /**
     * @private
     */
    set hasBorders(value) {
        this.isBorders = value;
    }
    /**
     * @private
     */
    clone() {
        let chart = new ChartDataTable();
        chart.isSeriesKeys = this.isSeriesKeys;
        chart.isHorzBorder = this.isHorzBorder;
        chart.isVertBorder = this.isVertBorder;
        chart.isBorders = this.isBorders;
        return chart;
    }
    /**
     * @private
     */
    destroy() {
        this.isSeriesKeys = undefined;
        this.isHorzBorder = undefined;
        this.isVertBorder = undefined;
        this.isBorders = undefined;
    }
}
/**
 * @private
 */
class CommentCharacterElementBox extends ElementBox {
    constructor(type) {
        super();
        this.commentType = 0;
        this.commentId = '';
        this.commentType = type;
    }
    get comment() {
        return this.commentInternal;
    }
    set comment(value) {
        this.commentInternal = value;
    }
    getLength() {
        return 1;
    }
    clone() {
        let comment = new CommentCharacterElementBox(this.commentType);
        comment.commentId = this.commentId;
        comment.commentType = this.commentType;
        return comment;
    }
    renderCommentMark() {
        if (this.commentType === 0 && isNullOrUndefined(this.commentMark)) {
            this.commentMark = document.createElement('div');
            this.commentMark.style.display = 'none';
            this.commentMark.classList.add('e-de-cmt-mark');
            let span = document.createElement('span');
            span.classList.add('e-icons');
            span.classList.add('e-de-cmt-mark-icon');
            this.commentMark.appendChild(span);
        }
        if (this.line && isNullOrUndefined(this.commentMark.parentElement)) {
            let viewer = this.line.paragraph.bodyWidget.page.viewer;
            viewer.pageContainer.appendChild(this.commentMark);
            this.commentMark.addEventListener('click', this.selectComment.bind(this));
        }
    }
    selectComment() {
        let viewer = this.line.paragraph.bodyWidget.page.viewer;
        if (viewer.owner) {
            if (!viewer.owner.commentReviewPane.commentPane.isEditMode) {
                viewer.selectComment(this.comment);
            }
            else {
                viewer.owner.showComments = true;
            }
        }
    }
    removeCommentMark() {
        if (this.commentMark && this.commentMark.parentElement) {
            this.commentMark.removeEventListener('click', this.selectComment.bind(this));
            this.commentMark.parentElement.removeChild(this.commentMark);
        }
    }
    destroy() {
        if (this.commentMark) {
            this.removeCommentMark();
        }
    }
}
/**
 * @private
 */
class CommentElementBox extends CommentCharacterElementBox {
    constructor(date) {
        super(0);
        this.authorIn = '';
        this.initialIn = '';
        this.done = false;
        this.textIn = '';
        this.isReply = false;
        this.ownerComment = undefined;
        this.createdDate = date;
        this.replyComments = [];
    }
    get commentStart() {
        return this.commentStartIn;
    }
    set commentStart(value) {
        this.commentStartIn = value;
    }
    get commentEnd() {
        return this.commentEndIn;
    }
    set commentEnd(value) {
        this.commentEndIn = value;
    }
    get author() {
        return this.authorIn;
    }
    set author(value) {
        this.authorIn = value;
    }
    get initial() {
        return this.initialIn;
    }
    set initial(value) {
        this.initialIn = value;
    }
    get isResolved() {
        return this.done;
    }
    set isResolved(value) {
        this.done = value;
    }
    get date() {
        return this.createdDate;
    }
    get text() {
        return this.textIn;
    }
    set text(value) {
        this.textIn = value;
    }
    getLength() {
        return 1;
    }
    clone() {
        let comment = new CommentElementBox(this.date);
        comment.author = this.author;
        comment.initial = this.initial;
        comment.commentId = this.commentId;
        comment.replyComments = this.replyComments;
        comment.isResolved = this.isResolved;
        comment.text = this.text;
        return comment;
    }
    destroy() {
        this.ownerComment = undefined;
    }
}
/**
 * @private
 */
class Page {
    /**
     * Initialize the constructor of Page
     */
    constructor() {
        /**
         * Specifies the Bonding Rectangle
         * @private
         */
        this.boundingRectangle = new Rect(96, 96, 816, 1056);
        /**
         * @private
         */
        this.repeatHeaderRowTableWidget = false;
        /**
         * Specifies the bodyWidgets
         * @default []
         * @private
         */
        this.bodyWidgets = [];
        /**
         * @private
         */
        this.headerWidget = undefined;
        /**
         * @private
         */
        this.footerWidget = undefined;
        /**
         * @private
         */
        this.currentPageNum = 0;
        /**
         *
         */
        this.allowNextPageRendering = true;
        // let text: string = 'DocumentEditor';
    }
    /**
     * @private
     */
    get index() {
        if (this.viewer) {
            return this.viewer.pages.indexOf(this);
        }
        return -1;
    }
    /**
     * @private
     */
    get previousPage() {
        let index = this.index;
        if (index > 0) {
            return this.viewer.pages[index - 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get nextPage() {
        let index = this.index;
        if (index < this.viewer.pages.length - 1) {
            return this.viewer.pages[index + 1];
        }
        return undefined;
    }
    /**
     * @private
     */
    get sectionIndex() {
        if (this.bodyWidgets.length > 0) {
            return this.bodyWidgets[0].index;
        }
        return -1;
    }
    destroy() {
        if (this.headerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.headerWidget);
            }
            this.headerWidget.destroy();
        }
        this.headerWidget = undefined;
        if (this.footerWidget) {
            if (this.viewer && this.viewer.owner.editor) {
                this.viewer.owner.editor.removeFieldInWidget(this.footerWidget);
            }
            this.footerWidget.destroy();
        }
        this.footerWidget = undefined;
        this.bodyWidgets = [];
        this.bodyWidgets = undefined;
        if (!isNullOrUndefined(this.viewer)) {
            if (!isNullOrUndefined(this.viewer.pages)) {
                this.viewer.removePage(this);
            }
        }
        this.viewer = undefined;
    }
}
/**
 * @private
 */
class WTableHolder {
    constructor() {
        this.tableColumns = [];
        /**
         * @private
         */
        this.tableWidth = 0;
    }
    get columns() {
        return this.tableColumns;
    }
    /**
     * @private
     */
    resetColumns() {
        for (let i = 0; i < this.tableColumns.length; i++) {
            this.tableColumns[i].destroy();
        }
        this.tableColumns = [];
    }
    /**
     * @private
     */
    getPreviousSpannedCellWidth(previousColumnIndex, curColumnIndex) {
        let width = 0;
        for (let i = previousColumnIndex; i < curColumnIndex; i++) {
            width += this.tableColumns[i].preferredWidth;
        }
        return width;
    }
    /**
     * @private
     */
    addColumns(currentColumnIndex, columnSpan, width, sizeInfo, offset) {
        for (let i = this.columns.length; i < columnSpan; i++) {
            this.columns.push(new WColumn());
        }
        let availableWidth = 0;
        for (let j = currentColumnIndex; j < columnSpan; j++) {
            availableWidth += this.columns[j].preferredWidth;
        }
        // If width to add is greater than preferred width, then preferred width will be increased.
        // In case of Grid span > 1, only last grid column width will be updated.
        let gridSpan = columnSpan - currentColumnIndex;
        if (!(gridSpan > 1) && availableWidth < width) {
            this.columns[columnSpan - 1].preferredWidth += (width - availableWidth);
        }
        if (sizeInfo.minimumWordWidth > this.columns[columnSpan - 1].minimumWordWidth) {
            this.columns[columnSpan - 1].minimumWordWidth = sizeInfo.minimumWordWidth;
        }
        if (sizeInfo.maximumWordWidth > this.columns[columnSpan - 1].maximumWordWidth) {
            this.columns[columnSpan - 1].maximumWordWidth = sizeInfo.maximumWordWidth;
        }
        if (sizeInfo.minimumWidth > this.columns[columnSpan - 1].minimumWidth) {
            this.columns[columnSpan - 1].minimumWidth = sizeInfo.minimumWidth;
        }
        if (offset > this.columns[columnSpan - 1].endOffset) {
            this.columns[columnSpan - 1].endOffset = offset;
        }
    }
    /**
     * @private
     */
    getTotalWidth(type) {
        let width = 0;
        for (let i = 0; i < this.columns.length; i++) {
            let column = this.columns[i];
            width += type === 0 ? column.preferredWidth :
                type === 1 ? column.minimumWordWidth :
                    type === 2 ? column.maximumWordWidth : column.minimumWidth;
        }
        return width;
    }
    /**
     * @private
     */
    isFitColumns(containerWidth, preferredTableWidth, isAutoWidth) {
        // Gets total preferred width.
        let totalColumnWidth = this.getTotalWidth(0);
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            let factor = this.tableWidth / totalColumnWidth;
            factor = isNaN(factor) ? 1 : factor;
            for (let i = 0; i < this.columns.length; i++) {
                let column = this.columns[i];
                //column.PreferredWidth = factor * column.PreferredWidth;
                if (factor * column.preferredWidth < column.minWidth) {
                    return false;
                }
            }
            return true;
        }
        else {
            return true;
        }
    }
    /**
     * @private
     */
    autoFitColumn(containerWidth, preferredTableWidth, isAuto, isNestedTable) {
        // Cell's preferred width should be considered until the table width fits to the container width.
        let maxTotal = 0;
        let minTotal = 0;
        // For preferred width set as 0 pixels (not auto), then minimum word width only need to be considered.
        // But currently there is no way to find any one of cell in particular column has 0 px preferred width set.
        // If all columns are set as 0 pixels, then this will work.
        let remainingWidthTotal = 0;
        for (let i = 0; i < this.columns.length; i++) {
            let column = this.columns[i];
            // If preferred width of column is less than column minimum width and also column is empty, considered column preferred width
            if (column.minimumWordWidth === 0 && column.maximumWordWidth === 0 && column.minWidth === 0) {
                column.minimumWordWidth = column.preferredWidth;
                column.maximumWordWidth = column.preferredWidth;
                column.minWidth = column.preferredWidth;
            }
            maxTotal += column.preferredWidth > column.maximumWordWidth ? column.preferredWidth : column.maximumWordWidth;
            minTotal += column.preferredWidth > column.minimumWordWidth ? column.preferredWidth : column.minimumWordWidth;
            // tslint:disable-next-line:max-line-length
            let preferred = column.preferredWidth === 0 ? column.minimumWordWidth : column.preferredWidth > column.minimumWordWidth ? column.preferredWidth : column.minimumWordWidth;
            let difference = column.maximumWordWidth - preferred;
            remainingWidthTotal += difference > 0 ? difference : 0;
        }
        // Try to fit maximum word width to match preferredTableWidth.
        if (maxTotal <= preferredTableWidth) {
            for (let i = 0; i < this.columns.length; i++) {
                let column = this.columns[i];
                if (column.preferredWidth < column.maximumWordWidth) {
                    if (isNestedTable) {
                        column.preferredWidth = column.minimumWidth + column.minimumWordWidth;
                    }
                    else {
                        column.preferredWidth = column.maximumWordWidth;
                    }
                }
            }
            // If the width is defined for table(cells undefined) then fit the columns to preferred table width using FitColumns.
            if (!isAuto) {
                this.fitColumns(containerWidth, preferredTableWidth, isAuto);
            }
        }
        else {
            // If the table preferred table width is set, then check its greater than total minimum word width. 
            // tslint:disable-next-line:max-line-length
            // If yes then set table preferred table width as container width. Else, check whether the total minimum word width is less than container width.
            // If yes, then set total minimum word width as container width. Else, set the container width to container width.
            if (!isAuto) {
                let totalMinimumWordWidth = this.getTotalWidth(1);
                if (preferredTableWidth > totalMinimumWordWidth && totalMinimumWordWidth < containerWidth) {
                    this.fitColumns(containerWidth, preferredTableWidth, isAuto);
                    return;
                }
                // tslint:disable-next-line:max-line-length
                containerWidth = preferredTableWidth < totalMinimumWordWidth ? totalMinimumWordWidth < containerWidth ? totalMinimumWordWidth : containerWidth : preferredTableWidth;
            }
            // Try to fit minimum word width to match preferredTableWidth or containerWidth.
            if (minTotal <= preferredTableWidth || minTotal <= containerWidth) {
                let availableWidth = containerWidth > preferredTableWidth ? containerWidth : preferredTableWidth;
                availableWidth = availableWidth - minTotal;
                for (let i = 0; i < this.columns.length; i++) {
                    let column = this.columns[i];
                    if (column.preferredWidth === 0) {
                        column.preferredWidth = column.minimumWordWidth;
                    }
                    else {
                        if (column.preferredWidth < column.minimumWordWidth) {
                            column.preferredWidth = column.minimumWordWidth;
                        }
                        if (!isNestedTable) {
                            let difference = column.maximumWordWidth - column.preferredWidth;
                            difference = difference > 0 ? difference : 0;
                            let factor = availableWidth * (difference / remainingWidthTotal);
                            column.preferredWidth += isNaN(factor) ? 0 : factor;
                        }
                    }
                }
            }
            else {
                // Try to fit minimum width for each column and allot remaining space to columns based on their minimum word width.
                let totalMinimumWordWidth = this.getTotalWidth(1);
                let totalMinWidth = this.getTotalWidth(3);
                if (totalMinWidth > 2112) {
                    let cellWidth = 2112 / this.columns.length;
                    for (let i = 0; i < this.columns.length; i++) {
                        this.columns[i].preferredWidth = cellWidth;
                    }
                }
                else {
                    let availableWidth = totalMinWidth < containerWidth ? (containerWidth - totalMinWidth) : 0;
                    for (let i = 0; i < this.columns.length; i++) {
                        let column = this.columns[i];
                        // The factor depends of current column's minimum word width and total minimum word width.
                        let factor = availableWidth * column.minimumWordWidth / totalMinimumWordWidth;
                        factor = isNaN(factor) ? 0 : factor;
                        if (column.preferredWidth <= column.minimumWidth) {
                            continue;
                        }
                        column.preferredWidth = column.minimumWidth + factor;
                    }
                }
            }
        }
        this.tableWidth = this.getTotalWidth(0);
    }
    /**
     * @private
     */
    fitColumns(containerWidth, preferredTableWidth, isAutoWidth, indent) {
        if (isNullOrUndefined(indent)) {
            indent = 0;
        }
        // Gets total preferred width.
        let totalColumnWidth = this.getTotalWidth(0);
        // Neglected left indent value, because in preferred table width left indent value is neglected
        if (isAutoWidth) {
            totalColumnWidth -= indent;
        }
        // If auto table width, based on total column widths, minimum value will be updated.
        if (isAutoWidth) {
            this.tableWidth = preferredTableWidth > totalColumnWidth ? totalColumnWidth : preferredTableWidth;
        }
        else {
            this.tableWidth = preferredTableWidth;
        }
        // If total columns width doesn't match table width, then all grid column widths will be updated by even factor.
        // If totalColumnWidth < TableWidth, all grid columns are enlarged. Otherwise shrinked.
        if (totalColumnWidth !== this.tableWidth) {
            let factor = this.tableWidth / totalColumnWidth;
            for (let i = 0; i < this.columns.length; i++) {
                let column = this.columns[i];
                column.preferredWidth = factor * column.preferredWidth;
            }
        }
    }
    /**
     * @private
     */
    getCellWidth(columnIndex, columnSpan, preferredTableWidth) {
        let width = 0;
        for (let i = 0; i < columnSpan; i++) {
            width += this.tableColumns[i + columnIndex].preferredWidth;
        }
        return width;
    }
    /**
     * @private
     */
    validateColumnWidths() {
        for (let i = 0; i < this.columns.length; i++) {
            if (i === 0) {
                if (this.columns[i].preferredWidth !== this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset;
                }
            }
            else {
                // If Previous column offset + current column preferred width is less than current column offset, 
                // Then current column preferred width is set to current column offset - previous column offset.
                if (this.columns[i - 1].endOffset + this.columns[i].preferredWidth < this.columns[i].endOffset) {
                    this.columns[i].preferredWidth = this.columns[i].endOffset - this.columns[i - 1].endOffset;
                }
            }
        }
    }
    /**
     * @private
     */
    clone() {
        let tableHolder = new WTableHolder();
        tableHolder.tableWidth = this.tableWidth;
        for (let i = 0; i < this.columns.length; i++) {
            tableHolder.columns.push(this.columns[i].clone());
        }
        return tableHolder;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.tableColumns)) {
            for (let i = 0; i < this.tableColumns.length; i++) {
                let column = this.tableColumns[i];
                column.destroy();
            }
        }
        this.tableColumns = [];
        this.tableColumns = undefined;
        this.tableWidth = undefined;
    }
}
/**
 * @private
 */
class WColumn {
    constructor() {
        /**
         * @private
         */
        this.preferredWidth = 0;
        /**
         * @private
         */
        this.minWidth = 0;
        /**
         * @private
         */
        this.maxWidth = 0;
        /**
         * @private
         */
        this.endOffset = 0;
        /**
         * @private
         */
        this.minimumWordWidth = 0;
        /**
         * @private
         */
        this.maximumWordWidth = 0;
        /**
         * @private
         */
        this.minimumWidth = 0;
    }
    /**
     * @private
     */
    clone() {
        let column = new WColumn();
        column.preferredWidth = this.preferredWidth;
        column.minWidth = this.minWidth;
        column.maxWidth = this.maxWidth;
        return column;
    }
    /**
     * @private
     */
    destroy() {
        this.preferredWidth = undefined;
        this.minWidth = undefined;
        this.maxWidth = undefined;
    }
}
/**
 * @private
 */
class ColumnSizeInfo {
    constructor() {
        /**
         * @private
         */
        this.minimumWordWidth = 0;
        /**
         * @private
         */
        this.maximumWordWidth = 0;
        /**
         * @private
         */
        this.minimumWidth = 0;
        /**
         * @private
         */
        this.hasMinimumWidth = false;
        /**
         * @private
         */
        this.hasMinimumWordWidth = false;
        /**
         * @private
         */
        this.hasMaximumWordWidth = false;
    }
}

/**
 * The spell checker module
 */
class SpellChecker {
    /**
     *
     */
    constructor(viewer) {
        this.langIDInternal = 0;
        this.spellSuggestionInternal = true;
        /**
         * @private
         */
        this.uniqueKey = '';
        this.removeUnderlineInternal = false;
        /**
         * @default 1000
         */
        this.uniqueWordsCountInternal = 10000;
        this.performOptimizedCheck = false;
        this.viewer = viewer;
        this.errorWordCollection = new Dictionary();
        this.errorSuggestions = new Dictionary();
        this.ignoreAllItems = [];
        this.uniqueSpelledWords = [];
        this.uniqueKey = this.viewer.owner.element.id + '_' + this.createGuid();
    }
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'SpellChecker';
    }
    /**
     * Gets the boolean indicating whether optimized spell check to be performed.
     * @aspType bool
     * @blazorType bool
     */
    get enableOptimizedSpellCheck() {
        return this.performOptimizedCheck;
    }
    /**
     * Sets the boolean indicating whether optimized spell check to be performed.
     * @aspType bool
     * @blazorType bool
     */
    set enableOptimizedSpellCheck(value) {
        this.performOptimizedCheck = value;
    }
    /**
     * Gets the spell checked Unique words.
     * @aspType int
     * @blazorType int
     */
    get uniqueWordsCount() {
        return isNullOrUndefined(this.uniqueWordsCountInternal) ? 0 : this.uniqueWordsCountInternal;
    }
    /**
     * Sets the spell checked Unique words.
     * @aspType int
     * @blazorType int
     */
    set uniqueWordsCount(value) {
        this.uniqueWordsCountInternal = value;
    }
    /**
     * Gets the languageID.
     * @aspType int
     * @blazorType int
     */
    get languageID() {
        return isNullOrUndefined(this.langIDInternal) ? 0 : this.langIDInternal;
    }
    /**
     * Sets the languageID.
     * @aspType int
     * @blazorType int
     */
    set languageID(value) {
        this.langIDInternal = value;
    }
    /**
     * Getter indicates whether suggestion enabled.
     * @aspType bool
     * @blazorType bool
     */
    get allowSpellCheckAndSuggestion() {
        return this.spellSuggestionInternal;
    }
    /**
     * Setter to enable or disable suggestion
     * @aspType bool
     * @blazorType bool
     */
    set allowSpellCheckAndSuggestion(value) {
        this.spellSuggestionInternal = value;
    }
    /**
     * Getter indicates whether underline removed for mis-spelled word.
     * @aspType bool
     * @blazorType bool
     */
    get removeUnderline() {
        return this.removeUnderlineInternal;
    }
    /**
     * Setter to enable or disable underline for mis-spelled word
     * @aspType bool
     * @blazorType bool
     */
    set removeUnderline(value) {
        this.removeUnderlineInternal = value;
    }
    /**
     * Method to manage replace logic
     * @private
     */
    manageReplace(content, dialogElement) {
        this.viewer.triggerSpellCheck = true;
        let exactText = '';
        if (!isNullOrUndefined(dialogElement) && dialogElement instanceof ErrorTextElementBox) {
            let exactText = dialogElement.text;
            this.viewer.selection.start = dialogElement.start;
            this.viewer.selection.end = dialogElement.end;
            if (content !== 'Ignore Once') {
                content = this.manageSpecialCharacters(exactText, content);
                this.viewer.owner.editor.insertTextInternal(content, true);
                this.viewer.selection.start = this.viewer.selection.end;
                this.viewer.clearSelectionHighlight();
                return;
            }
            else {
                this.currentContextInfo = { 'text': exactText, 'element': dialogElement };
            }
        }
        if (!isNullOrUndefined(this.currentContextInfo) && this.currentContextInfo.element && content !== 'Ignore Once') {
            let elementBox = this.currentContextInfo.element;
            exactText = this.currentContextInfo.element.text;
            this.viewer.selection.start = elementBox.start;
            this.viewer.selection.end = elementBox.end;
        }
        else {
            this.handleReplace(content);
        }
        if (content !== 'Ignore Once') {
            this.viewer.owner.editor.insertTextInternal(content, true);
            if (!isNullOrUndefined(this.currentContextInfo)) {
                this.removeErrorsFromCollection(this.currentContextInfo);
            }
            this.viewer.selection.start = this.viewer.selection.end;
            this.viewer.clearSelectionHighlight();
        }
        //this.viewer.owner.errorWordCollection.remove(content);
        this.viewer.triggerSpellCheck = false;
    }
    /**
     * Method to handle replace logic
     * @param {string} content
     * @private
     */
    handleReplace(content) {
        let startPosition = this.viewer.selection.start;
        let offset = startPosition.offset;
        let startIndex = 0;
        let startInlineObj = startPosition.currentWidget.getInline(offset, startIndex, false, true);
        let startOffset = startInlineObj.element.line.getOffset(startInlineObj.element, 0) + startInlineObj.element.length;
        if (startOffset === offset) {
            this.retrieveExactElementInfo(startInlineObj);
        }
        let exactText = startInlineObj.element.text;
        // tslint:disable-next-line:max-line-length
        let startPattern = new RegExp('^[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\'\\,\\<\\.\\>\\/\\?\\`\\s]+', 'g');
        let matches = [];
        let matchInfo;
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchInfo = startPattern.exec(exactText))) {
            matches.push(matchInfo);
        }
        if (content === 'Ignore Once') {
            this.handleIgnoreOnce(startInlineObj);
            return;
        }
        startPosition.offset = offset - startInlineObj.index;
        if (!isNullOrUndefined(matches) && matches.length > 0) {
            startPosition.offset += matches[0].toString().length;
        }
        // tslint:disable-next-line:max-line-length
        startPosition.location = this.viewer.owner.selection.getPhysicalPositionInternal(startPosition.currentWidget, startPosition.offset, true);
        // tslint:disable-next-line:max-line-length
        startPosition = this.viewer.owner.searchModule.textSearch.getTextPosition(startPosition.currentWidget, startPosition.offset.toString());
        //startPosition.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
        startPosition.setPositionParagraph(startPosition.currentWidget, startPosition.offset);
        let index = (startPosition.offset + startInlineObj.element.length) - startPosition.offset;
        let endOffset = startPosition.currentWidget.getOffset(startInlineObj.element, index);
        let lineWidget = startPosition.currentWidget;
        // tslint:disable-next-line:max-line-length
        let endPattern = new RegExp('[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\'\\,\\<\\.\\>\\/\\?\\s\\`]+$', 'g');
        matches = [];
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchInfo = endPattern.exec(exactText))) {
            matches.push(matchInfo);
        }
        if (!isNullOrUndefined(matches) && matches.length > 0) {
            endOffset -= matches[0].toString().length;
        }
        // tslint:disable-next-line:max-line-length
        this.viewer.selection.end = this.viewer.owner.searchModule.textSearch.getTextPosition(lineWidget, endOffset.toString());
        // tslint:disable-next-line:max-line-length
        this.viewer.selection.end.location = this.viewer.owner.selection.getPhysicalPositionInternal(startPosition.currentWidget, endOffset, true);
        this.viewer.selection.end.setPositionParagraph(lineWidget, endOffset);
        this.currentContextInfo = { 'element': startInlineObj.element, 'text': startInlineObj.element.text };
    }
    /**
     * Method to retrieve exact element info
     * @param {ElementInfo} startInlineObj
     * @private
     */
    retrieveExactElementInfo(startInlineObj) {
        let nextElement = startInlineObj.element.nextElement;
        // tslint:disable-next-line:max-line-length
        startInlineObj.element = (!isNullOrUndefined(nextElement) && nextElement instanceof TextElementBox) ? startInlineObj.element.nextElement : startInlineObj.element;
    }
    /**
     * Method to handle to ignore error Once
     * @param {ElementInfo} startInlineObj
     * @private
     */
    handleIgnoreOnce(startInlineObj) {
        let textElement = startInlineObj.element;
        let exactText = '';
        if (!isNullOrUndefined(this.currentContextInfo) && this.currentContextInfo.element) {
            exactText = this.currentContextInfo.element.text;
        }
        else {
            exactText = textElement.text;
        }
        exactText = this.manageSpecialCharacters(exactText, undefined, true);
        if (textElement.ignoreOnceItems.indexOf(exactText) === -1) {
            textElement.ignoreOnceItems.push(exactText);
        }
        this.viewer.owner.editor.reLayout(this.viewer.selection);
    }
    /**
     * Method to handle ignore all items
     * @private
     */
    handleIgnoreAllItems(contextElement) {
        let contextItem = (!isNullOrUndefined(contextElement)) ? contextElement : this.retriveText();
        let retrievedText = this.manageSpecialCharacters(contextItem.text, undefined, true);
        if (this.ignoreAllItems.indexOf(retrievedText) === -1) {
            this.ignoreAllItems.push(retrievedText);
            this.removeErrorsFromCollection(contextItem);
            this.viewer.triggerSpellCheck = true;
            this.viewer.owner.editor.reLayout(this.viewer.selection);
            this.viewer.triggerSpellCheck = false;
            this.viewer.clearSelectionHighlight();
        }
    }
    /**
     * Method to handle dictionary
     * @private
     */
    handleAddToDictionary(contextElement) {
        let contextItem = (!isNullOrUndefined(contextElement)) ? contextElement : this.retriveText();
        let retrievedText = this.manageSpecialCharacters(contextItem.text, undefined, true);
        // tslint:disable-next-line:max-line-length
        /* tslint:disable:no-any */
        this.CallSpellChecker(this.languageID, retrievedText, false, false, true).then((data) => {
            this.viewer.triggerSpellCheck = true;
            this.removeErrorsFromCollection(contextItem);
            this.ignoreAllItems.push(retrievedText);
            this.viewer.owner.editor.reLayout(this.viewer.selection, true);
            this.viewer.triggerSpellCheck = false;
        });
    }
    /**
     * Method to append/remove special characters
     * @param {string} exactText
     * @param {boolean} isRemove
     * @private
     */
    // tslint:disable-next-line:max-line-length
    manageSpecialCharacters(exactText, replaceText, isRemove) {
        if (!isNullOrUndefined(exactText)) {
            if (isNullOrUndefined(replaceText)) {
                replaceText = exactText;
            }
            // tslint:disable-next-line:max-line-length
            let pattern = new RegExp('^[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\\”\'\\,\\<\\.\\>\\/\\?\\`\\s]+', 'g');
            let matches = [];
            let matchInfo;
            //tslint:disable no-conditional-assignment
            while (!isNullOrUndefined(matchInfo = pattern.exec(exactText))) {
                matches.push(matchInfo);
            }
            if (matches.length > 0) {
                for (let i = 0; i < matches.length; i++) {
                    /* tslint:disable:no-any */
                    let match = matches[i];
                    replaceText = (!isRemove) ? match[0] + replaceText : replaceText.replace(match[0], '');
                }
            }
            // tslint:disable-next-line:max-line-length
            let endPattern = new RegExp('[#\\@\\!\\~\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\{\\}\\[\\]\\:\\;\\"\\”\'\\,\\<\\.\\>\\/\\?\\s\\`]+$', 'g');
            matches = [];
            //tslint:disable no-conditional-assignment
            while (!isNullOrUndefined(matchInfo = endPattern.exec(replaceText))) {
                matches.push(matchInfo);
            }
            if (matches.length > 0) {
                for (let i = 0; i < matches.length; i++) {
                    /* tslint:disable:no-any */
                    let match = matches[i];
                    replaceText = (!isRemove) ? replaceText + match[0] : replaceText.slice(0, match.index);
                }
            }
        }
        return replaceText;
    }
    /**
     * Method to remove errors
     * @param {ContextElementInfo} contextItem
     * @private
     */
    removeErrorsFromCollection(contextItem) {
        if (this.errorWordCollection.containsKey(contextItem.text)) {
            let textElement = this.errorWordCollection.get(contextItem.text);
            if (textElement.indexOf(contextItem.element) >= 0) {
                textElement.splice(0, 1);
            }
            if (textElement.length === 0) {
                this.errorWordCollection.remove(contextItem.text);
            }
        }
    }
    /**
     * Method to retrieve exact text
     * @private
     */
    retriveText() {
        let exactText;
        let currentElement;
        if (!isNullOrUndefined(this.currentContextInfo) && this.currentContextInfo.element) {
            currentElement = this.currentContextInfo.element;
            exactText = this.currentContextInfo.element.text;
            this.viewer.selection.start = currentElement.start;
            this.viewer.selection.end = currentElement.end;
        }
        else {
            let startPosition = this.viewer.selection.start;
            let offset = startPosition.offset;
            let startIndex = 0;
            let startInlineObj = startPosition.currentWidget.getInline(offset, startIndex);
            currentElement = startInlineObj.element;
            exactText = startInlineObj.element.text;
        }
        return { 'text': exactText, 'element': currentElement };
    }
    /**
     * Method to handle suggestions
     * @param {any} jsonObject
     * @param {PointerEvent} event
     * @private
     */
    /* tslint:disable:no-any */
    handleSuggestions(allsuggestions) {
        this.spellCheckSuggestion = [];
        if (allsuggestions.length === 0) {
            this.spellCheckSuggestion.push('Add To Dictionary');
        }
        else {
            // tslint:disable-next-line:max-line-length
            allsuggestions = (allsuggestions.length === 5) ? this.constructInlineMenu(allsuggestions) : allsuggestions;
            this.spellCheckSuggestion.push('Add To Dictionary');
        }
        /* tslint:disable:no-any */
        let spellSuggestion = [];
        if (this.spellCheckSuggestion.length > 0) {
            for (let str of this.spellCheckSuggestion) {
                spellSuggestion.push({
                    text: str,
                    id: this.viewer.owner.element.id + '_contextmenu_otherSuggestions_spellcheck_' + str,
                    iconCss: ''
                });
            }
        }
        return spellSuggestion;
    }
    /**
     * Method to check whether text element has errors
     * @param {string} text
     * @param {any} element
     * @param {number} left
     * @private
     */
    checktextElementHasErrors(text, element, left) {
        let hasError = false;
        let erroElements = [];
        text = text.replace(/[\s]+/g, '');
        if (!isNullOrUndefined(element.errorCollection) && element.errorCollection.length > 0) {
            // tslint:disable-next-line:max-line-length
            if (!this.viewer.isScrollHandler && (element.ischangeDetected || element.paragraph.isChangeDetected)) {
                this.updateStatusForGlobalErrors(element.errorCollection, element);
                element.errorCollection = [];
                element.ischangeDetected = true;
                return { 'errorFound': hasError, 'elements': erroElements };
            }
            for (let i = 0; i < element.errorCollection.length; i++) {
                if (this.handleErrorCollection(element.errorCollection[i])) {
                    hasError = true;
                    erroElements.push(element.errorCollection[i]);
                }
            }
        }
        else if (!this.viewer.isScrollHandler && element.paragraph.isChangeDetected) {
            element.ischangeDetected = true;
        }
        else if (!element.ischangeDetected && this.handleErrorCollection(element)) {
            hasError = true;
            erroElements.push(element);
        }
        return { 'errorFound': hasError, 'elements': erroElements };
    }
    /**
     * Method to update status for error elements
     * @param {ErrorTextElementBox[]} erroElements
     */
    updateStatusForGlobalErrors(erroElements, parentElement) {
        if (erroElements.length > 0) {
            for (let i = 0; i < erroElements.length; i++) {
                let exactText = this.manageSpecialCharacters(erroElements[i].text, undefined, true);
                if (this.errorWordCollection.containsKey(exactText)) {
                    let elements = this.errorWordCollection.get(exactText);
                    for (let j = 0; j < elements.length; j++) {
                        if (elements[j] instanceof ErrorTextElementBox && elements[j] === erroElements[i]) {
                            elements[j].ischangeDetected = true;
                            // tslint:disable-next-line:max-line-length
                            elements[j].start.offset = parentElement.line.getOffset(parentElement.istextCombined ? this.getCombinedElement(parentElement) : parentElement, 0);
                            elements[j].line = parentElement.line;
                            break;
                        }
                    }
                }
            }
        }
    }
    /**
     * Method to handle document error collection.
     * @param {string} errorInElement
     * @private
     */
    handleErrorCollection(errorInElement) {
        let errors = this.errorWordCollection;
        let exactText = this.manageSpecialCharacters(errorInElement.text, undefined, true);
        if (errors.containsKey(exactText) && errorInElement.length > 1) {
            let ignoreAllIndex = this.ignoreAllItems.indexOf(exactText);
            if (ignoreAllIndex > -1) {
                if (errors.containsKey(exactText)) {
                    errors.remove(exactText);
                }
                return false;
            }
            return true;
        }
        return false;
    }
    /**
     * Method to construct inline menu
     */
    /* tslint:disable:no-any */
    constructInlineMenu(inlineSuggestion) {
        /* tslint:disable:no-any */
        for (let i = inlineSuggestion.length - 1; i > 0; i--) {
            if (inlineSuggestion.length > 3) {
                this.spellCheckSuggestion.push(inlineSuggestion[i]);
                inlineSuggestion.pop();
            }
        }
        return inlineSuggestion;
    }
    /**
     * Method to retrieve error element text
     * @private
     */
    findCurretText() {
        let insertPosition = this.viewer.selection.start;
        /* tslint:disable:no-any */
        let element;
        /* tslint:disable:no-any */
        let inlineObj = insertPosition.currentWidget.getInline(this.viewer.selection.start.offset, 0);
        let text;
        if (!isNullOrUndefined(inlineObj.element)) {
            if (!isNullOrUndefined(inlineObj.element.errorCollection) && inlineObj.element.errorCollection.length > 0) {
                for (let i = 0; i < inlineObj.element.errorCollection.length; i++) {
                    let errorElement = inlineObj.element.errorCollection[i];
                    // tslint:disable-next-line:max-line-length
                    if (errorElement.start.location.x <= insertPosition.location.x && errorElement.end.location.x >= insertPosition.location.x) {
                        text = errorElement.text;
                        element = errorElement;
                        break;
                    }
                }
            }
            else {
                text = inlineObj.element.text;
            }
            if (text === ' ') {
                inlineObj = insertPosition.currentWidget.getInline(this.viewer.selection.start.offset + 1, 0);
                text = inlineObj.element.text;
            }
        }
        return { 'text': text, 'element': element };
    }
    /**
     * Method to add error word in document error collection
     * @param text
     * @param element
     */
    addErrorCollection(text, elementToCompare, suggestions) {
        text = this.manageSpecialCharacters(text, undefined, true);
        if (this.errorWordCollection.containsKey(text)) {
            let errorElements = this.errorWordCollection.get(text);
            if (elementToCompare instanceof ErrorTextElementBox) {
                if (!this.compareErrorTextElement(elementToCompare, errorElements)) {
                    errorElements.push(elementToCompare);
                }
            }
            else if (elementToCompare instanceof TextElementBox) {
                if (!this.compareTextElement(elementToCompare, errorElements)) {
                    errorElements.push(elementToCompare);
                }
            }
        }
        else {
            if (!isNullOrUndefined(suggestions) && suggestions.length > 0) {
                this.errorSuggestions.add(text, suggestions);
            }
            this.errorWordCollection.add(text, [elementToCompare]);
        }
    }
    /**
     * Method to compare error text elements
     * @param {ErrorTextElementBox} errorElement
     * @param {ElementBox[]} errorCollection
     */
    compareErrorTextElement(errorElement, errorCollection) {
        let copyElement = [];
        let isChanged = false;
        for (let i = 0; i < errorCollection.length; i++) {
            copyElement.push(errorCollection[i]);
        }
        let length = errorCollection.length;
        for (let i = 0; i < length; i++) {
            if (copyElement[i] instanceof ErrorTextElementBox) {
                if (copyElement[i].ischangeDetected) {
                    let exactText = this.manageSpecialCharacters(copyElement[i].text, undefined, true);
                    isChanged = true;
                    // tslint:disable-next-line:max-line-length
                    this.removeErrorsFromCollection({ 'element': copyElement[i], 'text': exactText });
                }
                else {
                    let currentElement = copyElement[i];
                    // tslint:disable-next-line:max-line-length
                    if (errorElement.start.offset === currentElement.start.offset && errorElement.end.offset === currentElement.end.offset) {
                        return true;
                    }
                }
            }
        }
        if (isChanged) {
            // tslint:disable-next-line:max-line-length
            this.errorWordCollection.add(this.manageSpecialCharacters(errorElement.text, undefined, true), [errorElement]);
        }
        return false;
    }
    /**
     * Method to compare text elements
     * @param {TextElementBox} errorElement
     * @param {ElementBox[]} errorCollection
     * @private
     */
    compareTextElement(errorElement, errorCollection) {
        for (let i = 0; i < errorCollection.length; i++) {
            if (errorCollection[i] instanceof TextElementBox) {
                let currentElement = errorCollection[i];
                if (currentElement === errorElement) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Method to handle Word by word spell check
     * @param {any} jsonObject
     *  @param {TextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {BaselineAlignment} baselineAlignment
     * @param {boolean} isSamePage
     * @private
     */
    // tslint:disable-next-line:max-line-length
    handleWordByWordSpellCheck(jsonObject, elementBox, left, top, underlineY, baselineAlignment, isSamePage) {
        if (jsonObject.HasSpellingError && isSamePage) {
            this.addErrorCollection(elementBox.text, elementBox, jsonObject.Suggestions);
            // tslint:disable-next-line:max-line-length
            let backgroundColor = (elementBox.line.paragraph.containerWidget instanceof TableCellWidget) ? elementBox.line.paragraph.containerWidget.cellFormat.shading.backgroundColor : this.viewer.backgroundColor;
            this.viewer.render.renderWavyline(elementBox, left, top, underlineY, '#FF0000', 'Single', baselineAlignment, backgroundColor);
            elementBox.isSpellChecked = true;
        }
        else {
            elementBox.isSpellChecked = true;
        }
    }
    /**
     * Method to check errors for combined elements
     * @param {TextElementBox} elementBox
     * @param {number} underlineY
     * @private
     */
    // tslint:disable-next-line:max-line-length
    checkElementCanBeCombined(elementBox, underlineY, beforeIndex, callSpellChecker, textToCombine, isNext, isPrevious, canCombine) {
        let currentText = isNullOrUndefined(textToCombine) ? '' : textToCombine;
        let isCombined = isNullOrUndefined(canCombine) ? false : canCombine;
        let checkPrevious = !isNullOrUndefined(isPrevious) ? isPrevious : true;
        let checkNext = !isNullOrUndefined(isNext) ? isNext : true;
        let combinedElements = [];
        let line = this.viewer.selection.getLineWidget(elementBox, 0);
        let index = line.children.indexOf(elementBox);
        let prevText = elementBox.text;
        combinedElements.push(elementBox);
        let difference = (isPrevious) ? 0 : 1;
        let prevCombined = false;
        let isPrevField = false;
        if (elementBox.text !== '\v') {
            if (checkPrevious) {
                let textElement = undefined;
                for (let i = index - difference; i >= 0; i--) {
                    textElement = line.children[i];
                    if (textElement instanceof TextElementBox && !isPrevField) {
                        if (prevText.indexOf(' ') !== 0 && textElement.text.lastIndexOf(' ') !== textElement.text.length - 1) {
                            prevCombined = !isNullOrUndefined(textToCombine) ? true : false;
                            currentText = textElement.text + currentText;
                            prevText = textElement.text;
                            isPrevField = false;
                            combinedElements.push(textElement);
                            isCombined = true;
                        }
                        else if (!isNullOrUndefined(textElement)) {
                            textElement = textElement.nextElement;
                            break;
                        }
                    }
                    else if (textElement instanceof FieldElementBox && textElement.fieldType !== 1) {
                        isPrevField = true;
                    }
                }
                let currentElement = (isCombined) ? textElement : elementBox;
                if (this.lookThroughPreviousLine(currentText, prevText, currentElement, underlineY, beforeIndex)) {
                    return true;
                }
            }
            if (isPrevious) {
                currentText = (prevCombined) ? currentText : elementBox.text + currentText;
            }
            else {
                currentText += elementBox.text;
            }
            isPrevField = false;
            let nextText = elementBox.text;
            if (checkNext) {
                let canCombine = false;
                let element = undefined;
                for (let i = index + 1; i < line.children.length; i++) {
                    element = line.children[i];
                    if (element instanceof TextElementBox && !isPrevField) {
                        if (nextText.lastIndexOf(' ') !== nextText.length - 1 && element.text.indexOf(' ') !== 0) {
                            currentText += element.text;
                            nextText = element.text;
                            isPrevField = false;
                            combinedElements.push(element);
                            canCombine = true;
                            isCombined = true;
                        }
                        else if (!isNullOrUndefined(element)) {
                            element = element.previousElement;
                            break;
                        }
                    }
                    else if (element instanceof FieldElementBox && element.fieldType !== 2) {
                        isPrevField = true;
                    }
                }
                let currentElement = (canCombine) ? element : elementBox;
                // tslint:disable-next-line:max-line-length
                if (currentElement.text !== '\f' && this.lookThroughNextLine(currentText, prevText, currentElement, underlineY, beforeIndex)) {
                    return true;
                }
            }
        }
        if (isCombined && callSpellChecker && !this.checkCombinedElementsBeIgnored(combinedElements, currentText)) {
            this.handleCombinedElements(elementBox, currentText, underlineY, beforeIndex);
        }
        return isCombined;
    }
    // tslint:disable-next-line:max-line-length
    lookThroughPreviousLine(currentText, prevText, currentElement, underlineY, beforeIndex) {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(currentElement) && currentElement.indexInOwner === 0 && !isNullOrUndefined(currentElement.line.previousLine)) {
            let previousLine = currentElement.line.previousLine;
            let index = previousLine.children.length - 1;
            if (!isNullOrUndefined(previousLine.children[index]) && previousLine.children[index] instanceof TextElementBox) {
                let firstElement = previousLine.children[index];
                if (currentElement.text.indexOf(' ') !== 0 && firstElement.text.lastIndexOf(' ') !== firstElement.text.length - 1) {
                    currentText = (currentText.length > 0) ? currentText : prevText;
                    this.checkElementCanBeCombined(firstElement, underlineY, beforeIndex, true, currentText, false, true, true);
                    return true;
                }
            }
        }
        return false;
    }
    // tslint:disable-next-line:max-line-length
    lookThroughNextLine(currentText, prevText, elementBox, underlineY, beforeIndex) {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(elementBox) && elementBox.indexInOwner === elementBox.line.children.length - 1 && !isNullOrUndefined(elementBox.line.nextLine)) {
            let nextLine = elementBox.line.nextLine;
            if (!isNullOrUndefined(nextLine.children[0]) && nextLine.children[0] instanceof TextElementBox) {
                let firstElement = nextLine.children[0];
                if (elementBox.text.lastIndexOf(' ') !== elementBox.text.length - 1 && firstElement.text.indexOf(' ') !== 0) {
                    currentText = (currentText.length > 0) ? currentText : prevText;
                    this.checkElementCanBeCombined(firstElement, underlineY, beforeIndex, true, currentText, true, false, true);
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Method to handle combined elements
     * @param {TextElementBox} elementBox
     * @param {string} currentText
     * @param {number} underlineY
     * @param {number} beforeIndex
     * @private
     */
    handleCombinedElements(elementBox, currentText, underlineY, beforeIndex) {
        elementBox.istextCombined = true;
        let splittedText = currentText.split(/[\s]+/);
        // tslint:disable-next-line:max-line-length
        if (this.ignoreAllItems.indexOf(currentText) === -1 && elementBox instanceof TextElementBox && elementBox.ignoreOnceItems.indexOf(currentText) === -1) {
            if (splittedText.length > 1) {
                for (let i = 0; i < splittedText.length; i++) {
                    let currentText = splittedText[i];
                    currentText = this.manageSpecialCharacters(currentText, undefined, true);
                    // tslint:disable-next-line:max-line-length
                    this.viewer.render.handleUnorderdElements(currentText, elementBox, underlineY, i, 0, i === splittedText.length - 1, beforeIndex);
                }
            }
            else {
                currentText = this.manageSpecialCharacters(currentText, undefined, true);
                this.viewer.render.handleUnorderdElements(currentText, elementBox, underlineY, 0, 0, true, beforeIndex);
            }
        }
    }
    /**
     * Method to check error element collection has unique element
     * @param {ErrorTextElementBox[]} errorCollection
     * @param {ErrorTextElementBox} elementToCheck
     * @private
     */
    CheckArrayHasSameElement(errorCollection, elementToCheck) {
        for (let i = 0; i < errorCollection.length; i++) {
            let errorText = errorCollection[i];
            // tslint:disable-next-line:max-line-length
            if ((errorText.start.location.x === elementToCheck.start.location.x) && (errorText.start.location.y === elementToCheck.start.location.y)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to handle splitted and combined words for spell check.
     * @param {any} jsonObject
     * @param {string} currentText
     * @param {ElementBox} elementBox
     * @param {boolean} isSamePage
     * @private
     */
    // tslint:disable-next-line:max-line-length
    handleSplitWordSpellCheck(jsonObject, currentText, elementBox, isSamePage, underlineY, iteration, markIndex, isLastItem) {
        if (jsonObject.HasSpellingError && elementBox.text !== ' ' && isSamePage) {
            let matchResults = this.getMatchedResultsFromElement(elementBox, currentText);
            // tslint:disable-next-line:max-line-length
            markIndex = (elementBox.istextCombined) ? elementBox.line.getOffset(this.getCombinedElement(elementBox), 0) : markIndex;
            // tslint:disable-next-line:max-line-length
            this.viewer.owner.searchModule.textSearch.updateMatchedTextLocation(matchResults.matches, matchResults.textResults, matchResults.elementInfo, 0, elementBox, false, null, markIndex);
            this.handleMatchedResults(matchResults.textResults, elementBox, underlineY, iteration, jsonObject.Suggestions, isLastItem);
        }
        else if (isLastItem) {
            elementBox.isSpellChecked = true;
        }
    }
    /**
     * Method to include matched results in element box and to render it
     * @param {TextSearchResults} results
     * @param {TextElementBox} elementBox
     * @param {number} wavyLineY
     * @param {number} index
     */
    // tslint:disable-next-line:max-line-length
    handleMatchedResults(results, elementBox, wavyLineY, index, suggestions, isLastItem) {
        if (results.length === 0 && isLastItem) {
            elementBox.isSpellChecked = true;
            return;
        }
        for (let i = 0; i < results.length; i++) {
            let span = this.createErrorElementWithInfo(results.innerList[i], elementBox);
            let color = '#FF0000';
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(elementBox.errorCollection) && !this.CheckArrayHasSameElement(elementBox.errorCollection, span)) {
                elementBox.errorCollection.splice(index, 0, span);
            }
            this.addErrorCollection(span.text, span, suggestions);
            // tslint:disable-next-line:max-line-length
            let backgroundColor = (elementBox.line.paragraph.containerWidget instanceof TableCellWidget) ? elementBox.paragraph.containerWidget.cellFormat.shading.backgroundColor : this.viewer.backgroundColor;
            this.viewer.render.renderWavyline(span, span.start.location.x, span.start.location.y - elementBox.margin.top, wavyLineY, color, 'Single', elementBox.characterFormat.baselineAlignment, backgroundColor);
            if (isLastItem) {
                elementBox.isSpellChecked = true;
            }
        }
    }
    /**
     * Calls the spell checker service
     * @param {number} languageID
     * @param {string} word
     * @param {boolean} checkSpellingAndSuggestion
     * @param {boolean} addWord
     * @private
     */
    /* tslint:disable:no-any */
    // tslint:disable-next-line:max-line-length
    CallSpellChecker(languageID, word, checkSpelling, checkSuggestion, addWord, isByPage) {
        return new Promise((resolve, reject) => {
            if (!isNullOrUndefined(this)) {
                let httpRequest = new XMLHttpRequest();
                // tslint:disable-next-line:max-line-length
                let service = this.viewer.owner.serviceUrl + this.viewer.owner.serverActionSettings.spellCheck;
                service = (isByPage) ? service + 'ByPage' : service;
                httpRequest.open('POST', service, true);
                httpRequest.setRequestHeader('Content-Type', 'application/json');
                this.setCustomHeaders(httpRequest);
                // tslint:disable-next-line:max-line-length
                /* tslint:disable:no-any */
                let spellCheckData = { LanguageID: languageID, TexttoCheck: word, CheckSpelling: checkSpelling, CheckSuggestion: checkSuggestion, AddWord: addWord };
                httpRequest.send(JSON.stringify(spellCheckData));
                httpRequest.onreadystatechange = () => {
                    if (httpRequest.readyState === 4) {
                        if (httpRequest.status === 200 || httpRequest.status === 304) {
                            resolve(httpRequest.response);
                        }
                        else {
                            reject(httpRequest.response);
                        }
                    }
                };
            }
        });
    }
    setCustomHeaders(httpRequest) {
        for (let i = 0; i < this.viewer.owner.headers.length; i++) {
            let header = this.viewer.owner.headers[i];
            for (let key of Object.keys(header)) {
                httpRequest.setRequestHeader(key, header[key]);
            }
        }
    }
    /**
     * Method to check for next error
     * @private
     */
    checkForNextError() {
        if (!isNullOrUndefined(this.viewer)) {
            let errorWords = this.errorWordCollection;
            if (errorWords.length > 0) {
                for (let i = 0; i < errorWords.length; i++) {
                    let errorElements = errorWords.get(errorWords.keys[i]);
                    for (let j = 0; j < errorElements.length; j++) {
                        if (errorElements[j] instanceof ErrorTextElementBox && !errorElements[j].ischangeDetected) {
                            this.updateErrorElementTextBox(errorWords.keys[i], errorElements[j]);
                        }
                        else if (errorElements[j] instanceof TextElementBox) {
                            let matchResults = this.getMatchedResultsFromElement(errorElements[j]);
                            let results = matchResults.textResults;
                            // tslint:disable-next-line:max-line-length
                            let markIndex = (errorElements[j].ischangeDetected) ? errorElements[j].start.offset : errorElements[j].line.getOffset(errorElements[j], 0);
                            // tslint:disable-next-line:max-line-length
                            this.viewer.owner.searchModule.textSearch.updateMatchedTextLocation(matchResults.matches, results, matchResults.elementInfo, 0, errorElements[j], false, null, markIndex);
                            for (let i = 0; i < results.length; i++) {
                                let element = this.createErrorElementWithInfo(results.innerList[i], errorElements[j]);
                                this.updateErrorElementTextBox(element.text, element);
                                break;
                            }
                        }
                        break;
                    }
                    break;
                }
            }
            else {
                this.viewer.clearSelectionHighlight();
            }
        }
    }
    /**
     * Method to create error element with matched results
     * @param {TextSearchResult} result
     * @param {ElementBox} errorElement
     * @private
     */
    createErrorElementWithInfo(result, errorElement) {
        let element = new ErrorTextElementBox();
        element.text = result.text;
        element.start = result.start;
        element.end = result.end;
        element.height = errorElement.height;
        element.canTrigger = errorElement.canTrigger;
        element.characterFormat.copyFormat(errorElement.characterFormat);
        element.width = this.viewer.textHelper.getWidth(element.text, errorElement.characterFormat);
        return element;
    }
    /**
     * Method to get matched results from element box
     * @param {ElementBox} errorElement
     * @private
     */
    getMatchedResultsFromElement(errorElement, currentText) {
        let line = errorElement.line;
        // tslint:disable-next-line:max-line-length
        let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex((isNullOrUndefined(currentText)) ? errorElement.text : currentText, 'CaseSensitive');
        this.viewer.owner.searchModule.textSearchResults.clearResults();
        // tslint:disable-next-line:max-line-length
        let results = this.viewer.owner.searchModule.textSearchResults;
        let textLineInfo = this.viewer.owner.searchModule.textSearch.getElementInfo(line.children[0], 0, false);
        let text = textLineInfo.fullText;
        let matches = [];
        let spans = textLineInfo.elementsWithOffset;
        let matchObject;
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchObject = pattern.exec(text))) {
            matches.push(matchObject);
        }
        return { 'matches': matches, 'elementInfo': spans, 'textResults': results };
    }
    /**
     * Method to update error element information
     * @param {string} error
     * @param {ErrorTextElementBox} errorElement
     * @private
     */
    updateErrorElementTextBox(error, errorElement) {
        let element = errorElement;
        this.viewer.clearSelectionHighlight();
        this.viewer.selection.start = element.start;
        this.viewer.selection.end = element.end;
        this.viewer.selection.highlight(errorElement.start.paragraph, errorElement.start, errorElement.end);
        this.viewer.owner.spellCheckDialog.updateSuggestionDialog(error, element);
    }
    /**
     * Method to retrieve space information in a text
     * @param {string} text
     * @param {WCharacterFormat} characterFormat
     * @private
     */
    getWhiteSpaceCharacterInfo(text, characterFormat) {
        /* tslint:disable:no-any */
        let matchedText = [];
        let width = 0;
        let length = 0;
        matchedText = text.match(/[\s]+/);
        if (!isNullOrUndefined(matchedText) && matchedText.length > 0) {
            for (let i = 0; i < matchedText.length; i++) {
                width += this.viewer.textHelper.getWidth(matchedText[i], characterFormat);
                length += matchedText[i].length;
            }
        }
        return { 'width': width, 'wordLength': length, 'isBeginning': (!isNullOrUndefined(matchedText) && matchedText.index === 0) };
    }
    /**
     * Retrieve Special character info
     * @param {string} text
     * @param {WCharacterFormat} characterFormat
     * @private
     */
    getSpecialCharactersInfo(text, characterFormat) {
        /* tslint:disable:no-any */
        let matchedText = [];
        let beginingwidth = 0;
        let endWidth = 0;
        let length = 0;
        matchedText = text.match(/^[\#\@\!\~\$\%\^\&\*\(\)\-\_\+\=\{\}\[\]\:\;\"\'\,\<\.\>\/\?\`]*/);
        for (let i = 0; i < matchedText.length; i++) {
            if (!isNullOrUndefined(matchedText[i]) && matchedText[i].length > 0) {
                beginingwidth = this.viewer.textHelper.getWidth(matchedText[i], characterFormat);
            }
            length = matchedText.length;
        }
        matchedText = text.match(/[\#\@\!\~\$\%\^\&\*\(\)\-\_\+\=\{\}\[\]\:\;\"\'\,\<\.\>\/\?\`]*$/);
        for (let i = 0; i < matchedText.length; i++) {
            if (!isNullOrUndefined(matchedText[i]) && matchedText[i].length > 0) {
                endWidth = this.viewer.textHelper.getWidth(matchedText[i], characterFormat);
            }
            length = matchedText.length;
        }
        return { 'beginningWidth': beginingwidth, 'endWidth': endWidth, 'wordLength': length };
    }
    /**
     * Method to retrieve next available combined element
     * @param {ElementBox} element
     * @private
     */
    getCombinedElement(element) {
        let prevElement = element;
        while (!isNullOrUndefined(element) && element instanceof TextElementBox && element.istextCombined) {
            prevElement = element;
            element = element.previousElement;
        }
        return prevElement;
    }
    /**
     * Method to retrieve next available combined element
     * @param {ElementBox} element
     */
    checkCombinedElementsBeIgnored(elements, exactText) {
        exactText = this.manageSpecialCharacters(exactText, undefined, true);
        for (let i = 0; i < elements.length; i++) {
            if (elements[i].ignoreOnceItems.indexOf(exactText) !== -1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to update error collection
     * @param {TextElementBox} currentElement
     * @param {TextElementBox} splittedElement
     * @private
     */
    updateSplittedElementError(currentElement, splittedElement) {
        let errorCount = currentElement.errorCollection.length;
        if (errorCount > 0) {
            let errorCollection = [];
            for (let i = 0; i < errorCount; i++) {
                errorCollection.push(currentElement.errorCollection[i]);
            }
            for (let i = 0; i < errorCount; i++) {
                if (currentElement.text.indexOf(errorCollection[i].text) === -1) {
                    splittedElement.ischangeDetected = true;
                    currentElement.errorCollection.splice(0, 1);
                }
            }
        }
    }
    /**
     * @private
     */
    getPageContent(page) {
        let content = '';
        if (this.viewer.owner.sfdtExportModule) {
            let sfdtExport = this.viewer.owner.sfdtExportModule;
            sfdtExport.Initialize();
            let document = sfdtExport.writePage(page);
            if (this.viewer.owner.textExportModule) {
                let textExport = this.viewer.owner.textExportModule;
                textExport.pageContent = '';
                textExport.setDocument(document);
                textExport.writeInternal();
                content = textExport.pageContent;
            }
        }
        return content;
    }
    /**
     * @private
     * @param spelledWords
     */
    updateUniqueWords(spelledWords) {
        if (!isNullOrUndefined(localStorage.getItem(this.uniqueKey))) {
            this.uniqueSpelledWords = JSON.parse(localStorage.getItem(this.uniqueKey));
        }
        let totalCount = spelledWords.length + this.uniqueSpelledWords.length;
        if (totalCount <= this.uniqueWordsCount) {
            for (let i = 0; i < spelledWords.length; i++) {
                this.checkForUniqueWords(spelledWords[i]);
            }
        }
        localStorage.setItem(this.uniqueKey, JSON.stringify(this.uniqueSpelledWords));
        this.uniqueSpelledWords = [];
    }
    checkForUniqueWords(spellData) {
        let identityMatched = false;
        for (let i = 0; i < this.uniqueSpelledWords.length; i++) {
            if (this.uniqueSpelledWords[i].Text === spellData.Text) {
                identityMatched = true;
                break;
            }
        }
        if (!identityMatched) {
            this.uniqueSpelledWords.push(spellData);
        }
    }
    /**
     * Method to clear cached words for spell check
     */
    clearCache() {
        if (!isNullOrUndefined(localStorage.getItem(this.uniqueKey))) {
            localStorage.removeItem(this.uniqueKey);
        }
    }
    /**
     * Method to create GUID
     */
    createGuid() {
        let dateTime = new Date().getTime();
        let uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (char) => {
            let randNo = (dateTime + Math.random() * 16) % 16 | 0;
            dateTime = Math.floor(dateTime / 16);
            return (char === 'x' ? randNo : (randNo & 0x3 | 0x8)).toString(16);
        });
        return uuid;
    }
    /**
     * Check spelling in page data
     * @private
     * @param {string} wordToCheck
     */
    checkSpellingInPageInfo(wordToCheck) {
        let hasError = false;
        let elementPresent = false;
        /* tslint:disable:no-any */
        let uniqueWords = JSON.parse(localStorage.getItem(this.viewer.owner.spellChecker.uniqueKey));
        if (!isNullOrUndefined(uniqueWords)) {
            for (let i = 0; i < uniqueWords.length; i++) {
                if (uniqueWords[i].Text === wordToCheck) {
                    return { hasSpellError: uniqueWords[i].HasSpellError, isElementPresent: true };
                }
            }
        }
        return { hasSpellError: hasError, isElementPresent: elementPresent };
    }
    /**
     * @private
     */
    destroy() {
        this.errorWordCollection = undefined;
        this.ignoreAllItems = undefined;
        this.errorSuggestions = undefined;
        this.uniqueSpelledWords = [];
        if (!isNullOrUndefined(localStorage.getItem(this.uniqueKey))) {
            localStorage.removeItem(this.uniqueKey);
        }
    }
}

/**
 * Spell check dialog
 */
class SpellCheckDialog {
    constructor(viewer) {
        /* tslint:disable:no-any */
        this.selectHandler = (args) => {
            this.selectedText = args.text;
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.clearSelectionHighlight();
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.onIgnoreClicked = () => {
            if (!isNullOrUndefined(this.elementBox)) {
                showSpinner(this.owner.dialog.element);
                this.parent.spellChecker.manageReplace('Ignore Once', this.elementBox);
                this.removeErrors();
                this.parent.spellChecker.checkForNextError();
            }
        };
        /**
         * @private
         */
        this.onIgnoreAllClicked = () => {
            if (!isNullOrUndefined(this.elementBox)) {
                showSpinner(this.owner.dialog.element);
                let text = this.elementBox.text;
                this.parent.spellChecker.handleIgnoreAllItems({ element: this.elementBox, text: text });
                this.parent.spellChecker.checkForNextError();
            }
        };
        /**
         * @private
         */
        this.addToDictClicked = () => {
            if (!isNullOrUndefined(this.elementBox)) {
                showSpinner(this.owner.dialog.element);
                // tslint:disable-next-line:max-line-length
                this.parent.spellChecker.handleAddToDictionary({ element: this.elementBox, text: this.elementBox.text });
                if (this.parent.spellChecker.errorWordCollection.containsKey(this.errorText)) {
                    this.parent.spellChecker.errorWordCollection.remove(this.errorText);
                }
                this.parent.spellChecker.checkForNextError();
            }
        };
        /**
         * @private
         */
        this.changeButtonClicked = () => {
            if (!isNullOrUndefined(this.selectedText)) {
                this.isSpellChecking = true;
                showSpinner(this.owner.dialog.element);
                this.parent.spellChecker.manageReplace(this.selectedText, this.elementBox);
                this.removeErrors();
                this.parent.spellChecker.checkForNextError();
                this.owner.dialog.content = '';
            }
        };
        /**
         * @private
         */
        this.changeAllButtonClicked = () => {
            if (!isNullOrUndefined(this.selectedText)) {
                this.isSpellChecking = true;
                showSpinner(this.owner.dialog.element);
                let elements = this.parent.spellChecker.errorWordCollection.get(this.errorText);
                for (let i = 0; i < elements.length; i++) {
                    if (elements[i] instanceof ErrorTextElementBox && !elements[i].ischangeDetected) {
                        this.parent.spellChecker.manageReplace(this.selectedText, elements[i]);
                    }
                    else if (elements[i] instanceof TextElementBox) {
                        let matchResults = this.parent.spellChecker.getMatchedResultsFromElement(elements[i]);
                        let results = matchResults.textResults;
                        // tslint:disable-next-line:max-line-length
                        let markIndex = (elements[i].ischangeDetected) ? elements[i].start.offset : elements[i].line.getOffset(elements[i], 0);
                        // tslint:disable-next-line:max-line-length
                        this.parent.searchModule.textSearch.updateMatchedTextLocation(matchResults.matches, results, matchResults.elementInfo, 0, elements[i], false, null, markIndex);
                        for (let j = 0; j < results.length; j++) {
                            let element = this.parent.spellChecker.createErrorElementWithInfo(results.innerList[j], elements[i]);
                            this.parent.spellChecker.manageReplace(this.selectedText, element);
                        }
                    }
                }
                if (this.parent.spellChecker.errorWordCollection.containsKey(this.errorText)) {
                    this.parent.spellChecker.errorWordCollection.remove(this.errorText);
                }
                this.parent.spellChecker.checkForNextError();
                this.owner.dialog.content = '';
            }
        };
        this.owner = viewer;
        createSpinner({ target: this.owner.dialog.element, cssClass: 'e-spin-overlay' });
    }
    /**
     * Gets the spell checker
     * @private
     */
    get parent() {
        return this.owner.owner;
    }
    getModuleName() {
        return 'SpellCheckDialog';
    }
    /**
     * Method to remove errors
     */
    removeErrors() {
        if (!isNullOrUndefined(this.errorText) && this.parent.spellChecker.errorWordCollection.containsKey(this.errorText)) {
            let textElement = this.parent.spellChecker.errorWordCollection.get(this.errorText);
            textElement.splice(0, 1);
            if (textElement.length === 0) {
                this.parent.spellChecker.errorWordCollection.remove(this.errorText);
            }
        }
        if (this.parent.spellChecker.errorWordCollection.length === 0) {
            this.owner.dialog.hide();
        }
    }
    /**
     * @private
     */
    show(error, elementbox, callSpellChecker) {
        this.target = undefined;
        this.localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.updateSuggestionDialog(error, elementbox, callSpellChecker);
        }
    }
    /**
     * @private
     */
    updateSuggestionDialog(error, elementBox, callSpellChecker) {
        this.elementBox = elementBox;
        let suggestions;
        if (this.isSpellChecking) {
            // tslint:disable-next-line:max-line-length
            /* tslint:disable:no-any */
            this.parent.spellChecker.CallSpellChecker(this.parent.spellChecker.languageID, error, false, true).then((data) => {
                /* tslint:disable:no-any */
                let jsonObject = JSON.parse(data);
                suggestions = jsonObject.Suggestions;
                this.isSpellChecking = false;
                this.handleRetrievedSuggestion(error, suggestions);
            });
        }
        else {
            error = this.parent.spellChecker.manageSpecialCharacters(error, undefined, true);
            // tslint:disable-next-line:max-line-length
            suggestions = this.parent.spellChecker.errorSuggestions.containsKey(error) ? this.parent.spellChecker.errorSuggestions.get(error) : [];
            this.handleRetrievedSuggestion(error, suggestions);
        }
    }
    /**
     * Method to handle retrieved suggestions from server side
     * @param {string} error
     * @param {any} jsonObject
     */
    /* tslint:disable:no-any */
    handleRetrievedSuggestion(error, suggestions) {
        error = this.parent.spellChecker.manageSpecialCharacters(error, undefined, true);
        this.initSpellCheckDialog(this.localValue, error, suggestions);
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog.header = 'Spelling Editor';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.onCancelButtonClick,
                buttonModel: { content: this.localValue.getConstant('Cancel'), cssClass: 'e-control e-flat', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
        hideSpinner(this.owner.dialog.element);
    }
    /**
     * @private
     */
    initSpellCheckDialog(localValue, error, suggestion) {
        let id = this.owner.owner.containerId + '_add_SpellCheck';
        this.target = createElement('div', { id: id, className: 'e-de-insert-spellchecker' });
        this.errorText = error;
        let textContainer = createElement('div', {
            className: 'e-de-dlg-spellchecker-subheader', innerHTML: localValue.getConstant('Spelling')
        });
        this.target.appendChild(textContainer);
        let spellContainer = createElement('div', { className: 'e-de-spellcheck-error-container' });
        let listviewDiv = createElement('div', { className: 'e-de-dlg-spellcheck-listview', id: 'styles_listview' });
        spellContainer.appendChild(listviewDiv);
        this.spellingListView = new ListView({
            dataSource: [error],
            cssClass: 'e-dlg-spellcheck-listitem',
        });
        this.spellingListView.appendTo(listviewDiv);
        let buttonDiv = createElement('div', { className: 'e-de-spellcheck-btncontainer' });
        spellContainer.appendChild(buttonDiv);
        let ignoreButtonElement = createElement('button', { innerHTML: localValue.getConstant('Ignore'), id: 'ignore' });
        buttonDiv.appendChild(ignoreButtonElement);
        let ignorebutton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        ignorebutton.appendTo(ignoreButtonElement);
        ignoreButtonElement.addEventListener('click', this.onIgnoreClicked);
        let ignoreAllButtonElement = createElement('button', { innerHTML: localValue.getConstant('Ignore all'), id: 'new' });
        buttonDiv.appendChild(ignoreAllButtonElement);
        let ignoreAllbutton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        ignoreAllbutton.appendTo(ignoreAllButtonElement);
        ignoreAllButtonElement.addEventListener('click', this.onIgnoreAllClicked);
        // tslint:disable-next-line:max-line-length
        let addDictButtonElement = createElement('button', { innerHTML: localValue.getConstant('Add to Dictionary'), id: 'new' });
        buttonDiv.appendChild(addDictButtonElement);
        let addDictButton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        addDictButton.appendTo(addDictButtonElement);
        addDictButtonElement.addEventListener('click', this.addToDictClicked);
        this.target.appendChild(spellContainer);
        let suggestionDiv = createElement('div', {
            className: 'e-de-dlg-spellchecker-subheaderbtm', innerHTML: localValue.getConstant('Suggestions')
        });
        this.target.appendChild(suggestionDiv);
        let suggestionContainer = createElement('div', { className: 'e-de-spellcheck-suggestion-container' });
        this.target.appendChild(suggestionContainer);
        let suggestListDiv = createElement('div', { className: 'e-de-dlg-spellcheck-listview' });
        suggestionContainer.appendChild(suggestListDiv);
        this.suggestionListView = new ListView({
            dataSource: suggestion,
            cssClass: 'e-dlg-spellcheck-listitem',
        });
        this.suggestionListView.appendTo(suggestListDiv);
        this.suggestionListView.addEventListener('select', this.selectHandler);
        let suggestBtnContainder = createElement('div', { className: 'e-de-spellcheck-btncontainer' });
        suggestionContainer.appendChild(suggestBtnContainder);
        let changeButtonElement = createElement('button', { innerHTML: localValue.getConstant('Change'), id: 'Change' });
        suggestBtnContainder.appendChild(changeButtonElement);
        let changeButton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        changeButton.appendTo(changeButtonElement);
        changeButtonElement.addEventListener('click', this.changeButtonClicked);
        // tslint:disable-next-line:max-line-length
        let changeAllButtonElement = createElement('button', { innerHTML: localValue.getConstant('Change All'), id: 'Change All' });
        suggestBtnContainder.appendChild(changeAllButtonElement);
        let changeAllbutton = new Button({ cssClass: 'e-de-spellcheck-btn' });
        changeAllbutton.appendTo(changeAllButtonElement);
        changeAllButtonElement.addEventListener('click', this.changeAllButtonClicked);
        if (isNullOrUndefined(suggestion) || suggestion.length === 0) {
            changeButton.disabled = true;
            changeAllbutton.disabled = true;
        }
    }
    /**
     * @private
     */
    destroy() {
        if (this.target) {
            this.target.remove();
            this.target = undefined;
        }
        if (this.spellingListView) {
            this.spellingListView.destroy();
            this.spellingListView = undefined;
        }
        if (this.suggestionListView) {
            this.suggestionListView.destroy();
            this.suggestionListView = undefined;
        }
    }
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var DocumentEditor_1;
// tslint:disable-next-line:max-line-length
/**
 * The Document editor component is used to draft, save or print rich text contents as page by page.
 */
let DocumentEditor = DocumentEditor_1 = class DocumentEditor extends Component {
    /**
     * Initialize the constructor of DocumentEditor
     */
    constructor(options, element) {
        super(options, element);
        //Internal Variable
        this.enableHeaderFooterIn = false;
        /**
         * @private
         */
        this.isShiftingEnabled = false;
        /**
         * @private
         */
        this.isLayoutEnabled = true;
        /**
         * @private
         */
        this.isPastingContent = false;
        /**
         * @private
         */
        this.parser = undefined;
        this.disableHistoryIn = false;
        /**
         * @private
         */
        this.findResultsList = undefined;
        /**
         * @private
         */
        this.tablePropertiesDialogModule = undefined;
        /**
         * @private
         */
        this.bordersAndShadingDialogModule = undefined;
        /**
         * @private
         */
        this.cellOptionsDialogModule = undefined;
        /**
         * @private
         */
        this.tableOptionsDialogModule = undefined;
        /**
         * @private
         */
        this.paragraphDialogModule = undefined;
        /**
         * @private
         */
        this.imageResizerModule = undefined;
        /**
         * @private
         */
        this.defaultLocale = {
            'Table': 'Table',
            'Row': 'Row',
            'Cell': 'Cell',
            'Ok': 'Ok',
            'Cancel': 'Cancel',
            'Size': 'Size',
            'Preferred Width': 'Preferred width',
            'Points': 'Points',
            'Percent': 'Percent',
            'Measure in': 'Measure in',
            'Alignment': 'Alignment',
            'Left': 'Left',
            'Center': 'Center',
            'Right': 'Right',
            'Justify': 'Justify',
            'Indent from left': 'Indent from left',
            'Borders and Shading': 'Borders and Shading',
            'Options': 'Options',
            'Specify height': 'Specify height',
            'At least': 'At least',
            'Exactly': 'Exactly',
            'Row height is': 'Row height is',
            'Allow row to break across pages': 'Allow row to break across pages',
            'Repeat as header row at the top of each page': 'Repeat as header row at the top of each page',
            'Vertical alignment': 'Vertical alignment',
            'Top': 'Top',
            'Bottom': 'Bottom',
            'Default cell margins': 'Default cell margins',
            'Default cell spacing': 'Default cell spacing',
            'Allow spacing between cells': 'Allow spacing between cells',
            'Cell margins': 'Cell margins',
            'Same as the whole table': 'Same as the whole table',
            'Borders': 'Borders',
            'None': 'None',
            'Style': 'Style',
            'Width': 'Width',
            'Height': 'Height',
            'Letter': 'Letter',
            'Tabloid': 'Tabloid',
            'Legal': 'Legal',
            'Statement': 'Statement',
            'Executive': 'Executive',
            'A3': 'A3',
            'A4': 'A4',
            'A5': 'A5',
            'B4': 'B4',
            'B5': 'B5',
            'Custom Size': 'Custom size',
            'Different odd and even': 'Different odd and even',
            'Different first page': 'Different first page',
            'From edge': 'From edge',
            'Header': 'Header',
            'Footer': 'Footer',
            'Margin': 'Margins',
            'Paper': 'Paper',
            'Layout': 'Layout',
            'Orientation': 'Orientation',
            'Landscape': 'Landscape',
            'Portrait': 'Portrait',
            'Show page numbers': 'Show page numbers',
            'Right align page numbers': 'Right align page numbers',
            'Nothing': 'Nothing',
            'Tab leader': 'Tab leader',
            'Show levels': 'Show levels',
            'Use hyperlinks instead of page numbers': 'Use hyperlinks instead of page numbers',
            'Build table of contents from': 'Build table of contents from',
            'Styles': 'Styles',
            'Available styles': 'Available styles',
            'TOC level': 'TOC level',
            'Heading': 'Heading',
            'Heading 1': 'Heading 1',
            'Heading 2': 'Heading 2',
            'Heading 3': 'Heading 3',
            'Heading 4': 'Heading 4',
            'Heading 5': 'Heading 5',
            'Heading 6': 'Heading 6',
            'List Paragraph': 'List Paragraph',
            'Normal': 'Normal',
            'Outline levels': 'Outline levels',
            'Table entry fields': 'Table entry fields',
            'Modify': 'Modify',
            'Color': 'Color',
            'Setting': 'Setting',
            'Box': 'Box',
            'All': 'All',
            'Custom': 'Custom',
            'Preview': 'Preview',
            'Shading': 'Shading',
            'Fill': 'Fill',
            'Apply To': 'Apply to',
            'Table Properties': 'Table Properties',
            'Cell Options': 'Cell Options',
            'Table Options': 'Table Options',
            'Insert Table': 'Insert Table',
            'Number of columns': 'Number of columns',
            'Number of rows': 'Number of rows',
            'Text to display': 'Text to display',
            'Address': 'Address',
            'Insert Hyperlink': 'Insert Hyperlink',
            'Edit Hyperlink': 'Edit Hyperlink',
            'Insert': 'Insert',
            'General': 'General',
            'Indentation': 'Indentation',
            'Before text': 'Before text',
            'Special': 'Special',
            'First line': 'First line',
            'Hanging': 'Hanging',
            'After text': 'After text',
            'By': 'By',
            'Before': 'Before',
            'Line Spacing': 'Line spacing',
            'After': 'After',
            'At': 'At',
            'Multiple': 'Multiple',
            'Spacing': 'Spacing',
            'Define new Multilevel list': 'Define new Multilevel list',
            'List level': 'List level',
            'Choose level to modify': 'Choose level to modify',
            'Level': 'Level',
            'Number format': 'Number format',
            'Number style for this level': 'Number style for this level',
            'Enter formatting for number': 'Enter formatting for number',
            'Start at': 'Start at',
            'Restart list after': 'Restart list after',
            'Position': 'Position',
            'Text indent at': 'Text indent at',
            'Aligned at': 'Aligned at',
            'Follow number with': 'Follow number with',
            'Tab character': 'Tab character',
            'Space': 'Space',
            'Arabic': 'Arabic',
            'UpRoman': 'UpRoman',
            'LowRoman': 'LowRoman',
            'UpLetter': 'UpLetter',
            'LowLetter': 'LowLetter',
            'Number': 'Number',
            'Leading zero': 'Leading zero',
            'Bullet': 'Bullet',
            'Ordinal': 'Ordinal',
            'Ordinal Text': 'Ordinal Text',
            'For East': 'For East',
            'No Restart': 'No Restart',
            'Font': 'Font',
            'Font style': 'Font style',
            'Underline style': 'Underline style',
            'Font color': 'Font color',
            'Effects': 'Effects',
            'Strikethrough': 'Strikethrough',
            'Superscript': 'Superscript',
            'Subscript': 'Subscript',
            'Double strikethrough': 'Double strikethrough',
            'Regular': 'Regular',
            'Bold': 'Bold',
            'Italic': 'Italic',
            'Cut': 'Cut',
            'Copy': 'Copy',
            'Paste': 'Paste',
            'Hyperlink': 'Hyperlink',
            'Open Hyperlink': 'Open Hyperlink',
            'Copy Hyperlink': 'Copy Hyperlink',
            'Remove Hyperlink': 'Remove Hyperlink',
            'Paragraph': 'Paragraph',
            'Linked(Paragraph and Character)': 'Linked(Paragraph and Character)',
            'Character': 'Character',
            'Merge Cells': 'Merge Cells',
            'Insert Above': 'Insert Above',
            'Insert Below': 'Insert Below',
            'Insert Left': 'Insert Left',
            'Insert Right': 'Insert Right',
            'Delete': 'Delete',
            'Delete Table': 'Delete Table',
            'Delete Row': 'Delete Row',
            'Delete Column': 'Delete Column',
            'File Name': 'File Name',
            'Format Type': 'Format Type',
            'Save': 'Save',
            'Navigation': 'Navigation',
            'Results': 'Results',
            'Replace': 'Replace',
            'Replace All': 'Replace All',
            'We replaced all': 'We replaced all',
            'Find': 'Find',
            'No matches': 'No matches',
            'All Done': 'All Done',
            'Result': 'Result',
            'of': 'of',
            'instances': 'instances',
            'with': 'with',
            'Click to follow link': 'Click to follow link',
            'Continue Numbering': 'Continue Numbering',
            'Bookmark name': 'Bookmark name',
            'Close': 'Close',
            'Restart At': 'Restart At',
            'Properties': 'Properties',
            'Name': 'Name',
            'Style type': 'Style type',
            'Style based on': 'Style based on',
            'Style for following paragraph': 'Style for following paragraph',
            'Formatting': 'Formatting',
            'Numbering and Bullets': 'Numbering and Bullets',
            'Numbering': 'Numbering',
            'Update Field': 'Update Field',
            'Edit Field': 'Edit Field',
            'Bookmark': 'Bookmark',
            'Page Setup': 'Page Setup',
            'No bookmarks found': 'No bookmarks found',
            'Number format tooltip information': 'Single-level number format: </br>[PREFIX]%[LEVELNUMBER][SUFFIX]</br>'
                + 'For example, "Chapter %1." will display numbering like</br>Chapter 1. Item</br>Chapter 2. Item</br>…'
                + '</br>Chapter N. Item</br>'
                + '</br>Multilevel number format:</br>[PREFIX]%[LEVELNUMBER][SUFFIX]+[PREFIX]%[LEVELNUMBER][SUFFIX]'
                + '</br>For example, "%1.%2." will display numbering like</br>1.1. Item</br>1.2. Item</br>…</br>1.N. Item',
            'Format': 'Format',
            'Create New Style': 'Create New Style',
            'Modify Style': 'Modify Style',
            'New': 'New',
            'Bullets': 'Bullets',
            'Use bookmarks': 'Use bookmarks',
            'Table of Contents': 'Table of Contents',
            'AutoFit': 'AutoFit',
            'AutoFit to Contents': 'AutoFit to Contents',
            'AutoFit to Window': 'AutoFit to Window',
            'Fixed Column Width': 'Fixed Column Width',
            'Reset': 'Reset',
            'Match case': 'Match case',
            'Whole words': 'Whole words',
            'Add': 'Add',
            'Go To': 'Go To',
            'Search for': 'Search for',
            'Replace with': 'Replace with',
            'TOC 1': 'TOC 1',
            'TOC 2': 'TOC 2',
            'TOC 3': 'TOC 3',
            'TOC 4': 'TOC 4',
            'TOC 5': 'TOC 5',
            'TOC 6': 'TOC 6',
            'TOC 7': 'TOC 7',
            'TOC 8': 'TOC 8',
            'TOC 9': 'TOC 9',
            'Right-to-left': 'Right-to-left',
            'Left-to-right': 'Left-to-right',
            'Direction': 'Direction',
            'Table direction': 'Table direction',
            'Indent from right': 'Indent from right',
            /* tslint:disable */
            "Don't add space between the paragraphs of the same styles": "Don't add space between the paragraphs of the same styles",
            "The password don't match": "The password don't match",
            /* tslint:enable */
            'Restrict Editing': 'Restrict Editing',
            'Formatting restrictions': 'Formatting restrictions',
            'Allow formatting': 'Allow formatting',
            'Editing restrictions': 'Editing restrictions',
            'Read only': 'Read only',
            'Exceptions (optional)': 'Exceptions (optional)',
            // tslint:disable-next-line:max-line-length
            'Select parts of the document and choose users who are allowed to freely edit them.': 'Select parts of the document and choose users who are allowed to freely edit them.',
            'Everyone': 'Everyone',
            'More users': 'More users',
            'Add Users': 'Add Users',
            'Yes, Start Enforcing Protection': 'Yes, Start Enforcing Protection',
            'Start Enforcing Protection': 'Start Enforcing Protection',
            'Enter User': 'Enter User',
            'Users': 'Users',
            'Enter new password': 'Enter new password',
            'Reenter new password to confirm': 'Reenter new password to confirm',
            'Your permissions': 'Your permissions',
            // tslint:disable-next-line:max-line-length
            'This document is protected from unintentional editing.You may edit in this region.': 'This document is protected from unintentional editing.You may edit in this region.',
            'You may format text only with certain styles.': 'You may format text only with certain styles.',
            'Stop Protection': 'Stop Protection',
            'Password': 'Password',
            'Spelling Editor': 'Spelling Editor',
            'Spelling': 'Spelling',
            'Spell Check': 'Spell Check',
            'Underline errors': 'Underline errors',
            'Ignore': 'Ignore',
            'Ignore all': 'Ignore All',
            'Add to Dictionary': 'Add to Dictionary',
            'Change': 'Change',
            'Change All': 'Change All',
            'Suggestions': 'Suggestions',
            'The password is incorrect': 'The password is incorrect',
            'Error in establishing connection with web server': 'Error in establishing connection with web server',
            'Highlight the regions I can edit': 'Highlight the regions I can edit',
            'Show All Regions I Can Edit': 'Show All Regions I Can Edit',
            'Find Next Region I Can Edit': 'Find Next Region I Can Edit',
            'Keep source formatting': 'Keep source formatting',
            'Match destination formatting': 'Match destination formatting',
            'Text only': 'Text only',
            'Comments': 'Comments',
            'Type your comment': 'Type your comment',
            'Post': 'Post',
            'Reply': 'Reply',
            'New Comment': 'New Comment',
            'Edit': 'Edit',
            'Resolve': 'Resolve',
            'Reopen': 'Reopen',
            'No comments in this document': 'No comments in this document',
            'more': 'more',
            'Type your comment hear': 'Type your comment hear',
            'Next Comment': 'Next Comment',
            'Previous Comment': 'Previous Comment',
            'Un-posted comments': 'Un-posted comments',
            // tslint:disable-next-line:max-line-length
            'Added comments not posted. If you continue, that comment will be discarded.': 'Added comments not posted. If you continue, that comment will be discarded.'
        };
        this.viewer = new PageLayoutViewer(this);
        this.parser = new SfdtReader(this.viewer);
    }
    /**
     * @private
     */
    get enableHeaderAndFooter() {
        return this.enableHeaderFooterIn;
    }
    set enableHeaderAndFooter(value) {
        this.enableHeaderFooterIn = value;
        this.viewer.updateScrollBars();
    }
    /**
     * Gets the total number of pages.
     * @returns {number}
     */
    get pageCount() {
        if (!this.isDocumentLoaded || isNullOrUndefined(this.viewer)) {
            return 1;
        }
        return this.viewer.pages.length;
    }
    /**
     *  Gets the selection object of the document editor.
     * @aspType Selection
     * @blazorType Selection
     * @returns {Selection}
     * @default undefined
     */
    get selection() {
        return this.selectionModule;
    }
    /**
     *  Gets the editor object of the document editor.
     * @aspType Editor
     * @blazorType Editor
     * @returns {Editor}
     * @default undefined
     */
    get editor() {
        return this.editorModule;
    }
    /**
     * Gets the editor history object of the document editor.
     * @aspType EditorHistory
     * @blazorType EditorHistory
     * @returns {EditorHistory}
     */
    get editorHistory() {
        return this.editorHistoryModule;
    }
    /**
     * Gets the search object of the document editor.
     * @aspType Search
     * @blazorType Search
     * @returns { Search }
     */
    get search() {
        return this.searchModule;
    }
    /**
     * Gets the context menu object of the document editor.
     * @aspType ContextMenu
     * @blazorType ContextMenu
     * @returns {ContextMenu}
     */
    get contextMenu() {
        return this.contextMenuModule;
    }
    /**
     * Gets the spell check dialog object of the document editor.
     * @returns SpellCheckDialog
     */
    get spellCheckDialog() {
        return this.spellCheckDialogModule;
    }
    /**
     * Gets the spell check object of the document editor.
     * @aspType SpellChecker
     * @blazorType SpellChecker
     * @returns SpellChecker
     */
    get spellChecker() {
        return this.spellCheckerModule;
    }
    /**
     * @private
     */
    get containerId() {
        return this.element.id;
    }
    /**
     * @private
     */
    get isDocumentLoaded() {
        return this.isDocumentLoadedIn;
    }
    set isDocumentLoaded(value) {
        this.isDocumentLoadedIn = value;
    }
    /**
     * Determines whether history needs to be enabled or not.
     * @default - false
     * @private
     */
    get enableHistoryMode() {
        return this.enableEditorHistory && !isNullOrUndefined(this.editorHistoryModule);
    }
    /**
     * Gets the start text position in the document.
     * @default undefined
     * @private
     */
    get documentStart() {
        if (!isNullOrUndefined(this.selectionModule)) {
            return this.selection.getDocumentStart();
        }
        return undefined;
    }
    /**
     * Gets the end text position in the document.
     * @default undefined
     * @private
     */
    get documentEnd() {
        if (!isNullOrUndefined(this.selectionModule)) {
            return this.selection.getDocumentEnd();
        }
        return undefined;
    }
    /**
     * @private
     */
    get isReadOnlyMode() {
        return this.isReadOnly || isNullOrUndefined(this.editorModule)
            || isNullOrUndefined(this.selectionModule) || !isNullOrUndefined(this.editor) && this.editor.restrictEditing;
    }
    /**
     * Specifies to enable image resizer option
     * default - false
     * @private
     */
    get enableImageResizerMode() {
        return this.enableImageResizer && !isNullOrUndefined(this.imageResizerModule);
    }
    preRender() {
        this.findResultsList = [];
        //pre render section
    }
    render() {
        this.viewer.initializeComponents();
        this.openBlank();
        if (!isNullOrUndefined(this.element)) {
            let container = this.element;
            container.style.minHeight = '200px';
            container.style.minWidth = '200px';
        }
        this.renderComplete();
    }
    /**
     * Get component name
     * @private
     */
    getModuleName() {
        return 'DocumentEditor';
    }
    /**
     * Called internally if any of the property value changed.
     * @private
     */
    onPropertyChanged(model, oldProp) {
        for (let prop of Object.keys(model)) {
            switch (prop) {
                case 'zoomFactor':
                    if (this.viewer) {
                        this.viewer.zoomFactor = model.zoomFactor;
                    }
                    break;
                case 'locale':
                    this.localizeDialogs();
                    break;
                case 'isReadOnly':
                    if (!isNullOrUndefined(this.optionsPaneModule) && this.optionsPaneModule.isOptionsPaneShow) {
                        this.optionsPaneModule.showHideOptionsPane(false);
                    }
                    break;
                case 'currentUser':
                case 'userColor':
                    if (this.selection && this.viewer.isDocumentProtected) {
                        this.selection.highlightEditRegion();
                    }
                    break;
                case 'pageGap':
                case 'pageOutline':
                    this.viewer.updateScrollBars();
                    break;
                case 'zIndex':
                    if (this.viewer.dialog) {
                        this.viewer.dialog.zIndex = model.zIndex + 10;
                    }
                    if (this.viewer.dialog2) {
                        this.viewer.dialog2.zIndex = model.zIndex;
                    }
                    break;
                case 'showComments':
                    if (this.viewer) {
                        this.viewer.showComments(model.showComments);
                    }
                    break;
            }
        }
    }
    localizeDialogs() {
        if (this.locale !== '') {
            let l10n = new L10n('documenteditor', this.defaultLocale);
            l10n.setLocale(this.locale);
            if (this.optionsPaneModule) {
                this.optionsPaneModule.initOptionsPane(l10n);
            }
            if (this.paragraphDialogModule) {
                this.paragraphDialogModule.initParagraphDialog(l10n);
            }
            if (this.pageSetupDialogModule) {
                this.pageSetupDialogModule.initPageSetupDialog(l10n);
            }
            if (this.fontDialogModule) {
                this.fontDialogModule.initFontDialog(l10n);
            }
            if (this.hyperlinkDialogModule) {
                this.hyperlinkDialogModule.initHyperlinkDialog(l10n);
            }
            if (this.contextMenuModule) {
                this.contextMenuModule.contextMenuInstance.destroy();
                this.contextMenuModule.initContextMenu(l10n);
            }
            if (this.listDialogModule) {
                this.listDialogModule.initListDialog(l10n);
            }
            if (this.tablePropertiesDialogModule) {
                this.tablePropertiesDialogModule.initTablePropertyDialog(l10n);
            }
            if (this.bordersAndShadingDialogModule) {
                this.bordersAndShadingDialogModule.initBordersAndShadingsDialog(l10n);
            }
            if (this.cellOptionsDialogModule) {
                this.cellOptionsDialogModule.initCellMarginsDialog(l10n);
            }
            if (this.tableOptionsDialogModule) {
                this.tableOptionsDialogModule.initTableOptionsDialog(l10n);
            }
            if (this.tableDialogModule) {
                this.tableDialogModule.initTableDialog(l10n);
            }
            if (this.styleDialogModule) {
                this.styleDialogModule.initStyleDialog(l10n);
            }
            if (this.tableOfContentsDialogModule) {
                this.tableOfContentsDialogModule.initTableOfContentDialog(l10n);
            }
            if (this.commentReviewPane && this.commentReviewPane.reviewPane) {
                if (this.enableRtl) {
                    classList(this.commentReviewPane.reviewPane, ['e-rtl'], []);
                }
                else {
                    classList(this.commentReviewPane.reviewPane, [], ['e-rtl']);
                }
            }
        }
    }
    /**
     * Set the default character format for document editor
     * @param characterFormat
     */
    setDefaultCharacterFormat(characterFormat) {
        this.characterFormat = characterFormat;
    }
    /**
     * Set the default paragraph format for document editor
     * @param paragraphFormat
     */
    setDefaultParagraphFormat(paragraphFormat) {
        this.paragraphFormat = paragraphFormat;
    }
    /**
     * Set the default section format for document editor
     * @param sectionFormat
     */
    setDefaultSectionFormat(sectionFormat) {
        this.sectionFormat = sectionFormat;
    }
    /**
     * Get the properties to be maintained in the persisted state.
     * @private
     */
    getPersistData() {
        return 'documenteditor';
    }
    clearPreservedCollectionsInViewer() {
        if (this.viewer instanceof LayoutViewer) {
            this.viewer.clearDocumentItems();
        }
    }
    /**
     * @private
     */
    getDocumentEditorElement() {
        return this.element;
    }
    /**
     * @private
     */
    fireContentChange() {
        let eventArgs = { source: isBlazor() ? null : this };
        this.trigger('contentChange', eventArgs);
    }
    /**
     * @private
     */
    fireDocumentChange() {
        let eventArgs = { source: isBlazor() ? null : this };
        this.trigger('documentChange', eventArgs);
    }
    /**
     * @private
     */
    fireSelectionChange() {
        if (!this.viewer.isCompositionStart && Browser.isDevice && this.editorModule) {
            this.editorModule.predictText();
        }
        let eventArgs = { source: isBlazor() ? null : this };
        this.trigger('selectionChange', eventArgs);
    }
    /**
     * @private
     */
    fireZoomFactorChange() {
        let eventArgs = { source: isBlazor() ? null : this };
        this.trigger('zoomFactorChange', eventArgs);
    }
    /**
     * @private
     */
    fireViewChange() {
        if (this.viewer && this.viewer.pages.length > 0) {
            if (this.viewer.visiblePages.length > 0) {
                let pages = this.viewer.visiblePages;
                let eventArgs = {
                    startPage: pages[0].index + 1,
                    endPage: pages[pages.length - 1].index + 1,
                    source: isBlazor() ? null : this
                };
                this.trigger('viewChange', eventArgs);
            }
        }
    }
    /**
     * @private
     */
    fireCustomContextMenuSelect(item) {
        let eventArgs = { id: item };
        this.trigger('customContextMenuSelect', eventArgs);
    }
    /**
     * @private
     */
    fireCustomContextMenuBeforeOpen(item) {
        let eventArgs = { ids: item };
        this.trigger('customContextMenuBeforeOpen', eventArgs);
    }
    /**
     * Shows the Paragraph dialog
     * @private
     */
    showParagraphDialog(paragraphFormat) {
        if (this.paragraphDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.paragraphDialogModule.show(paragraphFormat);
        }
    }
    /**
     * Shows the margin dialog
     * @private
     */
    showPageSetupDialog() {
        if (this.pageSetupDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.pageSetupDialogModule.show();
        }
    }
    /**
     * Shows the font dialog
     * @private
     */
    showFontDialog(characterFormat) {
        if (this.fontDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.fontDialogModule.showFontDialog(characterFormat);
        }
    }
    /**
     * Shows the cell option dialog
     * @private
     */
    showCellOptionsDialog() {
        if (this.cellOptionsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.cellOptionsDialogModule.show();
        }
    }
    /**
     * Shows the table options dialog.
     * @private
     */
    showTableOptionsDialog() {
        if (this.tableOptionsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableOptionsDialogModule.show();
        }
    }
    /**
     * Shows insert table dialog
     * @private
     */
    showTableDialog() {
        if (this.tableDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableDialogModule.show();
        }
    }
    /**
     * Shows the table of content dialog
     * @private
     */
    showTableOfContentsDialog() {
        if (this.tableOfContentsDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tableOfContentsDialogModule.show();
        }
    }
    /* tslint:enable:no-any */
    /**
     * Shows the style dialog
     * @private
     */
    showStyleDialog() {
        if (this.styleDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.styleDialogModule.show();
        }
    }
    /**
     * Shows the hyperlink dialog
     * @private
     */
    showHyperlinkDialog() {
        if (this.hyperlinkDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.hyperlinkDialogModule.show();
        }
    }
    /**
     * Shows the bookmark dialog.
     * @private
     */
    showBookmarkDialog() {
        if (this.bookmarkDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.bookmarkDialogModule.show();
        }
    }
    /**
     * Shows the styles dialog.
     * @private
     */
    showStylesDialog() {
        if (this.stylesDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.stylesDialogModule.show();
        }
    }
    /**
     * Shows the List dialog
     * @private
     */
    showListDialog() {
        if (this.listDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.listDialogModule.showListDialog();
        }
    }
    /**
     * Shows the table properties dialog
     * @private
     */
    showTablePropertiesDialog() {
        if (this.tablePropertiesDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.tablePropertiesDialogModule.show();
        }
    }
    /**
     * Shows the borders and shading dialog
     * @private
     */
    showBordersAndShadingDialog() {
        if (this.bordersAndShadingDialogModule && !this.isReadOnlyMode && this.viewer) {
            this.bordersAndShadingDialogModule.show();
        }
    }
    //tslint:disable: max-func-body-length
    requiredModules() {
        let modules = [];
        if (this.enablePrint) {
            modules.push({
                member: 'Print', args: []
            });
        }
        if (this.enableSfdtExport || this.enableWordExport || this.enableTextExport || this.enableSelection || this.enableEditor) {
            modules.push({
                member: 'SfdtExport', args: [this.viewer]
            });
        }
        if (this.enableWordExport) {
            modules.push({
                member: 'WordExport', args: []
            });
        }
        if (this.enableTextExport) {
            modules.push({
                member: 'TextExport', args: []
            });
        }
        if (this.enableSelection || this.enableSearch || this.enableEditor) {
            modules.push({
                member: 'Selection', args: [this]
            });
            if (this.enableContextMenu) {
                modules.push({
                    member: 'ContextMenu', args: [this.viewer]
                });
            }
        }
        if (this.enableSearch) {
            modules.push({
                member: 'Search', args: [this]
            });
            if (this.enableOptionsPane) {
                modules.push({
                    member: 'OptionsPane', args: [this.viewer]
                });
            }
        }
        if (this.enableEditor) {
            modules.push({
                member: 'Editor', args: [this.viewer]
            });
            if (this.enableImageResizer) {
                modules.push({
                    member: 'ImageResizer', args: [this, this.viewer]
                });
            }
            if (this.enableEditorHistory) {
                modules.push({
                    member: 'EditorHistory', args: [this]
                });
            }
            if (this.enableHyperlinkDialog) {
                modules.push({
                    member: 'HyperlinkDialog', args: [this.viewer]
                });
            }
            if (this.enableTableDialog) {
                modules.push({
                    member: 'TableDialog', args: [this.viewer]
                });
            }
            if (this.enableBookmarkDialog) {
                modules.push({
                    member: 'BookmarkDialog', args: [this.viewer]
                });
            }
            if (this.enableTableOfContentsDialog) {
                modules.push({
                    member: 'TableOfContentsDialog', args: [this.viewer]
                });
            }
            if (this.enablePageSetupDialog) {
                modules.push({
                    member: 'PageSetupDialog', args: [this.viewer]
                });
            }
            if (this.enableStyleDialog) {
                modules.push({
                    member: 'StylesDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'StyleDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'BulletsAndNumberingDialog', args: [this.viewer]
                });
            }
            if (this.enableListDialog) {
                modules.push({
                    member: 'ListDialog', args: [this.viewer]
                });
            }
            if (this.enableParagraphDialog) {
                modules.push({
                    member: 'ParagraphDialog', args: [this.viewer]
                });
            }
            if (this.enableFontDialog) {
                modules.push({
                    member: 'FontDialog', args: [this.viewer]
                });
            }
            if (this.enableTablePropertiesDialog) {
                modules.push({
                    member: 'TablePropertiesDialog', args: [this.viewer]
                });
                modules.push({
                    member: 'CellOptionsDialog', args: [this.viewer]
                });
            }
            if (this.enableBordersAndShadingDialog) {
                modules.push({
                    member: 'BordersAndShadingDialog', args: [this.viewer]
                });
            }
            if (this.enableTableOptionsDialog) {
                modules.push({
                    member: 'TableOptionsDialog', args: [this.viewer]
                });
            }
            if (this.enableSpellCheck) {
                modules.push({
                    member: 'SpellChecker', args: [this.viewer]
                });
                modules.push({
                    member: 'SpellCheckDialog', args: [this.viewer]
                });
            }
        }
        return modules;
    }
    // Public Implementation Starts
    /**
     * Opens the given Sfdt text.
     * @param {string} sfdtText.
     */
    open(sfdtText) {
        if (!isNullOrUndefined(this.viewer)) {
            this.showComments = false;
            this.clearPreservedCollectionsInViewer();
            this.viewer.userCollection.push('Everyone');
            this.viewer.lists = [];
            this.viewer.abstractLists = [];
            this.viewer.styles = new WStyles();
            this.viewer.cachedPages = [];
            if (this.enableSpellCheck && !this.spellChecker.enableOptimizedSpellCheck) {
                this.viewer.triggerElementsOnLoading = true;
                this.viewer.triggerSpellCheck = true;
            }
            if (!isNullOrUndefined(sfdtText) && this.viewer) {
                this.viewer.onDocumentChanged(this.parser.convertJsonToDocument(sfdtText));
                if (this.editorModule) {
                    this.editorModule.intializeDefaultStyles();
                }
            }
            if (this.enableSpellCheck && !this.spellChecker.enableOptimizedSpellCheck) {
                this.viewer.triggerElementsOnLoading = false;
                this.viewer.triggerSpellCheck = false;
            }
        }
    }
    /**
     * Scrolls view to start of the given page number if exists.
     * @param  {number} pageNumber.
     * @returns void
     */
    scrollToPage(pageNumber) {
        if (isNullOrUndefined(this.viewer) || pageNumber < 1 || pageNumber > this.viewer.pages.length) {
            return false;
        }
        this.viewer.scrollToPage(pageNumber - 1);
        return true;
    }
    /**
     * Enables all the modules.
     * @returns void
     */
    enableAllModules() {
        this.enablePrint = this.enableSfdtExport = this.enableWordExport = this.enableTextExport
            = this.enableSelection = this.enableContextMenu = this.enableSearch = this.enableOptionsPane
                = this.enableEditor = this.enableImageResizer = this.enableEditorHistory
                    = this.enableHyperlinkDialog = this.enableTableDialog = this.enableBookmarkDialog
                        = this.enableTableOfContentsDialog = this.enablePageSetupDialog = this.enableStyleDialog
                            = this.enableListDialog = this.enableParagraphDialog = this.enableFontDialog
                                = this.enableTablePropertiesDialog = this.enableBordersAndShadingDialog
                                    = this.enableTableOptionsDialog = this.enableSpellCheck = true;
        // tslint:disable-next-line:max-line-length
        DocumentEditor_1.Inject(Print, SfdtExport, WordExport, TextExport, Selection, Search, Editor, ImageResizer, EditorHistory, ContextMenu$1, OptionsPane, HyperlinkDialog, TableDialog, BookmarkDialog, TableOfContentsDialog, PageSetupDialog, StyleDialog, ListDialog, ParagraphDialog, BulletsAndNumberingDialog, FontDialog, TablePropertiesDialog, BordersAndShadingDialog, TableOptionsDialog, CellOptionsDialog, StylesDialog, SpellChecker, SpellCheckDialog);
    }
    /**
     * Resizes the component and its sub elements based on given size or container size.
     * @param width
     * @param height
     */
    resize(width, height) {
        if (this.element) {
            if (!isNullOrUndefined(width) && width > 200) {
                this.element.style.width = width + 'px';
            }
            if (!isNullOrUndefined(height) && height > 200) {
                this.element.style.height = height + 'px';
            }
            if (this.viewer) {
                this.viewer.updateViewerSize();
            }
        }
    }
    /**
     * Shifts the focus to the document.
     */
    focusIn() {
        if (this.viewer) {
            this.viewer.updateFocus();
        }
    }
    /**
     * Fits the page based on given fit type.
     * @param  {PageFitType} pageFitType? - Default value of ‘pageFitType’ parameter is 'None'
     * @returns void
     */
    fitPage(pageFitType) {
        if (isNullOrUndefined(pageFitType)) {
            pageFitType = 'None';
        }
        if (this.viewer) {
            this.viewer.pageFitType = pageFitType;
        }
    }
    /**
     * Prints the document.
     * @param  {Window} printWindow? - Default value of 'printWindow' parameter is undefined.
     */
    print(printWindow) {
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation.');
        }
        if (this.printModule) {
            this.printModule.print(this.viewer, printWindow);
        }
        else {
            throw new Error('Invalid operation. Print is not enabled.');
        }
    }
    /**
     * Serialize the data to JSON string.
     */
    serialize() {
        let json = '';
        if (this.enableSfdtExport && this.sfdtExportModule instanceof SfdtExport) {
            json = this.sfdtExportModule.serialize();
        }
        else {
            throw new Error('Invalid operation. Sfdt export is not enabled.');
        }
        return json;
    }
    /**
     * Saves the document.
     * @param {string} fileName
     * @param {FormatType} formatType
     */
    save(fileName, formatType) {
        fileName = fileName || 'Untitled';
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation.');
        }
        if (formatType === 'Docx' && this.wordExportModule) {
            if (this.wordExportModule) {
                this.wordExportModule.save(this.viewer, fileName);
            }
        }
        else if (formatType === 'Txt' && this.textExportModule) {
            this.textExportModule.save(this.viewer, fileName);
        }
        else if (formatType === 'Sfdt' && this.enableSfdtExport && this.sfdtExportModule) {
            let jsonString = this.serialize();
            let blob = new Blob([jsonString], {
                type: 'application/json'
            });
            Save.save(fileName + '.sfdt', blob);
        }
        else {
            throw new Error('Invalid operation. Specified export is not enabled.');
        }
    }
    /**
     * Saves the document as blob.
     * @param {FormatType} formatType
     */
    saveAsBlob(formatType) {
        if (isNullOrUndefined(this.viewer)) {
            throw new Error('Invalid operation');
        }
        return new Promise((resolve, reject) => {
            if (formatType === 'Docx' && this.wordExportModule) {
                resolve(this.wordExportModule.saveAsBlob(this.viewer));
            }
            else if (formatType === 'Txt' && this.textExportModule) {
                resolve(this.textExportModule.saveAsBlob(this.viewer));
            }
            else if (formatType === 'Sfdt' && this.enableSfdtExport && this.sfdtExportModule) {
                resolve(this.sfdtExportModule.saveAsBlob(this.viewer));
            }
        });
    }
    /**
     * Opens a blank document.
     */
    openBlank() {
        let section = new BodyWidget();
        section.index = 0;
        section.sectionFormat = new WSectionFormat(section);
        if (this.sectionFormat) {
            this.parser.parseSectionFormat(this.sectionFormat, section.sectionFormat);
        }
        let paragraph = new ParagraphWidget();
        paragraph.index = 0;
        paragraph.paragraphFormat = new WParagraphFormat(paragraph);
        paragraph.characterFormat = new WCharacterFormat(paragraph);
        section.childWidgets.push(paragraph);
        paragraph.containerWidget = section;
        let sections = [];
        sections.push(section);
        // tslint:disable-next-line:max-line-length
        let hfs = this.parser.parseHeaderFooter({ header: {}, footer: {}, evenHeader: {}, evenFooter: {}, firstPageHeader: {}, firstPageFooter: {} }, undefined);
        if (this.viewer) {
            this.clearPreservedCollectionsInViewer();
            this.viewer.userCollection.push('Everyone');
            this.viewer.cachedPages = [];
            this.viewer.setDefaultDocumentFormat();
            this.viewer.headersFooters.push(hfs);
            this.viewer.onDocumentChanged(sections);
            if (this.editorModule) {
                this.editorModule.intializeDefaultStyles();
                let style = this.viewer.styles.findByName('Normal');
                paragraph.paragraphFormat.baseStyle = style;
                paragraph.paragraphFormat.listFormat.baseStyle = style;
            }
        }
    }
    /**
     * Gets the style names based on given style type.
     * @param styleType
     */
    getStyleNames(styleType) {
        if (this.viewer) {
            return this.viewer.styles.getStyleNames(styleType);
        }
        return [];
    }
    /**
     * Gets the style objects on given style type.
     * @param styleType
     */
    getStyles(styleType) {
        if (this.viewer) {
            return this.viewer.styles.getStyles(styleType);
        }
        return [];
    }
    /**
     * Gets the bookmarks.
     */
    getBookmarks() {
        let bookmarks = [];
        if (this.viewer) {
            bookmarks = this.viewer.getBookmarks(true);
        }
        return bookmarks;
    }
    /**
     * Shows the dialog.
     * @param {DialogType} dialogType
     * @returns void
     */
    showDialog(dialogType) {
        switch (dialogType) {
            case 'Hyperlink':
                this.showHyperlinkDialog();
                break;
            case 'Table':
                this.showTableDialog();
                break;
            case 'Bookmark':
                this.showBookmarkDialog();
                break;
            case 'TableOfContents':
                this.showTableOfContentsDialog();
                break;
            case 'PageSetup':
                this.showPageSetupDialog();
                break;
            case 'List':
                this.showListDialog();
                break;
            case 'Styles':
                this.showStylesDialog();
                break;
            case 'Style':
                this.showStyleDialog();
                break;
            case 'Paragraph':
                this.showParagraphDialog();
                break;
            case 'Font':
                this.showFontDialog();
                break;
            case 'TableProperties':
                this.showTablePropertiesDialog();
                break;
            case 'BordersAndShading':
                this.showBordersAndShadingDialog();
                break;
            case 'TableOptions':
                this.showTableOptionsDialog();
                break;
        }
    }
    /**
     * Shows the options pane.
     */
    showOptionsPane() {
        if (!isNullOrUndefined(this.optionsPaneModule) && !isNullOrUndefined(this.viewer)) {
            this.optionsPaneModule.showHideOptionsPane(true);
        }
    }
    /**
     * Destroys all managed resources used by this object.
     */
    destroy() {
        super.destroy();
        this.destroyDependentModules();
        if (!isNullOrUndefined(this.viewer)) {
            this.viewer.destroy();
        }
        this.viewer = undefined;
        if (!isNullOrUndefined(this.element)) {
            this.element.classList.remove('e-documenteditor');
            this.element.innerHTML = '';
        }
        this.element = undefined;
        this.findResultsList = [];
        this.findResultsList = undefined;
    }
    /* tslint:disable */
    destroyDependentModules() {
        if (this.printModule) {
            this.printModule.destroy();
            this.printModule = undefined;
        }
        if (this.sfdtExportModule) {
            this.sfdtExportModule.destroy();
            this.sfdtExportModule = undefined;
        }
        if (this.optionsPaneModule) {
            this.optionsPaneModule.destroy();
            this.optionsPaneModule = undefined;
        }
        if (this.commentReviewPane) {
            this.commentReviewPane.destroy();
            this.commentReviewPane = undefined;
        }
        if (!isNullOrUndefined(this.hyperlinkDialogModule)) {
            this.hyperlinkDialogModule.destroy();
            this.hyperlinkDialogModule = undefined;
        }
        if (this.searchModule) {
            this.searchModule.destroy();
            this.searchModule = undefined;
        }
        if (this.contextMenuModule) {
            this.contextMenuModule.destroy();
            this.contextMenuModule = undefined;
        }
        if (this.editorModule) {
            this.editorModule.destroy();
            this.editorModule = undefined;
        }
        if (this.selectionModule) {
            this.selectionModule.destroy();
            this.selectionModule = undefined;
        }
        if (this.editorHistoryModule) {
            this.editorHistoryModule.destroy();
            this.editorHistoryModule = undefined;
        }
        if (!isNullOrUndefined(this.paragraphDialogModule)) {
            this.paragraphDialogModule.destroy();
            this.paragraphDialogModule = undefined;
        }
        if (this.pageSetupDialogModule) {
            this.pageSetupDialogModule.destroy();
            this.pageSetupDialogModule = undefined;
        }
        if (this.fontDialogModule) {
            this.fontDialogModule.destroy();
            this.fontDialogModule = undefined;
        }
        if (this.listDialogModule) {
            this.listDialogModule.destroy();
            this.listDialogModule = undefined;
        }
        if (this.imageResizerModule) {
            this.imageResizerModule.destroy();
            this.imageResizerModule = undefined;
        }
        if (this.tablePropertiesDialogModule) {
            this.tablePropertiesDialogModule.destroy();
            this.tablePropertiesDialogModule = undefined;
        }
        if (this.bordersAndShadingDialogModule) {
            this.bordersAndShadingDialogModule.destroy();
            this.bordersAndShadingDialogModule = undefined;
        }
        if (this.cellOptionsDialogModule) {
            this.cellOptionsDialogModule.destroy();
            this.cellOptionsDialogModule = undefined;
        }
        if (this.tableOptionsDialogModule) {
            this.tableOptionsDialogModule.destroy();
            this.tableOptionsDialogModule = undefined;
        }
        if (this.tableDialogModule) {
            this.tableDialogModule.destroy();
            this.tableDialogModule = undefined;
        }
        if (this.styleDialogModule) {
            this.styleDialogModule = undefined;
        }
        if (this.bookmarkDialogModule) {
            this.bookmarkDialogModule.destroy();
            this.bookmarkDialogModule = undefined;
        }
        if (this.styleDialogModule) {
            this.styleDialogModule.destroy();
            this.styleDialogModule = undefined;
        }
        if (this.textExportModule) {
            this.textExportModule.destroy();
            this.textExportModule = undefined;
        }
        if (this.wordExportModule) {
            this.wordExportModule.destroy();
            this.wordExportModule = undefined;
        }
        if (this.tableOfContentsDialogModule) {
            this.tableOfContentsDialogModule.destroy();
            this.tableOfContentsDialogModule = undefined;
        }
        if (this.spellCheckerModule) {
            this.spellCheckerModule.destroy();
            this.spellCheckerModule = undefined;
        }
    }
};
__decorate([
    Property('KeepSourceFormatting')
], DocumentEditor.prototype, "defaultPasteOption", void 0);
__decorate([
    Property('')
], DocumentEditor.prototype, "currentUser", void 0);
__decorate([
    Property('#FFFF00')
], DocumentEditor.prototype, "userColor", void 0);
__decorate([
    Property(20)
], DocumentEditor.prototype, "pageGap", void 0);
__decorate([
    Property('')
], DocumentEditor.prototype, "documentName", void 0);
__decorate([
    Property('')
], DocumentEditor.prototype, "serviceUrl", void 0);
__decorate([
    Property(1)
], DocumentEditor.prototype, "zoomFactor", void 0);
__decorate([
    Property(2000)
], DocumentEditor.prototype, "zIndex", void 0);
__decorate([
    Property(true)
], DocumentEditor.prototype, "isReadOnly", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enablePrint", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableSelection", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableEditor", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableEditorHistory", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableSfdtExport", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableWordExport", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTextExport", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableOptionsPane", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableContextMenu", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableHyperlinkDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableBookmarkDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTableOfContentsDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableSearch", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableParagraphDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableListDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTablePropertiesDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableBordersAndShadingDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enablePageSetupDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableStyleDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableFontDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTableOptionsDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableTableDialog", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableImageResizer", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableSpellCheck", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "acceptTab", void 0);
__decorate([
    Property(true)
], DocumentEditor.prototype, "useCtrlClickToFollowHyperlink", void 0);
__decorate([
    Property('#000000')
], DocumentEditor.prototype, "pageOutline", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableCursorOnReadOnly", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "enableLocalPaste", void 0);
__decorate([
    Property({ systemClipboard: 'SystemClipboard', spellCheck: 'SpellCheck', restrictEditing: 'RestrictEditing' })
], DocumentEditor.prototype, "serverActionSettings", void 0);
__decorate([
    Property([])
], DocumentEditor.prototype, "headers", void 0);
__decorate([
    Property(false)
], DocumentEditor.prototype, "showComments", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "documentChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "viewChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "zoomFactorChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "selectionChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "requestNavigate", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "contentChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "keyDown", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "searchResultsChange", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "created", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "destroyed", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "customContextMenuSelect", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "customContextMenuBeforeOpen", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "beforePaneSwitch", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "commentBegin", void 0);
__decorate([
    Event()
], DocumentEditor.prototype, "commentEnd", void 0);
DocumentEditor = DocumentEditor_1 = __decorate([
    NotifyPropertyChanges
], DocumentEditor);
/**
 * The `ServerActionSettings` module is used to provide the server action methods of Document Editor.
 */
class ServerActionSettings extends ChildProperty {
}
__decorate([
    Property('SystemClipboard')
], ServerActionSettings.prototype, "systemClipboard", void 0);
__decorate([
    Property('SpellCheck')
], ServerActionSettings.prototype, "spellCheck", void 0);
__decorate([
    Property('RestrictEditing')
], ServerActionSettings.prototype, "restrictEditing", void 0);
/**
 * The `ServerActionSettings` module is used to provide the server action methods of Document Editor Container.
 */
class ContainerServerActionSettings extends ServerActionSettings {
}
__decorate([
    Property('Import')
], ContainerServerActionSettings.prototype, "import", void 0);

/**
 * Print class
 */
class Print {
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'Print';
    }
    /**
     * Prints the current viewer
     * @param viewer
     * @param printWindow
     * @private
     */
    print(viewer, printWindow) {
        this.printWindow(viewer, navigator.userAgent, printWindow);
    }
    /**
     * Opens print window and displays current page to print.
     * @private
     */
    printWindow(viewer, browserUserAgent, printWindow) {
        let height = this.getPageHeight(viewer.pages);
        let width = this.getPageWidth(viewer.pages);
        let printElement = document.createElement('div');
        printElement.style.width = '100%';
        printElement.style.height = '100%';
        printElement.style.overflow = 'scroll';
        // Rendering canvas to print
        this.generatePrintContent(viewer, printElement);
        if (isNullOrUndefined(printWindow)) {
            printWindow = window.open('', 'print', 'height=452,width=1024,tabbar=no');
        }
        if ((browserUserAgent.indexOf('Chrome') !== -1) || (browserUserAgent.indexOf('Firefox')) !== -1) {
            // Chrome and Firefox
            printWindow.document.write('<!DOCTYPE html>');
            // tslint:disable-next-line:max-line-length
            printWindow.document.write('<html moznomarginboxes mozdisallowselectionprint><head><style>html, body { height: 100 %; } img { height: 100 %; width: 100 %; display: block;}img { box-sizing: border-box; }br, button { display: none; }@page{ margin: 0cm; size:' + width.toString() + 'px ' + height.toString() + 'px; }@media print{ body { margin: 0cm; }</style></head> <body><center>');
        }
        else {
            // Internet Explorer and Edge
            // tslint:disable-next-line:max-line-length
            printWindow.document.write('<html><head><style>@page{margin:0;size:' + width.toString() + 'px ' + height.toString() + 'px;}</style></head><body><center>');
        }
        // tslint:disable-next-line:max-line-length
        printWindow.document.write(printElement.innerHTML + '</center><script> (function() { window.ready = true; })(); </script></body></html>');
        printElement = undefined;
        printWindow.document.close();
        printWindow.focus();
        let interval = setInterval(() => {
            if (printWindow.ready) {
                printWindow.print();
                printWindow.close();
                clearInterval(interval);
            }
        }, 500);
    }
    /**
     * Generates print content.
     * @private
     */
    generatePrintContent(viewer, element) {
        // Rendering canvas to print
        let htmlString = '';
        for (let i = 0; i < viewer.pages.length; i++) {
            let page = viewer.pages[i];
            let pageHeight = page.boundingRectangle.height;
            let pageWidth = page.boundingRectangle.width;
            viewer.render.isPrinting = true;
            viewer.render.renderWidgets(page, 0, 0, 0, 0);
            let canvasURL = viewer.render.pageCanvas.toDataURL();
            viewer.render.isPrinting = false;
            // tslint:disable-next-line:max-line-length
            htmlString += '<div><img src=' + canvasURL + ' style="margin:0px;display:block;width: ' + pageWidth.toString() + 'px; height:' + pageHeight.toString() + 'px; "/></div><br/>';
        }
        element.innerHTML = htmlString;
    }
    /**
     * Gets page width.
     * @param pages
     * @private
     */
    getPageWidth(pages) {
        let width = 0;
        for (let i = 0; i < pages.length; i++) {
            if (width < pages[i].boundingRectangle.width) {
                width = pages[i].boundingRectangle.width;
            }
        }
        return width;
    }
    /**
     *  Gets page height.
     * @private
     */
    getPageHeight(pages) {
        let height = 0;
        for (let i = 0; i < pages.length; i++) {
            if (height < pages[i].boundingRectangle.height) {
                height = pages[i].boundingRectangle.height;
            }
        }
        return height;
    }
    /**
     * @private
     */
    destroy() {
        return;
    }
}

const CONTEXTMENU_COPY = '_contextmenu_copy';
const CONTEXTMENU_CUT = '_contextmenu_cut';
const CONTEXTMENU_PASTE = '_contextmenu_paste';
const CONTEXTMENU_ADD_COMMENT = '_add_comment';
const CONTEXTMENU_UPDATE_FIELD = '_contextmenu_update_field';
const CONTEXTMENU_EDIT_FIELD = '_contextmenu_edit_field';
const CONTEXTMENU_HYPERLINK = '_contextmenu_hyperlink';
const CONTEXTMENU_OPEN_HYPERLINK = '_contextmenu_open_hyperlink';
const CONTEXTMENU_COPY_HYPERLINK = '_contextmenu_copy_hyperlink';
const CONTEXTMENU_REMOVE_HYPERLINK = '_contextmenu_remove_hyperlink';
const CONTEXTMENU_EDIT_HYPERLINK = '_contextmenu_edit_hyperlink';
const CONTEXTMENU_FONT_DIALOG = '_contextmenu_font_dialog';
const CONTEXTMENU_PARAGRAPH = '_contextmenu_paragraph_dialog';
const CONTEXTMENU_TABLE = '_contextmenu_table_dialog';
const CONTEXTMENU_INSERT_TABLE = '_contextmenu_insert_table';
const CONTEXTMENU_DELETE_TABLE = '_contextmenu_delete_table';
const CONTEXTMENU_INSERT_ABOVE = '_contextmenu_insert_above';
const CONTEXTMENU_INSERT_BELOW = '_contextmenu_insert_below';
const CONTEXTMENU_INSERT_RIGHT = '_contextmenu_insert_right';
const CONTEXTMENU_INSERT_LEFT = '_contextmenu_insert_left';
const CONTEXTMENU_COMPLETE_DELETE_TABLE = '_contextmenu_complete_table_delete';
const CONTEXTMENU_DELETE_ROW = '_contextmenu_delete_row';
const CONTEXTMENU_DELETE_COLUMN = '_contextmenu_delete_column';
const CONTEXTMENU_MERGE_CELL = '_contextmenu_merge_cell';
const CONTEXTMENU_AUTO_FIT = '_contextmenu_auto_fit';
const CONTEXTMENU_AUTO_FIT_TO_CONTENTS = '_contextmenu_auto_fit_contents';
const CONTEXTMENU_AUTO_FIT_TO_WINDOW = '_contextmenu_auto_fit_window';
const CONTEXTMENU_FIXED_COLUMN_WIDTH = '_contextmenu_fixed_column_width';
const CONTEXTMENU_CONTINUE_NUMBERING = '_contextmenu_continue_numbering';
const CONTEXTMENU_RESTART_AT = '_contextmenu_restart_at';
const CONTEXTMENU_SPELLING_DIALOG = '_contextmenu_spelling_dialog';
const CONTEXTMENU_SPELLCHECK_OTHERSUGGESTIONS = '_contextmenu_otherSuggestions_spellcheck_';
const CONTEXTMENU_NO_SUGGESTION = '_contextmenu_no_suggestion';
/**
 * Context Menu class
 */
class ContextMenu$1 {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.contextMenuInstance = undefined;
        /**
         * @private
         */
        this.menuItems = [];
        /**
         * @private
         */
        this.customMenuItems = [];
        /**
         * @private
         */
        this.ids = [];
        this.spellContextItems = [];
        this.customItems = [];
        /**
         * Handles on context menu key pressed.
         * @param  {PointerEvent} event
         * @private
         */
        this.onContextMenuInternal = (event) => {
            let isTouch = event instanceof TouchEvent;
            if (this.viewer.owner.enableSpellCheck && this.spellChecker.allowSpellCheckAndSuggestion) {
                event.preventDefault();
                this.currentContextInfo = this.spellChecker.findCurretText();
                let splittedSuggestion;
                /* tslint:disable:no-any */
                let allSuggestions;
                let exactData = this.spellChecker.manageSpecialCharacters(this.currentContextInfo.text, undefined, true);
                if (!isNullOrUndefined(exactData) && this.spellChecker.errorWordCollection.containsKey(exactData)) {
                    this.spellChecker.currentContextInfo = this.currentContextInfo;
                    if (this.spellChecker.errorSuggestions.containsKey(exactData)) {
                        allSuggestions = this.spellChecker.errorSuggestions.get(exactData).slice();
                        splittedSuggestion = this.spellChecker.handleSuggestions(allSuggestions);
                        this.processSuggestions(allSuggestions, splittedSuggestion, isTouch ? event : event);
                    }
                    else {
                        if (this.spellChecker.enableOptimizedSpellCheck) {
                            // tslint:disable-next-line:max-line-length
                            this.spellChecker.CallSpellChecker(this.spellChecker.languageID, exactData, false, true, false, false).then((data) => {
                                /* tslint:disable:no-any */
                                let jsonObject = JSON.parse(data);
                                allSuggestions = jsonObject.Suggestions;
                                if (!isNullOrUndefined(allSuggestions)) {
                                    this.spellChecker.errorSuggestions.add(exactData, allSuggestions.slice());
                                    splittedSuggestion = this.spellChecker.handleSuggestions(allSuggestions);
                                }
                                // tslint:disable-next-line:max-line-length
                                this.processSuggestions(allSuggestions, splittedSuggestion, isTouch ? event : event);
                            });
                        }
                        else {
                            // tslint:disable-next-line:max-line-length
                            this.processSuggestions(allSuggestions, splittedSuggestion, isTouch ? event : event);
                        }
                    }
                }
                else {
                    this.hideSpellContextItems();
                    this.showContextMenuOnSel(isTouch ? event : event);
                }
            }
            else {
                this.hideSpellContextItems();
                this.showContextMenuOnSel(isTouch ? event : event);
            }
        };
        this.viewer = viewer;
        this.locale = new L10n('documenteditor', this.viewer.owner.defaultLocale);
        this.locale.setLocale(this.viewer.owner.locale);
        this.initContextMenu(this.locale, this.viewer.owner.enableRtl);
    }
    /**
     * Gets the spell checker
     * @private
     */
    get spellChecker() {
        return this.viewer.owner.spellChecker;
    }
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'ContextMenu';
    }
    /**
     * Initialize context menu.
     * @param localValue Localize value.
     * @private
     */
    // tslint:disable:max-func-body-length
    initContextMenu(localValue, isRtl) {
        let id = this.viewer.owner.element.id;
        this.contextMenu = document.createElement('div');
        this.contextMenu.id = this.viewer.owner.containerId + 'e-de-contextmenu';
        document.body.appendChild(this.contextMenu);
        let ul = document.createElement('ul');
        ul.style.width = 'auto';
        ul.id = this.viewer.owner.containerId + 'e-de-contextmenu-list';
        ul.style.listStyle = 'none';
        ul.style.margin = '0px';
        ul.style.maxHeight = 'auto';
        ul.oncontextmenu = this.disableBrowserContextmenu;
        this.contextMenu.appendChild(ul);
        this.menuItems = [
            {
                text: localValue.getConstant('Cut'),
                iconCss: 'e-icons e-de-cut',
                id: id + CONTEXTMENU_CUT
            },
            {
                text: localValue.getConstant('Copy'),
                iconCss: 'e-icons e-de-copy',
                id: id + CONTEXTMENU_COPY
            },
            {
                text: localValue.getConstant('Paste'),
                iconCss: 'e-icons e-de-paste',
                id: id + CONTEXTMENU_PASTE
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('New Comment'),
                iconCss: 'e-icons e-de-cmt-add',
                id: id + CONTEXTMENU_ADD_COMMENT
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Update Field'),
                iconCss: 'e-icons e-de-update_field',
                id: id + CONTEXTMENU_UPDATE_FIELD
            },
            {
                text: localValue.getConstant('Edit Field'),
                iconCss: 'e-icons e-de-edit_field',
                id: id + CONTEXTMENU_EDIT_FIELD
            },
            {
                text: localValue.getConstant('Continue Numbering'),
                iconCss: 'e-icons e-de-continue-numbering',
                id: id + CONTEXTMENU_CONTINUE_NUMBERING
            },
            {
                text: localValue.getConstant('Restart At') + ' 1',
                iconCss: 'e-icons e-de-restart-at',
                id: id + CONTEXTMENU_RESTART_AT
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Hyperlink'),
                iconCss: 'e-icons e-de-insertlink',
                id: id + CONTEXTMENU_HYPERLINK
            },
            {
                text: localValue.getConstant('Edit Hyperlink') + '...',
                iconCss: 'e-icons e-de-edit-hyperlink',
                id: id + CONTEXTMENU_EDIT_HYPERLINK
            },
            {
                text: localValue.getConstant('Open Hyperlink'),
                iconCss: 'e-icons e-de-open-hyperlink',
                id: id + CONTEXTMENU_OPEN_HYPERLINK
            },
            {
                text: localValue.getConstant('Copy Hyperlink'),
                iconCss: 'e-icons e-de-copy-hyperlink',
                id: id + CONTEXTMENU_COPY_HYPERLINK
            },
            {
                text: localValue.getConstant('Remove Hyperlink'),
                iconCss: 'e-icons e-de-remove-hyperlink',
                id: id + CONTEXTMENU_REMOVE_HYPERLINK
            },
            {
                separator: true
            },
            {
                text: localValue.getConstant('Font'),
                iconCss: 'e-icons e-de-fonts',
                id: id + CONTEXTMENU_FONT_DIALOG
            },
            {
                text: localValue.getConstant('Paragraph'),
                iconCss: 'e-icons e-de-paragraph',
                id: id + CONTEXTMENU_PARAGRAPH
            },
            {
                separator: true,
            },
            {
                text: localValue.getConstant('Table Properties'),
                id: id + CONTEXTMENU_TABLE,
                iconCss: 'e-icons e-de-table'
            },
            {
                text: localValue.getConstant('Merge Cells'),
                id: id + CONTEXTMENU_MERGE_CELL,
                iconCss: 'e-icons e-de-ctnr-mergecell'
            },
            {
                text: localValue.getConstant('AutoFit'),
                id: id + CONTEXTMENU_AUTO_FIT,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('AutoFit to Contents'),
                        id: id + CONTEXTMENU_AUTO_FIT_TO_CONTENTS,
                        iconCss: 'e-icons e-de-icon-autofit e-de-autofit-contents'
                    },
                    {
                        text: localValue.getConstant('AutoFit to Window'),
                        id: id + CONTEXTMENU_AUTO_FIT_TO_WINDOW,
                        iconCss: 'e-icons e-de-icon-auto-fitwindow e-de-autofit-window'
                    },
                    {
                        text: localValue.getConstant('Fixed Column Width'),
                        id: id + CONTEXTMENU_FIXED_COLUMN_WIDTH,
                        iconCss: 'e-icons e-de-icon-fixed-columnwidth e-de-fixed-column'
                    }
                ]
            },
            {
                text: localValue.getConstant('Insert'),
                id: id + CONTEXTMENU_INSERT_TABLE,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('Insert Above'),
                        id: id + CONTEXTMENU_INSERT_ABOVE,
                        iconCss: 'e-icons e-de-insertabove'
                    },
                    {
                        text: localValue.getConstant('Insert Below'),
                        id: id + CONTEXTMENU_INSERT_BELOW,
                        iconCss: 'e-icons e-de-insertbelow'
                    },
                    {
                        text: localValue.getConstant('Insert Left'),
                        id: id + CONTEXTMENU_INSERT_LEFT,
                        iconCss: 'e-icons e-de-insertleft'
                    },
                    {
                        text: localValue.getConstant('Insert Right'),
                        id: id + CONTEXTMENU_INSERT_RIGHT,
                        iconCss: 'e-icons e-de-insertright'
                    }
                ]
            },
            {
                text: localValue.getConstant('Delete'),
                id: id + CONTEXTMENU_DELETE_TABLE,
                iconCss: 'e-icons',
                items: [
                    {
                        text: localValue.getConstant('Delete Table'),
                        id: id + CONTEXTMENU_COMPLETE_DELETE_TABLE,
                        iconCss: 'e-icons e-de-delete-table'
                    },
                    {
                        text: localValue.getConstant('Delete Row'),
                        id: id + CONTEXTMENU_DELETE_ROW,
                        iconCss: 'e-icons e-de-deleterow'
                    },
                    {
                        text: localValue.getConstant('Delete Column'),
                        id: id + CONTEXTMENU_DELETE_COLUMN,
                        iconCss: 'e-icons e-de-deletecolumn'
                    }
                ]
            },
        ];
        let menuOptions = {
            target: '#' + this.viewer.owner.containerId + 'e-de-contextmenu',
            enableRtl: isRtl,
            items: this.addMenuItems(this.menuItems),
            select: (args) => {
                let item = args.element.id;
                this.handleContextMenuItem(item);
            },
        };
        this.contextMenuInstance = new ContextMenu(menuOptions, '#' + this.viewer.owner.containerId + 'e-de-contextmenu-list');
        this.contextMenuInstance.beforeOpen = () => {
            for (let index = 0; index < this.customMenuItems.length; index++) {
                if (typeof this.customMenuItems[index].id !== 'undefined') {
                    this.ids[index] = this.customMenuItems[index].id;
                }
                else {
                    this.ids[index] = this.customMenuItems[index + 1].id;
                }
            }
            this.viewer.owner.fireCustomContextMenuBeforeOpen(this.ids);
            if (this.enableCustomContextMenu) {
                for (let index = 0; index < this.menuItems.length; index++) {
                    if (typeof this.menuItems[index].id !== 'undefined') {
                        document.getElementById(this.menuItems[index].id).style.display = 'none';
                    }
                    else {
                        document.getElementById(this.menuItems[index - 1].id).nextSibling.style.display = 'none';
                    }
                }
            }
            if (this.viewer && this.viewer.selection) {
                classList(this.viewer.selection.caret, [], ['e-de-cursor-animation']);
                this.viewer.selection.showCaret();
            }
        };
        this.contextMenuInstance.onClose = () => {
            if (this.viewer && this.viewer.selection) {
                classList(this.viewer.selection.caret, ['e-de-cursor-animation'], []);
                this.viewer.updateFocus();
            }
        };
    }
    /**
     * Disable browser context menu.
     */
    disableBrowserContextmenu() {
        return false;
    }
    /**
     * Handles context menu items.
     * @param  {string} item Specifies which item is selected.
     * @private
     */
    handleContextMenuItem(item) {
        let id = this.viewer.owner.element.id;
        switch (item) {
            case id + CONTEXTMENU_COPY:
                this.viewer.selection.copy();
                break;
            case id + CONTEXTMENU_CUT:
                this.viewer.owner.editor.cut();
                break;
            case id + CONTEXTMENU_PASTE:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.pasteInternal(undefined);
                }
                break;
            case id + CONTEXTMENU_ADD_COMMENT:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.insertComment();
                }
                break;
            case id + CONTEXTMENU_UPDATE_FIELD:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.editorModule.updateToc();
                }
                break;
            case id + CONTEXTMENU_EDIT_FIELD:
                if (!this.viewer.owner.isReadOnlyMode) {
                    this.viewer.owner.tableOfContentsDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_FONT_DIALOG:
                if (this.viewer.owner.fontDialogModule) {
                    this.viewer.owner.fontDialogModule.showFontDialog();
                }
                break;
            case id + CONTEXTMENU_OPEN_HYPERLINK:
                this.viewer.selection.navigateHyperlink();
                break;
            case id + CONTEXTMENU_COPY_HYPERLINK:
                this.viewer.selection.copyHyperlink();
                break;
            case id + CONTEXTMENU_EDIT_HYPERLINK:
            case id + CONTEXTMENU_HYPERLINK:
                if (this.viewer.owner.hyperlinkDialogModule) {
                    this.viewer.owner.hyperlinkDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_REMOVE_HYPERLINK:
                this.viewer.owner.editor.removeHyperlink();
                break;
            case id + CONTEXTMENU_PARAGRAPH:
                if (this.viewer.owner.paragraphDialogModule) {
                    this.viewer.owner.paragraphDialogModule.show();
                }
                break;
            case id + CONTEXTMENU_TABLE:
                this.viewer.owner.tablePropertiesDialogModule.show();
                break;
            case id + CONTEXTMENU_MERGE_CELL:
                this.viewer.owner.editor.mergeCells();
                break;
            case id + CONTEXTMENU_INSERT_ABOVE:
                this.viewer.owner.editor.insertRow(true);
                break;
            case id + CONTEXTMENU_INSERT_BELOW:
                this.viewer.owner.editor.insertRow(false);
                break;
            case id + CONTEXTMENU_INSERT_LEFT:
                this.viewer.owner.editor.insertColumn(true);
                break;
            case id + CONTEXTMENU_INSERT_RIGHT:
                this.viewer.owner.editor.insertColumn(false);
                break;
            case id + CONTEXTMENU_COMPLETE_DELETE_TABLE:
                this.viewer.owner.editor.deleteTable();
                break;
            case id + CONTEXTMENU_DELETE_ROW:
                this.viewer.owner.editor.deleteRow();
                break;
            case id + CONTEXTMENU_DELETE_COLUMN:
                this.viewer.owner.editor.deleteColumn();
                break;
            case id + CONTEXTMENU_CONTINUE_NUMBERING:
                this.viewer.owner.editorModule.applyContinueNumbering(this.viewer.selection);
                break;
            case id + CONTEXTMENU_RESTART_AT:
                this.viewer.owner.editorModule.applyRestartNumbering(this.viewer.selection);
                break;
            case id + CONTEXTMENU_AUTO_FIT_TO_CONTENTS:
                this.viewer.owner.editor.autoFitTable('FitToContents');
                break;
            case id + CONTEXTMENU_AUTO_FIT_TO_WINDOW:
                this.viewer.owner.editor.autoFitTable('FitToWindow');
                break;
            case id + CONTEXTMENU_FIXED_COLUMN_WIDTH:
                this.viewer.owner.editor.autoFitTable('FixedColumnWidth');
                break;
            case id + CONTEXTMENU_SPELLING_DIALOG:
                let contextInfo = this.spellChecker.retriveText();
                this.currentContextInfo = null;
                this.viewer.owner.spellCheckDialog.show(contextInfo.text, contextInfo.element);
                break;
            default:
                let expectedData = this.viewer.owner.element.id + CONTEXTMENU_SPELLCHECK_OTHERSUGGESTIONS;
                if (item.substring(0, expectedData.length) === expectedData) {
                    let content = item.substring(item.lastIndexOf('_') + 1);
                    this.callSelectedOption(content);
                    break;
                }
                else {
                    // fires customContextMenuSelect while selecting the added custom menu item
                    this.viewer.owner.fireCustomContextMenuSelect(item);
                    break;
                }
        }
    }
    /**
     * Method to call the selected item
     * @param {string} content
     */
    callSelectedOption(content) {
        if (content === 'Add To Dictionary') {
            this.spellChecker.handleAddToDictionary();
        }
        else if (content === 'Ignore All') {
            this.spellChecker.handleIgnoreAllItems();
        }
        else {
            this.spellChecker.manageReplace(content);
        }
    }
    /**
     * To add and customize custom context menu
     * @param {MenuItemModel[]} items - To add custom menu item
     * @param {boolean} isEnable - To hide existing menu item and show custom menu item alone
     * @param {boolean} isBottom - To show the custom menu item in bottom of the existing item
     */
    addCustomMenu(items, isEnable, isBottom) {
        let menuItems = JSON.parse(JSON.stringify(items));
        this.destroy();
        if (this.spellContextItems.length === 0) {
            this.customItems = items;
        }
        for (let index = 0; index < menuItems.length; index++) {
            this.customMenuItems.push(menuItems[index]);
            this.customMenuItems[index].id = this.viewer.owner.element.id + this.customMenuItems[index].id;
        }
        this.enableCustomContextMenu = isEnable;
        this.enableCustomContextMenuBottom = isBottom;
        this.initContextMenu(this.locale);
    }
    /**
     * Context Menu Items.
     * @param {MenuItemModel[]} menuItems - To add MenuItem to context menu
     * @private
     */
    addMenuItems(menuItems) {
        if (this.enableCustomContextMenuBottom) {
            return menuItems.concat(this.customMenuItems);
        }
        else {
            return this.customMenuItems.concat(menuItems);
        }
    }
    /**
     * Opens context menu.
     * @param {PointerEvent | TouchEvent} event
     */
    showContextMenuOnSel(event) {
        let isTouch = event instanceof TouchEvent;
        let xPos = 0;
        let yPos = 0;
        if (isTouch) {
            let point = this.viewer.getTouchOffsetValue(event);
            xPos = point.x;
            yPos = point.y;
        }
        else {
            yPos = event.y;
            xPos = event.x;
        }
        if (this.showHideElements(this.viewer.selection)) {
            if (isTouch) {
                this.viewer.isMouseDown = false;
            }
            this.contextMenuInstance.open(yPos, xPos);
            event.preventDefault();
        }
    }
    /**
     * Method to hide spell context items
     */
    hideSpellContextItems() {
        if (this.spellContextItems.length > 0) {
            for (let i = 0; i < this.spellContextItems.length; i++) {
                let item = document.getElementById(this.viewer.owner.element.id + this.spellContextItems[i].id);
                if (!isNullOrUndefined(item)) {
                    item.style.display = 'none';
                }
            }
        }
    }
    /**
     * Method to process suggestions to add in context menu
     * @param {any} allSuggestions
     * @param {string[]} splittedSuggestion
     * @param {PointerEvent} event
     * @private
     */
    /* tslint:disable:no-any */
    processSuggestions(allSuggestions, splittedSuggestion, event) {
        this.spellContextItems = this.constructContextmenu(allSuggestions, splittedSuggestion);
        this.addCustomMenu(this.spellContextItems);
        this.noSuggestion = document.getElementById(this.viewer.owner.element.id + CONTEXTMENU_NO_SUGGESTION);
        if (!isNullOrUndefined(this.noSuggestion)) {
            this.noSuggestion.style.display = 'block';
            classList(this.noSuggestion, ['e-disabled'], ['e-focused']);
        }
        this.showContextMenuOnSel(event);
    }
    /**
     * Method to add inline menu
     * @private
     */
    /* tslint:disable:no-any */
    constructContextmenu(allSuggestion, splittedSuggestion) {
        let contextMenuItems = this.customItems.length > 0 ? this.customItems.slice() : [];
        // classList(this.noSuggestion,['e-disabled'],[]);
        if (isNullOrUndefined(allSuggestion) || allSuggestion.length === 0) {
            contextMenuItems.push({ text: 'no suggestions', id: CONTEXTMENU_NO_SUGGESTION, classList: ['e-focused'], iconCss: '' });
        }
        else {
            for (let i = 0; i < allSuggestion.length; i++) {
                // tslint:disable-next-line:max-line-length
                contextMenuItems.push({ text: allSuggestion[i], id: CONTEXTMENU_SPELLCHECK_OTHERSUGGESTIONS + allSuggestion[i], iconCss: '' });
            }
        }
        contextMenuItems.push({ separator: true, id: '_contextmenu_suggestion_seperator' });
        if (!isNullOrUndefined(splittedSuggestion) && splittedSuggestion.length > 1) {
            contextMenuItems.push({ text: 'More Suggestion', items: splittedSuggestion });
            contextMenuItems.push({ separator: true, id: '_contextmenu_moreSuggestion_seperator' });
        }
        else {
            // tslint:disable-next-line:max-line-length
            contextMenuItems.push({ text: 'Add To Dictionary ', id: '_contextmenu_otherSuggestions_spellcheck_Add To Dictionary', iconCss: '' });
        }
        contextMenuItems.push({ text: 'Ignore Once', id: '_contextmenu_otherSuggestions_spellcheck_Ignore Once', iconCss: '' });
        contextMenuItems.push({ text: 'Ignore All', id: '_contextmenu_otherSuggestions_spellcheck_Ignore All', iconCss: '' });
        contextMenuItems.push({ separator: true, id: '_contextmenu_change_seperator' });
        // tslint:disable-next-line:max-line-length
        contextMenuItems.push({ text: this.locale.getConstant('Spelling'), id: CONTEXTMENU_SPELLING_DIALOG, iconCss: 'e-icons e-de-spellcheck', items: [] });
        contextMenuItems.push({ separator: true, id: '_contextmenu_spelling_seperator' });
        return contextMenuItems;
    }
    showHideElements(selection) {
        if (isNullOrUndefined(selection)) {
            return false;
        }
        selection.hideToolTip();
        let owner = this.viewer.owner;
        let id = owner.element.id;
        let copy = document.getElementById(id + CONTEXTMENU_COPY);
        let cut = document.getElementById(id + CONTEXTMENU_CUT);
        let paste = document.getElementById(id + CONTEXTMENU_PASTE);
        let updateField = document.getElementById(id + CONTEXTMENU_UPDATE_FIELD);
        let editField = document.getElementById(id + CONTEXTMENU_EDIT_FIELD);
        let font = document.getElementById(id + CONTEXTMENU_FONT_DIALOG);
        let paragraph = document.getElementById(id + CONTEXTMENU_PARAGRAPH);
        let tableProperties = document.getElementById(id + CONTEXTMENU_TABLE);
        let insertTable = document.getElementById(id + CONTEXTMENU_INSERT_TABLE);
        let deleteTable = document.getElementById(id + CONTEXTMENU_DELETE_TABLE);
        let mergeCells = document.getElementById(id + CONTEXTMENU_MERGE_CELL);
        let hyperlink = document.getElementById(id + CONTEXTMENU_HYPERLINK);
        let openHyperlink = document.getElementById(id + CONTEXTMENU_OPEN_HYPERLINK);
        let editHyperlink = document.getElementById(id + CONTEXTMENU_EDIT_HYPERLINK);
        let copyHyperlink = document.getElementById(id + CONTEXTMENU_COPY_HYPERLINK);
        let removeHyperlink = document.getElementById(id + CONTEXTMENU_REMOVE_HYPERLINK);
        let continueNumbering = document.getElementById(id + CONTEXTMENU_CONTINUE_NUMBERING);
        let restartAt = document.getElementById(id + CONTEXTMENU_RESTART_AT);
        let autoFitTable = document.getElementById(id + CONTEXTMENU_AUTO_FIT);
        let addComment = document.getElementById(id + CONTEXTMENU_ADD_COMMENT);
        cut.style.display = 'none';
        paste.style.display = 'none';
        paste.nextSibling.style.display = 'none';
        hyperlink.style.display = 'none';
        openHyperlink.style.display = 'none';
        copyHyperlink.style.display = 'none';
        editHyperlink.style.display = 'none';
        removeHyperlink.style.display = 'none';
        removeHyperlink.nextSibling.style.display = 'none';
        mergeCells.style.display = 'none';
        autoFitTable.style.display = 'none';
        font.style.display = 'none';
        paragraph.style.display = 'none';
        paragraph.nextSibling.style.display = 'none';
        insertTable.style.display = 'none';
        deleteTable.style.display = 'none';
        tableProperties.style.display = 'none';
        updateField.style.display = 'none';
        editField.style.display = 'none';
        continueNumbering.style.display = 'none';
        restartAt.style.display = 'none';
        restartAt.nextSibling.style.display = 'none';
        let isSelectionEmpty = selection.isEmpty;
        classList(cut, isSelectionEmpty ? ['e-disabled'] : [], !isSelectionEmpty ? ['e-disabled'] : []);
        classList(copy, isSelectionEmpty ? ['e-disabled'] : [], !isSelectionEmpty ? ['e-disabled'] : []);
        addComment.style.display = this.viewer.owner.isReadOnlyMode ? 'none' : 'block';
        addComment.previousSibling.style.display = this.viewer.owner.isReadOnlyMode ? 'none' : 'block';
        addComment.nextSibling.style.display = this.viewer.owner.isReadOnlyMode ? 'none' : 'block';
        if (owner.isReadOnlyMode) {
            return true;
        }
        if (this.viewer && this.viewer.owner && this.viewer.owner.commentReviewPane &&
            this.viewer.owner.commentReviewPane.commentPane.isEditMode) {
            classList(addComment, ['e-disabled'], []);
        }
        else {
            classList(addComment, [], ['e-disabled']);
        }
        cut.style.display = 'block';
        paste.style.display = 'block';
        paste.nextSibling.style.display = 'block';
        classList(insertTable, ['e-blankicon'], []);
        classList(deleteTable, ['e-blankicon'], []);
        classList(updateField, ['e-blankicon'], []);
        classList(editField, ['e-blankicon'], []);
        classList(autoFitTable, ['e-blankicon'], []);
        let enablePaste = (owner.enableLocalPaste && !isNullOrUndefined(owner.editor.copiedData));
        classList(paste, enablePaste ? [] : ['e-disabled'], enablePaste ? ['e-disabled'] : []);
        if (selection.contextType === 'TableOfContents') {
            updateField.style.display = 'block';
            editField.style.display = 'block';
        }
        else {
            let start = selection.start;
            let end = selection.end;
            if (selection.contextType === 'List'
                && owner.editorModule.getListLevel(start.paragraph).listLevelPattern !== 'Bullet') {
                continueNumbering.style.display = 'block';
                restartAt.style.display = 'block';
                restartAt.nextSibling.style.display = 'block';
            }
            let isCellOrRowSelected = start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
                || start.paragraph.associatedCell !== end.paragraph.associatedCell
                || selection.isCellSelected(start.paragraph.associatedCell, start, end));
            if (isCellOrRowSelected) {
                hyperlink.classList.add('e-disabled');
            }
            else {
                if (hyperlink.classList.contains('e-disabled')) {
                    hyperlink.classList.remove('e-disabled');
                }
            }
            let field = selection.getHyperlinkField();
            if (field instanceof FieldElementBox && !selection.isImageField()) {
                openHyperlink.style.display = 'block';
                copyHyperlink.style.display = 'block';
                if (owner.hyperlinkDialogModule) {
                    editHyperlink.style.display = 'block';
                }
                removeHyperlink.style.display = 'block';
                removeHyperlink.nextSibling.style.display = 'block';
            }
            else {
                if (owner.hyperlinkDialogModule) {
                    hyperlink.style.display = 'block';
                }
            }
        }
        if (this.viewer.owner.selection.start.paragraph.isInsideTable
            && this.viewer.owner.selection.end.paragraph.isInsideTable) {
            paragraph.nextSibling.style.display = 'block';
            if (owner.tablePropertiesDialogModule) {
                tableProperties.style.display = 'block';
            }
            insertTable.style.display = 'block';
            deleteTable.style.display = 'block';
            if (this.viewer.owner.editor.canMergeCells()) {
                mergeCells.style.display = 'block';
            }
            autoFitTable.style.display = this.viewer.selection.isTableSelected() ? 'block' : 'none';
        }
        else {
            if (this.viewer.owner.fontDialogModule) {
                font.style.display = 'block';
                font.previousSibling.style.display = 'block';
            }
            if (this.viewer.owner.paragraphDialogModule) {
                paragraph.style.display = 'block';
            }
        }
        if (selection.contextType === 'Image') {
            font.style.display = 'none';
            paragraph.style.display = 'none';
            removeHyperlink.nextSibling.style.display = 'none';
        }
        return true;
    }
    /**
     * Disposes the internal objects which are maintained.
     * @private
     */
    destroy() {
        if (this.contextMenuInstance) {
            this.contextMenuInstance.destroy();
        }
        if (this.contextMenu && this.contextMenu.parentElement) {
            this.contextMenu.parentElement.removeChild(this.contextMenu);
            this.contextMenu.innerHTML = '';
        }
        this.contextMenu = undefined;
        this.contextMenuInstance = undefined;
        this.menuItems = [];
        this.customMenuItems = [];
        this.ids = [];
    }
}

/**
 * @private
 */
class WAbstractList {
    constructor() {
        this.abstractListIdIn = -1;
        this.levels = [];
    }
    get abstractListId() {
        return this.abstractListIdIn;
    }
    set abstractListId(abstractListId) {
        this.abstractListIdIn = abstractListId;
    }
    destroy() {
        if (!isNullOrUndefined(this.levels)) {
            for (let i = 0; i < this.levels.length; i++) {
                let listLevel = this.levels[i];
                listLevel.destroy();
                this.levels.splice(this.levels.indexOf(listLevel), 1);
                i--;
            }
            this.levels = [];
        }
        this.levels = undefined;
    }
}

/**
 * @private
 */
class WListLevel {
    constructor(node) {
        this.uniqueListLevel = undefined;
        this.paragraphFormat = undefined;
        this.characterFormat = undefined;
        if (node instanceof WAbstractList) {
            this.ownerBase = node;
        }
        else {
            this.ownerBase = node;
        }
        this.characterFormat = new WCharacterFormat(undefined);
        this.paragraphFormat = new WParagraphFormat(undefined);
    }
    get listLevelPattern() {
        return this.getPropertyValue('listLevelPattern');
    }
    set listLevelPattern(listLevelPattern) {
        this.setPropertyValue('listLevelPattern', listLevelPattern);
    }
    get followCharacter() {
        return this.getPropertyValue('followCharacter');
    }
    set followCharacter(followCharacter) {
        this.setPropertyValue('followCharacter', followCharacter);
    }
    get startAt() {
        return this.getPropertyValue('startAt');
    }
    set startAt(startAt) {
        this.setPropertyValue('startAt', startAt);
    }
    get numberFormat() {
        return this.getPropertyValue('numberFormat');
    }
    set numberFormat(numberFormat) {
        this.setPropertyValue('numberFormat', numberFormat);
    }
    get restartLevel() {
        return this.getPropertyValue('restartLevel');
    }
    set restartLevel(restartLevel) {
        this.setPropertyValue('restartLevel', restartLevel);
    }
    getPropertyValue(property) {
        let propertyType = WUniqueFormat.getPropertyType(WListLevel.uniqueFormatType, property);
        if (!isNullOrUndefined(this.uniqueListLevel) && this.uniqueListLevel.propertiesHash.containsKey(propertyType)) {
            return this.uniqueListLevel.propertiesHash.get(propertyType);
        }
        return WListLevel.getPropertyDefaultValue(property);
    }
    setPropertyValue(property, value) {
        if (isNullOrUndefined(value) || value === '') {
            value = WListLevel.getPropertyDefaultValue(property);
        }
        if (isNullOrUndefined(this.uniqueListLevel)) {
            this.initializeUniqueWListLevel(property, value);
        }
        else {
            let propertyType = WUniqueFormat.getPropertyType(this.uniqueListLevel.uniqueFormatType, property);
            if (this.uniqueListLevel.propertiesHash.containsKey(propertyType) &&
                // tslint:disable-next-line:max-line-length
                this.uniqueListLevel.propertiesHash.get(propertyType) === value) { //Do nothing, since no change in property value and return
                return;
            }
            // tslint:disable-next-line:max-line-length
            this.uniqueListLevel = WListLevel.uniqueListLevels.updateUniqueFormat(this.uniqueListLevel, property, value);
        }
    }
    initializeUniqueWListLevel(property, propValue) {
        let uniqueListLevelTemp = new Dictionary();
        this.addUniqueWListLevel('listLevelPattern', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('startAt', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('followCharacter', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('numberFormat', property, propValue, uniqueListLevelTemp);
        this.addUniqueWListLevel('restartLevel', property, propValue, uniqueListLevelTemp);
        // tslint:disable-next-line:max-line-length    
        this.uniqueListLevel = WListLevel.uniqueListLevels.addUniqueFormat(uniqueListLevelTemp, WListLevel.uniqueFormatType);
    }
    // tslint:disable-next-line:max-line-length
    addUniqueWListLevel(property, modifiedProperty, propValue, uniqueCharFormatTemp) {
        let propertyType;
        propertyType = WUniqueFormat.getPropertyType(WListLevel.uniqueFormatType, property);
        if (property === modifiedProperty) {
            uniqueCharFormatTemp.add(propertyType, propValue);
        }
        else {
            uniqueCharFormatTemp.add(propertyType, WListLevel.getPropertyDefaultValue(property));
        }
    }
    static getPropertyDefaultValue(property) {
        let value = undefined;
        switch (property) {
            case 'listLevelPattern':
                value = 'Arabic';
                break;
            case 'startAt':
                value = 0;
                break;
            case 'followCharacter':
                value = 'Tab';
                break;
            case 'numberFormat':
                value = '';
                break;
            case 'restartLevel':
                value = 0;
                break;
        }
        return value;
    }
    destroy() {
        if (!isNullOrUndefined(this.characterFormat)) {
            this.characterFormat.destroy();
        }
        if (!isNullOrUndefined(this.paragraphFormat)) {
            this.paragraphFormat.destroy();
        }
        if (!isNullOrUndefined(this.uniqueListLevel)) {
            WListLevel.uniqueListLevels.remove(this.uniqueListLevel);
        }
        this.uniqueListLevel = undefined;
        this.characterFormat = undefined;
        this.paragraphFormat = undefined;
    }
    static clear() {
        this.uniqueListLevels.clear();
    }
}
WListLevel.dotBullet = '\uf0b7';
WListLevel.squareBullet = '\uf0a7'; //Symbol font \u25aa.
WListLevel.arrowBullet = '\u27a4';
WListLevel.circleBullet = '\uf06f' + '\u0020';
WListLevel.uniqueListLevels = new WUniqueFormats();
WListLevel.uniqueFormatType = 9;

/**
 * List implementation
 */

/**
 * @private
 */
class Layout {
    /**
     * viewer definition
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.allowLayout = true;
        /**
         * @private
         */
        this.isInitialLoad = true;
        this.fieldBegin = undefined;
        this.maxTextHeight = 0;
        this.maxBaseline = 0;
        this.maxTextBaseline = 0;
        this.isFieldCode = false;
        this.isRTLLayout = false;
        /**
         * @private
         */
        this.isBidiReLayout = false;
        /**
         * @private
         */
        this.defaultTabWidthPixel = 48;
        this.viewer = viewer;
    }
    isSameStyle(currentParagraph, isAfterSpacing) {
        let nextOrPrevSibling = undefined;
        if (isAfterSpacing) {
            if (currentParagraph.nextWidget instanceof ParagraphWidget) {
                nextOrPrevSibling = currentParagraph.nextWidget;
            }
        }
        else {
            if (currentParagraph.previousWidget instanceof ParagraphWidget) {
                nextOrPrevSibling = currentParagraph.previousWidget;
            }
        }
        if (isNullOrUndefined(nextOrPrevSibling)) {
            return false;
        }
        if (currentParagraph.paragraphFormat.baseStyle === nextOrPrevSibling.paragraphFormat.baseStyle) {
            return currentParagraph.paragraphFormat.contextualSpacing;
        }
        return false;
    }
    /**
     * @private
     */
    layout() {
        // Todo: Need to handle complete document layout(relayout).
        let page = this.viewer.pages[0];
        let body = page.bodyWidgets[0];
    }
    /**
     * Releases un-managed and - optionally - managed resources.
     */
    destroy() {
        this.viewer = undefined;
        this.value = undefined;
        this.allowLayout = undefined;
        this.isInitialLoad = undefined;
        this.fieldBegin = undefined;
        this.maxTextHeight = undefined;
        this.maxBaseline = undefined;
        this.maxTextBaseline = undefined;
        this.isFieldCode = undefined;
    }
    /**
     * Layouts the items
     * @private
     */
    layoutItems(sections) {
        let page;
        for (let i = 0; i < sections.length; i++) {
            let section = sections[i];
            page = this.viewer.createNewPage(section);
            this.addBodyWidget(this.viewer.clientActiveArea, section);
            if (this.viewer.pages.length > 1) {
                let pageIndex = 0;
                for (let i = 0; i < this.viewer.pages.length; i++) {
                    let prevPage = this.viewer.pages[i];
                    let prevSectionIndex = prevPage.sectionIndex;
                    let index = section.index;
                    if (prevSectionIndex > index || prevPage === page) {
                        break;
                    }
                    pageIndex++;
                }
                if (pageIndex < this.viewer.pages.length - 1) {
                    this.viewer.insertPage(pageIndex, page);
                }
            }
            this.layoutSection(section, 0, this.viewer);
        }
        this.layoutComments(this.viewer.comments);
        this.updateFieldElements();
        /* tslint:disable:align */
        setTimeout(() => {
            if (this.viewer) {
                this.viewer.isScrollHandler = true;
                if (this.viewer.owner.enableSpellCheck && this.viewer.owner.spellChecker.enableOptimizedSpellCheck) {
                    this.viewer.triggerElementsOnLoading = true;
                }
                this.viewer.updateScrollBars();
                this.viewer.isScrollHandler = false;
                this.isInitialLoad = false;
            }
        }, 50);
    }
    /**
     * Layouts the comments
     * @param comments
     * @private
     */
    layoutComments(comments) {
        if (!isNullOrUndefined(comments)) {
            this.viewer.owner.commentReviewPane.layoutComments();
        }
    }
    /**
     * Layouts the items
     * @param section
     * @param viewer
     * @private
     */
    layoutSection(section, index, viewer, ownerWidget) {
        let block = section.firstChild;
        let nextBlock;
        do {
            if (block instanceof TableWidget && block.tableFormat.preferredWidthType === 'Auto'
                && !block.tableFormat.allowAutoFit) {
                block.calculateGrid();
            }
            this.viewer.updateClientAreaForBlock(block, true);
            nextBlock = this.layoutBlock(block, index);
            index = 0;
            this.viewer.updateClientAreaForBlock(block, false);
            block = nextBlock;
        } while (block);
    }
    /**
     * Layouts the header footer items
     * @param section
     * @param viewer
     * @private
     */
    layoutHeaderFooter(section, viewer, page) {
        //Header layout
        let headerFooterWidget = viewer.getCurrentPageHeaderFooter(section, true);
        if (headerFooterWidget) {
            let header = headerFooterWidget.clone();
            header.page = page;
            viewer.updateHFClientArea(section.sectionFormat, true);
            page.headerWidget = this.layoutHeaderFooterItems(viewer, header);
            this.updateHeaderFooterToParent(header);
        }
        //Footer Layout
        headerFooterWidget = viewer.getCurrentPageHeaderFooter(section, false);
        if (headerFooterWidget) {
            let footer = headerFooterWidget.clone();
            footer.page = page;
            viewer.updateHFClientArea(section.sectionFormat, false);
            page.footerWidget = this.layoutHeaderFooterItems(viewer, footer);
            this.updateHeaderFooterToParent(footer);
        }
    }
    /**
     * @private
     */
    updateHeaderFooterToParent(node) {
        let sectionIndex = node.page.sectionIndex;
        let typeIndex = this.viewer.getHeaderFooter(node.headerFooterType);
        let clone = node.clone();
        this.viewer.headersFooters[sectionIndex][typeIndex] = clone;
        for (let j = 0; j < clone.childWidgets.length; j++) {
            let child = clone.childWidgets[j];
            if (child instanceof TableWidget) {
                this.clearTableWidget(child, false, true);
            }
        }
        return clone;
    }
    linkFieldInHeaderFooter(widget) {
        let firstChild = widget.firstChild;
        do {
            if (firstChild instanceof ParagraphWidget) {
                this.linkFieldInParagraph(firstChild);
            }
            else {
                this.linkFieldInTable(firstChild);
            }
            //tslint:disable:no-conditional-assignment
        } while (firstChild = firstChild.nextWidget);
    }
    /**
     * @private
     */
    linkFieldInParagraph(widget) {
        for (let j = 0; j < widget.childWidgets.length; j++) {
            let line = widget.childWidgets[j];
            for (let i = 0; i < line.children.length; i++) {
                let element = line.children[i];
                if (element instanceof FieldElementBox && element.fieldType !== 0) {
                    element.linkFieldCharacter(this.viewer);
                }
            }
        }
    }
    /**
     * @private
     */
    linkFieldInTable(widget) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let row = widget.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                for (let k = 0; k < cell.childWidgets.length; k++) {
                    let block = cell.childWidgets[k];
                    if (block instanceof ParagraphWidget) {
                        this.linkFieldInParagraph(block);
                    }
                    else {
                        this.linkFieldInTable(block);
                    }
                }
            }
        }
    }
    /**
     * Layouts the header footer items.
     * @param viewer
     * @param hfModule
     * @private
     */
    layoutHeaderFooterItems(viewer, widget) {
        this.viewer.updateClientAreaLocation(widget, viewer.clientActiveArea);
        if (widget.childWidgets.length === 0) {
            let pargaraph = new ParagraphWidget();
            let line = new LineWidget(pargaraph);
            pargaraph.childWidgets.push(line);
            widget.childWidgets.push(pargaraph);
            pargaraph.containerWidget = widget;
        }
        this.linkFieldInHeaderFooter(widget);
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let block = widget.childWidgets[i];
            if (block instanceof TableWidget && block.tableFormat.preferredWidthType === 'Auto'
                && !block.tableFormat.allowAutoFit && !block.isGridUpdated) {
                block.calculateGrid();
            }
            viewer.updateClientAreaForBlock(block, true);
            this.layoutBlock(block, 0);
            viewer.updateClientAreaForBlock(block, false);
        }
        let type = widget.headerFooterType;
        if (type === 'OddFooter' || type === 'EvenFooter' || type === 'FirstPageFooter') {
            this.shiftChildLocation(viewer.clientArea.y - viewer.clientActiveArea.y, widget);
        }
        return widget;
    }
    /**
     * Shifts the child location
     * @param shiftTop
     * @param bodyWidget
     */
    shiftChildLocation(shiftTop, bodyWidget) {
        let widgetTop = bodyWidget.y + shiftTop;
        let footerMaxHeight = bodyWidget.page.boundingRectangle.height - (bodyWidget.page.boundingRectangle.height / 100) * 40;
        widgetTop = Math.max(widgetTop, footerMaxHeight);
        shiftTop = widgetTop - bodyWidget.y;
        let childTop = bodyWidget.y = widgetTop;
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let childWidget = bodyWidget.childWidgets[i];
            if (childWidget instanceof ParagraphWidget) {
                childWidget.x = childWidget.x;
                childWidget.y = i === 0 ? childWidget.y + shiftTop : childTop;
                childTop += childWidget.height;
            }
            else {
                this.shiftChildLocationForTableWidget(childWidget, shiftTop);
            }
        }
    }
    /**
     * Shifts the child location for table widget.
     * @param tableWidget
     * @param shiftTop
     */
    shiftChildLocationForTableWidget(tableWidget, shiftTop) {
        tableWidget.y = tableWidget.y + shiftTop;
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let childWidget = tableWidget.childWidgets[i];
            if (childWidget instanceof TableRowWidget) {
                this.shiftChildLocationForTableRowWidget(childWidget, shiftTop);
            }
        }
    }
    /**
     * Shifts the child location for table row widget.
     * @param rowWidget
     * @param shiftTop
     */
    shiftChildLocationForTableRowWidget(rowWidget, shiftTop) {
        rowWidget.y = rowWidget.y + shiftTop;
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            this.shiftChildLocationForTableCellWidget(rowWidget.childWidgets[i], shiftTop);
        }
    }
    /**
     * Shifts the child location for table cell widget.
     * @param cellWidget
     * @param shiftTop
     */
    shiftChildLocationForTableCellWidget(cellWidget, shiftTop) {
        cellWidget.y = cellWidget.y + shiftTop;
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                cellWidget.childWidgets[i].x = cellWidget.childWidgets[i].x;
                cellWidget.childWidgets[i].y = cellWidget.childWidgets[i].y + shiftTop;
            }
            else {
                this.shiftChildLocationForTableWidget(cellWidget.childWidgets[i], shiftTop);
            }
        }
    }
    /**
     * Layouts specified block.
     * @param block
     * @private
     */
    layoutBlock(block, index, moveToLine) {
        let nextBlock;
        if (block instanceof ParagraphWidget) {
            nextBlock = this.layoutParagraph(block, index);
        }
        else {
            nextBlock = this.layoutTable(block, index);
        }
        return nextBlock.nextRenderedWidget;
    }
    /**
     * Adds paragraph widget.
     * @param area
     */
    addParagraphWidget(area, paragraphWidget) {
        if (paragraphWidget.isEmpty() && !isNullOrUndefined(paragraphWidget.paragraphFormat) &&
            (paragraphWidget.paragraphFormat.textAlignment === 'Center' || paragraphWidget.paragraphFormat.textAlignment === 'Right') &&
            paragraphWidget.paragraphFormat.listFormat.listId === -1) {
            let width = this.viewer.textHelper.getParagraphMarkWidth(paragraphWidget.characterFormat);
            let left = area.x;
            if (paragraphWidget.paragraphFormat.textAlignment === 'Center') {
                left += (area.width - width) / 2;
            }
            else {
                left += area.width - width;
            }
            paragraphWidget.width = width;
            paragraphWidget.x = left;
            paragraphWidget.y = area.y;
        }
        else {
            paragraphWidget.width = area.width;
            paragraphWidget.x = area.x;
            paragraphWidget.y = area.y;
        }
        return paragraphWidget;
    }
    /**
     * Adds line widget.
     * @param paragraph
     */
    addLineWidget(paragraphWidget) {
        let line = undefined;
        line = new LineWidget(paragraphWidget);
        line.width = paragraphWidget.width;
        paragraphWidget.childWidgets.push(line);
        line.paragraph = paragraphWidget;
        return line;
    }
    isFirstElementWithPageBreak(paragraphWidget) {
        let isPageBreak = false;
        let lineWidget = paragraphWidget.childWidgets[0];
        if (lineWidget) {
            let element = lineWidget.children[0];
            while (element) {
                if (element instanceof BookmarkElementBox && element.name.indexOf('_') >= 0) {
                    element = element.nextElement;
                    continue;
                }
                if (element instanceof TextElementBox && element.text === '\f') {
                    isPageBreak = true;
                }
                break;
            }
        }
        return isPageBreak;
    }
    ;
    /**
     * Layouts specified paragraph.
     * @private
     * @param paragraph
     */
    layoutParagraph(paragraph, lineIndex) {
        this.addParagraphWidget(this.viewer.clientActiveArea, paragraph);
        let isListLayout = true;
        let isFirstElmIsparagraph = this.isFirstElementWithPageBreak(paragraph);
        if (!isFirstElmIsparagraph) {
            this.layoutListItems(paragraph);
            isListLayout = false;
        }
        if (paragraph.isEmpty()) {
            this.layoutEmptyLineWidget(paragraph, true);
        }
        else {
            let line = lineIndex < paragraph.childWidgets.length ?
                paragraph.childWidgets[lineIndex] : undefined;
            while (line instanceof LineWidget) {
                if (paragraph !== line.paragraph && line.indexInOwner === 0 && isListLayout) {
                    this.layoutListItems(line.paragraph);
                }
                if (line.isFirstLine() && isNullOrUndefined(this.fieldBegin)) {
                    if (!isNullOrUndefined(paragraph.paragraphFormat)) {
                        // tslint:disable-next-line:max-line-length
                        let firstLineIndent = -HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
                        this.viewer.updateClientWidth(firstLineIndent);
                    }
                }
                line = this.layoutLine(line, 0);
                paragraph = line.paragraph;
                line = line.nextLine;
            }
        }
        this.updateWidgetToPage(this.viewer, paragraph);
        return paragraph;
    }
    clearLineMeasures() {
        this.maxBaseline = 0;
        this.maxTextBaseline = 0;
        this.maxTextHeight = 0;
    }
    moveElementFromNextLine(line) {
        let nextLine = line.nextLine;
        while (nextLine instanceof LineWidget) {
            if (nextLine.children.length > 0) {
                let element = nextLine.children.splice(0, 1)[0];
                line.children.push(element);
                element.line = line;
                break;
            }
            else {
                if (nextLine.paragraph.childWidgets.length === 1) {
                    nextLine.paragraph.destroy();
                }
                else {
                    nextLine.destroy();
                }
                nextLine = line.nextLine;
            }
        }
    }
    layoutLine(line, count) {
        let paragraph = line.paragraph;
        if (line.children.length === 0) {
            this.moveElementFromNextLine(line);
        }
        let element = line.children[count];
        this.clearLineMeasures();
        while (element instanceof ElementBox) {
            this.layoutElement(element, paragraph);
            line = element.line;
            if (element instanceof TextElementBox) {
                let textElement = element;
                if (!isNullOrUndefined(textElement.errorCollection) && textElement.errorCollection.length > 0) {
                    textElement.ischangeDetected = true;
                }
            }
            if (!this.isRTLLayout) {
                element = element.nextElement;
            }
            else {
                element = undefined;
                this.isRTLLayout = false;
            }
        }
        return line;
    }
    // tslint:disable:max-func-body-length
    layoutElement(element, paragraph) {
        let line = element.line;
        let text = '';
        let index = element.indexInOwner;
        if (element instanceof FieldElementBox) {
            if (element.fieldType === 0 && this.viewer.fields.indexOf(element) === -1) {
                this.viewer.fields.push(element);
            }
            this.layoutFieldCharacters(element);
            if (element.line.isLastLine() && isNullOrUndefined(element.nextNode) && !this.isFieldCode) {
                if (isNullOrUndefined(element.fieldSeparator)) {
                    this.layoutEmptyLineWidget(paragraph, false, element.line);
                }
                this.moveToNextLine(line);
            }
            else if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            else if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width === 0) {
                this.moveToNextLine(line);
                if (line.paragraph.lastChild === line && !isNullOrUndefined(line.nextLine) &&
                    this.viewer.clientActiveArea.height >= 0) {
                    this.moveFromNextPage(line);
                }
            }
            return;
        }
        if (element instanceof ListTextElementBox || this.isFieldCode || element instanceof BookmarkElementBox ||
            element instanceof EditRangeEndElementBox || element instanceof EditRangeStartElementBox) {
            if (element instanceof BookmarkElementBox) {
                if (element.bookmarkType === 0 && !this.viewer.bookmarks.containsKey(element.name)) {
                    this.viewer.bookmarks.add(element.name, element);
                }
                else if (element.bookmarkType === 1 && this.viewer.bookmarks.containsKey(element.name)) {
                    let bookmrkElement = this.viewer.bookmarks.get(element.name);
                    if (isNullOrUndefined(bookmrkElement.reference)) {
                        bookmrkElement.reference = element;
                        element.reference = bookmrkElement;
                    }
                }
            }
            if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            if (element.line.isLastLine() && isNullOrUndefined(element.nextElement)) {
                if (this.hasValidElement(line.paragraph)) {
                    this.moveToNextLine(line);
                }
                else {
                    this.layoutEmptyLineWidget(line.paragraph, false, line, false);
                }
            }
            return;
        }
        let width = element.width;
        if (element instanceof FieldTextElementBox) {
            text = this.viewer.getFieldResult(element.fieldBegin, element.paragraph.bodyWidget.page);
            if (text !== '') {
                element.text = text;
            }
            else {
                text = element.text;
            }
        }
        else if (element instanceof TextElementBox) {
            this.checkAndSplitTabOrLineBreakCharacter(element.text, element);
            this.splitBySpecialCharacters(element);
            text = element.text;
        }
        // Here field code width and height update need to skipped based on the hidden property.
        if (element instanceof TextElementBox) {
            width = this.viewer.textHelper.getTextSize(element, element.characterFormat);
            if (element.text === '\t') {
                element.width = this.getTabWidth(paragraph, this.viewer, index, line, element);
            }
        }
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, line);
            if (element instanceof FieldTextElementBox) {
                this.updateFieldText(element);
            }
            if (element.previousElement) {
                this.cutClientWidth(element.previousElement);
            }
        }
        if (parseFloat(width.toFixed(4)) <= parseFloat(this.viewer.clientActiveArea.width.toFixed(4)) || !this.viewer.textWrap) {
            //Fits the text in current line.
            this.addElementToLine(paragraph, element);
            if (isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width > 0 && !element.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
            else if (!element.line.isLastLine() && isNullOrUndefined(element.nextElement) && this.viewer.clientActiveArea.width === 0) {
                this.moveToNextLine(line);
                if (line.paragraph.lastChild === line && this.viewer.clientActiveArea.height >= 0) {
                    this.moveFromNextPage(line);
                }
            }
        }
        else if (element instanceof TextElementBox) {
            if (element.text === '\t') {
                let currentLine = element.line;
                this.addSplittedLineWidget(currentLine, currentLine.children.indexOf(element) - 1);
                this.moveToNextLine(currentLine);
                // Recalculates tab width based on new client active area X position
                element.width = this.getTabWidth(paragraph, this.viewer, index, element.line, element);
                this.addElementToLine(paragraph, element);
            }
            else {
                //Splits the text and arrange line by line, till end of text.
                do {
                    line = element.line;
                    this.splitTextForClientArea(line, element, element.text, element.width, element.characterFormat);
                    this.checkLineWidgetWithClientArea(line, element);
                    if (element instanceof FieldTextElementBox) {
                        this.updateFieldText(element);
                    }
                } while (element.line !== line && this.cutClientWidth(element));
            }
        }
        else {
            do {
                line = element.line;
                this.splitElementForClientArea(paragraph, element);
                this.checkLineWidgetWithClientArea(line, element);
                if (element instanceof FieldTextElementBox) {
                    this.updateFieldText(element);
                }
            } while (element.line !== line && this.cutClientWidth(element));
        }
        if (text === '\v' || text === '\f') {
            let elementIndex = line.children.indexOf(element);
            if (elementIndex > -1) {
                this.addSplittedLineWidget(line, elementIndex);
            }
        }
        if (element.line.isLastLine() && isNullOrUndefined(element.nextElement) || text === '\v' || text === '\f') {
            this.moveToNextLine(element.line);
            if (text === '\v' && isNullOrUndefined(element.nextNode)) {
                this.layoutEmptyLineWidget(paragraph, true, line, true);
            }
            else if (text === '\f') {
                if (isNullOrUndefined(element.nextNode)) {
                    this.moveToNextPage(this.viewer, element.line, true);
                }
                else {
                    this.moveToNextPage(this.viewer, element.line.nextLine, false);
                }
            }
        }
    }
    /**
     * Return true if paragraph has valid inline
     * @private
     */
    hasValidElement(paragraph) {
        let line = paragraph.firstChild;
        if (line && !isNullOrUndefined(this.viewer.selection)) {
            let elementBox = line.children[0];
            while (elementBox) {
                if (elementBox instanceof FieldElementBox) {
                    elementBox = this.viewer.selection.getNextValidElementForField(elementBox);
                    if (!elementBox.line.paragraph.equals(paragraph)) {
                        return false;
                    }
                }
                if (elementBox instanceof TextElementBox || elementBox instanceof ImageElementBox) {
                    return true;
                }
                elementBox = elementBox.nextNode;
            }
        }
        return false;
    }
    updateFieldText(element) {
        // tslint:disable-next-line:max-line-length
        let text = this.viewer.getFieldResult(element.fieldBegin, element.paragraph.bodyWidget.page);
        if (text !== '') {
            element.text = text;
            this.viewer.textHelper.getTextSize(element, element.characterFormat);
        }
    }
    checkLineWidgetWithClientArea(line, element) {
        if (line !== element.line || element.line === line && isNullOrUndefined(element.nextElement)
            && !element.line.isLastLine()) {
            this.moveToNextLine(line);
            if (line !== element.line) {
                this.isRTLLayout = false;
            }
        }
        if (element.line !== line && this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height &&
            this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, element.line);
        }
        else if (element.line === line && isNullOrUndefined(element.nextElement)
            && line.paragraph.lastChild === line && !line.isLastLine() && this.viewer.clientActiveArea.height >= 0) {
            this.moveFromNextPage(line);
        }
    }
    checkAndSplitTabOrLineBreakCharacter(text, element) {
        let char = ['\t', '\v', '\f'];
        let index = HelperMethods.indexOfAny(text, char);
        if (index > -1) {
            let character = text[index];
            if ((character === '\t' && text !== '\t') || (character === '\v' && text !== '\v')
                || (character === '\f' && text !== '\f')) {
                this.splitByLineBreakOrTab(this.viewer, element, index, character);
            }
        }
    }
    splitBySpecialCharacters(span) {
        if (this.viewer.textHelper.isRTLText(span.text) && this.viewer.textHelper.containsSpecialChar(span.text)) {
            let inlineIndex = span.line.children.indexOf(span);
            let text = span.text;
            let specialChars = '*|.\:[]{}`\;()@&$#%!~';
            let textToReplace = '';
            let spanTextUpdated = false;
            for (let i = 0; i < text.length; i++) {
                if (specialChars.indexOf(text.charAt(i)) !== -1) {
                    if (spanTextUpdated && textToReplace !== '') {
                        let newSpan1 = new TextElementBox();
                        newSpan1.line = span.line;
                        newSpan1.characterFormat.copyFormat(span.characterFormat);
                        span.line.children.splice(inlineIndex = inlineIndex + 1, 0, newSpan1);
                        newSpan1.text = textToReplace;
                    }
                    let newSpan = new TextElementBox();
                    newSpan.line = span.line;
                    newSpan.characterFormat.copyFormat(span.characterFormat);
                    span.line.children.splice(inlineIndex = inlineIndex + 1, 0, newSpan);
                    newSpan.text = text.charAt(i);
                    if (!spanTextUpdated) {
                        span.text = textToReplace;
                        spanTextUpdated = true;
                    }
                    textToReplace = '';
                }
                else {
                    textToReplace += text.charAt(i);
                }
            }
            if (spanTextUpdated && textToReplace !== '') {
                let newSpan2 = new TextElementBox();
                newSpan2.line = span.line;
                newSpan2.characterFormat.copyFormat(span.characterFormat);
                span.line.children.splice(inlineIndex = inlineIndex + 1, 0, newSpan2);
                newSpan2.text = textToReplace;
            }
        }
    }
    /**
     * @private
     */
    moveFromNextPage(line) {
        let nextLine = line.nextLine;
        if (nextLine && line.paragraph.childWidgets.indexOf(nextLine) === -1) {
            nextLine.paragraph.childWidgets.splice(nextLine.indexInOwner, 1);
            line.paragraph.childWidgets.push(nextLine);
            nextLine.paragraph = line.paragraph;
        }
    }
    cutClientWidth(currentElement) {
        this.clearLineMeasures();
        let line = currentElement.line;
        let width = 0;
        for (let i = 0; i < line.children.length; i++) {
            let element = line.children[i];
            width += element.width;
            if (currentElement === element) {
                break;
            }
        }
        let splitCurrentWidget = this.viewer.clientActiveArea.width - width < 0;
        if (!splitCurrentWidget) {
            this.viewer.cutFromLeft(this.viewer.clientActiveArea.x + width);
            if (currentElement.line.paragraph.paragraphFormat.textAlignment === 'Justify' &&
                currentElement instanceof TextElementBox) {
                this.splitTextElementWordByWord(currentElement);
            }
            if (isNullOrUndefined(currentElement.nextElement) && this.viewer.clientActiveArea.width > 0
                && !currentElement.line.isLastLine()) {
                this.moveElementFromNextLine(line);
            }
        }
        else if (currentElement.previousElement) {
            this.cutClientWidth(currentElement.previousElement);
        }
        return splitCurrentWidget;
    }
    layoutFieldCharacters(element) {
        if (element.fieldType === 0) {
            if (!this.isFieldCode && (!isNullOrUndefined(element.fieldEnd) || element.hasFieldEnd)) {
                this.viewer.fieldStacks.push(element);
                this.isFieldCode = true;
                element.hasFieldEnd = true;
            }
        }
        else if (this.viewer.fieldStacks.length > 0) {
            if (element.fieldType === 2) {
                let field = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                if (field.fieldSeparator === element && (!isNullOrUndefined(field.fieldEnd) || field.hasFieldEnd)) {
                    this.isFieldCode = false;
                }
            }
            else {
                let field = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                if (element === field.fieldEnd) {
                    this.viewer.fieldStacks.pop();
                    this.isFieldCode = false;
                }
            }
        }
    }
    /**
     * Layouts empty line widget.
     */
    // tslint:disable-next-line:max-line-length
    layoutEmptyLineWidget(paragraph, isEmptyLine, line, isShiftEnter) {
        let paraFormat = paragraph.paragraphFormat;
        let subWidth = 0;
        let whiteSpaceCount = 0;
        isShiftEnter = isNullOrUndefined(isShiftEnter) ? false : isShiftEnter;
        //Calculate line height and descent based on formatting defined in paragraph.
        let paragraphMarkSize = this.viewer.textHelper.getParagraphMarkSize(paragraph.characterFormat);
        let maxHeight = paragraphMarkSize.Height;
        let beforeSpacing = this.getBeforeSpacing(paragraph);
        let lineWidget;
        if (paragraph.childWidgets.length > 0 && !isShiftEnter) {
            lineWidget = paragraph.childWidgets[0];
            if (lineWidget.children.length > 0) {
                if (!this.isBidiReLayout && (paraFormat.bidi || this.isContainsRtl(lineWidget))) {
                    this.reArrangeElementsForRtl(lineWidget, paraFormat.bidi);
                }
                let isParagraphStart = lineWidget.isFirstLine();
                let isParagraphEnd = lineWidget.isLastLine();
                let firstLineIndent = 0;
                if (isParagraphStart) {
                    beforeSpacing = this.getBeforeSpacing(paragraph);
                    firstLineIndent = HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
                }
                let textAlignment = paraFormat.textAlignment;
                if (textAlignment !== 'Left' && this.viewer.textWrap
                    && (!(textAlignment === 'Justify' && isParagraphEnd)
                        || (textAlignment === 'Justify' && paraFormat.bidi))) {
                    // tslint:disable-next-line:max-line-length
                    let getWidthAndSpace = this.getSubWidth(lineWidget, textAlignment === 'Justify', whiteSpaceCount, firstLineIndent, isParagraphEnd);
                    subWidth = getWidthAndSpace.subWidth;
                    whiteSpaceCount = getWidthAndSpace.spaceCount;
                }
            }
        }
        else {
            lineWidget = isEmptyLine ? this.addLineWidget(paragraph) : line;
        }
        //isNullOrUndefined(this.viewer.currentHeaderFooter) && 
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < beforeSpacing + maxHeight
            && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            this.moveToNextPage(this.viewer, lineWidget);
        }
        //Gets line spacing.
        let lineSpacing = this.getLineSpacing(paragraph, maxHeight);
        let maxDescent = maxHeight - paragraphMarkSize.BaselineOffset;
        //Calculate the bottom position of current line - max height + line spacing.
        if (!isNaN(this.maxTextHeight)
            && maxHeight < this.maxTextHeight) {
            maxHeight = this.maxTextHeight;
            maxDescent = maxHeight - this.maxTextBaseline;
        }
        let topMargin = 0;
        let bottomMargin = 0;
        let leftMargin = 0;
        let height = maxHeight;
        let lineSpacingType = paragraph.paragraphFormat.lineSpacingType;
        if (lineSpacingType === 'Multiple') {
            if (lineSpacing > maxHeight) {
                bottomMargin += lineSpacing - maxHeight;
            }
            else {
                topMargin += lineSpacing - maxHeight;
            }
        }
        else if (lineSpacingType === 'Exactly') {
            topMargin += lineSpacing - (topMargin + height + bottomMargin);
        }
        else if (lineSpacing > topMargin + height + bottomMargin) {
            topMargin += lineSpacing - (topMargin + height + bottomMargin);
        }
        topMargin += beforeSpacing;
        bottomMargin += HelperMethods.convertPointToPixel(this.getAfterSpacing(paragraph));
        for (let i = 0; i < lineWidget.children.length; i++) {
            let element = lineWidget.children[i];
            if (i === 0 && element instanceof ListTextElementBox) {
                let textAlignment = paragraph.paragraphFormat.textAlignment;
                if (textAlignment === 'Right') { //Aligns the text as right justified.
                    leftMargin = subWidth;
                }
                else if (textAlignment === 'Center') { //Aligns the text as center justified.
                    leftMargin = subWidth / 2;
                }
                element.margin = new Margin(leftMargin, topMargin, 0, bottomMargin);
                element.line = lineWidget;
                lineWidget.height = topMargin + height + bottomMargin;
            }
        }
        lineWidget.height = topMargin + height + bottomMargin;
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + lineWidget.height);
        //Clears the previous line elements from collection.     
    }
    /**
     * @private
     */
    layoutListItems(paragraph) {
        if (!this.isFieldCode) {
            if (!isNullOrUndefined(paragraph.paragraphFormat)
                && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)
                && !isNullOrUndefined(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId)) &&
                paragraph.paragraphFormat.listFormat.listLevelNumber >= 0
                && paragraph.paragraphFormat.listFormat.listLevelNumber < 9) {
                this.clearListElementBox(paragraph);
                this.layoutList(paragraph, this.viewer);
            }
            else if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId === -1) {
                this.clearListElementBox(paragraph);
            }
        }
    }
    /**
     * Layouts list.
     * @param viewer
     */
    layoutList(paragraph, viewer) {
        let list = viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
        viewer.updateClientWidth(-HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent));
        let currentListLevel = this.getListLevel(list, paragraph.paragraphFormat.listFormat.listLevelNumber);
        // if (isNullOrUndefined(currentListLevel)) {
        //     return;
        // }
        let lineWidget = paragraph.childWidgets[0];
        if (isNullOrUndefined(lineWidget)) {
            lineWidget = new LineWidget(paragraph);
            paragraph.childWidgets.push(lineWidget);
        }
        let element = new ListTextElementBox(currentListLevel, false);
        element.line = lineWidget;
        if (currentListLevel.listLevelPattern === 'Bullet') {
            element.text = currentListLevel.numberFormat;
        }
        else {
            element.text = this.getListNumber(paragraph.paragraphFormat.listFormat);
        }
        viewer.textHelper.updateTextSize(element, paragraph);
        let moveToNextPage;
        if (this.viewer instanceof PageLayoutViewer
            && this.viewer.clientActiveArea.height < element.height && this.viewer.clientActiveArea.y !== this.viewer.clientArea.y) {
            moveToNextPage = true;
        }
        viewer.cutFromLeft(viewer.clientActiveArea.x + element.width);
        //Adds the text element to the line
        lineWidget.children.splice(0, 0, element);
        if (currentListLevel.followCharacter !== 'None') {
            element = new ListTextElementBox(currentListLevel, true);
            if (currentListLevel.followCharacter === 'Tab') {
                element.text = '\t';
                let index = lineWidget.children.indexOf(element);
                element.width = this.getTabWidth(paragraph, viewer, index, lineWidget, element);
            }
            else {
                element.text = ' ';
                viewer.textHelper.updateTextSize(element, paragraph);
            }
            viewer.cutFromLeft(viewer.clientActiveArea.x + element.width);
            //Adds the tabSpace to the line
            lineWidget.children.splice(1, 0, element);
            element.line = lineWidget;
        }
        if (moveToNextPage) {
            this.moveToNextPage(this.viewer, lineWidget);
            this.cutClientWidth(element);
            return;
        }
        if (currentListLevel.followCharacter !== 'None') {
            viewer.updateClientWidth(HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent));
        }
    }
    /**
     * Adds body widget.
     * @param area
     * @param section
     * @private
     */
    addBodyWidget(area, widget) {
        let bodyWidget;
        if (widget) {
            bodyWidget = widget;
        }
        else {
            bodyWidget = new BodyWidget();
        }
        bodyWidget.width = area.width;
        bodyWidget.x = area.x;
        bodyWidget.y = area.y;
        // this.addSectionInDictionary(this.viewer, section, bodyWidget);
        return bodyWidget;
    }
    /**
     * Adds list level.
     * @param abstractList
     */
    addListLevels(abstractList) {
        for (let i = abstractList.levels.length; i < 9; i++) {
            let listLevel = new WListLevel(abstractList);
            let val = i % 3;
            if (abstractList.levels[0].listLevelPattern === 'Bullet') {
                listLevel.listLevelPattern = 'Bullet';
                listLevel.numberFormat = val === 0 ? '\uf0b7' : val === 1 ? '\uf0a7' : '\uf0d8';
                listLevel.characterFormat.fontFamily = listLevel.numberFormat === '\uf0a7' || '\uf0d8' ? 'Wingdings' : 'Symbol';
            }
            else {
                listLevel.listLevelPattern = this.getListLevelPattern(val);
                listLevel.numberFormat = '%' + (i + 1).toString() + '.';
                listLevel.startAt = 1;
                listLevel.restartLevel = i;
            }
            listLevel.paragraphFormat = new WParagraphFormat(undefined);
            listLevel.paragraphFormat.leftIndent = 48 * (i + 1);
            listLevel.paragraphFormat.firstLineIndent = -24;
            abstractList.levels.push(listLevel);
        }
    }
    addSplittedLineWidget(lineWidget, elementIndex, splittedElementBox) {
        let paragraph = lineWidget.paragraph;
        let movedElementBox = [];
        let lineIndex = paragraph.childWidgets.indexOf(lineWidget);
        if (!isNullOrUndefined(splittedElementBox)) {
            movedElementBox.push(splittedElementBox);
        }
        let newLineWidget = undefined;
        //Move Next element box to temp collection
        for (let i = elementIndex + 1; i < lineWidget.children.length; i++) {
            movedElementBox.push(lineWidget.children[i]);
        }
        if (movedElementBox.length > 0) {
            if (lineIndex === paragraph.childWidgets.length - 1) {
                newLineWidget = new LineWidget(paragraph);
            }
            else {
                newLineWidget = paragraph.childWidgets[lineIndex + 1];
            }
            for (let j = 0; j < movedElementBox.length; j++) {
                movedElementBox[j].line = newLineWidget;
            }
            lineWidget.children.splice(elementIndex + 1, lineWidget.children.length - 1);
            newLineWidget.children = movedElementBox.concat(newLineWidget.children);
            if (paragraph.childWidgets.indexOf(newLineWidget) === -1) {
                paragraph.childWidgets.splice(lineIndex + 1, 0, newLineWidget);
            }
        }
    }
    /**
     * Adds element to line.
     * @param element
     */
    addElementToLine(paragraph, element) {
        this.viewer.cutFromLeft(this.viewer.clientActiveArea.x + element.width);
        if (paragraph.paragraphFormat.textAlignment === 'Justify' && element instanceof TextElementBox) {
            this.splitTextElementWordByWord(element);
        }
    }
    /**
     * Splits element for client area.
     * @param element
     */
    splitElementForClientArea(paragraph, element) {
        let line = element.line;
        if (element.line.children.length > 0) {
            let previousElement = element.previousElement;
            let index = element.indexInOwner;
            // if line widget contain only single image element box need to skip this from splitting
            // else move element to next line
            if (element.line.children.length > 1) {
                if (previousElement && this.viewer.clientActiveArea.x !== this.viewer.clientArea.x) {
                    index -= 1;
                }
            }
            this.addSplittedLineWidget(element.line, index);
        }
    }
    /**
     * Splits by word
     * @param elementBox
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    splitByWord(lineWidget, paragraph, elementBox, text, width, characterFormat) {
        let index = this.getSplitIndexByWord(this.viewer.clientActiveArea.width, text, width, characterFormat);
        if (index > 0 && index < elementBox.length) {
            let indexOf = lineWidget.children.indexOf(elementBox);
            let lineIndex = paragraph.childWidgets.indexOf(lineWidget);
            let splittedElementBox = new TextElementBox();
            text = text.substring(index);
            splittedElementBox.text = text;
            if (text[0] === ' ') {
                let prevLength = text.length;
                text = HelperMethods.trimStart(text); //To trim white space at starting of the text.
                index += prevLength - text.length;
            }
            splittedElementBox.characterFormat.copyFormat(elementBox.characterFormat);
            splittedElementBox.width = this.viewer.textHelper.getWidth(splittedElementBox.text, characterFormat);
            elementBox.text = elementBox.text.substr(0, index);
            elementBox.width -= splittedElementBox.width;
            splittedElementBox.height = elementBox.height;
            splittedElementBox.baselineOffset = elementBox.baselineOffset;
            this.splitErrorCollection(elementBox, splittedElementBox);
            this.addSplittedLineWidget(lineWidget, indexOf, splittedElementBox);
            this.addElementToLine(paragraph, elementBox);
            if (elementBox.width === 0) {
                lineWidget.children.splice(indexOf, 1);
            }
        }
    }
    /**
     * Method to include error collection on splitted element
     * @private
     * @param {ElementBox} elementBox
     * @param {ElementBox} splittedBox
     */
    splitErrorCollection(elementBox, splittedBox) {
        if (elementBox.errorCollection.length > 0) {
            let errorCollection = [];
            let ignoreItems = elementBox.ignoreOnceItems;
            for (let i = 0; i < elementBox.errorCollection.length; i++) {
                errorCollection.push(elementBox.errorCollection[i]);
            }
            for (let j = 0; j < elementBox.errorCollection.length; j++) {
                let index = elementBox.text.indexOf(elementBox.errorCollection[j].text);
                let textElement = elementBox.errorCollection[j];
                if (index < 0) {
                    errorCollection.splice(0, 1);
                    splittedBox.errorCollection.push(textElement);
                }
                else if (splittedBox.text.indexOf(textElement.text) > 0) {
                    splittedBox.errorCollection.push(textElement);
                }
            }
            splittedBox.ignoreOnceItems = ignoreItems;
            elementBox.ignoreOnceItems = [];
            elementBox.errorCollection = errorCollection;
        }
    }
    /**
     * Splits by character.
     * @param textElement
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    splitByCharacter(lineWidget, textElement, text, width, characterFormat) {
        let paragraph = lineWidget.paragraph;
        // tslint:disable-next-line:max-line-length
        let index = this.getTextSplitIndexByCharacter(this.viewer.clientArea.width, this.viewer.clientActiveArea.width, text, width, characterFormat);
        let splitWidth = 0;
        if (index < textElement.length) {
            splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.substring(0, index), characterFormat);
            text = text.substring(index);
        }
        if (splitWidth > this.viewer.clientActiveArea.width && textElement.indexInOwner > 0) {
            this.addSplittedLineWidget(lineWidget, textElement.indexInOwner - 1);
            return;
        }
        let indexOf = lineWidget.children.indexOf(textElement);
        if (index < textElement.length) {
            let lineIndex = paragraph.childWidgets.indexOf(lineWidget);
            let splittedElement = new TextElementBox();
            splittedElement.text = text;
            splittedElement.errorCollection = textElement.errorCollection;
            textElement.text = textElement.text.substr(0, index);
            splittedElement.characterFormat.copyFormat(textElement.characterFormat);
            splittedElement.width = this.viewer.textHelper.getWidth(splittedElement.text, characterFormat);
            textElement.width -= splittedElement.width;
            splittedElement.height = textElement.height;
            splittedElement.baselineOffset = textElement.baselineOffset;
            lineWidget.children.splice(textElement.indexInOwner + 1, 0, splittedElement);
            this.addSplittedLineWidget(lineWidget, indexOf);
            this.addElementToLine(paragraph, textElement);
            if (textElement.width === 0) {
                lineWidget.children.splice(indexOf, 1);
            }
        }
        else {
            //Adds the last text element on inline to line elements collection. 
            this.addSplittedLineWidget(lineWidget, indexOf);
            this.addElementToLine(paragraph, textElement);
        }
    }
    /**
     * Splits text element word by word.
     * @param textElement
     */
    splitTextElementWordByWord(textElement) {
        let lineWidget = textElement.line;
        let indexOf = lineWidget.children.indexOf(textElement);
        let text = textElement.text;
        let format;
        let characterUptoWs = text.trim().indexOf(' ');
        if (characterUptoWs >= 0) {
            lineWidget.children.splice(indexOf, 1);
            format = textElement.characterFormat;
            let fontSize = format.fontSize;
            let index = textElement.length - HelperMethods.trimStart(text).length; //Trim start
            while (index < textElement.length) {
                index = this.getTextIndexAfterSpace(text, index);
                if (index === 0 || index === textElement.length) {
                    break;
                }
                if (index < textElement.length) {
                    let splittedElement = new TextElementBox();
                    let splittedText = text.substring(0, index);
                    text = text.substring(index);
                    if (text.substring(0, 1) === ' ') {
                        // start of the text is trimmed and its length is reduced from text length.                        
                        index += text.length - HelperMethods.trimStart(text).length;
                    }
                    splittedElement.text = splittedText;
                    splittedElement.characterFormat.copyFormat(textElement.characterFormat);
                    splittedElement.line = lineWidget;
                    splittedElement.width = this.viewer.textHelper.getWidth(splittedElement.text, format);
                    splittedElement.height = textElement.height;
                    splittedElement.baselineOffset = textElement.baselineOffset;
                    lineWidget.children.splice(indexOf, 0, splittedElement);
                    textElement.text = text;
                    textElement.width -= splittedElement.width;
                    if (textElement.width === 0) {
                        lineWidget.children.splice(lineWidget.children.indexOf(textElement), 1);
                    }
                    index = 0;
                    indexOf++;
                }
            }
            textElement.text = text;
            lineWidget.children.splice(indexOf, 0, textElement);
        }
    }
    /**
     * Splits text for client area.
     * @param element
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    splitTextForClientArea(lineWidget, element, text, width, characterFormat) {
        let paragraph = lineWidget.paragraph;
        let isSplitByWord = true;
        let index = -1;
        if (!(text.substring(0, 1) === ' ')) {
            let textWidth = width;
            let characterUptoWS = 0;
            characterUptoWS = HelperMethods.trimEnd(text).indexOf(' ') + 1;
            index = characterUptoWS;
            //Checks whether text not starts with white space. If starts with white space, no need to check previous text blocks.
            if (index > 0) {
                textWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.slice(0, index), characterFormat);
            }
            if (this.viewer.clientActiveArea.width < textWidth) {
                //Check and split the previous text elements to next line.            
                isSplitByWord = this.checkPreviousElement(lineWidget, lineWidget.children.indexOf(element), characterFormat);
                if (isSplitByWord) {
                    //lineWidget = paragraph.childWidgets[paragraph.childWidgets.indexOf(lineWidget) + 1] as LineWidget;
                    //isSplitByWord = textWidth <= this.viewer.clientActiveArea.width;
                    return;
                }
            }
        }
        else {
            index = 1;
        }
        if (width <= this.viewer.clientActiveArea.width) {
            //Fits the text in current line.
            this.addElementToLine(paragraph, element);
        }
        else if (isSplitByWord && (index > 0 || text.indexOf(' ') !== -1)) {
            this.splitByWord(lineWidget, paragraph, element, text, width, characterFormat);
        }
        else {
            this.splitByCharacter(lineWidget, element, text, width, characterFormat);
        }
    }
    /**
     * Handle tab or line break character splitting
     * @param  {LayoutViewer} viewer
     * @param  {TextElementBox} span
     * @param  {number} index
     * @param  {string} spiltBy
     * @private
     */
    splitByLineBreakOrTab(viewer, span, index, spiltBy) {
        // Splits tab character to separate SpanAdv
        let inlineIndex = span.line.children.indexOf(span);
        let value = span.text;
        let remainder = value.substring(index);
        let newSpan = spiltBy === '\t' ? new TabElementBox() : new TextElementBox();
        newSpan.line = span.line;
        newSpan.characterFormat.copyFormat(span.characterFormat);
        span.line.children.splice(inlineIndex + 1, 0, newSpan);
        if (index > 0 && remainder.length === 1) {
            newSpan.text = value.substring(index);
            span.text = value.substring(0, index);
        }
        else if (index > 0) {
            newSpan.text = spiltBy;
            let newText = new TextElementBox();
            newText.line = span.line;
            newText.text = value.substring(index + 1);
            newText.characterFormat.copyFormat(span.characterFormat);
            span.line.children.splice(inlineIndex + 2, 0, newText);
            span.text = value.substring(0, index);
        }
        else if (remainder !== '') {
            newSpan.text = value.substring(index + 1);
            span.text = spiltBy;
        }
    }
    /**
     * Moves to next line.
     */
    moveToNextLine(line) {
        let paragraph = line.paragraph;
        let paraFormat = paragraph.paragraphFormat;
        let isParagraphStart = line.isFirstLine();
        let isParagraphEnd = line.isLastLine();
        let height = 0;
        let maxDescent = 0;
        let afterSpacing = 0;
        let beforeSpacing = 0;
        let lineSpacing = 0;
        let firstLineIndent = 0;
        this.updateLineWidget(line);
        height = this.maxTextHeight;
        maxDescent = height - this.maxTextBaseline;
        //Updates before spacing at the top of Paragraph first line.
        if (isParagraphStart) {
            beforeSpacing = this.getBeforeSpacing(paragraph);
            firstLineIndent = HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
        }
        //Updates after spacing at the bottom of Paragraph last line.
        if (isParagraphEnd) {
            afterSpacing = HelperMethods.convertPointToPixel(this.getAfterSpacing(paragraph));
        }
        if (!this.isBidiReLayout && (paraFormat.bidi || this.isContainsRtl(line))) {
            this.reArrangeElementsForRtl(line, paraFormat.bidi);
            this.isRTLLayout = true;
        }
        if (isNaN(this.maxTextHeight)) {
            //Calculate line height and descent based on formatting defined in paragraph.
            let measurement = this.viewer.textHelper.measureText('a', paragraph.characterFormat);
            height = measurement.Height;
            maxDescent = height - measurement.BaselineOffset;
        }
        else {
            height = this.maxTextHeight;
            maxDescent = height - this.maxTextBaseline;
        }
        // Gets line spacing.
        lineSpacing = this.getLineSpacing(paragraph, height);
        if (paraFormat.lineSpacingType === 'Exactly'
            && lineSpacing < maxDescent + this.maxBaseline) {
            lineSpacing = maxDescent + this.maxBaseline;
        }
        let subWidth = 0;
        let whiteSpaceCount = 0;
        let textAlignment = paraFormat.textAlignment;
        // calculates the sub width, for text alignments - Center, Right, Justify.
        // if the element is paragraph end and para bidi is true and text alignment is justify
        // we need to calculate subwidth and add it to the left margin of the element.
        if (textAlignment !== 'Left' && this.viewer.textWrap && (!(textAlignment === 'Justify' && isParagraphEnd)
            || (textAlignment === 'Justify' && paraFormat.bidi))) {
            // tslint:disable-next-line:max-line-length
            let getWidthAndSpace = this.getSubWidth(line, textAlignment === 'Justify', whiteSpaceCount, firstLineIndent, isParagraphEnd);
            subWidth = getWidthAndSpace.subWidth;
            whiteSpaceCount = getWidthAndSpace.spaceCount;
        }
        let addSubWidth = false;
        let lineSpacingType = paraFormat.lineSpacingType;
        for (let i = 0; i < line.children.length; i++) {
            let topMargin = 0;
            let bottomMargin = 0;
            let leftMargin = 0;
            let elementBox = line.children[i];
            // tslint:disable-next-line:max-line-length
            let alignElements = this.alignLineElements(elementBox, topMargin, bottomMargin, maxDescent, addSubWidth, subWidth, textAlignment, whiteSpaceCount, i === line.children.length - 1);
            topMargin = alignElements.topMargin;
            bottomMargin = alignElements.bottomMargin;
            addSubWidth = alignElements.addSubWidth;
            whiteSpaceCount = alignElements.whiteSpaceCount;
            //Updates line spacing, paragraph after/ before spacing and aligns the text to base line offset.
            if (lineSpacingType === 'Multiple') {
                if (lineSpacing > height) {
                    bottomMargin += lineSpacing - height;
                }
                else {
                    topMargin += lineSpacing - height;
                }
            }
            else if (lineSpacingType === 'Exactly') {
                topMargin += lineSpacing - (topMargin + elementBox.height + bottomMargin);
            }
            else if (lineSpacing > topMargin + elementBox.height + bottomMargin) {
                topMargin += lineSpacing - (topMargin + elementBox.height + bottomMargin);
            }
            topMargin += beforeSpacing;
            bottomMargin += afterSpacing;
            if (i === 0) {
                line.height = topMargin + elementBox.height + bottomMargin;
                if (textAlignment === 'Right' || (textAlignment === 'Justify' && paraFormat.bidi && isParagraphEnd)) {
                    //Aligns the text as right justified and consider subwidth for bidirectional paragrph with justify.
                    leftMargin = subWidth;
                }
                else if (textAlignment === 'Center') {
                    //Aligns the text as center justified.
                    leftMargin = subWidth / 2;
                }
            }
            elementBox.margin = new Margin(leftMargin, topMargin, 0, bottomMargin);
            elementBox.line = line;
        }
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + line.height);
    }
    updateLineWidget(line) {
        for (let i = 0; i < line.children.length; i++) {
            let element = line.children[i];
            if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
                if (this.maxTextHeight < element.height) {
                    this.maxTextHeight = element.height;
                    this.maxTextBaseline = element.baselineOffset;
                }
                if (this.maxBaseline < this.maxTextBaseline) {
                    this.maxBaseline = this.maxTextBaseline;
                }
            }
            else if (this.maxBaseline < element.height) {
                this.maxBaseline = element.height;
            }
        }
    }
    /**
     * @param viewer
     */
    moveToNextPage(viewer, line, isPageBreak) {
        let paragraphWidget = line.paragraph;
        let index = 0;
        if (!isNullOrUndefined(line)) {
            index = paragraphWidget.childWidgets.indexOf(line);
            if (index > 0 || isPageBreak) {
                paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            }
        }
        let nextBody = this.moveBlocksToNextPage(paragraphWidget);
        this.viewer.updateClientArea(nextBody.sectionFormat, nextBody.page);
        this.viewer.updateClientAreaForBlock(paragraphWidget, true);
        if (index > 0) {
            if (line.isLastLine() && isPageBreak) {
                return;
            }
            let nextParagraph;
            if (nextBody.firstChild instanceof ParagraphWidget && nextBody.firstChild.equals(paragraphWidget)) {
                nextParagraph = nextBody.firstChild;
            }
            else {
                nextParagraph = new ParagraphWidget();
            }
            nextParagraph = this.addParagraphWidget(this.viewer.clientActiveArea, nextParagraph);
            nextParagraph.index = paragraphWidget.index;
            let insertIndex = 0;
            for (let i = index; i < paragraphWidget.childWidgets.length; i++) {
                let lineWidget = paragraphWidget.childWidgets[i];
                lineWidget.paragraph = nextParagraph;
                nextParagraph.childWidgets.splice(insertIndex, 0, lineWidget);
                lineWidget.paragraph = nextParagraph;
                insertIndex++;
            }
            nextParagraph.paragraphFormat = paragraphWidget.paragraphFormat;
            nextParagraph.characterFormat = paragraphWidget.characterFormat;
            paragraphWidget.childWidgets.splice(index);
            paragraphWidget = nextParagraph;
        }
        else if (!isPageBreak) {
            paragraphWidget.containerWidget.removeChild(paragraphWidget.indexInOwner);
        }
        if (!isPageBreak) {
            if (nextBody.childWidgets.indexOf(paragraphWidget) === -1) {
                nextBody.childWidgets.splice(0, 0, paragraphWidget);
            }
            paragraphWidget.containerWidget = nextBody;
            this.viewer.updateClientAreaLocation(paragraphWidget, this.viewer.clientActiveArea);
        }
    }
    /**
     * Aligns line elements
     * @param element
     * @param topMargin
     * @param bottomMargin
     * @param maxDescent
     * @param addSubWidth
     * @param subWidth
     * @param textAlignment
     * @param whiteSpaceCount
     * @param isLastElement
     */
    // tslint:disable-next-line:max-line-length
    alignLineElements(element, topMargin, bottomMargin, maxDescent, addSubWidth, subWidth, textAlignment, whiteSpaceCount, isLastElement) {
        if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
            let textElement = element instanceof TextElementBox ? element : undefined;
            //Updates the text to base line offset.
            // tslint:disable-next-line:max-line-length
            let baselineOffset = element instanceof TextElementBox ? textElement.baselineOffset : element.baselineOffset;
            topMargin += this.maxBaseline - baselineOffset;
            bottomMargin += maxDescent - (element.height - baselineOffset);
            //Updates the text to base line offset.
            if (!isNullOrUndefined(textElement) && textAlignment === 'Justify' && whiteSpaceCount > 0) {
                //Aligns the text as Justified.
                let width = textElement.width;
                let text = textElement.text;
                if (!addSubWidth) {
                    text = HelperMethods.trimStart(text); // trim start
                    addSubWidth = (text.length > 0);
                }
                if (addSubWidth) {
                    let spaceCount = text.length - HelperMethods.removeSpace(text).length;
                    if (isLastElement) {
                        spaceCount -= text.length - HelperMethods.trimEnd(text).length;
                    }
                    if (whiteSpaceCount < spaceCount) {
                        width = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text, textElement.characterFormat);
                        spaceCount = whiteSpaceCount;
                    }
                    if (spaceCount > 0) {
                        textElement.width = width + subWidth * spaceCount;
                        whiteSpaceCount -= spaceCount;
                    }
                }
            }
        }
        else {
            addSubWidth = true;
            //Updates the Image/UIElement to base line offset.
            topMargin += this.maxBaseline - element.height;
            bottomMargin += maxDescent;
        }
        return { 'topMargin': topMargin, 'bottomMargin': bottomMargin, 'addSubWidth': addSubWidth, 'whiteSpaceCount': whiteSpaceCount };
    }
    /**
     * Updates widget to page.
     * @param viewer
     * @param block
     * @private
     */
    updateWidgetToPage(viewer, paragraphWidget) {
        if (paragraphWidget.isInsideTable) {
            let cellWidget = paragraphWidget.associatedCell;
            paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            // if (viewer instanceof PageLayoutViewer) {
            if (isNullOrUndefined(paragraphWidget.associatedCell) || isNullOrUndefined(paragraphWidget.associatedCell.ownerRow)
                || isNullOrUndefined(paragraphWidget.associatedCell.ownerRow.rowFormat)) {
                return;
            }
            if (paragraphWidget.associatedCell.ownerRow.rowFormat.heightType === 'Exactly') {
                cellWidget.height = HelperMethods.convertPointToPixel(paragraphWidget.associatedCell.ownerRow.rowFormat.height);
            }
            else {
                // tslint:disable-next-line:max-line-length
                if ([cellWidget].length <= 1 && paragraphWidget.associatedCell.ownerRow.rowFormat.heightType === 'AtLeast') {
                    cellWidget.height = Math.max(HelperMethods.convertPointToPixel(paragraphWidget.associatedCell.ownerRow.rowFormat.height), this.getCellContentHeight(cellWidget));
                }
                else {
                    cellWidget.height = cellWidget.height + paragraphWidget.height;
                }
            }
            // } else {
            //     cellWidget.height = cellWidget.height + paragraphWidget.height;
            // }
            // cellWidget.childWidgets.push(paragraphWidget);
            paragraphWidget.containerWidget = cellWidget;
        }
        else {
            if (!paragraphWidget.isEndsWithPageBreak) {
                paragraphWidget.height = viewer.clientActiveArea.y - paragraphWidget.y;
            }
            //Adds the paragraph widget to the Header Footer/ Body widget.
            // this.updateWidgetsToBody(paragraphWidget, viewer, paragraphWidget);
            //For canvas no need to render paragraph widget here. In case of div, need to render paragraph here.
            // tslint:disable-next-line:max-line-length             
            // this.render.renderParagraphWidget((paragraphWidget.containerWidget as BodyWidget).page, paragraphWidget);
        }
        if (paragraphWidget.bodyWidget instanceof HeaderFooterWidget) {
            if (!paragraphWidget.isInsideTable) {
                paragraphWidget.containerWidget.height += paragraphWidget.height;
            }
            if (this.viewer.owner.enableHeaderAndFooter && paragraphWidget.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
                this.shiftFooterChildLocation(paragraphWidget.bodyWidget, this.viewer);
            }
        }
    }
    /**
     * @private
     */
    shiftFooterChildLocation(widget, viewer) {
        let pageHeight = widget.page.bodyWidgets[0].sectionFormat.pageHeight;
        if (widget.headerFooterType.indexOf('Footer') !== -1) {
            let footerDistance = widget.page.bodyWidgets[0].sectionFormat.footerDistance;
            let height = HelperMethods.convertPointToPixel(pageHeight - footerDistance);
            let top;
            if (widget.y + widget.height > height) {
                top = height - (widget.y + widget.height);
            }
            else if (widget.y + widget.height < height) {
                top = (widget.y + widget.height) - height;
            }
            if (!isNullOrUndefined(top)) {
                top = height - (widget.y + widget.height);
                this.shiftChildLocation(top, widget);
                viewer.clientActiveArea.y += top;
            }
        }
    }
    /**
     * Checks previous element.
     * @param characterFormat
     */
    checkPreviousElement(line, index, characterFormat) {
        let paragraph = line.paragraph;
        let isSplitByWord = false;
        let lastTextElement = 0;
        for (let i = index - 1; i >= 0; i--) {
            let textElement = line.children[i];
            if (textElement instanceof TextElementBox) {
                let text = textElement.text;
                lastTextElement = i;
                if (text.length > 0 && text[text.length - 1] === ' ') {
                    if (i === index - 1) {
                        this.addSplittedLineWidget(line, index - 1);
                        return true;
                    }
                    isSplitByWord = true;
                    break;
                }
                else if (text === '\t') {
                    return false;
                }
                else if (text.indexOf(' ') >= 0) {
                    isSplitByWord = true;
                    let index = text.lastIndexOf(' ') + 1;
                    //Splits the text element by space.
                    let splittedElement = new TextElementBox();
                    splittedElement.text = text.substr(index);
                    splittedElement.characterFormat.copyFormat(textElement.characterFormat);
                    textElement.text = text.substr(0, index);
                    this.viewer.textHelper.getTextSize(splittedElement, characterFormat);
                    textElement.width -= splittedElement.width;
                    textElement.height = splittedElement.height;
                    if (textElement.width === 0) {
                        line.children.splice(i, 1);
                    }
                    //Adds the text element to the line
                    line.children.splice(i + 1, 0, splittedElement);
                    break;
                }
            }
            else if (!(textElement instanceof ListTextElementBox)) {
                //Handled for inline images/UIelements.
                lastTextElement = i;
                isSplitByWord = true;
                break;
            }
        }
        if (isSplitByWord) {
            lastTextElement++;
            if (lastTextElement < line.children.length) {
                let splitWidth = 0;
                for (let i = lastTextElement; i < line.children.length; i++) {
                    splitWidth += line.children[i].width;
                    this.addSplittedLineWidget(line, i - 1);
                    i--;
                }
                this.viewer.updateClientWidth(splitWidth);
            }
        }
        return isSplitByWord;
    }
    /**
     * @private
     */
    clearListElementBox(paragraph) {
        if (paragraph.childWidgets.length === 0) {
            return;
        }
        let line = paragraph.childWidgets[0];
        if (isNullOrUndefined(line.children)) {
            return;
        }
        for (let i = line.children.length - 1; i > 0; i--) {
            if (line.children[i] instanceof ListTextElementBox) {
                line.children.splice(i, 1);
            }
            else {
                break;
            }
        }
        for (let i = 0; i < line.children.length; i++) {
            if (line.children[i] instanceof ListTextElementBox) {
                line.children.splice(i, 1);
                i--;
            }
            else {
                break;
            }
        }
    }
    /**
     * Gets list number.
     * @param listFormat
     * @param document
     * @private
     */
    getListNumber(listFormat, isAutoList) {
        let list = this.viewer.getListById(listFormat.listId);
        let levelNumber = listFormat.listLevelNumber;
        let listLevel = this.getListLevel(list, listFormat.listLevelNumber);
        // tslint:disable-next-line:max-line-length
        let levelOverride = !isNullOrUndefined(list.levelOverrides) ? list.levelOverrides[levelNumber] : undefined;
        // If LevelOverride exists and have either override list level or StartAtOverride, then only list numbering will be restarted.
        // tslint:disable-next-line:max-line-length
        // if (!isNullOrUndefined(levelOverride) && !(document.renderedLevelOverrides.indexOf(levelOverride) > -1) && isNullOrUndefined(levelOverride.overrideListLevel)) {
        //     //Add List Override style
        //     document.renderedLevelOverrides.push(list.levelOverrides.getItem(levelNumber) as WLevelOverride);
        //     if (document.renderedLists.containsKey((list.wordDocument as WordDocument).getAbstractListById(list.abstractListId))) {
        // tslint:disable-next-line:max-line-length
        //         let levels: Dictionary<number, number> = document.renderedLists.get((list.wordDocument as WordDocument).getAbstractListById(list.abstractListId));
        //         if (levels.containsKey(levelNumber)) {
        //             levels.remove(levelNumber);
        //         }
        //     }
        // }
        if (isNullOrUndefined(isAutoList)) {
            this.updateListValues(list, levelNumber);
        }
        return this.getListText(list, levelNumber, listLevel);
    }
    /**
     * Gets list start value
     * @param listLevelNumber
     * @param list
     * @private
     */
    getListStartValue(listLevelNumber, list) {
        // tslint:disable-next-line:max-line-length
        let levelOverride = !isNullOrUndefined(list.levelOverrides) ? list.levelOverrides[listLevelNumber] : undefined;
        if (!isNullOrUndefined(levelOverride) && isNullOrUndefined(levelOverride.overrideListLevel)) {
            return levelOverride.startAt;
        }
        let listLevel = this.getListLevel(list, listLevelNumber);
        if (isNullOrUndefined(listLevel)) {
            return 0;
        }
        else {
            return listLevel.startAt;
        }
    }
    /**
     * Updates list values.
     * @param list
     * @param listLevelNumber
     * @param document
     */
    updateListValues(list, listLevelNumber) {
        if (!this.viewer.renderedLists.containsKey(this.viewer.getAbstractListById(list.abstractListId))) {
            let startVal = new Dictionary();
            this.viewer.renderedLists.add(this.viewer.getAbstractListById(list.abstractListId), startVal);
            let listLevel = this.getListLevel(list, listLevelNumber);
            for (let i = 0; i <= listLevelNumber; i++) {
                startVal.add(i, this.getListStartValue(i, list));
            }
        }
        else {
            // tslint:disable-next-line:max-line-length
            let levels = this.viewer.renderedLists.get(this.viewer.getAbstractListById(list.abstractListId));
            if (levels.containsKey(listLevelNumber)) {
                let startAt = levels.get(listLevelNumber);
                levels.set(listLevelNumber, startAt + 1);
                let levelNumber = listLevelNumber + 1;
                while (levelNumber < this.viewer.getAbstractListById(list.abstractListId).levels.length) {
                    let listLevel = this.getListLevel(list, levelNumber);
                    // if (!isNullOrUndefined(listLevel)) {
                    if (levels.containsKey(levelNumber) && listLevel.restartLevel > listLevelNumber) {
                        levels.remove(levelNumber);
                        // if (document.renderedListLevels.indexOf(listLevel) > -1) {
                        //     document.renderedListLevels.pop();
                        // }
                    }
                    // }
                    levelNumber++;
                }
            }
            else {
                let levelNumber = listLevelNumber;
                while (!levels.containsKey(levelNumber - 1) && levelNumber > 0) {
                    let listLevel = this.getListLevel(list, levelNumber - 1);
                    // if (!isNullOrUndefined(listLevel)) {
                    levels.add(levelNumber - 1, this.getListStartValue(levelNumber - 1, list));
                    // if (document.renderedListLevels.indexOf(listLevel) !== -1) {
                    //     document.renderedListLevels.push(listLevel);
                    // }
                    // }
                    levelNumber--;
                }
                let startAt = this.getListStartValue(listLevelNumber, list);
                levels.add(listLevelNumber, startAt);
            }
        }
    }
    /**
     * Gets list text
     * @param listAdv
     * @param listLevelNumber
     * @param currentListLevel
     * @param document
     */
    getListText(listAdv, listLevelNumber, currentListLevel) {
        let listText = currentListLevel.numberFormat;
        // tslint:disable-next-line:max-line-length
        if (this.viewer.renderedLists.containsKey(this.viewer.getAbstractListById(listAdv.abstractListId))) {
            let levels = this.viewer.renderedLists.get(this.viewer.getAbstractListById(listAdv.abstractListId));
            let keys = levels.keys;
            for (let i = 0; i < keys.length; i++) {
                let levelNumber = keys[i];
                let levelKey = '%' + (levelNumber + 1).toString();
                let listLevel = this.getListLevel(listAdv, levelNumber);
                if (listText.match(levelKey)) {
                    if (levelNumber > listLevelNumber) {
                        return '';
                    }
                    else if (levels.containsKey(levelNumber) && !isNullOrUndefined(listLevel)) {
                        listText = listText.replace(levelKey, this.getListTextListLevel(listLevel, levels.get(levelNumber)));
                    }
                    else {
                        listText = listText.replace(levelKey, '0');
                    }
                }
            }
        }
        return listText;
    }
    /**
     * Gets the roman letter.
     * @param number
     * @private
     */
    getAsLetter(number) {
        // if (number <= 0) {
        //     return '';
        // }
        let quotient = number / 26;
        let remainder = number % 26;
        if (remainder === 0) {
            //If number denotes the factor of 26, then reduce quotient by 1 and set remainder as 26.
            remainder = 26;
            quotient--;
        }
        //Index of A char in the ASCII table.     
        let letter = String.fromCharCode(65 - 1 + remainder);
        let listValue = '';
        while (quotient >= 0) {
            listValue = listValue + letter.toString();
            quotient--;
        }
        return listValue;
    }
    /**
     * Gets list text using list level pattern.
     * @param listLevel
     * @param listValue
     * @private
     */
    getListTextListLevel(listLevel, listValue) {
        switch (listLevel.listLevelPattern) {
            case 'UpRoman':
                return this.getAsRoman(listValue).toUpperCase();
            case 'LowRoman':
                return this.getAsRoman(listValue).toLowerCase();
            case 'UpLetter':
                return this.getAsLetter(listValue).toUpperCase();
            case 'LowLetter':
                return this.getAsLetter(listValue).toLowerCase();
            case 'Arabic':
                return (listValue).toString();
            case 'LeadingZero':
                return this.getAsLeadingZero(listValue);
            case 'Number':
                return (listValue).toString();
            case 'OrdinalText':
                return (listValue).toString();
            case 'Ordinal':
                return (listValue).toString();
            case 'FarEast':
                return (listValue).toString();
            case 'Special':
                return (listValue).toString();
            default:
                return '';
        }
    }
    /**
     * Generate roman number for the specified number.
     * @param number
     * @param magnitude
     * @param letter
     */
    generateNumber(number, magnitude, letter) {
        let numberstring = '';
        while (number >= magnitude) {
            number -= magnitude;
            numberstring += letter;
            this.value = number;
        }
        return numberstring.toString();
    }
    /**
     * Gets list value prefixed with zero, if less than 10
     * @param listValue
     */
    getAsLeadingZero(listValue) {
        if (listValue < 10) {
            return '0' + listValue.toString();
        }
        else {
            return listValue.toString();
        }
    }
    /**
     * Gets the roman number
     * @param number
     * @private
     */
    getAsRoman(number) {
        let retval = '';
        this.value = number;
        retval += this.generateNumber(this.value, 1000, 'M');
        retval += this.generateNumber(this.value, 900, 'CM');
        retval += this.generateNumber(this.value, 500, 'D');
        retval += this.generateNumber(this.value, 400, 'CD');
        retval += this.generateNumber(this.value, 100, 'C');
        retval += this.generateNumber(this.value, 90, 'XC');
        retval += this.generateNumber(this.value, 50, 'L');
        retval += this.generateNumber(this.value, 40, 'XL');
        retval += this.generateNumber(this.value, 10, 'X');
        retval += this.generateNumber(this.value, 9, 'IX');
        retval += this.generateNumber(this.value, 5, 'V');
        retval += this.generateNumber(this.value, 4, 'IV');
        retval += this.generateNumber(this.value, 1, 'I');
        return retval.toString();
    }
    /**
     * Gets the list level
     * @param list
     * @param listLevelNumber
     * @private
     */
    getListLevel(list, listLevelNumber) {
        if (!isNullOrUndefined(list)) {
            let abstractList = this.viewer.getAbstractListById(list.abstractListId);
            if (!isNullOrUndefined(list) && abstractList.levels.length <= listLevelNumber
                && listLevelNumber >= 0 && listLevelNumber < 9) {
                this.addListLevels(abstractList);
            }
            let levelOverrideAdv = undefined;
            let level = false;
            level = (!isNullOrUndefined(list.levelOverrides))
                && !isNullOrUndefined(((levelOverrideAdv = list.levelOverrides[listLevelNumber])))
                && (!isNullOrUndefined(levelOverrideAdv.overrideListLevel));
            if (level) {
                return levelOverrideAdv.overrideListLevel;
            }
            else if (!isNullOrUndefined(abstractList) && listLevelNumber >= 0 && listLevelNumber < abstractList.levels.length) {
                return abstractList.levels[listLevelNumber];
            }
        }
        return undefined;
    }
    /**
     * Gets tab width
     * @param paragraph
     * @param viewer
     */
    // tslint:disable-next-line:max-line-length
    getTabWidth(paragraph, viewer, index, lineWidget, element) {
        let elementWidth = element ? this.viewer.textHelper.getTextSize(element, element.characterFormat) : 0;
        let fPosition = 0;
        let isCustomTab = false;
        let tabs = paragraph.paragraphFormat.getUpdatedTabs();
        let isList = false;
        let isSingleTab = false;
        // tslint:disable-next-line:max-line-length
        if (element.previousElement instanceof TextElementBox && element.previousElement.previousElement instanceof FieldElementBox && tabs.length === 1) {
            isSingleTab = element.nextElement instanceof TextElementBox;
            if (isSingleTab) {
                tabs.length = 0;
            }
        }
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(paragraph.paragraphFormat.listFormat.listLevel) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat.listLevel.paragraphFormat)) {
            let listFormat = paragraph.paragraphFormat.listFormat.listLevel.paragraphFormat;
            if (paragraph.paragraphFormat.leftIndent !== listFormat.leftIndent) {
                isList = true;
            }
        }
        //  Calculate hanging width
        if (element instanceof ListTextElementBox && viewer.clientActiveArea.x < this.viewer.clientArea.x) {
            return viewer.clientArea.x - viewer.clientActiveArea.x;
        }
        // Calculates tabwidth based on pageleftmargin and defaulttabwidth property
        let leftIndent = HelperMethods.convertPointToPixel(paragraph.paragraphFormat.leftIndent);
        let firstLineIndent = HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
        let position = viewer.clientActiveArea.x -
            (viewer.clientArea.x - leftIndent);
        let defaultTabWidth = HelperMethods.convertPointToPixel(viewer.defaultTabWidth);
        if (tabs.length === 0) {
            if (position > 0 && defaultTabWidth > position && isList ||
                defaultTabWidth === this.defaultTabWidthPixel && defaultTabWidth > position) {
                return defaultTabWidth - position;
            }
            else if (isSingleTab) {
                return defaultTabWidth - leftIndent;
            }
            else if (defaultTabWidth === this.defaultTabWidthPixel && defaultTabWidth < position) {
                return defaultTabWidth + firstLineIndent;
            }
            return defaultTabWidth;
        }
        else {
            if (tabs.length > 0) {
                for (let i = 0; i < tabs.length; i++) {
                    let tabStop = tabs[i];
                    let tabPosition = HelperMethods.convertPointToPixel(tabs[i].position);
                    if ((position + elementWidth) < tabPosition) {
                        isCustomTab = true;
                        if (tabStop.tabJustification === 'Left' || tabStop.tabJustification === 'List') {
                            fPosition = tabPosition;
                            if (element instanceof TabElementBox) {
                                element.tabLeader = tabs[i].tabLeader;
                                element.tabText = '';
                            }
                            break;
                        }
                        else {
                            let tabWidth = tabPosition - position;
                            let width = this.getRightTabWidth(element.indexInOwner + 1, lineWidget, paragraph);
                            if (width < tabWidth) {
                                if (tabStop.tabJustification === 'Right') {
                                    defaultTabWidth = tabWidth - width;
                                    let areaWidth = this.viewer.clientActiveArea.width - defaultTabWidth;
                                    if (areaWidth < 0) {
                                        defaultTabWidth += areaWidth - width;
                                    }
                                    else if (width > areaWidth) {
                                        defaultTabWidth -= width - areaWidth;
                                    }
                                }
                                else {
                                    defaultTabWidth = tabWidth - width / 2;
                                }
                            }
                            else if (tabStop.tabJustification === 'Center' && (width / 2) < tabWidth) {
                                defaultTabWidth = tabWidth - width / 2;
                            }
                            else {
                                defaultTabWidth = tabStop.tabJustification === 'Right' ? 0 : elementWidth;
                            }
                            fPosition = position;
                            if (element instanceof TabElementBox) {
                                element.tabLeader = tabs[i].tabLeader;
                                element.tabText = '';
                            }
                            break;
                        }
                    }
                    else if (element.previousElement instanceof TextElementBox && element.nextElement instanceof TextElementBox) {
                        if (leftIndent > defaultTabWidth) {
                            defaultTabWidth = leftIndent - defaultTabWidth;
                            break;
                        }
                    }
                    else if (element instanceof ListTextElementBox && viewer.clientActiveArea.x > this.viewer.clientArea.x) {
                        return viewer.clientActiveArea.x - viewer.clientArea.x;
                    }
                }
            }
            if (!isCustomTab) {
                let diff = ((Math.round(position) * 100) % (Math.round(defaultTabWidth) * 100)) / 100;
                let cnt = (Math.round(position) - diff) / Math.round(defaultTabWidth);
                fPosition = (cnt + 1) * defaultTabWidth;
            }
            return (fPosition - position) > 0 ? fPosition - position : defaultTabWidth;
        }
    }
    /**
     * Returns the right tab width
     * @param index - index of starting inline
     * @param lineWidget - current line widget
     * @param paragraph - current paragraph widget
     */
    getRightTabWidth(index, lineWidget, paragraph) {
        let width = 0;
        let isFieldCode = false;
        let elementBox = lineWidget.children[index];
        while (elementBox) {
            if ((elementBox instanceof FieldElementBox) || (elementBox instanceof BookmarkElementBox) || isFieldCode) {
                if (elementBox instanceof FieldElementBox) {
                    if (elementBox.fieldType === 0) {
                        isFieldCode = true;
                    }
                    else if (elementBox.fieldType === 2) {
                        isFieldCode = false;
                    }
                }
                elementBox.width = 0;
            }
            else {
                if (elementBox instanceof TextElementBox) {
                    this.viewer.textHelper.getTextSize(elementBox, elementBox.characterFormat);
                }
            }
            if (elementBox instanceof TextElementBox && elementBox.text === '\t') {
                return width;
            }
            else {
                width = width + elementBox.width;
            }
            elementBox = elementBox.nextNode;
        }
        return width;
    }
    /**
     * Gets split index by word.
     * @param clientActiveWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    getSplitIndexByWord(clientActiveWidth, text, width, characterFormat) {
        let index = 0;
        let length = text.length;
        while (index < length) {
            let nextIndex = this.getTextIndexAfterSpace(text, index);
            if (nextIndex === 0 || nextIndex === length) {
                nextIndex = length - 1;
            }
            let splitWidth = width;
            if ((nextIndex < length - 1 || (nextIndex === length - 1 && text[nextIndex - 1] === ' ')) && index !== nextIndex) {
                splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.slice(0, nextIndex), characterFormat);
            }
            if (splitWidth <= clientActiveWidth) {
                index = nextIndex;
            }
            else {
                if (index === 0 && text[0] === ' ') {
                    index = this.getTextIndexAfterSpace(text, 0);
                }
                break;
            }
        }
        return index;
    }
    /**
     * Gets split index by character
     * @param totalClientWidth
     * @param clientActiveAreaWidth
     * @param text
     * @param width
     * @param characterFormat
     */
    // tslint:disable-next-line:max-line-length
    getTextSplitIndexByCharacter(totalClientWidth, clientActiveAreaWidth, text, width, characterFormat) {
        let length = text.length;
        for (let i = 0; i < length; i++) {
            let splitWidth = width;
            if (i + 1 < length) {
                splitWidth = this.viewer.textHelper.measureTextExcludingSpaceAtEnd(text.substring(0, i + 1), characterFormat);
            }
            if (splitWidth > clientActiveAreaWidth) {
                if (i === 0 && splitWidth > totalClientWidth) {
                    //Handle for cell/section having client width less than a character's width.
                    return (length > 1 && text[1] === ' ') ? this.getTextIndexAfterSpace(text, 1) : 1;
                }
                return i;
            }
        }
        return 0;
    }
    /**
     * Gets sub width.
     * @param justify
     * @param spaceCount
     * @param firstLineIndent
     */
    // tslint:disable-next-line:max-line-length
    getSubWidth(lineWidget, justify, spaceCount, firstLineIndent, isParagraphEnd) {
        let width = 0;
        let trimSpace = true;
        let lineText = '';
        for (let i = lineWidget.children.length - 1; i >= 0; i--) {
            let element = lineWidget.children[i];
            if (element instanceof TextElementBox) {
                let elementText = element.text;
                lineText = elementText + lineText;
                if (trimSpace && (elementText.trim() !== '' || elementText === '\t')) {
                    if (HelperMethods.endsWith(elementText)) {
                        width += this.viewer.textHelper.measureTextExcludingSpaceAtEnd(elementText, element.characterFormat);
                    }
                    else {
                        width += element.width;
                    }
                    trimSpace = false;
                }
                else if (!trimSpace) {
                    width += element.width;
                }
            }
            else {
                lineText = 'a' + lineText;
                trimSpace = false;
                width += element.width;
            }
            if (!justify) {
                width = Math.round(width);
            }
        }
        lineText = lineText.trim();
        spaceCount = lineText.length - HelperMethods.removeSpace(lineText).length;
        let subWidth = (this.viewer.clientArea.width - firstLineIndent - width);
        if (subWidth <= 0 || (spaceCount === 0 && justify && !lineWidget.paragraph.paragraphFormat.bidi)) {
            spaceCount = 0;
            subWidth = 0;
        }
        else if (justify) {
            // For justify alignment, element width will be updated based space count value.
            // So when the element is paragraph end, need to set space count to zero.
            if (!isParagraphEnd && spaceCount > 0) {
                subWidth = subWidth / spaceCount;
            }
            else {
                spaceCount = 0;
            }
        }
        return { 'subWidth': subWidth, 'spaceCount': spaceCount };
    }
    /**
     * Gets before spacing.
     * @param paragraph
     * @private
     */
    getBeforeSpacing(paragraph) {
        let beforeSpacing = 0;
        if (paragraph.previousWidget instanceof ParagraphWidget) {
            let afterSpacing = this.getAfterSpacing(paragraph.previousWidget);
            if (afterSpacing < paragraph.paragraphFormat.beforeSpacing) {
                // tslint:disable-next-line:max-line-length
                beforeSpacing = paragraph.paragraphFormat.beforeSpacing - afterSpacing;
            }
        }
        else {
            beforeSpacing = paragraph.paragraphFormat.beforeSpacing;
        }
        if (this.isSameStyle(paragraph, false)) {
            return 0;
        }
        else {
            return beforeSpacing;
        }
    }
    getAfterSpacing(paragraph) {
        let afterSpacing = paragraph.paragraphFormat.afterSpacing;
        if (this.isSameStyle(paragraph, true)) {
            return 0;
        }
        else {
            return afterSpacing;
        }
    }
    /**
     * Gets line spacing.
     * @param paragraph
     * @param maxHeight
     * @private
     */
    getLineSpacing(paragraph, maxHeight) {
        if (isNullOrUndefined(paragraph.paragraphFormat)) {
            return 0;
        }
        let lineSpacing = 0;
        switch (paragraph.paragraphFormat.lineSpacingType) {
            case 'AtLeast':
            case 'Exactly':
                lineSpacing = paragraph.paragraphFormat.lineSpacing;
                break;
            default:
                lineSpacing = paragraph.paragraphFormat.lineSpacing * maxHeight;
                break;
        }
        return lineSpacing;
    }
    /**
     * Checks whether current line is first line in a paragraph.
     * @param paragraph
     */
    isParagraphFirstLine(paragraph, line) {
        let widget = paragraph;
        if (isNullOrUndefined(widget.childWidgets) || widget.childWidgets.indexOf(line) === 0) {
            //If the line elements conatins the elements from previous paragraph then need to retun false.
            //Example scenario, Field start and field end in different paragraphs.
            if (line.children.length > 0 && !isNullOrUndefined(paragraph.previousWidget)
                && paragraph.previousWidget instanceof ParagraphWidget) {
                return line.paragraph.index !== paragraph.previousWidget.index;
            }
            return true; //If the line elements count is zero then also need to return true.
        }
        return false;
    }
    /**
     * Checks whether current line is last line in a paragraph.
     * @param paragraph
     */
    isParagraphLastLine(element) {
        let paragraph = element.line.paragraph;
        let lastLineWidget = paragraph.childWidgets[paragraph.childWidgets.length - 1];
        let lastInline = lastLineWidget.children[lastLineWidget.children.length - 1];
        if (element === lastInline) {
            // tslint:disable-next-line:max-line-length            
            return (lastInline instanceof FieldElementBox) || ((!(lastInline instanceof TextElementBox && lastInline.text === '\v')));
        }
        return false;
    }
    /**
     * Gets text index after space.
     * @param text
     * @param startIndex
     */
    getTextIndexAfterSpace(text, startIndex) {
        let length = text.length;
        let index = 0;
        index = text.indexOf(' ', startIndex) + 1;
        let nextIndex = index;
        if (nextIndex === 0 || nextIndex === length) {
            return nextIndex;
        }
        while (text[nextIndex] === ' ') {
            nextIndex++;
            if (nextIndex === length) {
                break;
            }
        }
        return nextIndex;
    }
    //#region Table
    /**
     * @private
     */
    moveNextWidgetsToTable(tableWidget, rowWidgets, moveFromNext) {
        let currentRow = moveFromNext ? rowWidgets[rowWidgets.length - 2] : rowWidgets[rowWidgets.length - 1];
        let rowIndex = currentRow.indexInOwner;
        let currentTable = tableWidget[tableWidget.length - 1];
        if (moveFromNext) {
            rowIndex += 1;
        }
        let nextWidgets = currentRow.containerWidget.childWidgets.splice(rowIndex);
        for (let i = 0; i < nextWidgets.length; i++) {
            currentTable.childWidgets.push(nextWidgets[i]);
            nextWidgets[i].containerWidget = currentTable;
        }
    }
    /**
     * Adds table cell widget.
     * @param cell
     * @param area
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    addTableCellWidget(cell, area, maxCellMarginTop, maxCellMarginBottom) {
        //let tableCellWidget: TableCellWidget = new TableCellWidget(cell);
        let prevColumnIndex = 0;
        let cellspace = 0;
        let left = 0;
        let top = maxCellMarginTop;
        let right = 0;
        let bottom = maxCellMarginBottom;
        if (!isNullOrUndefined(cell.cellFormat)) {
            if (cell.cellFormat.containsMargins()) {
                // tslint:disable-next-line:max-line-length
                left = isNullOrUndefined(cell.cellFormat.leftMargin) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.leftMargin) : HelperMethods.convertPointToPixel(cell.cellFormat.leftMargin);
                right = isNullOrUndefined(cell.cellFormat.rightMargin) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.rightMargin) : HelperMethods.convertPointToPixel(cell.cellFormat.rightMargin);
            }
            else {
                if (cell.columnIndex === 0 && cell.ownerRow.rowFormat.hasValue('leftMargin')) {
                    left = HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.leftMargin);
                }
                else {
                    left = HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.leftMargin);
                }
                if (cell.columnIndex === cell.ownerTable.tableHolder.columns.length - 1 &&
                    cell.ownerRow.rowFormat.hasValue('rightMargin')) {
                    right = HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.rightMargin);
                }
                else {
                    right = HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.rightMargin);
                }
            }
        }
        cell.margin = new Margin(left, top, right, bottom);
        cell.width = HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
        if (!isNullOrUndefined(cell.previousWidget)) {
            // tslint:disable-next-line:max-line-length
            prevColumnIndex = cell.previousWidget.columnIndex + cell.previousWidget.cellFormat.columnSpan;
        }
        // tslint:disable-next-line:max-line-length
        cellspace = !isNullOrUndefined(cell.ownerTable) && !isNullOrUndefined(cell.ownerTable.tableFormat) ? HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing) : 0;
        let prevSpannedCellWidth = 0;
        if (prevColumnIndex < cell.columnIndex) {
            // tslint:disable-next-line:max-line-length
            prevSpannedCellWidth = HelperMethods.convertPointToPixel(cell.ownerTable.tableHolder.getPreviousSpannedCellWidth(prevColumnIndex, cell.columnIndex));
            if (prevColumnIndex === 0) {
                prevSpannedCellWidth = prevSpannedCellWidth - cellspace / 2;
            }
        }
        cell.x = area.x + prevSpannedCellWidth + cell.margin.left;
        cell.y = area.y + cell.margin.top + cellspace;
        cell.width = cell.width - cell.margin.left - cell.margin.right;
        if (cellspace > 0) {
            cell.x += cellspace;
            if (cell.ownerTable.tableHolder.columns.length === 1) {
                cell.width -= cellspace * 2;
            }
            else if (cell.columnIndex === 0 || cell.columnIndex === cell.ownerTable.tableHolder.columns.length - 1) {
                cell.width -= ((cellspace * 2) - cellspace / 2);
            }
            else {
                cell.width -= cellspace;
            }
        }
        let leftBorderWidth = HelperMethods.convertPointToPixel(TableCellWidget.getCellLeftBorder(cell).getLineWidth());
        let rightBorderWidth = HelperMethods.convertPointToPixel(TableCellWidget.getCellRightBorder(cell).getLineWidth());
        // update the margins values respect to layouting of borders.
        // for normal table cells only left border is rendred. for last cell left and right border is rendred.
        // this border widths are not included in margins.
        cell.leftBorderWidth = !cell.ownerTable.isBidiTable ? leftBorderWidth : rightBorderWidth;
        let isLeftStyleNone = (cell.cellFormat.borders.left.lineStyle === 'None');
        let isRightStyleNone = (cell.cellFormat.borders.right.lineStyle === 'None');
        cell.x += (!isLeftStyleNone) ? 0 : (cell.leftBorderWidth > 0) ? 0 : cell.leftBorderWidth;
        cell.width -= (!isLeftStyleNone) ? 0 : (cell.leftBorderWidth > 0) ? 0 : cell.leftBorderWidth;
        let lastCell = !cell.ownerTable.isBidiTable ? cell.cellIndex === cell.ownerRow.childWidgets.length - 1
            : cell.cellIndex === 0;
        if (cellspace > 0 || cell.cellIndex === cell.ownerRow.childWidgets.length - 1) {
            cell.rightBorderWidth = !cell.ownerTable.isBidiTable ? rightBorderWidth : leftBorderWidth;
            if (!cell.ownerTable.tableFormat.allowAutoFit) {
                cell.width -= cell.rightBorderWidth;
            }
        }
        //Add the border widths to respective margin side.
        cell.margin.left += (isLeftStyleNone) ? 0 : (cell.leftBorderWidth);
        cell.margin.right += (isRightStyleNone) ? 0 : (cell.rightBorderWidth);
        //cell.ownerWidget = owner;
        return cell;
    }
    /**
     * Adds specified row widget to table.
     * @param viewer
     * @param tableRowWidget
     * @param row
     */
    // tslint:disable-next-line:max-line-length
    addWidgetToTable(viewer, tableCollection, rowCollection, row, endRowWidget, isInitialLayout) {
        //Adds table row widget to owner table widget.
        let tableWidget = tableCollection[0];
        let index = tableWidget.childWidgets.length;
        let prevWidget = undefined;
        let rowWidgetIndex = rowCollection.indexOf(row);
        if (rowWidgetIndex > 0) {
            prevWidget = rowCollection[rowWidgetIndex - 1];
            // Need to update on this further
        }
        else if (row.previousRenderedWidget instanceof TableRowWidget &&
            row.previousRenderedWidget.ownerTable.equals(row.ownerTable)) {
            // Need to update on this further
            prevWidget = row.previousRenderedWidget;
        }
        if (!isNullOrUndefined(prevWidget)) {
            tableWidget = prevWidget.containerWidget;
            // index = tableWidget.childWidgets.length;
            index = tableWidget.childWidgets.indexOf(prevWidget) + 1;
            if (Math.round(row.y) !== Math.round(prevWidget.y + prevWidget.height)) {
                let prevIndex = tableCollection.indexOf(tableWidget);
                if (prevIndex + 1 >= tableCollection.length) {
                    //Creates new table widget for splitted rows.
                    this.addTableWidget(viewer.clientActiveArea, tableCollection, true);
                }
                tableWidget = tableCollection[prevIndex + 1];
                index = tableWidget.childWidgets.length;
            }
            if (rowWidgetIndex > 0) {
                index = 0;
            }
        }
        this.updateRowHeightBySpannedCell(tableWidget, row, index);
        this.updateRowHeightByCellSpacing(tableCollection, row, viewer);
        //Remove widget from previous container after splitteing
        if (row.containerWidget && row.containerWidget !== tableWidget &&
            row.containerWidget.childWidgets.indexOf(row) !== -1) {
            row.containerWidget.childWidgets.splice(row.containerWidget.childWidgets.indexOf(row), 1);
        }
        if (tableWidget.childWidgets.indexOf(row) === -1) {
            tableWidget.childWidgets.splice(index, 0, row);
        }
        row.containerWidget = tableWidget;
        tableWidget.height = tableWidget.height + row.height;
        // Shift the widgets for Right to left directed table.
        if (tableWidget.isBidiTable) {
            row.shiftWidgetForRtlTable(this.viewer.clientArea, tableWidget, row);
        }
        if (!isNullOrUndefined(tableWidget.containerWidget)
            && tableWidget.containerWidget.childWidgets.indexOf(tableWidget) >= 0 &&
            !(tableWidget.containerWidget instanceof HeaderFooterWidget)) {
            tableWidget.containerWidget.height += row.height;
        }
        this.updateHeightForRowWidget(viewer, false, tableCollection, rowCollection, row, false, endRowWidget, isInitialLayout);
        viewer.cutFromTop(row.y + row.height);
    }
    /**
     * Updates row height by spanned cell.
     * @param tableWidget
     * @param rowWidget
     * @param insertIndex
     * @param row
     * @private
     */
    updateRowHeightBySpannedCell(tableWidget, row, insertIndex) {
        let rowSpan = 1;
        if (tableWidget.childWidgets.length === 0 || insertIndex === 0) {
            this.updateRowHeight(row, row);
            return;
        }
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cellWidget = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan : cellWidget.cellFormat.rowSpan;
            this.updateSpannedRowCollection(rowSpan, row, cellWidget);
        }
        if (!isNullOrUndefined(row.ownerTable)) {
            for (let i = 0; i < row.ownerTable.spannedRowCollection.length; i++) {
                if (row.ownerTable.spannedRowCollection.keys[i] === row.index) {
                    // Back track to previous table row widgets and update it height if vertical merge ends with this row.
                    for (let j = 0; j < insertIndex; j++) {
                        let prevRowWidget = tableWidget.childWidgets[j];
                        this.updateRowHeight(prevRowWidget, row);
                    }
                    row.ownerTable.spannedRowCollection.remove(row.ownerTable.spannedRowCollection.keys[i]);
                    break;
                }
            }
        }
    }
    /**
     * Updates row height.
     * @param prevRowWidget
     * @param rowWidget
     * @param row
     */
    updateRowHeight(prevRowWidget, row) {
        let rowIndex = row.index;
        let rowSpan = 1;
        for (let i = 0; i < prevRowWidget.childWidgets.length; i++) {
            let cellWidget = prevRowWidget.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan : cellWidget.cellFormat.rowSpan;
            //To update Row height- if row has row span value greater than 1, need to add it in spannedRowCollection            
            this.updateSpannedRowCollection(rowSpan, row, cellWidget);
            if (rowIndex - cellWidget.rowIndex === rowSpan - 1) {
                let mergedCellHeight = cellWidget.y + cellWidget.height + cellWidget.margin.bottom - row.y;
                if (row.height < mergedCellHeight) {
                    row.height = mergedCellHeight;
                }
            }
        }
    }
    //if row has row span value greater than 1, need to add it in spannedRowCollection
    updateSpannedRowCollection(rowSpan, row, cellWidget) {
        if (rowSpan > 1 && !isNullOrUndefined(row.ownerTable)) {
            //Checks the rowspan is already exist in the list
            if (!row.ownerTable.spannedRowCollection.containsKey(row.index + rowSpan - 1)) {
                row.ownerTable.spannedRowCollection.add(row.index + rowSpan - 1, row.index);
            }
        }
    }
    /**
     * Updates row height by cell spacing
     * @param rowWidget
     * @param viewer
     * @param row
     */
    updateRowHeightByCellSpacing(tableCollection, row, viewer) {
        if (row.ownerTable.tableFormat.cellSpacing > 0) {
            // In the Case of tableWidget is greater than one and rowWidget is start at the Top Position of the page. 
            // In such case we have update the row height with half of cell spacing.
            // Remaining cases we have to update the entire hight
            // tslint:disable-next-line:max-line-length
            if (tableCollection.length > 1 && row.y === viewer.clientArea.y && viewer instanceof PageLayoutViewer) {
                row.height = row.height - HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.cellSpacing) / 2;
            }
        }
    }
    /**
     * Checks whether row span is end.
     * @param row
     * @param viewer
     */
    isRowSpanEnd(row, viewer) {
        let rowIndex = row.index;
        let rowSpan = 1;
        for (let i = 0; i < viewer.splittedCellWidgets.length; i++) {
            let splittedCell = viewer.splittedCellWidgets[i];
            // tslint:disable-next-line:max-line-length
            rowSpan = (isNullOrUndefined(splittedCell) || isNullOrUndefined(splittedCell.cellFormat)) ? rowSpan : splittedCell.cellFormat.rowSpan;
            if (rowIndex - splittedCell.rowIndex === rowSpan - 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks whether vertical merged cell to continue or not.
     * @param row
     * @private
     */
    isVerticalMergedCellContinue(row) {
        let colIndex = 0;
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            if (colIndex < cell.columnIndex) {
                return true;
            }
            colIndex += cell.cellFormat.columnSpan;
        }
        return colIndex < row.ownerTable.tableHolder.columns.length;
    }
    /**
     * Splits widgets.
     * @param tableRowWidget
     * @param viewer
     * @param splittedWidget
     * @param row
     */
    // tslint:disable-next-line:max-line-length
    splitWidgets(tableRowWidget, viewer, tableCollection, rowCollection, splittedWidget, isLastRow) {
        if (this.isFirstLineFitForRow(viewer.clientArea.bottom, tableRowWidget) && tableRowWidget.childWidgets.length > 0) {
            splittedWidget = this.getSplittedWidgetForRow(viewer.clientArea.bottom, tableCollection, rowCollection, tableRowWidget);
            if (viewer.splittedCellWidgets.length > 0 || splittedWidget !== tableRowWidget) {
                if (isLastRow) {
                    for (let i = 0; i < splittedWidget.childWidgets.length; i++) {
                        let cell = splittedWidget.childWidgets[i];
                        if (cell.rowIndex !== splittedWidget.index) {
                            splittedWidget.childWidgets.splice(i, 1);
                            i--;
                        }
                    }
                }
                //Adds the splitted widget of a vertical merged cell, to next row widget in the next page.
                this.insertSplittedCellWidgets(viewer, tableCollection, splittedWidget, tableRowWidget.indexInOwner - 1);
            }
        }
        else {
            //Adds the splitted widget of a vertical merged cell, to next row widget in the next page.
            this.insertSplittedCellWidgets(viewer, tableCollection, splittedWidget, tableRowWidget.indexInOwner - 1);
        }
        return splittedWidget;
    }
    /**
     * Gets splitted widget for row.
     * @param bottom
     * @param tableRowWidget
     */
    // tslint:disable-next-line:max-line-length
    getSplittedWidgetForRow(bottom, tableCollection, rowCollection, tableRowWidget) {
        let splittedWidget = undefined;
        let rowIndex = tableRowWidget.index;
        for (let i = 0; i < tableRowWidget.childWidgets.length; i++) {
            let cellWidget = tableRowWidget.childWidgets[i];
            let splittedCell = this.getSplittedWidget(bottom, true, tableCollection, rowCollection, cellWidget);
            if (!isNullOrUndefined(splittedCell)) {
                if (splittedCell === cellWidget) {
                    //Returns if the whole content of the row does not fit in current page.
                    return tableRowWidget;
                }
                if (tableRowWidget.childWidgets.indexOf(splittedCell) !== -1) {
                    tableRowWidget.childWidgets.splice(tableRowWidget.childWidgets.indexOf(splittedCell), 1);
                }
                if (i === 0 || tableRowWidget.height < cellWidget.height + cellWidget.margin.top + cellWidget.margin.bottom) {
                    tableRowWidget.height = cellWidget.height + cellWidget.margin.top + cellWidget.margin.bottom;
                }
                if (isNullOrUndefined(splittedWidget)) {
                    //Creates new widget, to hold the splitted contents.
                    splittedWidget = new TableRowWidget();
                    splittedWidget.containerWidget = tableRowWidget.containerWidget;
                    splittedWidget.index = tableRowWidget.index;
                    splittedWidget.rowFormat = tableRowWidget.rowFormat;
                    this.updateWidgetLocation(tableRowWidget, splittedWidget);
                    splittedWidget.height = 0;
                    rowCollection.push(splittedWidget);
                }
                let rowSpan = 1;
                // tslint:disable-next-line:max-line-length
                rowSpan = (isNullOrUndefined(splittedCell) || isNullOrUndefined(splittedCell.cellFormat)) ? rowSpan : splittedCell.cellFormat.rowSpan;
                if (rowIndex - splittedCell.rowIndex === rowSpan - 1
                    && splittedWidget.height < splittedCell.height + splittedCell.margin.top + splittedCell.margin.bottom) {
                    splittedWidget.height = splittedCell.height + splittedCell.margin.top + splittedCell.margin.bottom;
                }
                splittedWidget.childWidgets.push(splittedCell);
                splittedCell.containerWidget = splittedWidget;
            }
        }
        return splittedWidget;
    }
    /**
     * Updates widget to table.
     * @param row
     * @param viewer
     */
    /* tslint:disable */
    updateWidgetsToTable(tableWidgets, rowWidgets, row) {
        let rowHeight = this.getRowHeight(row, [row]);
        let viewer = this.viewer;
        //initializing row properties with default values.
        let isHeader = row.rowFormat.isHeader;
        let isAllowBreakAcrossPages = row.rowFormat.allowBreakAcrossPages;
        let heightType = row.rowFormat.heightType;
        let cellSpacing = 0;
        let count = 0;
        let tableRowWidget = row;
        let moveRowToNextTable = false;
        if (row.ownerTable.continueHeader && !isHeader) {
            row.ownerTable.continueHeader = false;
        }
        let isInitialLayout = row.ownerTable.isInsideTable;
        let isLastRow = false;
        cellSpacing = (!isNullOrUndefined(row.ownerTable) && !isNullOrUndefined(row.ownerTable.tableFormat)) ? HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.cellSpacing) : 0;
        while (count < rowWidgets.length) {
            count = rowWidgets.length;
            if (row.ownerTable.isInsideTable || (viewer.splittedCellWidgets.length === 0 && tableRowWidget.y + tableRowWidget.height + cellSpacing <= viewer.clientArea.bottom)) {
                if (this.isVerticalMergedCellContinue(row) && (tableRowWidget.y === viewer.clientArea.y
                    || tableRowWidget.y === this.viewer.clientArea.y + tableRowWidget.ownerTable.headerHeight)) {
                    this.insertSplittedCellWidgets(viewer, tableWidgets, tableRowWidget, tableRowWidget.index - 1);
                }
                this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget, undefined, isInitialLayout);
                if (viewer.splittedCellWidgets.length > 0 && isNullOrUndefined(rowWidgets[rowWidgets.length - 1].nextRow)) {
                    count--;
                    isLastRow = true;
                }
                isInitialLayout = false;
            }
            else {
                isInitialLayout = false;
                //Split widget for next page
                if (viewer.splittedCellWidgets.length > 0 && tableRowWidget.y + tableRowWidget.height <= viewer.clientArea.bottom) {
                    let isRowSpanEnd = this.isRowSpanEnd(row, viewer);
                    if (!isRowSpanEnd) {
                        if (this.isVerticalMergedCellContinue(row) && (tableRowWidget.y === viewer.clientArea.y
                            || tableRowWidget.y === this.viewer.clientArea.y + tableRowWidget.ownerTable.headerHeight)) {
                            this.insertSplittedCellWidgets(viewer, tableWidgets, tableRowWidget, tableRowWidget.indexInOwner - 1);
                        }
                        this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                        continue;
                    }
                }
                let splittedWidget = tableRowWidget;
                let tableWidget = tableWidgets[tableWidgets.length - 1];
                if (rowHeight + tableRowWidget.y > viewer.clientArea.bottom) {
                    // tslint:disable-next-line:max-line-length
                    if (!isAllowBreakAcrossPages || (isHeader && row.ownerTable.continueHeader) || (heightType === 'AtLeast' && HelperMethods.convertPointToPixel(row.rowFormat.height) < viewer.clientArea.bottom)) {
                        // tslint:disable-next-line:max-line-length
                        if ((heightType === 'AtLeast' && HelperMethods.convertPointToPixel(row.rowFormat.height) < viewer.clientActiveArea.height && isAllowBreakAcrossPages) || (heightType !== 'Exactly' && tableRowWidget.y === viewer.clientArea.y) || (heightType === 'Auto' && isAllowBreakAcrossPages)) {
                            splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                        }
                        if (heightType === 'Exactly' && tableRowWidget.y === viewer.clientArea.y) {
                            this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                            count++;
                        }
                        if (isHeader && row.ownerTable.continueHeader) {
                            row.ownerTable.header = false;
                            row.ownerTable.continueHeader = false;
                            row.ownerTable.headerHeight = 0;
                            let pages = undefined;
                            // if (viewer instanceof PageLayoutViewer) {
                            pages = viewer.pages;
                            // }
                            if (!isNullOrUndefined(pages)) {
                                for (let i = 0; i < pages.length; i++) {
                                    if (pages[i].repeatHeaderRowTableWidget) {
                                        pages[i].repeatHeaderRowTableWidget = false;
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if ((heightType === 'Auto' || heightType === 'AtLeast') && isAllowBreakAcrossPages) {
                            // tslint:disable-next-line:max-line-length
                            if (!(HelperMethods.convertPointToPixel(row.rowFormat.height) > viewer.clientArea.bottom) || tableRowWidget.y === viewer.clientArea.y) {
                                splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                            }
                        }
                        else if (heightType === 'Exactly' && tableRowWidget.y === viewer.clientArea.y) {
                            this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget);
                            count++;
                        }
                    }
                }
                else {
                    let isInsertSplittedWidgets = false;
                    // Splitting handled for the merged cell with allowRowBreakAcross pages. 
                    if (this.isVerticalMergedCellContinue(row) && (isAllowBreakAcrossPages ||
                        (isInsertSplittedWidgets = (tableRowWidget.y === viewer.clientArea.y
                            || tableRowWidget.y === this.viewer.clientArea.y + tableRowWidget.ownerTable.headerHeight)))) {
                        if (isInsertSplittedWidgets) {
                            this.insertSplittedCellWidgets(viewer, tableWidgets, splittedWidget, tableRowWidget.indexInOwner - 1);
                        }
                        else {
                            splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                        }
                    }
                    else if (isLastRow && !isAllowBreakAcrossPages) {
                        splittedWidget = this.splitWidgets(tableRowWidget, viewer, tableWidgets, rowWidgets, splittedWidget, isLastRow);
                    }
                }
                //Create New table for splitted widget
                if (!isNullOrUndefined(splittedWidget)) {
                    if (splittedWidget !== tableRowWidget) {
                        this.addWidgetToTable(viewer, tableWidgets, rowWidgets, tableRowWidget, tableRowWidget.nextRow);
                        //Updates the fitted table rows to current page.
                        this.updateWidgetsToPage(tableWidgets, rowWidgets, row.ownerTable, tableRowWidget.nextRow);
                        let index = tableWidgets.indexOf(tableRowWidget.containerWidget);
                        if (index + 1 >= tableWidgets.length) {
                            //Creates new table widget for splitted rows.
                            this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                        }
                        tableRowWidget = splittedWidget;
                    }
                    else {
                        if (row.index > 0) {
                            //Updates the fitted table rows to current page.
                            this.updateWidgetsToPage(tableWidgets, rowWidgets, row.ownerTable, row);
                            // Need to update on this further
                            if (row.previousRenderedWidget instanceof TableRowWidget) {
                                // Need to update on this further
                                let prevWidget = row.previousRenderedWidget;
                                if (HelperMethods.round(tableRowWidget.y, 2) === HelperMethods.round(prevWidget.y + prevWidget.height, 2)) {
                                    let prevIndex = tableWidgets.indexOf(prevWidget.containerWidget);
                                    if (prevIndex + 1 >= tableWidgets.length) {
                                        //Creates new table widget for splitted rows.
                                        this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                                    }
                                }
                                else {
                                    //Creates new table widget for splitted rows.
                                    this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                                }
                            }
                            else {
                                //Creates new table widget for splitted rows.
                                this.addTableWidget(viewer.clientActiveArea, tableWidgets, true);
                            }
                        }
                        moveRowToNextTable = true;
                        count--;
                    }
                    tableWidget = tableWidgets[tableWidgets.length - 1];
                    let prevBodyWidget = undefined;
                    if (tableWidgets.length > 1) {
                        //Get Previous Splitted Widget container
                        prevBodyWidget = tableWidgets[tableWidgets.length - 2].containerWidget;
                    }
                    else {
                        let previousBlock = row.ownerTable.previousRenderedWidget;
                        prevBodyWidget = previousBlock.containerWidget;
                    }
                    let pageIndex = 0;
                    if (!isNullOrUndefined(prevBodyWidget)) {
                        pageIndex = viewer.pages.indexOf(prevBodyWidget.page);
                    }
                    let index = row.ownerTable.containerWidget.index;
                    let bodyWidget;
                    let block;
                    if (moveRowToNextTable && tableWidgets.length === 1) {
                        block = tableWidgets[tableWidgets.length - 1];
                    }
                    else {
                        block = tableWidgets[tableWidgets.length - 2];
                    }
                    bodyWidget = this.moveBlocksToNextPage(block);
                    let curretTable = tableWidgets[tableWidgets.length - 1];
                    //Move Next RowWidge to next page
                    if (moveRowToNextTable) {
                        // tslint:disable-next-line:max-line-length
                        if (row.index === 0 && curretTable.containerWidget && curretTable.containerWidget.childWidgets.indexOf(curretTable) !== -1) {
                            curretTable.containerWidget.childWidgets.splice(curretTable.containerWidget.childWidgets.indexOf(curretTable), 1);
                        }
                    }
                    if (bodyWidget.childWidgets.indexOf(curretTable) !== -1) {
                        bodyWidget.childWidgets.splice(bodyWidget.childWidgets.indexOf(curretTable), 1);
                    }
                    bodyWidget.childWidgets.unshift(curretTable);
                    curretTable.containerWidget = bodyWidget;
                    if (moveRowToNextTable && row.index > 0 || rowWidgets.length > 1) {
                        this.moveNextWidgetsToTable(tableWidgets, rowWidgets, !moveRowToNextTable);
                    }
                    moveRowToNextTable = false;
                    if (row.ownerTable.header && tableRowWidget.height < viewer.clientArea.bottom) {
                        // if (viewer instanceof PageLayoutViewer) {
                        viewer.currentRenderingPage.repeatHeaderRowTableWidget = true;
                        // }
                        //Updates table widgets location.
                        viewer.updateClientAreaForBlock(row.ownerTable, true, tableWidgets);
                        // tslint:disable-next-line:max-line-length
                        //Update splitted row widget location. if header is repeated update the y position of splitted widget to header height.
                        splittedWidget.x = splittedWidget.x;
                        splittedWidget.y = tableWidget.y + row.ownerTable.headerHeight;
                        // let cellspace: number = viewer instanceof PageLayoutViewer ? cellspacing / 2 : cellspacing;
                        let cellspace = cellSpacing / 2;
                        this.updateChildLocationForRow(tableWidget.y + row.ownerTable.headerHeight - cellspace, splittedWidget);
                    }
                    else {
                        //Updates table widgets location.
                        viewer.updateClientAreaForBlock(row.ownerTable, true, tableWidgets);
                        // tslint:disable-next-line:max-line-length
                        //Update splitted row widget location. if header is repeated update the y position of splitted widget to header height.
                        splittedWidget.x = splittedWidget.x;
                        splittedWidget.y = tableWidget.y;
                        // let cellspace: number = viewer instanceof PageLayoutViewer ? cellspacing / 2 : cellspacing;
                        let cellspace = cellSpacing / 2;
                        this.updateChildLocationForRow(tableWidget.y - cellspace, splittedWidget);
                    }
                }
                isLastRow = false;
            }
            if (isHeader && row.ownerTable.continueHeader) {
                row.ownerTable.header = true;
                row.ownerTable.headerHeight = rowHeight + row.ownerTable.headerHeight;
            }
            if (isHeader && !isNullOrUndefined(this.getHeader(row.ownerTable)) && row.index === this.getHeader(row.ownerTable).index) {
                let headerHeight = this.getHeaderHeight(row.ownerTable, row, rowWidgets);
                if (headerHeight > row.ownerTable.headerHeight || headerHeight > row.ownerTable.headerHeight) {
                    row.ownerTable.headerHeight = headerHeight;
                }
                if (row.ownerTable.headerHeight > viewer.clientArea.height) {
                    row.ownerTable.header = false;
                    row.ownerTable.continueHeader = false;
                    row.ownerTable.headerHeight = 0;
                    let pages = viewer.pages;
                    for (let i = 0; i < pages.length; i++) {
                        if (pages[i].repeatHeaderRowTableWidget) {
                            pages[i].repeatHeaderRowTableWidget = false;
                        }
                    }
                }
            }
            if (tableWidgets.length > 2 && row.ownerTable.header && tableRowWidget.height < viewer.clientActiveArea.bottom &&
                !viewer.currentRenderingPage.repeatHeaderRowTableWidget) {
                viewer.currentRenderingPage.repeatHeaderRowTableWidget = true;
            }
        }
    }
    /* tslint:enable */
    /**
     * Gets header.
     * @param table
     * @private
     */
    getHeader(table) {
        let header = undefined;
        let flag = true;
        table = table.getSplitWidgets()[0];
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.rowFormat.isHeader) {
                header = row;
            }
            else {
                flag = false;
            }
            if (!flag) {
                break;
            }
        }
        return header;
    }
    /**
     * Gets header height.
     * @param ownerTable
     * @param row
     */
    getHeaderHeight(ownerTable, row, rowCollection) {
        let height = 0;
        if (row.ownerTable.childWidgets.length > 0 && ownerTable.childWidgets[0].rowFormat.isHeader) {
            for (let i = 0; i < ownerTable.childWidgets.length; i++) {
                let row = ownerTable.childWidgets[i];
                if (row.rowFormat.isHeader) {
                    height = height + this.getRowHeight(row, rowCollection);
                }
                else {
                    break;
                }
            }
        }
        return height;
    }
    /**
     * Updates widgets to row.
     * @param cell
     */
    updateWidgetToRow(cell) {
        let viewer = this.viewer;
        //Adds table cell widget to owner row widget.
        let rowWidget = cell.ownerRow;
        let cellLeft = rowWidget.x;
        if (rowWidget.childWidgets.length > 0) {
            let lastWidget = rowWidget.childWidgets[rowWidget.childWidgets.length - 1];
            cellLeft = lastWidget.x + lastWidget.width + lastWidget.margin.right;
        }
        // rowWidget.childWidgets.push(cell);
        cell.containerWidget = rowWidget;
        //If the row height is set as Atleast then height is set to atleast height for the first cell of the row.
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(cell.ownerRow) && cell.ownerRow.rowFormat.heightType !== 'Exactly' && HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.height) > 0 && cell.cellIndex === 0) {
            rowWidget.height = rowWidget.height + HelperMethods.convertPointToPixel(cell.ownerRow.rowFormat.height);
        }
        //Add condition not cell merged vertically.
        if (cell.cellFormat.rowSpan === 1) {
            let cellHeight = cell.height + cell.margin.top + cell.margin.bottom;
            if (rowWidget.height - HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing) < cellHeight) {
                rowWidget.height = cellHeight + HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing);
            }
        }
    }
    /**
     * Updates height for row widget.
     * @param viewer
     * @param isUpdateVerticalPosition
     * @param rowWidget
     */
    // tslint:disable-next-line:max-line-length
    updateHeightForRowWidget(viewer, isUpdateVerticalPosition, tableCollection, rowCollection, rowWidget, isLayouted, endRowWidget, isInitialLayout) {
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellspacing = 0;
            let cellWidget = undefined;
            let childWidget = rowWidget.childWidgets[i];
            // if (childWidget instanceof TableCellWidget) {
            cellWidget = childWidget;
            // }
            let rowSpan = 1;
            rowSpan = cellWidget.cellFormat.rowSpan;
            cellspacing = HelperMethods.convertPointToPixel(cellWidget.ownerTable.tableFormat.cellSpacing);
            if (rowSpan > 1) {
                let currentRowWidgetIndex = rowWidget.containerWidget.childWidgets.indexOf(rowWidget);
                // tslint:disable-next-line:max-line-length
                let rowSpanWidgetEndIndex = currentRowWidgetIndex + rowSpan - 1 - (rowWidget.index - cellWidget.rowIndex);
                if (!isInitialLayout && (viewer.clientArea.bottom < cellWidget.y + cellWidget.height + cellWidget.margin.bottom
                    || rowSpanWidgetEndIndex >= currentRowWidgetIndex + 1)) {
                    this.splitSpannedCellWidget(cellWidget, tableCollection, rowCollection, viewer);
                }
                let spanEndRowWidget = rowWidget;
                if (rowSpanWidgetEndIndex > 0) {
                    if (rowSpanWidgetEndIndex < rowWidget.containerWidget.childWidgets.length) {
                        let childWidget = rowWidget.containerWidget.childWidgets[rowSpanWidgetEndIndex];
                        if (childWidget instanceof TableRowWidget) {
                            spanEndRowWidget = childWidget;
                            if (spanEndRowWidget === endRowWidget) {
                                spanEndRowWidget = rowWidget;
                            }
                        }
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        spanEndRowWidget = rowWidget.containerWidget.childWidgets[rowWidget.containerWidget.childWidgets.length - 1];
                    }
                }
                if (cellWidget.y + cellWidget.height + cellWidget.margin.bottom < spanEndRowWidget.y + spanEndRowWidget.height) {
                    cellWidget.height = spanEndRowWidget.y + spanEndRowWidget.height - cellWidget.y - cellWidget.margin.bottom;
                    // tslint:disable-next-line:max-line-length
                }
                else if (isLayouted && spanEndRowWidget && (spanEndRowWidget.y !== 0 && spanEndRowWidget.height !== 0) && cellWidget.y + cellWidget.height + cellWidget.margin.bottom > spanEndRowWidget.y + spanEndRowWidget.height) {
                    spanEndRowWidget.height = cellWidget.y + cellWidget.height + cellWidget.margin.bottom - spanEndRowWidget.y;
                    // tslint:disable-next-line:max-line-length
                    //Update the next rowlayout widget location. Reason for the updation is previous row height is updated when cell height is greater. So already layouted next row location has to be updated again.
                    // if (rowWidget === spanEndRowWidget && rowWidget.nextWidget instanceof TableRowWidget) {
                    //     let nextRow: TableRowWidget = rowWidget.nextWidget as TableRowWidget;
                    //     // Need to update on this further
                    //     // if (viewer.renderedElements.containsKey(nextRow)) {
                    //     //     let nextWidget: TableRowWidget[] = viewer.renderedElements.get(nextRow) as TableRowWidget[];
                    //     //     if (nextWidget.length > 0) {
                    //     //         nextWidget[0].x = nextWidget[0].x;
                    //     //         nextWidget[0].y = rowWidget.y + rowWidget.height;
                    //     //     }
                    //     // }
                    // }
                }
            }
            else {
                if (cellspacing > 0) {
                    // In the Case of tableWidget is greater than one and rowWidget is start at the Top Position of the page. 
                    // In such case we have update the cell height with half of cell spacing.
                    // Remaining cases we have to update the entire hight
                    // tslint:disable-next-line:max-line-length
                    if (tableCollection.length > 1 && rowWidget.y === viewer.clientArea.y && viewer instanceof PageLayoutViewer) {
                        cellspacing = cellspacing / 2;
                    }
                }
                cellWidget.height = rowWidget.height - cellWidget.margin.top - cellWidget.margin.bottom - cellspacing;
            }
            this.updateHeightForCellWidget(viewer, tableCollection, rowCollection, cellWidget);
            let widget = rowWidget.containerWidget;
            while (widget.containerWidget instanceof Widget) {
                widget = widget.containerWidget;
            }
            let page = undefined;
            if (widget instanceof BodyWidget) {
                page = widget.page;
            }
            // tslint:disable-next-line:max-line-length
            if ((viewer instanceof PageLayoutViewer && viewer.visiblePages.indexOf(page) !== -1) || isUpdateVerticalPosition) {
                this.updateCellVerticalPosition(cellWidget, false, false);
            }
            //Renders the current table row contents, after relayout based on editing.
            // if (viewer instanceof PageLayoutViewer && (viewer as PageLayoutViewer).visiblePages.indexOf(page) !== -1) {
            //     //Added proper undefined condition check for Asynchronous operation.
            //     if (!isNullOrUndefined(rowWidget.tableRow) && !isNullOrUndefined(rowWidget.tableRow.rowFormat)) {
            //         this.viewer.updateScrollBars();
            //         //this.render.renderTableCellWidget(page, cellWidget);
            //     }
            // }
        }
    }
    /**
     * Updates height for cell widget.
     * @param viewer
     * @param cellWidget
     */
    // tslint:disable-next-line:max-line-length
    updateHeightForCellWidget(viewer, tableWidget, rowCollection, cellWidget) {
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof TableWidget) {
                this.updateHeightForTableWidget(tableWidget, rowCollection, cellWidget.childWidgets[i]);
            }
        }
    }
    /**
     * Gets row height.
     * @param row
     * @private
     */
    getRowHeight(row, rowCollection) {
        let height = 0;
        if (row.rowFormat.heightType === 'Exactly') {
            height = row.rowFormat.height;
        }
        else {
            for (let i = 0; i < rowCollection.length; i++) {
                if (rowCollection[i] instanceof TableRowWidget) {
                    height = rowCollection[i].height + height;
                }
            }
            height = Math.max(height, row.rowFormat.height);
        }
        return height;
    }
    /**
     * splits spanned cell widget.
     * @param cellWidget
     * @param viewer
     */
    // tslint:disable-next-line:max-line-length
    splitSpannedCellWidget(cellWidget, tableCollection, rowCollection, viewer) {
        let splittedCell = this.getSplittedWidget(viewer.clientArea.bottom, false, tableCollection, rowCollection, cellWidget);
        if (!isNullOrUndefined(splittedCell)) {
            //Adds the splitted contents of a vertical merged cell, in order preserve in next page.
            viewer.splittedCellWidgets.push(splittedCell);
        }
    }
    /**
     * Inserts splitted cell widgets.
     * @param viewer
     * @param rowWidget
     */
    // tslint:disable-next-line:max-line-length
    insertSplittedCellWidgets(viewer, tableCollection, rowWidget, previousRowIndex) {
        let left = rowWidget.x;
        let tableWidth = 0;
        tableWidth = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableHolder.tableWidth);
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellWidget = rowWidget.childWidgets[i];
            if (Math.round(left) < Math.round(cellWidget.x - cellWidget.margin.left)) {
                if (this.insertRowSpannedWidget(rowWidget, viewer, left, i)) {
                    i--;
                    continue;
                }
                let length = rowWidget.childWidgets.length;
                this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, i, previousRowIndex);
                if (length < rowWidget.childWidgets.length) {
                    i--;
                    continue;
                }
            }
            left += cellWidget.margin.left + cellWidget.width + cellWidget.margin.right;
            if (i === rowWidget.childWidgets.length - 1 && Math.round(left) < Math.round(rowWidget.x + tableWidth)) {
                if (this.insertRowSpannedWidget(rowWidget, viewer, left, i + 1)) {
                    continue;
                }
                this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, i + 1, previousRowIndex);
                continue;
            }
        }
        // tslint:disable-next-line:max-line-length
        // Special case: when the child widgets of row is equal to 0 then the splitted widgets in the viewer is added in the table row widgets. 
        if ((isNullOrUndefined(rowWidget.childWidgets) || rowWidget.childWidgets.length === 0) && viewer.splittedCellWidgets.length > 0) {
            for (let j = 0; j < viewer.splittedCellWidgets.length; j++) {
                let widget = viewer.splittedCellWidgets[j];
                if (Math.round(left) <= Math.round(widget.x - widget.margin.left)) {
                    if (this.insertRowSpannedWidget(rowWidget, viewer, left, j)) {
                        j--;
                        continue;
                    }
                    let count = rowWidget.childWidgets.length;
                    this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, j, previousRowIndex);
                    if (count < rowWidget.childWidgets.length) {
                        j--;
                        continue;
                    }
                }
                left += widget.margin.left + widget.width + widget.margin.right;
                if (j === rowWidget.childWidgets.length - 1 && Math.round(left) <
                    Math.round(rowWidget.x + tableWidth)) {
                    if (this.insertRowSpannedWidget(rowWidget, viewer, left, j + 1)) {
                        continue;
                    }
                    this.insertEmptySplittedCellWidget(rowWidget, tableCollection, left, j + 1, previousRowIndex);
                    continue;
                }
            }
        }
        if (viewer.splittedCellWidgets.length > 0) {
            viewer.splittedCellWidgets = [];
        }
    }
    /**
     * Inserts spanned row widget.
     * @param rowWidget
     * @param viewer
     * @param left
     * @param index
     */
    insertRowSpannedWidget(rowWidget, viewer, left, index) {
        let cellSpacing = 0;
        if (rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            cellSpacing = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
        }
        for (let i = 0; i < viewer.splittedCellWidgets.length; i++) {
            let splittedCell = viewer.splittedCellWidgets[i];
            if (Math.round(left) === Math.round(splittedCell.x - splittedCell.margin.left)) {
                rowWidget.childWidgets.splice(index, 0, splittedCell);
                splittedCell.containerWidget = rowWidget;
                //If the splitted cell location differs from expected location update the location of row child widgets.
                if (splittedCell.y !== rowWidget.y + splittedCell.margin.top + cellSpacing) {
                    this.updateChildLocationForRow(rowWidget.y, rowWidget);
                }
                viewer.splittedCellWidgets.splice(i, 1);
                return true;
            }
        }
        return false;
    }
    /**
     * Inserts empty splitted cell widgets.
     * @param rowWidget
     * @param left
     * @param index
     */
    // tslint:disable-next-line:max-line-length
    insertEmptySplittedCellWidget(currentRow, tableCollection, left, index, previousRowIndex) {
        let tableWidget = tableCollection[tableCollection.length - 1];
        let previousRow;
        for (let j = tableCollection.length - 1; j >= 0; j--) {
            let table = tableCollection[j];
            for (let z = table.childWidgets.length - 1; z >= 0; z--) {
                let row = table.childWidgets[z];
                if (row.index === previousRowIndex) {
                    previousRow = row;
                    break;
                }
            }
        }
        if (previousRow) {
            tableWidget = previousRow.ownerTable;
            previousRowIndex = previousRow.indexInOwner;
        }
        for (let i = previousRowIndex; i >= 0; i--) {
            let rowWidget = tableWidget.childWidgets[i];
            let previousLeft = rowWidget.x;
            for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                let rowSpan = 1;
                let cellWidget = rowWidget.childWidgets[j];
                if (Math.round(left) === Math.round(previousLeft)) {
                    rowSpan = (isNullOrUndefined(cellWidget) || isNullOrUndefined(cellWidget.cellFormat)) ? rowSpan :
                        cellWidget.cellFormat.rowSpan;
                    if (rowSpan > 1) {
                        let emptyCellWidget = this.createCellWidget(cellWidget);
                        currentRow.childWidgets.splice(index, 0, emptyCellWidget);
                        emptyCellWidget.containerWidget = currentRow;
                        this.updateChildLocationForRow(currentRow.y, currentRow);
                        return;
                    }
                }
                previousLeft += cellWidget.margin.left + cellWidget.width + cellWidget.margin.right;
            }
        }
    }
    /**
     * Gets spllited widget.
     * @param bottom
     * @param splitMinimalWidget
     * @param cellWidget
     */
    // tslint:disable-next-line:max-line-length
    getSplittedWidget(bottom, splitMinimalWidget, tableCollection, rowCollection, cellWidget) {
        let splittedWidget = undefined;
        if (cellWidget.y + cellWidget.height > bottom - cellWidget.margin.bottom) {
            for (let i = 0; i < cellWidget.childWidgets.length; i++) {
                if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                    let paragraphWidget = cellWidget.childWidgets[i];
                    let splittedPara = this.getSplittedWidgetForPara(bottom - cellWidget.margin.bottom, paragraphWidget);
                    if (!isNullOrUndefined(splittedPara)) {
                        if (i === 0 && splittedPara === paragraphWidget) {
                            //Returns if the whole content of the cell does not fit in current page.
                            return cellWidget;
                        }
                        if (cellWidget.childWidgets.indexOf(splittedPara) !== -1) {
                            cellWidget.childWidgets.splice(cellWidget.childWidgets.indexOf(splittedPara), 1);
                            i--;
                        }
                        cellWidget.height -= splittedPara.height;
                        if (isNullOrUndefined(splittedWidget)) {
                            //Creates new widget, to hold the splitted contents.
                            splittedWidget = this.createCellWidget(cellWidget);
                        }
                        splittedWidget.height += splittedPara.height;
                        splittedWidget.childWidgets.push(splittedPara);
                        splittedPara.containerWidget = splittedWidget;
                    }
                }
                else {
                    let tableWidget = cellWidget.childWidgets[i];
                    let tableCol = [tableWidget];
                    //Check for nested table.
                    if (bottom - cellWidget.margin.bottom < tableWidget.y + tableWidget.height) {
                        let tableHeight = tableWidget.height;
                        // tslint:disable-next-line:max-line-length
                        let splittedTable = this.getSplittedWidgetForTable(bottom - cellWidget.margin.bottom, tableCol, tableWidget);
                        if (!isNullOrUndefined(splittedTable)) {
                            if (i === 0 && splittedTable === tableWidget) {
                                //Returns if the whole table does not fit in current page.
                                return cellWidget;
                            }
                            if (cellWidget.childWidgets.indexOf(splittedTable) !== -1) {
                                cellWidget.childWidgets.splice(cellWidget.childWidgets.indexOf(splittedTable), 1);
                                i--;
                                cellWidget.height -= splittedTable.height;
                            }
                            else {
                                cellWidget.height -= tableHeight - tableWidget.height;
                            }
                            if (isNullOrUndefined(splittedWidget)) {
                                //Creates new widget, to hold the splitted contents.
                                splittedWidget = this.createCellWidget(cellWidget);
                            }
                            splittedWidget.height += splittedTable.height;
                            splittedWidget.childWidgets.push(splittedTable);
                            splittedTable.containerWidget = splittedWidget;
                        }
                    }
                }
            }
        }
        if (isNullOrUndefined(splittedWidget) && splitMinimalWidget) {
            //Creates new widget, to hold the splitted contents.
            splittedWidget = this.createCellWidget(cellWidget);
        }
        return splittedWidget;
    }
    /**
     * Gets list level pattern
     * @param value
     * @private
     */
    getListLevelPattern(value) {
        switch (value) {
            case 0:
                return 'Arabic';
            case 1:
                return 'UpRoman';
            case 2:
                return 'LowRoman';
            case 3:
                return 'UpLetter';
            case 4:
                return 'LowLetter';
            case 5:
                return 'Ordinal';
            case 6:
                return 'Number';
            case 7:
                return 'OrdinalText';
            case 8:
                return 'LeadingZero';
            case 9:
                return 'Bullet';
            case 10:
                return 'FarEast';
            case 11:
                return 'Special';
            default:
                return 'None';
        }
    }
    /**
     * Creates cell widget.
     * @param cell
     */
    createCellWidget(cell) {
        let cellWidget = new TableCellWidget();
        cellWidget.cellFormat = cell.cellFormat;
        cellWidget.index = cell.index;
        cellWidget.rowIndex = cell.rowIndex;
        cellWidget.columnIndex = cell.columnIndex;
        cellWidget.containerWidget = cell.containerWidget;
        this.updateWidgetLocation(cell, cellWidget);
        cellWidget.margin = cell.margin;
        cellWidget.leftBorderWidth = HelperMethods.convertPointToPixel(cell.leftBorderWidth);
        cellWidget.rightBorderWidth = HelperMethods.convertPointToPixel(cell.rightBorderWidth);
        return cellWidget;
    }
    /**
     * Create Table Widget
     */
    createTableWidget(table) {
        let newTable = new TableWidget();
        if (table.header) {
            newTable.header = table.header;
            newTable.headerHeight = table.headerHeight;
        }
        newTable.index = table.index;
        newTable.tableFormat = table.tableFormat;
        newTable.tableHolder = table.tableHolder;
        newTable.isGridUpdated = table.isGridUpdated;
        return newTable;
    }
    /**
     * Gets splitted widget for paragraph.
     * @param bottom
     * @param paragraphWidget
     */
    getSplittedWidgetForPara(bottom, paragraphWidget) {
        let lineBottom = paragraphWidget.y;
        let splittedWidget = undefined;
        for (let i = 0; i < paragraphWidget.childWidgets.length; i++) {
            let lineWidget = paragraphWidget.childWidgets[i];
            if (bottom < lineBottom + lineWidget.height) {
                if (i === 0) {
                    if (lineWidget.paragraph.containerWidget instanceof TableCellWidget) {
                        //checks first line of the page is exceed the page height
                        if (lineWidget.paragraph.containerWidget.y === paragraphWidget.y) {
                            lineBottom += lineWidget.height;
                            continue;
                        }
                    }
                    splittedWidget = paragraphWidget;
                    break;
                }
                if (paragraphWidget.childWidgets.indexOf(lineWidget) !== -1) {
                    paragraphWidget.childWidgets.splice(paragraphWidget.childWidgets.indexOf(lineWidget), 1);
                    i--;
                }
                paragraphWidget.height -= lineWidget.height;
                if (isNullOrUndefined(splittedWidget)) {
                    //Creates new widget, to hold the splitted contents.
                    splittedWidget = new ParagraphWidget();
                    splittedWidget.characterFormat = paragraphWidget.characterFormat;
                    splittedWidget.paragraphFormat = paragraphWidget.paragraphFormat;
                    splittedWidget.index = paragraphWidget.index;
                    this.updateWidgetLocation(paragraphWidget, splittedWidget);
                    splittedWidget.height = lineWidget.height;
                }
                else {
                    splittedWidget.height += lineWidget.height;
                }
                splittedWidget.childWidgets.push(lineWidget);
                lineWidget.paragraph = splittedWidget;
            }
            lineBottom += lineWidget.height;
        }
        return splittedWidget;
    }
    /**
     * Gets splitted table widget.
     * @param bottom
     * @param tableWidget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getSplittedWidgetForTable(bottom, tableCollection, tableWidget) {
        let rowBottom = tableWidget.y;
        let splittedWidget = undefined;
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = undefined;
            let childWidget = tableWidget.childWidgets[i];
            // if (childWidget instanceof TableRowWidget) {
            rowWidget = childWidget;
            // }
            let rowHeight = rowWidget.height;
            if (bottom < rowBottom + rowHeight || !isNullOrUndefined(splittedWidget)) {
                //ToDo: Check whether row included in vertical merge or AllowRowSplitbyPage is true, if so split row.
                //Checks if atleast first line fits in the client area.                
                let splittedRow = undefined;
                let allowRowBreakAcrossPages = true;
                if (!isNullOrUndefined(rowWidget) && !isNullOrUndefined(rowWidget.rowFormat)) {
                    allowRowBreakAcrossPages = rowWidget.rowFormat.allowBreakAcrossPages;
                }
                if (allowRowBreakAcrossPages) {
                    // tslint:disable-next-line:max-line-length
                    splittedRow = (isNullOrUndefined(splittedWidget) && this.isFirstLineFitForRow(bottom, rowWidget)) ? this.getSplittedWidgetForRow(bottom, tableCollection, [rowWidget], rowWidget) : rowWidget;
                }
                if (!isNullOrUndefined(splittedRow)) {
                    if (i === 0 && splittedRow === rowWidget) {
                        //Returns if the whole table does not fit in current page.
                        return tableWidget;
                    }
                    if (tableWidget.childWidgets.indexOf(splittedRow) !== -1) {
                        tableWidget.childWidgets.splice(tableWidget.childWidgets.indexOf(splittedRow), 1);
                        i--;
                        tableWidget.height -= splittedRow.height;
                    }
                    else {
                        tableWidget.height -= rowHeight - rowWidget.height;
                    }
                    if (isNullOrUndefined(splittedWidget)) {
                        //Creates new widget, to hold the splitted contents.
                        splittedWidget = this.createTableWidget(tableWidget);
                        this.updateWidgetLocation(tableWidget, splittedWidget);
                        splittedWidget.height = splittedRow.height;
                    }
                    else {
                        splittedWidget.height += splittedRow.height;
                    }
                    splittedWidget.childWidgets.push(splittedRow);
                    splittedRow.containerWidget = splittedWidget;
                }
            }
            rowBottom += rowWidget.height;
        }
        return splittedWidget;
    }
    /**
     * Checks whether first line fits for paragraph or not.
     * @param bottom
     * @param paraWidget
     */
    isFirstLineFitForPara(bottom, paraWidget) {
        let lineWidget = paraWidget.childWidgets[0];
        let cellwidget = lineWidget.paragraph.containerWidget;
        // let document: WordDocument = undefined;
        // if (!isNullOrUndefined(lineWidget.paragraph.currentNode) && !isNullOrUndefined(cellwidget.containerWidget)) {
        //     document = WordDocument.getDocumentOf(lineWidget.paragraph.currentNode);
        // }
        //checks first line of the page is exceed the page height
        if (this.viewer.isFirstLineFitInShiftWidgets) {
            if (this.viewer.clientActiveArea.y === this.viewer.clientArea.y && paraWidget.y + lineWidget.height >= bottom) {
                return true;
            }
        }
        else {
            // For nested tables,
            if (cellwidget.ownerTable.isInsideTable) {
                // Gets the container cell widgets, consider it as client area for the cell widget.
                let containerCellWidget = undefined;
                if (cellwidget.containerWidget instanceof TableRowWidget &&
                    cellwidget.containerWidget.containerWidget instanceof TableWidget
                    && cellwidget.containerWidget.containerWidget.containerWidget instanceof TableCellWidget) {
                    containerCellWidget = cellwidget.containerWidget.containerWidget.containerWidget;
                }
                if (!isNullOrUndefined(containerCellWidget) && cellwidget.containerWidget.y === containerCellWidget.y
                    && paraWidget.y + lineWidget.height >= bottom) {
                    return true;
                }
            }
            else if (cellwidget.containerWidget.y === this.viewer.clientArea.y && paraWidget.y + lineWidget.height >= bottom) {
                return true;
            }
        }
        return (paraWidget.y + lineWidget.height <= bottom);
    }
    /**
     * Checks whether first line fits for table or not.
     * @param bottom
     * @param tableWidget
     * @private
     */
    isFirstLineFitForTable(bottom, tableWidget) {
        let rowWidget = undefined;
        let isFit = false;
        let childWidget = tableWidget.childWidgets[0];
        // if (childWidget instanceof TableRowWidget) {
        rowWidget = childWidget;
        // }
        if (!isNullOrUndefined(rowWidget)) {
            isFit = this.isFirstLineFitForRow(bottom, rowWidget);
        }
        return isFit;
    }
    /**
     * Checks whether first line fits for row or not.
     * @param bottom
     * @param rowWidget
     */
    isFirstLineFitForRow(bottom, rowWidget) {
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellWidget = rowWidget.childWidgets[i];
            if (!this.isFirstLineFitForCell(bottom, cellWidget)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks whether first line fits for cell or not.
     * @param bottom
     * @param cellWidget
     */
    isFirstLineFitForCell(bottom, cellWidget) {
        if (cellWidget.childWidgets.length === 0) {
            return true;
        }
        if (cellWidget.childWidgets[0] instanceof ParagraphWidget) {
            let paraWidget = cellWidget.childWidgets[0];
            return this.isFirstLineFitForPara(bottom - cellWidget.margin.bottom, paraWidget);
        }
        else {
            let tableWidget = cellWidget.childWidgets[0];
            return this.isFirstLineFitForTable(bottom - cellWidget.margin.bottom, tableWidget);
        }
    }
    /**
     * Updates widget location.
     * @param widget
     * @param table
     */
    updateWidgetLocation(widget, table) {
        table.x = widget.x;
        table.y = widget.y;
        table.width = widget.width;
    }
    /**
     * Updates child location for table.
     * @param top
     * @param tableWidget
     * @private
     */
    updateChildLocationForTable(top, tableWidget) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = tableWidget.childWidgets[i];
            rowWidget.x = rowWidget.x;
            rowWidget.y = top;
            this.updateChildLocationForRow(top, rowWidget);
            top += rowWidget.height;
        }
    }
    /**
     * Updates child location for row.
     * @param top
     * @param rowWidget
     * @private
     */
    updateChildLocationForRow(top, rowWidget) {
        let spacing = 0;
        if (rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            spacing = HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
        }
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let cellWidget = rowWidget.childWidgets[i];
            cellWidget.x = cellWidget.x;
            cellWidget.y = top + cellWidget.margin.top + spacing;
            this.updateChildLocationForCell(cellWidget.y, cellWidget);
        }
    }
    /**
     * Updates child location for cell.
     * @param top
     * @param cellWidget
     */
    updateChildLocationForCell(top, cellWidget) {
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            cellWidget.childWidgets[i].x = cellWidget.childWidgets[i].x;
            cellWidget.childWidgets[i].y = top;
            if (cellWidget.childWidgets[i] instanceof TableWidget) {
                this.updateChildLocationForTable(top, cellWidget.childWidgets[i]);
            }
            top += cellWidget.childWidgets[i].height;
        }
    }
    /**
     * Updates cell vertical position.
     * @param cellWidget
     * @param isUpdateToTop
     * @param isInsideTable
     * @private
     */
    updateCellVerticalPosition(cellWidget, isUpdateToTop, isInsideTable) {
        if (cellWidget.ownerTable.containerWidget instanceof BodyWidget || isInsideTable) {
            let displacement = this.getDisplacement(cellWidget, isUpdateToTop);
            //Update Y position alone for the child widget of cell
            this.updateCellContentVerticalPosition(cellWidget, displacement, isUpdateToTop);
        }
    }
    /**
     * Updates cell content vertical position.
     * @param cellWidget
     * @param displacement
     * @param isUpdateToTop
     */
    updateCellContentVerticalPosition(cellWidget, displacement, isUpdateToTop) {
        if (displacement === 0) {
            return;
        }
        let location = cellWidget.y + displacement;
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                cellWidget.childWidgets[i].y = location;
            }
            else {
                location = this.updateTableWidgetLocation(cellWidget.childWidgets[i], location, isUpdateToTop);
            }
            location = location + cellWidget.childWidgets[i].height;
        }
    }
    /**
     * Updates table widget location.
     * @param tableWidget
     * @param location
     * @param isUpdateToTop
     */
    updateTableWidgetLocation(tableWidget, location, isUpdateToTop) {
        tableWidget.y = location = location + tableWidget.topBorderWidth;
        let cellSpacing = 0;
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = tableWidget.childWidgets[i];
            rowWidget.y = location;
            for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                let cellWidget = rowWidget.childWidgets[j];
                cellWidget.y = location + cellWidget.margin.top + cellSpacing;
                this.updateCellVerticalPosition(cellWidget, isUpdateToTop, true);
            }
            location = location + rowWidget.height;
        }
        return location;
    }
    /**
     * Gets displacement.
     * @param cellWidget
     * @param isUpdateToTop
     */
    getDisplacement(cellWidget, isUpdateToTop) {
        //Gets the height of row
        let rowHeight = 0;
        let rowWidget = cellWidget.containerWidget;
        let padding = cellWidget.margin.top + cellWidget.margin.bottom;
        if (!isNullOrUndefined(cellWidget.cellFormat) && cellWidget.cellFormat.rowSpan > 1) {
            rowHeight = cellWidget.height;
        }
        else {
            rowHeight = ((!isNullOrUndefined(rowWidget) ? rowWidget.height : 0) - padding);
        }
        //Gets the height of content within the cell
        let cellContentHeight = this.getCellContentHeight(cellWidget);
        //Displacement field holds the value which has reduced from rowHeight and cellContentHeight
        let displacement = 0;
        if (rowHeight > cellContentHeight) {
            displacement = rowHeight - cellContentHeight;
            if (cellWidget.cellFormat.verticalAlignment === 'Center') {
                displacement = displacement / 2;
            }
            else if ((cellWidget.cellFormat.verticalAlignment === 'Top' || isUpdateToTop)) {
                displacement = 0;
            }
        }
        return displacement;
    }
    /**
     * Gets cell content height.
     * @param cellWidget
     */
    getCellContentHeight(cellWidget) {
        if (isNullOrUndefined(cellWidget.childWidgets)) {
            return 0;
        }
        let contentHeight = 0;
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            if (cellWidget.childWidgets[i] instanceof ParagraphWidget) {
                contentHeight += cellWidget.childWidgets[i].height;
            }
            else {
                contentHeight += cellWidget.childWidgets[i].height;
            }
        }
        return contentHeight;
    }
    /**
     * Gets table left borders.
     * @param borders
     * @private
     */
    getTableLeftBorder(borders) {
        if (!isNullOrUndefined(borders.left)) {
            return borders.left;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Gets table right border.
     * @param borders
     * @private
     */
    getTableRightBorder(borders) {
        if (!isNullOrUndefined(borders.right)) {
            return borders.right;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Get table top border.
     * @param borders
     * @private
     */
    getTableTopBorder(borders) {
        if (!isNullOrUndefined(borders.top)) {
            return borders.top;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Gets table bottom border.
     * @param borders
     * @private
     */
    getTableBottomBorder(borders) {
        if (!isNullOrUndefined(borders.bottom)) {
            return borders.bottom;
        }
        else {
            let border = new WBorder(borders);
            border.lineStyle = 'Single';
            border.lineWidth = 0.66;
            return border;
        }
    }
    /**
     * Get diagonal cell up border.
     * @param tableCell
     * @private
     */
    getCellDiagonalUpBorder(tableCell) {
        let diagonalUpBorder = undefined;
        let cellBorder = undefined;
        cellBorder = tableCell.cellFormat.borders;
        diagonalUpBorder = cellBorder.diagonalUp;
        return diagonalUpBorder;
    }
    /**
     * Gets diagonal cell down border
     * @param tableCell
     * @private
     */
    getCellDiagonalDownBorder(tableCell) {
        let diagonalDownBorder = undefined;
        let cellBorder = undefined;
        cellBorder = tableCell.cellFormat.borders;
        diagonalDownBorder = cellBorder.diagonalDown;
        return diagonalDownBorder;
    }
    /**
     * Gets table width.
     * @param table
     * @private
     */
    getTableWidth(table) {
        let width = 0;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowWidth = 0;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                rowWidth += HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    //#region shifting
    /**
     * @private
     */
    layoutNextItemsBlock(blockAdv, viewer) {
        let sectionIndex = blockAdv.bodyWidget.sectionIndex;
        let block = blockAdv;
        let splittedWidget = block.getSplitWidgets();
        let nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        if (isNullOrUndefined(nextBlock) || this.viewer.blockToShift === block) {
            this.viewer.blockToShift = undefined;
        }
        let updateNextBlockList = true;
        while (nextBlock instanceof BlockWidget && nextBlock.bodyWidget.sectionIndex === sectionIndex) {
            let currentWidget = undefined;
            let blocks = block.getSplitWidgets();
            currentWidget = blocks[blocks.length - 1];
            // if (viewer.fieldEndParagraph === block) {
            //     //Sets field end paragraph to undefined, inorder to hold reLayouting with this paragraph.
            //     viewer.fieldEndParagraph = undefined;
            // }
            block = nextBlock;
            if (viewer.blockToShift === block) {
                viewer.blockToShift = undefined;
            }
            updateNextBlockList = false;
            let nextWidget = undefined;
            nextWidget = block.getSplitWidgets()[0];
            // tslint:disable-next-line:max-line-length
            if (viewer.fieldStacks.length === 0 && !isNullOrUndefined(nextWidget) && currentWidget.containerWidget === nextWidget.containerWidget
                && (HelperMethods.round(nextWidget.y, 2) === HelperMethods.round(currentWidget.y + currentWidget.height, 2))) {
                if (!isNullOrUndefined(viewer.blockToShift)) {
                    viewer.blockToShift = block;
                }
                break;
            }
            updateNextBlockList = true;
            if (viewer.owner.isShiftingEnabled && viewer.fieldStacks.length === 0) {
                viewer.blockToShift = block;
                break;
            }
            else if (isNullOrUndefined(this.viewer.owner.editorModule) || !this.viewer.owner.editorModule.isInsertingTOC) {
                block = block.combineWidget(this.viewer);
                let paragraph;
                if (currentWidget.containerWidget !== block.containerWidget) {
                    if (!(currentWidget instanceof ParagraphWidget) ||
                        (currentWidget instanceof ParagraphWidget) && !currentWidget.isEndsWithPageBreak) {
                        // tslint:disable-next-line:max-line-length
                        this.updateContainerWidget(block, currentWidget.containerWidget, currentWidget.indexInOwner + 1, false);
                    }
                }
                if (block instanceof TableWidget) {
                    this.clearTableWidget(block, true, true);
                    block.isGridUpdated = false;
                    paragraph = this.viewer.selection.getFirstParagraphInFirstCell(block);
                }
                else {
                    paragraph = block;
                }
                if ((this.viewer.owner.isDocumentLoaded) && this.viewer.owner.editorModule) {
                    this.viewer.owner.editorModule.updateWholeListItems(paragraph);
                }
                viewer.updateClientAreaForBlock(block, true);
                this.viewer.layout.layoutBlock(block, 0);
                viewer.updateClientAreaForBlock(block, false);
            }
            splittedWidget = nextBlock.getSplitWidgets();
            nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        }
        if (!viewer.owner.isShiftingEnabled || (this.viewer.blockToShift !== block)) {
            this.viewer.owner.editorModule.updateListItemsTillEnd(block, updateNextBlockList);
        }
    }
    /**
     * @private
     */
    updateClientAreaForLine(paragraph, startLineWidget, elementIndex) {
        //Clears the line widget starting from current line.
        let top = this.viewer.selection.getTop(startLineWidget);
        let left = this.viewer.clientArea.x;
        this.viewer.cutFromTop(top);
        this.viewer.cutFromLeft(left);
    }
    /**
     * @private
     */
    getParentTable(block) {
        let widget = block;
        while (widget.containerWidget) {
            if (widget.containerWidget instanceof BlockContainer) {
                return widget;
            }
            widget = widget.containerWidget;
        }
        return undefined;
    }
    /**
     * @private
     */
    reLayoutParagraph(paragraphWidget, lineIndex, elementBoxIndex, isBidi) {
        isBidi = isNullOrUndefined(isBidi) ? false : isBidi;
        if (this.viewer.blockToShift === paragraphWidget) {
            this.layoutBodyWidgetCollection(paragraphWidget.index, paragraphWidget.containerWidget, paragraphWidget, false);
            this.isBidiReLayout = true;
        }
        else {
            if (this.isBidiReLayout) {
                this.isBidiReLayout = false;
            }
        }
        // let isElementMoved: boolean = elementBoxIndex > 0;
        if (paragraphWidget.isInsideTable) {
            this.isBidiReLayout = true;
            this.reLayoutTable(paragraphWidget);
            this.isBidiReLayout = false;
        }
        else {
            this.reLayoutLine(paragraphWidget, lineIndex, isBidi);
        }
        if (paragraphWidget.bodyWidget instanceof HeaderFooterWidget &&
            paragraphWidget.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
            this.shiftFooterChildLocation(paragraphWidget.bodyWidget, this.viewer);
        }
    }
    /**
     * @private
     */
    reLayoutTable(block) {
        //Get Top level owner of block
        let table = this.getParentTable(block);
        //Combine splitted table in to single table
        let currentTable = table.combineWidget(this.viewer);
        let bodyWidget = currentTable.containerWidget;
        if (this.viewer.owner.enableHeaderAndFooter || block.isInHeaderFooter) {
            block.bodyWidget.isEmpty = false;
            bodyWidget.height -= currentTable.height;
            // tslint:disable-next-line:max-line-length
            this.viewer.updateHCFClientAreaWithTop(table.bodyWidget.sectionFormat, this.viewer.isBlockInHeader(table), bodyWidget.page);
        }
        else {
            this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
        }
        //Clear Hieght for all the content 
        if (this.viewer.owner.isDocumentLoaded && this.viewer.owner.editorModule) {
            let block = this.viewer.selection.getFirstParagraphInFirstCell(currentTable);
            this.viewer.owner.editorModule.updateWholeListItems(block);
        }
        this.viewer.updateClientAreaForBlock(currentTable, true);
        //Remove border width
        currentTable.x -= currentTable.leftBorderWidth;
        currentTable.y -= currentTable.topBorderWidth;
        //Update Client area for current position
        this.viewer.cutFromTop(currentTable.y);
        this.clearTableWidget(currentTable, true, true, true);
        this.layoutBlock(currentTable, 0, true);
        this.viewer.updateClientAreaForBlock(currentTable, false);
        this.layoutNextItemsBlock(currentTable, this.viewer);
    }
    /**
     * @private
     */
    clearTableWidget(table, clearPosition, clearHeight, clearGrid) {
        table.height = 0;
        if (clearGrid) {
            table.isGridUpdated = false;
        }
        if (clearPosition) {
            table.y = 0;
            table.x = 0;
        }
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            this.clearRowWidget(row, clearPosition, clearHeight, clearGrid);
        }
    }
    /**
     * @private
     */
    clearRowWidget(row, clearPosition, clearHeight, clearGrid) {
        row.height = 0;
        if (clearPosition) {
            row.y = 0;
            row.x = 0;
        }
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            this.clearCellWidget(cell, clearPosition, clearHeight, clearGrid);
        }
    }
    /**
     * @private
     */
    clearCellWidget(cell, clearPosition, clearHeight, clearGrid) {
        cell.height = 0;
        if (clearPosition) {
            cell.y = 0;
            cell.x = 0;
        }
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                if (clearHeight) {
                    block.height = 0;
                }
            }
            else {
                this.clearTableWidget(block, clearPosition, clearHeight, clearGrid);
            }
        }
    }
    /**
     * @param blockIndex
     * @param bodyWidget
     * @param block
     * @private
     */
    // tslint:disable-next-line:max-line-length
    layoutBodyWidgetCollection(blockIndex, bodyWidget, block, shiftNextWidget, isSkipShifting) {
        if (!isNullOrUndefined(this.viewer.owner)
            && this.viewer.owner.isLayoutEnabled) {
            if (bodyWidget instanceof BlockContainer) {
                let curretBlock = this.checkAndGetBlock(bodyWidget, blockIndex);
                if (isNullOrUndefined(curretBlock)) {
                    return;
                }
                if (bodyWidget instanceof HeaderFooterWidget) {
                    bodyWidget.isEmpty = false;
                    // tslint:disable-next-line:max-line-length
                    this.viewer.updateHCFClientAreaWithTop(bodyWidget.sectionFormat, bodyWidget.headerFooterType.indexOf('Header') !== -1, bodyWidget.page);
                    curretBlock.containerWidget.height -= curretBlock.height;
                }
                else {
                    this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
                }
                if (blockIndex > 0) {
                    let prevWidget = curretBlock.getSplitWidgets()[0].previousRenderedWidget;
                    if (!(prevWidget instanceof ParagraphWidget) ||
                        (prevWidget instanceof ParagraphWidget) && !prevWidget.isEndsWithPageBreak) {
                        this.viewer.cutFromTop(prevWidget.y + prevWidget.height);
                        if (isNullOrUndefined(isSkipShifting) && curretBlock.containerWidget !== prevWidget.containerWidget) {
                            // tslint:disable-next-line:max-line-length
                            this.updateContainerWidget(curretBlock, prevWidget.containerWidget, prevWidget.indexInOwner + 1, false);
                        }
                    }
                    else if (prevWidget instanceof ParagraphWidget && prevWidget.isEndsWithPageBreak &&
                        prevWidget.containerWidget === curretBlock.containerWidget) {
                        this.moveBlocksToNextPage(prevWidget);
                    }
                }
                let currentParagraph;
                curretBlock = curretBlock.combineWidget(this.viewer);
                if (curretBlock instanceof TableWidget) {
                    this.clearTableWidget(curretBlock, true, true);
                    curretBlock.isGridUpdated = false;
                    currentParagraph = this.viewer.selection.getFirstParagraphInFirstCell(curretBlock);
                }
                else {
                    currentParagraph = curretBlock;
                }
                if ((this.viewer.owner.isDocumentLoaded) && this.viewer.owner.editorModule) {
                    this.viewer.owner.editorModule.updateWholeListItems(currentParagraph);
                }
                this.viewer.updateClientAreaForBlock(curretBlock, true);
                this.viewer.layout.layoutBlock(curretBlock, 0, true);
                this.viewer.updateClientAreaForBlock(curretBlock, false);
                if (shiftNextWidget) {
                    this.shiftNextWidgets(curretBlock);
                }
                else {
                    this.layoutNextItemsBlock(curretBlock, this.viewer);
                }
            }
            else if (bodyWidget instanceof TableCellWidget) {
                let table = this.viewer.layout.getParentTable(bodyWidget.ownerTable).getSplitWidgets()[0];
                this.reLayoutTable(bodyWidget.ownerTable);
                this.layoutNextItemsBlock(table, this.viewer);
            }
        }
    }
    checkAndGetBlock(containerWidget, blockIndex) {
        let sectionIndex = containerWidget.index;
        while (containerWidget && containerWidget.index === sectionIndex) {
            if (containerWidget.childWidgets.length > 0 && containerWidget.firstChild.index <= blockIndex &&
                containerWidget.lastChild.index >= blockIndex) {
                for (let i = 0; i < containerWidget.childWidgets.length; i++) {
                    let block = containerWidget.childWidgets[i];
                    if (block.index === blockIndex) {
                        return block;
                    }
                }
            }
            if (containerWidget instanceof BodyWidget) {
                containerWidget = containerWidget.nextRenderedWidget;
            }
            else {
                break;
            }
        }
        return undefined;
    }
    //#endregion
    //#region Table
    /**
     * Layouts table.
     * @param table
     * @private
     */
    layoutTable(table, startIndex) {
        table.isBidiTable = table.bidi;
        if (!table.isGridUpdated) {
            table.buildTableColumns();
            table.isGridUpdated = true;
        }
        let tableView = [table];
        this.addTableWidget(this.viewer.clientActiveArea, tableView);
        this.viewer.updateClientAreaTopOrLeft(table, true);
        let isHeader = table.childWidgets[0].rowFormat.isHeader;
        if (table.childWidgets.length > 0) {
            table.header = isHeader;
            table.continueHeader = isHeader;
            table.headerHeight = 0;
        }
        let row = table.childWidgets[startIndex];
        while (row) {
            row = this.layoutRow(tableView, row);
            row = row.nextRow;
        }
        this.updateWidgetsToPage(tableView, [], table);
        return tableView[tableView.length - 1];
    }
    /**
     * Adds table widget.
     * @param area
     * @param table
     * @private
     */
    addTableWidget(area, table, create) {
        let tableWidget = table[table.length - 1];
        if (create) {
            tableWidget = this.createTableWidget(tableWidget);
            table.push(tableWidget);
        }
        tableWidget.width = area.width;
        tableWidget.x = area.x;
        tableWidget.y = area.y;
        //Update the table height of tableWidget when cell spacing has been defined. 
        if (tableWidget.tableFormat.cellSpacing > 0) {
            tableWidget.height = tableWidget.height + HelperMethods.convertPointToPixel(tableWidget.tableFormat.cellSpacing);
            if (!tableWidget.isBidiTable) {
                // tslint:disable-next-line:max-line-length
                tableWidget.leftBorderWidth = HelperMethods.convertPointToPixel(this.getTableLeftBorder(tableWidget.tableFormat.borders).getLineWidth());
                tableWidget.rightBorderWidth = HelperMethods.convertPointToPixel(this.getTableRightBorder(tableWidget.tableFormat.borders).getLineWidth());
            }
            else { // Right to left direction table.
                // tslint:disable-next-line:max-line-length
                tableWidget.leftBorderWidth = HelperMethods.convertPointToPixel(this.getTableRightBorder(tableWidget.tableFormat.borders).getLineWidth());
                tableWidget.rightBorderWidth = HelperMethods.convertPointToPixel(this.getTableLeftBorder(tableWidget.tableFormat.borders).getLineWidth());
            }
            // tslint:disable-next-line:max-line-length
            tableWidget.topBorderWidth = HelperMethods.convertPointToPixel(this.getTableTopBorder(tableWidget.tableFormat.borders).getLineWidth());
            tableWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(this.getTableBottomBorder(tableWidget.tableFormat.borders).getLineWidth());
            tableWidget.x += tableWidget.leftBorderWidth;
            tableWidget.y += tableWidget.topBorderWidth;
            tableWidget.width -= tableWidget.leftBorderWidth;
            tableWidget.width -= tableWidget.rightBorderWidth;
            tableWidget.height += tableWidget.bottomBorderWidth;
        }
        return tableWidget;
    }
    /**
     * Updates widget to page.
     * @param table
     * @private
     */
    updateWidgetsToPage(tables, rows, table, endRowWidget) {
        let viewer = this.viewer;
        let tableWidget = tables[tables.length - 1];
        if (!table.isInsideTable) {
            for (let i = 0; i < tables.length; i++) {
                this.updateHeightForTableWidget(tables, rows, tables[i], endRowWidget);
            }
            if (tableWidget.childWidgets.length > 0 && tableWidget.y !== tableWidget.childWidgets[0].y) {
                tableWidget.y = tableWidget.childWidgets[0].y;
            }
            // Need to update on this further
            //Adds the table widget to owner cell widget.
            // tslint:disable-next-line:max-line-length
            // (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).childWidgets.push(tableWidget);
            // tableWidget.containerWidget = viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as BodyWidget;
            // tslint:disable-next-line:max-line-length
            // (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).height = (viewer.renderedElements.get(table.associatedCell)[viewer.renderedElements.get(table.associatedCell).length - 1] as TableCellWidget).height + tableWidget.height;
        }
        if (table.tableFormat.cellSpacing > 0) {
            // tslint:disable-next-line:max-line-length
            if (tableWidget.y + tableWidget.height + HelperMethods.convertPointToPixel(table.tableFormat.cellSpacing) > viewer.clientArea.bottom && viewer instanceof PageLayoutViewer) {
                //update the table height when split to next page. Which is equivalent Ms Word Behaviour. 
                //In Ms Word if the Table Split to next page the bottom spacing of the table will be half of the current spacing.
                //And the Remaining space will be used in next page top of the table.
                tableWidget.height = tableWidget.height - HelperMethods.convertPointToPixel(table.tableFormat.cellSpacing) / 2;
            }
            //Update the current Y position of current clientactivearea.
            viewer.cutFromTop(tableWidget.y + tableWidget.height);
        }
        if (table.bodyWidget instanceof HeaderFooterWidget) {
            table.containerWidget.height += table.height;
            if (this.viewer.owner.enableHeaderAndFooter && table.bodyWidget.headerFooterType.indexOf('Footer') !== -1) {
                this.shiftFooterChildLocation(table.bodyWidget, this.viewer);
            }
        }
    }
    /**
     * Updates height for table widget.
     * @param viewer
     * @param tableWidget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    updateHeightForTableWidget(tables, rows, tableWidget, endRowWidget) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let rowWidget = tableWidget.childWidgets[i];
            if (rowWidget === endRowWidget) {
                break;
            }
            this.updateHeightForRowWidget(this.viewer, true, tables, rows, rowWidget, true, endRowWidget);
        }
    }
    //#endregion
    //#region Row
    /**
     * Layouts table row.
     * @param row
     * @private
     */
    layoutRow(tableWidget, row) {
        let viewer = this.viewer;
        let rowWidgets = [row];
        let widget = this.addTableRowWidget(viewer.clientActiveArea, rowWidgets);
        viewer.updateClientAreaForRow(row, true);
        let topMargin = this.getMaxTopCellMargin(row);
        let bottomMargin = this.getMaxBottomCellMargin(row);
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            this.layoutCell(cell, topMargin + row.topBorderWidth, bottomMargin + row.bottomBorderWidth, widget);
        }
        viewer.updateClientAreaForRow(row, false);
        let rows = [row];
        this.updateWidgetsToTable(tableWidget, rows, row);
        return rows[rows.length - 1];
    }
    /**
     * @param area
     * @param row
     */
    addTableRowWidget(area, row) {
        let rowWidget = row[row.length - 1];
        rowWidget.x = area.x + rowWidget.rowFormat.gridBeforeWidth;
        rowWidget.y = area.y;
        rowWidget.width = area.width;
        let borderWidth = 0;
        if (!isNullOrUndefined(rowWidget.ownerTable) && !isNullOrUndefined(rowWidget.ownerTable.tableFormat)
            && rowWidget.ownerTable.tableFormat.cellSpacing > 0) {
            rowWidget.height = rowWidget.height + HelperMethods.convertPointToPixel(rowWidget.ownerTable.tableFormat.cellSpacing);
            //Update the table height with the border width to layout the border when the cell spacing is defined..
            for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                if (!isNullOrUndefined(rowWidget.childWidgets[j].cellFormat)
                    && !isNullOrUndefined(rowWidget.childWidgets[j].cellFormat.borders)) {
                    // tslint:disable-next-line:max-line-length
                    let width = TableCellWidget.getCellBottomBorder(rowWidget.childWidgets[j]).getLineWidth();
                    if (width > borderWidth) {
                        borderWidth = width;
                    }
                }
            }
            //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
            rowWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
            if (rowWidget.index > 0 && !isNullOrUndefined(rowWidget.previousWidget)) {
                let prevRow = rowWidget.previousWidget;
                borderWidth = 0;
                for (let i = 0; i < prevRow.childWidgets.length; i++) {
                    // tslint:disable-next-line:max-line-length
                    if (!isNullOrUndefined(prevRow.childWidgets[i].cellFormat) && !isNullOrUndefined(prevRow.childWidgets[i].cellFormat.borders)) {
                        let value = TableCellWidget.getCellBottomBorder(prevRow.childWidgets[i]).getLineWidth();
                        if (value > borderWidth) {
                            borderWidth = value;
                        }
                    }
                }
                //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
                rowWidget.topBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
            }
        }
        if (!isNullOrUndefined(rowWidget.childWidgets)) {
            for (let i = 0; i < rowWidget.childWidgets.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(rowWidget.childWidgets[i].cellFormat) && !isNullOrUndefined(rowWidget.childWidgets[i].cellFormat.borders)) {
                    let value = TableCellWidget.getCellTopBorder(rowWidget.childWidgets[i]).getLineWidth();
                    if (value > borderWidth) {
                        borderWidth = value;
                    }
                }
            }
        }
        //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
        rowWidget.topBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
        //Update the table height of tableWidget when cell spacing has been defined. 
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(rowWidget.ownerTable) && !isNullOrUndefined(rowWidget.ownerTable.tableFormat) && rowWidget.ownerTable.tableFormat.cellSpacing <= 0 && rowWidget.rowIndex === rowWidget.ownerTable.childWidgets.length - 1) {
            // Update the bottom width for last row .
            for (let i = 0; i < rowWidget.childWidgets.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(rowWidget.childWidgets[i].cellFormat) && !isNullOrUndefined(rowWidget.childWidgets[i].cellFormat.borders)) {
                    let value = TableCellWidget.getCellBottomBorder(rowWidget.childWidgets[i]).getLineWidth();
                    if (value > borderWidth) {
                        borderWidth = value;
                    }
                }
            }
            //Maximum border width is calculated and hold it in a variable to add with the padding of the cells.
            rowWidget.bottomBorderWidth = HelperMethods.convertPointToPixel(borderWidth);
        }
        //tableRowWidget.ownerWidget = owner;
        return rowWidget;
    }
    /**
     * Gets maximum top cell margin.
     * @param row
     * @param topOrBottom
     */
    getMaxTopCellMargin(row) {
        if (isNullOrUndefined(row.childWidgets)) {
            return 0;
        }
        let value = 0;
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            let topMargin = 0;
            if (cell.cellFormat.hasValue('topMargin')) {
                topMargin = HelperMethods.convertPointToPixel(cell.cellFormat.topMargin);
            }
            else if (row.rowFormat.hasValue('topMargin')) {
                topMargin = HelperMethods.convertPointToPixel(row.rowFormat.topMargin);
            }
            else {
                topMargin = HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.topMargin);
            }
            if (topMargin > value) {
                value = topMargin;
            }
        }
        return value;
    }
    /**
     * Gets maximum bottom cell margin.
     * @param row
     * @param topOrBottom
     */
    getMaxBottomCellMargin(row) {
        if (isNullOrUndefined(row.childWidgets)) {
            return 0;
        }
        let value = 0;
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            let bottomMargin = 0;
            if (cell.cellFormat.hasValue('bottomMargin')) {
                bottomMargin = HelperMethods.convertPointToPixel(cell.cellFormat.bottomMargin);
            }
            else if (row.rowFormat.hasValue('bottomMargin')) {
                bottomMargin = HelperMethods.convertPointToPixel(row.rowFormat.bottomMargin);
            }
            else {
                bottomMargin = HelperMethods.convertPointToPixel(row.ownerTable.tableFormat.bottomMargin);
            }
            if (bottomMargin > value) {
                value = bottomMargin;
            }
        }
        return value;
    }
    //#endregion Row
    //#region cell
    /**
     * Layouts cell
     * @param cell
     * @param maxCellMarginTop
     * @param maxCellMarginBottom
     */
    layoutCell(cell, maxCellMarginTop, maxCellMarginBottom, owner) {
        let viewer = this.viewer;
        this.addTableCellWidget(cell, viewer.clientActiveArea, maxCellMarginTop, maxCellMarginBottom);
        viewer.updateClientAreaForCell(cell, true);
        if (cell.childWidgets.length === 0) {
            let paragraphWidget = new ParagraphWidget();
            paragraphWidget.characterFormat = new WCharacterFormat();
            paragraphWidget.paragraphFormat = new WParagraphFormat();
            paragraphWidget.index = 0;
            let lineWidget = new LineWidget(undefined);
            paragraphWidget.childWidgets.push(lineWidget);
            cell.childWidgets.push(paragraphWidget);
        }
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            viewer.updateClientAreaForBlock(block, true);
            block.containerWidget = cell;
            this.layoutBlock(block, 0);
            viewer.updateClientAreaForBlock(block, false);
        }
        this.updateWidgetToRow(cell);
        viewer.updateClientAreaForCell(cell, false);
    }
    //endregion cell
    //#region Shifting
    /**
     * @private
     */
    shiftLayoutedItems() {
        if (isNullOrUndefined(this.viewer.blockToShift) || isNullOrUndefined(this.viewer.blockToShift.containerWidget)) {
            this.viewer.blockToShift = undefined;
            return;
        }
        let block = this.viewer.blockToShift;
        let sectionIndex = block.bodyWidget.index;
        this.reLayoutOrShiftWidgets(block, this.viewer);
        let updateNextBlockList = true;
        // If flow layout, then all sections are in single page. Hence need to update till last block of last section.
        // Todo: For page layout and section break continuous, need to handle the same.
        let splittedWidget = block.getSplitWidgets();
        let nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        while (nextBlock instanceof BlockWidget && nextBlock.bodyWidget.index === sectionIndex) {
            let currentWidget = undefined;
            let blocks = block.getSplitWidgets();
            currentWidget = blocks[blocks.length - 1];
            block = nextBlock;
            updateNextBlockList = false;
            let nextWidget = undefined;
            blocks = block.getSplitWidgets();
            if (block instanceof ParagraphWidget) {
                nextWidget = blocks[0];
            }
            else {
                if (block instanceof TableWidget) {
                    nextWidget = blocks[0];
                }
            }
            if (currentWidget.containerWidget === nextWidget.containerWidget
                && (HelperMethods.round(nextWidget.y, 2) === HelperMethods.round(this.viewer.clientActiveArea.y, 2)) &&
                isNullOrUndefined(nextWidget.nextWidget)) {
                break;
            }
            updateNextBlockList = true;
            this.reLayoutOrShiftWidgets(block, this.viewer);
            splittedWidget = block.getSplitWidgets();
            nextBlock = splittedWidget[splittedWidget.length - 1].nextRenderedWidget;
        }
        if (this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateListItemsTillEnd(block, updateNextBlockList);
        }
        this.viewer.blockToShift = undefined;
        let viewer = this.viewer;
        // if (viewer instanceof PageLayoutViewer) {
        viewer.removeEmptyPages();
        this.updateFieldElements();
        viewer.updateScrollBars();
        // }
    }
    /**
     * @private
     */
    updateFieldElements() {
        for (let i = 0; i < this.viewer.fields.length; i++) {
            let fieldBegin = this.viewer.fields[i];
            if (!isNullOrUndefined(this.viewer.selection)) {
                let fieldCode = this.viewer.selection.getFieldCode(fieldBegin);
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(fieldCode) && (fieldCode.toLowerCase().match('numpages') || fieldCode.toLowerCase().match('sectionpages')) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    let textElement = fieldBegin.fieldSeparator.nextNode;
                    if (!isNullOrUndefined(textElement)) {
                        let prevPageNum = textElement.text;
                        textElement.text = this.viewer.pages.length.toString();
                        let paragraph = fieldBegin.line.paragraph;
                        if (!isNullOrUndefined(paragraph.bodyWidget) && !isNullOrUndefined(paragraph.bodyWidget.page)
                            && prevPageNum !== textElement.text) {
                            let lineIndex = paragraph.childWidgets.indexOf(fieldBegin.line);
                            let elementIndex = fieldBegin.line.children.indexOf(textElement);
                            this.reLayoutParagraph(paragraph, lineIndex, elementIndex);
                        }
                    }
                }
            }
        }
    }
    reLayoutOrShiftWidgets(blockAdv, viewer) {
        let block = blockAdv;
        // if (block instanceof ParagraphWidget) {
        //     reLayoutItems = viewer.renderedElements.get(block as ParagraphWidget).length === 0;
        // } else {
        //     reLayoutItems = viewer.renderedElements.get(block as TableWidget).length === 0;
        // }
        // if (reLayoutItems) {
        //     //Handle layouting the block.
        //     viewer.updateClientAreaForBlock(block, true);
        //     this.layoutMod.layoutBlock(block);
        //     viewer.updateClientAreaForBlock(block, false);
        // } else {
        //Handled to check client area and shift layouted widget.
        this.shiftWidgetsBlock(block, viewer);
        //Updates the list value of the rendered paragraph.
        if (this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateRenderedListItems(block);
        }
        // }
    }
    shiftWidgetsBlock(block, viewer) {
        if (block instanceof ParagraphWidget) {
            this.shiftWidgetsForPara(block, viewer);
        }
        else if (block instanceof TableWidget) {
            this.shiftWidgetsForTable(block, viewer);
        }
    }
    shiftWidgetsForPara(paragraph, viewer) {
        if (paragraph.height > viewer.clientArea.height) {
            return;
        }
        let prevBodyObj = this.getBodyWidgetOfPreviousBlock(paragraph, 0);
        let prevBodyWidget = prevBodyObj.bodyWidget;
        let index = prevBodyObj.index;
        let prevWidget = undefined;
        for (let i = 0; i < paragraph.getSplitWidgets().length; i++) {
            let widget = paragraph.getSplitWidgets()[i];
            if (!isNullOrUndefined(prevWidget)) {
                let isPageBreak = prevWidget.lastChild ? prevWidget.lastChild.isEndsWithPageBreak : false;
                this.shiftToPreviousWidget(widget, viewer, prevWidget, isPageBreak);
                if ((isNullOrUndefined(widget.childWidgets) || widget.childWidgets.length === 0) && !isPageBreak) {
                    i--;
                    continue;
                }
                prevWidget = undefined;
                if (prevBodyWidget !== widget.containerWidget) {
                    prevBodyWidget = widget.containerWidget;
                    if (isPageBreak) {
                        viewer.updateClientAreaByWidget(widget);
                    }
                }
            }
            if (this.isFitInClientArea(widget, viewer)) {
                //Check whether this widget is moved to previous container widget.
                prevWidget = widget;
                widget.y = viewer.clientActiveArea.y;
                viewer.cutFromTop(viewer.clientActiveArea.y + widget.height);
                //Moves the paragraph widget to previous body widget.
                if (!isNullOrUndefined(prevBodyWidget) && prevBodyWidget !== widget.containerWidget) {
                    index++;
                    if (!prevBodyWidget.lastChild.isEndsWithPageBreak) {
                        this.updateContainerWidget(widget, prevBodyWidget, index, true);
                    }
                }
                if (widget.isEndsWithPageBreak) {
                    let nextBodyWidget = this.createOrGetNextBodyWidget(prevBodyWidget, this.viewer);
                    nextBodyWidget = this.moveBlocksToNextPage(widget);
                    viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
                }
            }
            else {
                let previousBlock = widget.previousRenderedWidget;
                let isPageBreak = false;
                if (previousBlock instanceof ParagraphWidget && previousBlock.isEndsWithPageBreak) {
                    isPageBreak = true;
                }
                let isSplittedToNewPage = this.splitWidget(widget, viewer, prevBodyWidget, index + 1, isPageBreak);
                prevWidget = undefined;
                if (prevBodyWidget !== widget.containerWidget) {
                    prevBodyWidget = widget.containerWidget;
                    i--;
                }
                index = prevBodyWidget.childWidgets.indexOf(widget);
                if (isSplittedToNewPage) {
                    prevBodyWidget = paragraph.getSplitWidgets()[i + 1].containerWidget;
                }
            }
        }
    }
    /**
     * @private
     */
    shiftTableWidget(table, viewer) {
        let tables = [table];
        this.addTableWidget(this.viewer.clientActiveArea, tables);
        this.viewer.updateClientAreaTopOrLeft(table, true);
        let row = table.childWidgets[0];
        while (row) {
            row = this.shiftRowWidget(tables, row);
            row = row.nextRow;
        }
        this.updateWidgetsToPage(tables, [], table);
        return tables[tables.length - 1];
    }
    /**
     * @private
     */
    shiftRowWidget(tables, row) {
        let viewer = this.viewer;
        let rows = [row];
        let widget = this.addTableRowWidget(viewer.clientActiveArea, rows);
        viewer.updateClientAreaForRow(row, true);
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            // tslint:disable-next-line:max-line-length
            this.shiftCellWidget(cell, this.getMaxTopCellMargin(row) + row.topBorderWidth, this.getMaxBottomCellMargin(row) + row.bottomBorderWidth);
        }
        viewer.updateClientAreaForRow(row, false);
        this.updateWidgetsToTable(tables, rows, row);
        return rows[rows.length - 1];
    }
    /**
     * @private
     */
    shiftCellWidget(cell, maxCellMarginTop, maxCellMarginBottom) {
        let viewer = this.viewer;
        this.addTableCellWidget(cell, viewer.clientActiveArea, maxCellMarginTop, maxCellMarginBottom);
        viewer.updateClientAreaForCell(cell, true);
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            viewer.updateClientAreaForBlock(block, true);
            if (block instanceof ParagraphWidget) {
                this.shiftParagraphWidget(block);
            }
            else {
                this.shiftTableWidget(block, viewer);
            }
            viewer.updateClientAreaForBlock(block, false);
        }
        this.updateWidgetToRow(cell);
        viewer.updateClientAreaForCell(cell, false);
    }
    /**
     * @private
     */
    shiftParagraphWidget(paragraph) {
        this.addParagraphWidget(this.viewer.clientActiveArea, paragraph);
        this.viewer.cutFromTop(this.viewer.clientActiveArea.y + paragraph.height);
        this.updateWidgetToPage(this.viewer, paragraph);
    }
    shiftWidgetsForTable(table, viewer) {
        let prevObj = this.getBodyWidgetOfPreviousBlock(table, 0);
        let prevBodyWidget = prevObj.bodyWidget;
        let index = prevObj.index;
        let isPageBreak = prevBodyWidget.lastChild.lastChild.isEndsWithPageBreak;
        if (prevBodyWidget !== table.containerWidget) {
            if (!isPageBreak) {
                this.updateContainerWidget(table, prevBodyWidget, index + 1, true);
            }
            else {
                viewer.updateClientArea(table.bodyWidget.sectionFormat, table.bodyWidget.page);
            }
        }
        if (table.isInHeaderFooter) {
            table.containerWidget.height -= table.height;
        }
        this.viewer.updateClientAreaForBlock(table, true);
        this.updateVerticalPositionToTop(table, true);
        let combinedTable = table.combineWidget(this.viewer);
        this.viewer.layout.updateChildLocationForTable(combinedTable.y, combinedTable);
        this.clearTableWidget(combinedTable, true, false);
        this.shiftTableWidget(combinedTable, this.viewer);
        this.updateVerticalPositionToTop(table, false);
    }
    updateVerticalPositionToTop(table, isUpdateTop) {
        //Iterate the tableWidgets counts
        for (let i = 0; i < table.getSplitWidgets().length; i++) {
            let tablewidget = table.getSplitWidgets()[i];
            //Iterate the tableWidget child items
            for (let j = 0; j < tablewidget.childWidgets.length; j++) {
                let rowWidget = tablewidget.childWidgets[j];
                //Iterate the RowWidgets child items
                for (let k = 0; k < rowWidget.childWidgets.length; k++) {
                    let cellWidget = rowWidget.childWidgets[k];
                    //Iterate the RowWidgets child items
                    this.viewer.layout.updateCellVerticalPosition(cellWidget, isUpdateTop, false);
                }
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    splitWidget(paragraphWidget, viewer, previousBodyWidget, index, isPageBreak) {
        let firstLine = paragraphWidget.childWidgets[0];
        let maxElementHeight = this.getMaxElementHeight(firstLine, viewer);
        let paragraphView = paragraphWidget.getSplitWidgets();
        let nextBodyWidget = paragraphWidget.containerWidget;
        if (viewer.clientActiveArea.height >= maxElementHeight && !isPageBreak) {
            let splittedWidget = undefined;
            let widgetIndex = paragraphView.indexOf(paragraphWidget);
            if (widgetIndex < (paragraphView.length - 1)) {
                splittedWidget = paragraphView[widgetIndex + 1];
                nextBodyWidget = splittedWidget.containerWidget;
            }
            else {
                splittedWidget = new ParagraphWidget();
                splittedWidget.index = paragraphWidget.index;
                splittedWidget.characterFormat = paragraphWidget.characterFormat;
                splittedWidget.paragraphFormat = paragraphWidget.paragraphFormat;
                splittedWidget.width = paragraphWidget.width;
                splittedWidget.x = paragraphWidget.x;
                splittedWidget.y = paragraphWidget.y;
                paragraphView.push(splittedWidget);
            }
            if (previousBodyWidget !== paragraphWidget.containerWidget) {
                this.updateContainerWidget(paragraphWidget, previousBodyWidget, index, true);
            }
            for (let i = paragraphWidget.childWidgets.length - 1; i > 0; i--) {
                if (this.isFitInClientArea(paragraphWidget, viewer)) {
                    break;
                }
                else {
                    let line = paragraphWidget.childWidgets[i];
                    //Moves the line widget to next widget.
                    this.updateParagraphWidgetInternal(line, splittedWidget, 0);
                }
            }
            if (isNullOrUndefined(splittedWidget.containerWidget) && splittedWidget.childWidgets.length > 0) {
                let y = viewer.clientActiveArea.y;
                // tslint:disable-next-line:max-line-length
                let clientArea = new Rect(viewer.clientArea.x, viewer.clientArea.y, viewer.clientArea.width, viewer.clientArea.height);
                let activeArea = new Rect(viewer.clientActiveArea.x, viewer.clientActiveArea.y, viewer.clientActiveArea.width, viewer.clientActiveArea.height);
                //Checks whether next node exists, else adds new page.
                nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                // nextBodyWidget = this.createOrGetNextBodyWidget(previousBodyWidget, viewer);
                nextBodyWidget.childWidgets.splice(0, 0, splittedWidget);
                nextBodyWidget.height += splittedWidget.height;
                splittedWidget.containerWidget = nextBodyWidget;
                if (nextBodyWidget.childWidgets.length === 1 && nextBodyWidget.firstChild instanceof ParagraphWidget &&
                    nextBodyWidget.firstChild.equals(paragraphWidget)) {
                    paragraphWidget.x = paragraphWidget.x;
                    paragraphWidget.y = y;
                    return true;
                }
                else {
                    //Resetting Client area
                    viewer.clientArea = clientArea;
                    viewer.clientActiveArea = activeArea;
                }
            }
        }
        else {
            nextBodyWidget = this.createOrGetNextBodyWidget(previousBodyWidget, this.viewer);
            if (paragraphWidget.containerWidget !== nextBodyWidget) {
                nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                this.updateContainerWidget(paragraphWidget, nextBodyWidget, 0, true);
            }
        }
        if (previousBodyWidget === paragraphWidget.containerWidget) {
            paragraphWidget.y = viewer.clientActiveArea.y;
            viewer.cutFromTop(viewer.clientActiveArea.y + paragraphWidget.height);
        }
        else {
            //Updates client area based on next body widget.
            viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
        }
        return false;
    }
    getMaxElementHeight(lineWidget, viewer) {
        let height = 0;
        // tslint:disable-next-line:max-line-length
        if (lineWidget.children.length === 0 || ((lineWidget.children.length === 1 && lineWidget.children[0] instanceof ListTextElementBox) || (lineWidget.children.length === 2 && lineWidget.children[0] instanceof ListTextElementBox && lineWidget.children[1] instanceof ListTextElementBox))) {
            let topMargin = 0;
            let bottomMargin = 0;
            height = viewer.selection.getParagraphMarkSize(lineWidget.paragraph, topMargin, bottomMargin).height;
            height += topMargin;
            if (lineWidget.children.length > 0) {
                let element = lineWidget.children[0];
                if (height < element.margin.top + element.height) {
                    height = element.margin.top + element.height;
                }
            }
        }
        else {
            for (let i = 0; i < lineWidget.children.length; i++) {
                let element = lineWidget.children[i];
                if (height < element.margin.top + element.height) {
                    height = element.margin.top + element.height;
                }
            }
        }
        return height;
    }
    createOrGetNextBodyWidget(bodyWidget, viewer) {
        let nextBodyWidget = undefined;
        let pageIndex = 0;
        pageIndex = viewer.pages.indexOf(bodyWidget.page);
        let page = undefined;
        let index = undefined;
        index = bodyWidget.index;
        if (pageIndex === viewer.pages.length - 1
            || viewer.pages[pageIndex + 1].sectionIndex !== index) {
            let currentWidget = new BodyWidget();
            currentWidget.sectionFormat = bodyWidget.sectionFormat;
            currentWidget.index = bodyWidget.index;
            page = viewer.createNewPage(currentWidget);
            if (viewer.pages[pageIndex + 1].sectionIndex !== index) {
                viewer.insertPage(pageIndex + 1, page);
            }
            nextBodyWidget = page.bodyWidgets[0];
        }
        else {
            page = viewer.pages[pageIndex + 1];
            nextBodyWidget = page.bodyWidgets[0];
        }
        return nextBodyWidget;
    }
    isFitInClientArea(paragraphWidget, viewer) {
        let lastLine = paragraphWidget.childWidgets[paragraphWidget.childWidgets.length - 1];
        let height = paragraphWidget.height;
        let maxElementHeight = this.getMaxElementHeight(lastLine, viewer);
        if (lastLine.height > maxElementHeight) {
            height -= lastLine.height - maxElementHeight;
        }
        return viewer.clientActiveArea.height >= height;
    }
    // tslint:disable-next-line:max-line-length
    shiftToPreviousWidget(paragraphWidget, viewer, previousWidget, isPageBreak) {
        for (let i = 0; i < paragraphWidget.childWidgets.length; i++) {
            let line = paragraphWidget.childWidgets[i];
            let maxElementHeight = this.getMaxElementHeight(line, viewer);
            if (viewer.clientActiveArea.height >= maxElementHeight && !isPageBreak) {
                //Moves the line widget to previous widget.
                this.updateParagraphWidgetInternal(line, previousWidget, previousWidget.childWidgets.length);
                i--;
                viewer.cutFromTop(viewer.clientActiveArea.y + line.height);
                if (isNullOrUndefined(paragraphWidget.childWidgets)) {
                    break;
                }
            }
            else {
                let bodyWidget = previousWidget.containerWidget;
                let nextBodyWidget = this.createOrGetNextBodyWidget(bodyWidget, viewer);
                if (paragraphWidget.containerWidget !== nextBodyWidget) {
                    nextBodyWidget = this.moveBlocksToNextPage(paragraphWidget);
                }
                if (bodyWidget !== nextBodyWidget) {
                    this.updateContainerWidget(paragraphWidget, nextBodyWidget, 0, true);
                }
                //Updates client area based on next page.
                viewer.updateClientArea(nextBodyWidget.sectionFormat, nextBodyWidget.page);
                break;
            }
        }
    }
    updateParagraphWidgetInternal(lineWidget, newParagraphWidget, index) {
        if (!isNullOrUndefined(lineWidget.paragraph)) {
            lineWidget.paragraph.childWidgets.splice(lineWidget.paragraph.childWidgets.indexOf(lineWidget), 1);
            lineWidget.paragraph.height -= lineWidget.height;
            if (!isNullOrUndefined(lineWidget.paragraph.containerWidget)) {
                lineWidget.paragraph.containerWidget.height -= lineWidget.height;
            }
            // tslint:disable-next-line:max-line-length
            if (isNullOrUndefined(lineWidget.paragraph.childWidgets) || lineWidget.paragraph.childWidgets.length === 0) {
                lineWidget.paragraph.destroyInternal(this.viewer);
            }
        }
        newParagraphWidget.childWidgets.splice(index, 0, lineWidget);
        lineWidget.paragraph = newParagraphWidget;
        newParagraphWidget.height += lineWidget.height;
        if (!isNullOrUndefined(newParagraphWidget.containerWidget)) {
            newParagraphWidget.containerWidget.height += lineWidget.height;
        }
    }
    shiftNextWidgets(blockAdv) {
        let block = blockAdv;
        while (block.nextWidget instanceof BlockWidget) {
            block = block.nextWidget;
            this.reLayoutOrShiftWidgets(block, this.viewer);
        }
    }
    /**
     * @private
     */
    updateContainerWidget(widget, bodyWidget, index, destroyAndScroll) {
        if (!isNullOrUndefined(widget.containerWidget)) {
            widget.containerWidget.childWidgets.splice(widget.containerWidget.childWidgets.indexOf(widget), 1);
            widget.containerWidget.height -= bodyWidget.height;
            if ((isNullOrUndefined(widget.containerWidget.childWidgets) || widget.containerWidget.childWidgets.length === 0)
                && widget.containerWidget instanceof BodyWidget && widget.containerWidget !== bodyWidget && destroyAndScroll) {
                let page = widget.containerWidget.page;
                if (this.viewer.pages[this.viewer.pages.length - 1] === page &&
                    this.viewer.visiblePages.indexOf(page) !== -1) {
                    this.viewer.scrollToBottom();
                }
                if (isNullOrUndefined(page.nextPage) || page.nextPage.bodyWidgets[0].index !== widget.containerWidget.index) {
                    widget.containerWidget.destroyInternal(this.viewer);
                }
            }
        }
        bodyWidget.childWidgets.splice(index, 0, widget);
        bodyWidget.height += bodyWidget.height;
        widget.containerWidget = bodyWidget;
    }
    getBodyWidgetOfPreviousBlock(block, index) {
        index = 0;
        let prevBodyWidget = undefined;
        let previousBlock = block.previousRenderedWidget;
        prevBodyWidget = (previousBlock && previousBlock.containerWidget.equals(block.containerWidget)) ?
            previousBlock.containerWidget : block.containerWidget;
        index = previousBlock && previousBlock.containerWidget.equals(block.containerWidget) ?
            prevBodyWidget.childWidgets.indexOf(previousBlock) : block.containerWidget.childWidgets.indexOf(block);
        return { bodyWidget: prevBodyWidget, index: index };
    }
    /**
     * @private
     */
    moveBlocksToNextPage(block) {
        let body = block.bodyWidget;
        let page = body.page;
        let pageIndex = page.index + 1;
        let nextPage = undefined;
        let nextBody = undefined;
        let insertPage = false;
        if (this.viewer.pages.length > pageIndex) {
            nextPage = this.viewer.pages[pageIndex];
            if (nextPage.bodyWidgets.length === 0 || !body.equals(nextPage.bodyWidgets[0])) {
                nextPage = undefined;
                insertPage = true;
            }
            else {
                nextBody = nextPage.bodyWidgets[0];
                this.viewer.updateClientArea(nextBody.sectionFormat, nextBody.page);
            }
        }
        if (isNullOrUndefined(nextPage)) {
            nextBody = this.createSplitBody(body);
            nextPage = this.viewer.createNewPage(nextBody, pageIndex);
            if (insertPage) {
                this.viewer.insertPage(pageIndex, nextPage);
            }
        }
        //tslint:disable :no-constant-condition
        do {
            let lastBlock = body.lastChild;
            if (block === lastBlock) {
                break;
            }
            body.childWidgets.pop();
            nextBody.childWidgets.splice(0, 0, lastBlock);
            lastBlock.containerWidget = nextBody;
            nextBody.height += lastBlock.height;
        } while (true);
        return nextBody;
    }
    createSplitBody(body) {
        let newBody = this.addBodyWidget(this.viewer.clientActiveArea);
        newBody.sectionFormat = body.sectionFormat;
        newBody.index = body.index;
        return newBody;
    }
    //endregion
    //#region Relayout Parargaph 
    /**
     * Relayout Paragraph from specified line widget
     * @param paragraph Paragraph to reLayout
     * @param lineIndex start line index to reLayout
     * @private
     */
    reLayoutLine(paragraph, lineIndex, isBidi) {
        if (this.viewer.owner.isDocumentLoaded && this.viewer.owner.editorModule) {
            this.viewer.owner.editorModule.updateWholeListItems(paragraph);
        }
        let lineWidget;
        if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
            lineWidget = paragraph.getSplitWidgets()[0].firstChild;
        }
        else {
            lineWidget = paragraph.childWidgets[lineIndex];
        }
        if (!this.isBidiReLayout && (paragraph.paragraphFormat.bidi || this.isContainsRtl(lineWidget))) {
            let newLineIndex = lineIndex <= 0 ? 0 : lineIndex - 1;
            for (let i = newLineIndex; i < paragraph.childWidgets.length; i++) {
                if (isBidi || !(paragraph.paragraphFormat.bidi && this.isContainsRtl(lineWidget))) {
                    if (i === lineIndex) {
                        continue;
                    }
                }
                this.reArrangeElementsForRtl(paragraph.childWidgets[i], paragraph.paragraphFormat.bidi);
            }
        }
        let lineToLayout = lineWidget.previousLine;
        if (isNullOrUndefined(lineToLayout)) {
            lineToLayout = lineWidget;
        }
        let currentParagraph = lineToLayout.paragraph;
        let bodyWidget = paragraph.containerWidget;
        bodyWidget.height -= paragraph.height;
        if (this.viewer.owner.enableHeaderAndFooter || paragraph.isInHeaderFooter) {
            paragraph.bodyWidget.isEmpty = false;
            // tslint:disable-next-line:max-line-length
            this.viewer.updateHCFClientAreaWithTop(paragraph.bodyWidget.sectionFormat, this.viewer.isBlockInHeader(paragraph), bodyWidget.page);
        }
        else {
            this.viewer.updateClientArea(bodyWidget.sectionFormat, bodyWidget.page);
        }
        this.viewer.updateClientAreaForBlock(paragraph, true);
        if (lineToLayout.paragraph.isEmpty()) {
            this.viewer.cutFromTop(paragraph.y);
            this.layoutParagraph(paragraph, 0);
        }
        else {
            this.updateClientAreaForLine(lineToLayout.paragraph, lineToLayout, 0);
            this.layoutListItems(lineToLayout.paragraph);
            if (lineToLayout.isFirstLine() && !isNullOrUndefined(paragraph.paragraphFormat)) {
                let firstLineIndent = -HelperMethods.convertPointToPixel(paragraph.paragraphFormat.firstLineIndent);
                this.viewer.updateClientWidth(firstLineIndent);
            }
            do {
                lineToLayout = this.layoutLine(lineToLayout, 0);
                paragraph = lineToLayout.paragraph;
                lineToLayout = lineToLayout.nextLine;
            } while (lineToLayout);
            this.updateWidgetToPage(this.viewer, paragraph);
            this.viewer.updateClientAreaForBlock(paragraph, false);
        }
        this.layoutNextItemsBlock(paragraph, this.viewer);
    }
    //#endregion
    //RTL Feature layout start
    isContainsRtl(lineWidget) {
        let isContainsRTL = false;
        for (let i = 0; i < lineWidget.children.length; i++) {
            if (lineWidget.children[i] instanceof TextElementBox) {
                isContainsRTL = lineWidget.children[i].characterFormat.bidi || lineWidget.children[i].characterFormat.bdo === 'RTL'
                    || this.viewer.textHelper.isRTLText(lineWidget.children[i].text);
                if (isContainsRTL) {
                    break;
                }
            }
        }
        return isContainsRTL;
    }
    // Re arranges the elements for Right to left layotuing.
    // tslint:disable:max-func-body-length    
    reArrangeElementsForRtl(line, isParaBidi) {
        if (line.children.length === 0) {
            return;
        }
        let isFieldCode = false;
        let lastAddedElementIsRtl = false;
        let lastAddedRtlElementIndex = -1;
        let tempElements = [];
        for (let i = 0; i < line.children.length; i++) {
            let element = line.children[i];
            let elementCharacterFormat = undefined;
            if (element.characterFormat) {
                elementCharacterFormat = element.characterFormat;
            }
            let isRtl = false;
            let text = '';
            let containsSpecchrs = false;
            if (element instanceof BookmarkElementBox) {
                if (isParaBidi) {
                    if (lastAddedElementIsRtl || element.bookmarkType === 0 && element.nextElement
                        && element.nextElement.nextElement instanceof TextElementBox
                        && this.viewer.textHelper.isRTLText(element.nextElement.nextElement.text)
                        || element.bookmarkType === 1 && element.nextElement instanceof TextElementBox
                            && this.viewer.textHelper.isRTLText(element.nextElement.text)) {
                        tempElements.splice(0, 0, element);
                    }
                    else {
                        tempElements.splice(lastAddedElementIsRtl ? lastAddedRtlElementIndex : lastAddedRtlElementIndex + 1, 0, element);
                    }
                    lastAddedRtlElementIndex = tempElements.indexOf(element);
                }
                else {
                    tempElements.push(element);
                }
                continue;
            }
            if (element instanceof TextElementBox) {
                text = element.text;
                containsSpecchrs = this.viewer.textHelper.containsSpecialCharAlone(text);
                if (containsSpecchrs) {
                    if (text.length > 1 && elementCharacterFormat.bidi) {
                        text = HelperMethods.ReverseString(text);
                        element.text = text;
                    }
                }
            }
            // The list element box shold be added in the last position in line widget for the RTL paragraph 
            // and first in the line widget for LTR paragrph.
            if (element instanceof ListTextElementBox) {
                isRtl = isParaBidi;
            }
            else { // For Text element box we need to check the character format and unicode of text to detect the RTL text. 
                isRtl = this.viewer.textHelper.isRTLText(text) || elementCharacterFormat.bidi
                    || elementCharacterFormat.bdo === 'RTL';
            }
            if (element instanceof FieldElementBox || isFieldCode) {
                if (element.fieldType === 0) {
                    isFieldCode = true;
                }
                else if (element.fieldType === 1) {
                    isFieldCode = false;
                }
                isRtl = false;
            }
            // If the text element box contains only whitespaces, then need to check the previous and next elements.
            if (!isRtl && !isNullOrUndefined(text) && text !== '' && ((text !== '' && text.trim() === '') || containsSpecchrs)) {
                let elements = line.children;
                //Checks whether the langugae is RTL.
                if (elementCharacterFormat.bidi) {
                    // If the last added element is rtl then current text element box also considered as RTL for WhiteSpaces.
                    if (lastAddedElementIsRtl) {
                        isRtl = true;
                        // Else, Check for next element.
                    }
                    else if (i + 1 < line.children.length && line.children[i + 1] instanceof TextElementBox) {
                        text = elements[i + 1].text;
                        isRtl = this.viewer.textHelper.isRTLText(text) || elements[i + 1].characterFormat.bidi
                            || elements[i + 1].characterFormat.bdo === 'RTL';
                    } // If the last added element is rtl then current text element box also considered as RTL for WhiteSpaces.
                }
                else if (lastAddedElementIsRtl) {
                    isRtl = true;
                }
            }
            // Preserve the isRTL value, to reuse it for navigation and selection.
            element.isRightToLeft = isRtl;
            //Adds the text element to the line
            if (isRtl && elementCharacterFormat.bdo !== 'LTR') {
                if (lastAddedElementIsRtl) {
                    tempElements.splice(lastAddedRtlElementIndex, 0, element);
                }
                else {
                    if (!isParaBidi) {
                        tempElements.push(element);
                    }
                    else {
                        tempElements.splice(0, 0, element);
                    }
                    lastAddedElementIsRtl = true;
                    lastAddedRtlElementIndex = tempElements.indexOf(element);
                }
            }
            else {
                if (lastAddedElementIsRtl && element instanceof ImageElementBox) {
                    if (elementCharacterFormat.bidi) {
                        tempElements.splice(lastAddedRtlElementIndex + 1, 0, element);
                    }
                    else {
                        tempElements.splice(lastAddedRtlElementIndex, 0, element);
                    }
                }
                else {
                    if (!isParaBidi) {
                        tempElements.push(element);
                    }
                    else {
                        if (lastAddedElementIsRtl) {
                            tempElements.splice(0, 0, element);
                        }
                        else {
                            tempElements.splice(lastAddedRtlElementIndex + 1, 0, element);
                        }
                        lastAddedRtlElementIndex = tempElements.indexOf(element);
                    }
                    lastAddedElementIsRtl = false;
                }
            }
        }
        // Clear the elemnts and reassign the arranged elements.
        line.children = [];
        line.children = tempElements;
    }
}

// tslint:disable-next-line:max-line-length
/**
 * @private
 */
class Renderer {
    constructor(viewer) {
        this.isPrinting = false;
        this.pageLeft = 0;
        this.pageTop = 0;
        this.pageIndex = -1;
        this.isFieldCode = false;
        this.leftPosition = 0;
        this.topPosition = 0;
        this.viewer = viewer;
    }
    /**
     * Gets page canvas.
     * @private
     */
    get pageCanvas() {
        if (this.isPrinting) {
            if (isNullOrUndefined(this.pageCanvasIn)) {
                this.pageCanvasIn = document.createElement('canvas');
                this.pageCanvasIn.getContext('2d').save();
            }
            return this.pageCanvasIn;
        }
        return isNullOrUndefined(this.viewer) ? undefined : this.viewer.containerCanvas;
    }
    /**
     * Gets the spell checker
     * @private
     */
    get spellChecker() {
        return this.viewer.owner.spellChecker;
    }
    /**
     * Gets selection canvas.
     */
    get selectionCanvas() {
        return isNullOrUndefined(this.viewer) ? undefined : this.viewer.selectionCanvas;
    }
    /**
     * Gets page context.
     */
    get pageContext() {
        return this.pageCanvas.getContext('2d');
    }
    /**
     * Gets selection context.
     */
    get selectionContext() {
        return this.selectionCanvas.getContext('2d');
    }
    /**
     * Gets the color.
     * @private
     */
    getColor(color) {
        if (color.length > 0) {
            if (color[0] === '#') {
                if (color.length > 7) {
                    return color.substr(0, 7);
                }
            }
        }
        return color;
    }
    /**
     * Renders widgets.
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     * @param {number} width
     * @param {number} height
     * @private
     */
    renderWidgets(page, left, top, width, height) {
        if (isNullOrUndefined(this.pageCanvas) || isNullOrUndefined(page)) {
            return;
        }
        this.pageContext.fillStyle = this.getColor(this.viewer.backgroundColor);
        this.pageContext.beginPath();
        this.pageContext.fillRect(left, top, width, height);
        this.pageContext.closePath();
        this.pageContext.strokeStyle = this.viewer.owner.pageOutline;
        this.pageContext.strokeRect(left, top, width, height);
        this.pageLeft = left;
        this.pageTop = top;
        this.pageIndex = page.index;
        if (this.isPrinting) {
            this.setPageSize(page);
        }
        else {
            this.pageContext.beginPath();
            this.pageContext.save();
            this.pageContext.rect(left, top, width, height);
            this.pageContext.clip();
        }
        if (page.headerWidget) {
            this.renderHFWidgets(page, page.headerWidget, width, true);
        }
        if (page.footerWidget) {
            this.renderHFWidgets(page, page.footerWidget, width, false);
        }
        for (let i = 0; i < page.bodyWidgets.length; i++) {
            this.render(page, page.bodyWidgets[i]);
        }
        if (this.viewer.owner.enableHeaderAndFooter && !this.isPrinting) {
            this.renderHeaderSeparator(page, this.pageLeft, this.pageTop, page.headerWidget);
        }
        this.pageLeft = 0;
        this.pageTop = 0;
        this.pageContext.restore();
    }
    /**
     * Sets page size.
     * @param {Page} page
     */
    setPageSize(page) {
        this.pageContext.clearRect(0, 0, this.pageCanvas.width, this.pageCanvas.height);
        this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        this.pageContext.restore();
        this.selectionContext.restore();
        let width = page.boundingRectangle.width;
        let height = page.boundingRectangle.height;
        let dpr = Math.max(1, window.devicePixelRatio || 1);
        if (this.pageCanvas.width !== width * dpr || this.pageCanvas.height !== height * dpr) {
            this.pageCanvas.height = height * dpr;
            this.pageCanvas.width = width * dpr;
            this.pageCanvas.style.height = height + 'px';
            this.pageCanvas.style.width = width + 'px';
            this.pageContext.globalAlpha = 1;
            this.pageContext.scale(dpr, dpr);
        }
    }
    /**
     * Renders header footer widget.
     * @param {Page} page
     * @param {HeaderFooterWidget} headFootWidget
     */
    renderHFWidgets(page, widget, width, isHeader) {
        if (!this.isPrinting) {
            this.pageContext.globalAlpha = this.viewer.owner.enableHeaderAndFooter ? 1 : 0.65;
        }
        let cliped = false;
        let height = 0;
        let pageHt = 0;
        let headerFooterHeight = page.boundingRectangle.height / 100 * 40;
        if (isHeader) {
            let topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
            let widgetHeight = Math.max((widget.y + widget.height), topMargin);
            if (widgetHeight > headerFooterHeight) {
                cliped = true;
                this.pageContext.beginPath();
                this.pageContext.save();
                this.pageContext.rect(this.pageLeft, this.pageTop, width, this.getScaledValue(headerFooterHeight));
                this.pageContext.clip();
            }
        }
        else {
            let footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
            // tslint:disable-next-line:max-line-length
            let footerHeight = this.getScaledValue(page.boundingRectangle.height) -
                this.getScaledValue(Math.max(page.footerWidget.height + footerDistance, HelperMethods.convertPointToPixel(page.footerWidget.sectionFormat.bottomMargin)));
            height = Math.max((this.getScaledValue(page.boundingRectangle.height) - headerFooterHeight), footerHeight);
            pageHt = this.getScaledValue(page.boundingRectangle.height) - footerDistance;
        }
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let block = widget.childWidgets[i];
            if (!isHeader) {
                height += block.height;
            }
            if (isHeader || !isHeader && height <= pageHt) {
                this.renderWidget(page, block);
            }
        }
        if (cliped) {
            this.pageContext.restore();
        }
        if (!this.isPrinting) {
            this.pageContext.globalAlpha = this.viewer.owner.enableHeaderAndFooter ? 0.65 : 1;
        }
    }
    renderHeaderSeparator(page, left, top, widget) {
        //Header Widget
        let topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
        let y = this.getScaledValue(Math.max((widget.y + widget.height), topMargin));
        let pageWidth = this.getScaledValue(page.boundingRectangle.width);
        let ctx = this.pageContext;
        ctx.save();
        ctx.globalAlpha = 0.65;
        let headerFooterHeight = (this.getScaledValue(page.boundingRectangle.height) / 100) * 40;
        //Maximum header height limit       
        y = Math.min(y, headerFooterHeight);
        //Dash line Separator
        this.renderDashLine(ctx, left, top + y, pageWidth, '#000000', false);
        let type = this.getHeaderFooterType(page, true);
        ctx.font = '9pt Arial';
        let width = ctx.measureText(type).width;
        this.renderHeaderFooterMark(ctx, left + 5, top + y, width + 10, 20);
        this.renderHeaderFooterMarkText(ctx, type, left + 10, y + top + 15);
        if (page.footerWidget) {
            //Footer Widget
            let footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
            // tslint:disable-next-line:max-line-length
            let footerHeight = this.getScaledValue(page.boundingRectangle.height) -
                this.getScaledValue(Math.max(page.footerWidget.height + footerDistance, HelperMethods.convertPointToPixel(page.footerWidget.sectionFormat.bottomMargin)));
            //Maximum footer height limit     
            footerHeight = Math.max((this.getScaledValue(page.boundingRectangle.height) - headerFooterHeight), footerHeight);
            this.renderDashLine(ctx, left, top + footerHeight, pageWidth, '#000000', false);
            type = this.getHeaderFooterType(page, false);
            width = ctx.measureText(type).width;
            this.renderHeaderFooterMark(ctx, left + 5, top + footerHeight - 20, width + 10, 20);
            this.renderHeaderFooterMarkText(ctx, type, left + 10, top + footerHeight - 5);
            ctx.restore();
        }
    }
    getHeaderFooterType(page, isHeader) {
        let type;
        type = isHeader ? 'Header' : 'Footer';
        if (page.bodyWidgets[0].sectionFormat.differentFirstPage &&
            (isNullOrUndefined(page.previousPage) || page.sectionIndex !== page.previousPage.sectionIndex)) {
            type = isHeader ? 'First Page Header' : 'First Page Footer';
        }
        else if (page.bodyWidgets[0].sectionFormat.differentOddAndEvenPages) {
            if ((this.viewer.pages.indexOf(page) + 1) % 2 === 0) {
                type = isHeader ? 'Even Page Header' : 'Even Page Footer';
            }
            else {
                type = isHeader ? 'Odd Page Header' : 'Odd Page Footer';
            }
        }
        return type;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    renderDashLine(ctx, x, y, width, fillStyle, isSmallDash) {
        ctx.beginPath();
        ctx.strokeStyle = fillStyle;
        ctx.lineWidth = 1;
        if (isSmallDash) {
            ctx.setLineDash([3, 2]);
        }
        else {
            ctx.setLineDash([6, 4]);
        }
        ctx.moveTo(x, y);
        ctx.lineTo(x + width, y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.closePath();
    }
    renderHeaderFooterMark(ctx, x, y, w, h) {
        ctx.beginPath();
        ctx.fillStyle = 'lightgray';
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = 'black';
        ctx.strokeRect(x, y, w, h);
        ctx.closePath();
    }
    renderHeaderFooterMarkText(ctx, content, x, y) {
        ctx.beginPath();
        ctx.fillStyle = '#000000';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(content, x, y);
        ctx.closePath();
    }
    /**
     * Renders body widget.
     * @param {Page} page
     * @param {BodyWidget} bodyWidget
     */
    render(page, bodyWidget) {
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let widget = bodyWidget.childWidgets[i];
            if (i === 0 && bodyWidget.childWidgets[0] instanceof TableWidget && page.repeatHeaderRowTableWidget) {
                // tslint:disable-next-line:max-line-length
                this.renderHeader(page, widget, this.viewer.layout.getHeader(bodyWidget.childWidgets[0]));
            }
            this.renderWidget(page, widget);
        }
    }
    /**
     * Renders block widget.
     * @param {Page} page
     * @param {Widget} widget
     */
    renderWidget(page, widget) {
        if (widget instanceof ParagraphWidget) {
            this.renderParagraphWidget(page, widget);
        }
        else {
            this.renderTableWidget(page, widget);
        }
    }
    /**
     * Renders header.
     * @param {Page} page
     * @param {TableWidget} widget
     * @param {WRow} header
     * @private
     */
    renderHeader(page, widget, header) {
        if (isNullOrUndefined(header)) {
            return;
        }
        //Updated client area for current page
        page.viewer.updateClientArea(page.bodyWidgets[0].sectionFormat, page);
        let top = page.viewer.clientArea.y;
        let parentTable = header.ownerTable.getSplitWidgets()[0];
        for (let i = 0; i <= header.rowIndex; i++) {
            if (parentTable.childWidgets.length === 0) {
                return;
            }
            let row = parentTable.childWidgets[i];
            let headerWidget = row.clone();
            headerWidget.containerWidget = row.containerWidget;
            // tslint:disable-next-line:max-line-length
            page.viewer.updateClientAreaLocation(headerWidget, new Rect(page.viewer.clientArea.x, top, headerWidget.width, headerWidget.height));
            page.viewer.layout.updateChildLocationForRow(top, headerWidget);
            let cell = undefined;
            //Renders table cell outline rectangle - Border and background color.
            for (let j = 0; j < headerWidget.childWidgets.length; j++) {
                cell = headerWidget.childWidgets[j];
                this.renderTableCellWidget(page, cell);
            }
            top += headerWidget.height;
        }
        if (widget.y !== top) {
            //this.Location.Y = top;
            page.viewer.layout.updateChildLocationForTable(top, widget);
        }
    }
    /**
     * Renders paragraph widget.
     * @param {Page} page
     * @param {ParagraphWidget} paraWidget
     */
    renderParagraphWidget(page, paraWidget) {
        let top = paraWidget.y;
        let left = paraWidget.x;
        for (let i = 0; i < paraWidget.childWidgets.length; i++) {
            let widget = paraWidget.childWidgets[i];
            this.renderLine(widget, page, left, top);
            top += widget.height;
        }
    }
    /**
     * Renders table widget.
     * @param {Page} page
     * @param {TableWidget} tableWidget
     */
    renderTableWidget(page, tableWidget) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let widget = tableWidget.childWidgets[i];
            this.renderTableRowWidget(page, widget);
            if (tableWidget.tableFormat.cellSpacing > 0) {
                this.renderTableOutline(tableWidget);
            }
        }
    }
    /**
     * Renders table row widget.
     * @param {Page} page
     * @param {Widget} rowWidget
     */
    renderTableRowWidget(page, rowWidget) {
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let widget = rowWidget.childWidgets[i];
            this.renderTableCellWidget(page, widget);
        }
    }
    /**
     * Renders table cell widget.
     * @param {Page} page
     * @param {TableCellWidget} cellWidget
     */
    renderTableCellWidget(page, cellWidget) {
        if (!this.isPrinting) {
            if (this.getScaledValue(cellWidget.y, 2) + cellWidget.height * this.viewer.zoomFactor < 0 ||
                this.getScaledValue(cellWidget.y, 2) > this.viewer.visibleBounds.height) {
                return;
            }
        }
        if (!this.isPrinting && page.viewer.owner.selection && page.viewer.owner.selection.selectedWidgets.length > 0) {
            page.viewer.owner.selection.addSelectionHighlightTable(this.selectionContext, cellWidget);
        }
        this.renderTableCellOutline(page.viewer, cellWidget);
        for (let i = 0; i < cellWidget.childWidgets.length; i++) {
            let widget = cellWidget.childWidgets[i];
            let width = cellWidget.width + cellWidget.margin.left - cellWidget.leftBorderWidth;
            this.clipRect(cellWidget.x, cellWidget.y, this.getScaledValue(width), this.getScaledValue(cellWidget.height));
            this.renderWidget(page, widget);
            this.pageContext.restore();
        }
    }
    /**
     * Renders line widget.
     * @param {LineWidget} lineWidget
     * @param {Page} page
     * @param {number} left
     * @param {number} top
     */
    renderLine(lineWidget, page, left, top) {
        // tslint:disable-next-line:max-line-length
        if (!this.isPrinting && page.viewer.owner.selection && !this.viewer.isScrollToSpellCheck && page.viewer.owner.selection.selectedWidgets.length > 0) {
            page.viewer.owner.selection.addSelectionHighlight(this.selectionContext, lineWidget, top);
        }
        let paraFormat = lineWidget.paragraph.paragraphFormat;
        if (lineWidget.isFirstLine() && !paraFormat.bidi) {
            left += HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
        }
        if (this.viewer.owner.searchModule) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(page.viewer.owner.searchModule.searchHighlighters) && page.viewer.owner.searchModule.searchHighlighters.containsKey(lineWidget)) {
                let widgetInfo = page.viewer.owner.searchModule.searchHighlighters.get(lineWidget);
                for (let i = 0; i < widgetInfo.length; i++) {
                    this.pageContext.fillStyle = '#ffe97f';
                    // tslint:disable-next-line:max-line-length
                    this.pageContext.fillRect(this.getScaledValue(widgetInfo[i].left, 1), this.getScaledValue(top, 2), this.getScaledValue(widgetInfo[i].width), this.getScaledValue(lineWidget.height));
                }
            }
        }
        // EditRegion highlight 
        if (page.viewer.selection && !isNullOrUndefined(page.viewer.selection.editRegionHighlighters)
            && page.viewer.selection.editRegionHighlighters.containsKey(lineWidget)) {
            let widgetInfo = page.viewer.selection.editRegionHighlighters.get(lineWidget);
            for (let i = 0; i < widgetInfo.length; i++) {
                this.pageContext.fillStyle = widgetInfo[i].color !== '' ? widgetInfo[i].color : '#add8e6';
                // tslint:disable-next-line:max-line-length
                this.pageContext.fillRect(this.getScaledValue(widgetInfo[i].left, 1), this.getScaledValue(top, 2), this.getScaledValue(widgetInfo[i].width), this.getScaledValue(lineWidget.height));
            }
        }
        let isCommentMark = false;
        for (let i = 0; i < lineWidget.children.length; i++) {
            let elementBox = lineWidget.children[i];
            if (elementBox instanceof CommentCharacterElementBox &&
                elementBox.commentType === 0 && this.viewer.owner.selectionModule) {
                if (!isCommentMark) {
                    isCommentMark = true;
                    elementBox.renderCommentMark();
                    let pageGap = 0;
                    if (this.viewer instanceof PageLayoutViewer) {
                        pageGap = this.viewer.pageGap;
                    }
                    let style = 'display:block;position:absolute;';
                    elementBox.commentMark.style.display = 'block';
                    elementBox.commentMark.style.position = 'absolute';
                    let rightMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.rightMargin);
                    let pageWidth = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.pageWidth);
                    // tslint:disable-next-line:max-line-length
                    let leftPosition = page.boundingRectangle.x + this.getScaledValue((pageWidth - rightMargin) + (rightMargin / 4)) + 'px;';
                    let topPosition = this.getScaledValue(top + (page.boundingRectangle.y - (pageGap * (page.index + 1)))) + (pageGap * (page.index + 1)) + 'px;';
                    style = style + 'left:' + leftPosition + 'top:' + topPosition;
                    elementBox.commentMark.setAttribute('style', style);
                }
                else {
                    if (elementBox.commentMark) {
                        elementBox.commentMark.setAttribute('style', 'display:none');
                    }
                }
            }
            if (elementBox instanceof FieldElementBox || this.isFieldCode ||
                (elementBox.width === 0 && elementBox.height === 0)) {
                if (this.isFieldCode) {
                    elementBox.width = 0;
                }
                left += elementBox.width + elementBox.margin.left;
                this.toSkipFieldCode(elementBox);
                continue;
            }
            let underlineY = this.getUnderlineYPosition(lineWidget);
            if (!this.isPrinting) {
                if (this.getScaledValue(top + elementBox.margin.top, 2) + elementBox.height * this.viewer.zoomFactor < 0 ||
                    this.getScaledValue(top + elementBox.margin.top, 2) > this.viewer.visibleBounds.height) {
                    left += elementBox.width + elementBox.margin.left;
                    if (elementBox instanceof TextElementBox) {
                        elementBox.canTrigger = true;
                        elementBox.isVisible = false;
                        if (!elementBox.isSpellChecked || elementBox.line.paragraph.isChangeDetected) {
                            elementBox.ischangeDetected = true;
                        }
                    }
                    continue;
                }
            }
            if (elementBox instanceof ListTextElementBox) {
                this.renderListTextElementBox(elementBox, left, top, underlineY);
            }
            else if (elementBox instanceof ImageElementBox) {
                this.renderImageElementBox(elementBox, left, top, underlineY);
            }
            else {
                elementBox.isVisible = true;
                this.renderTextElementBox(elementBox, left, top, underlineY);
            }
            left += elementBox.width + elementBox.margin.left;
        }
    }
    toSkipFieldCode(element) {
        if (element instanceof FieldElementBox) {
            if (element.fieldType === 0) {
                if ((!isNullOrUndefined(element.fieldEnd) || element.hasFieldEnd)) {
                    this.isFieldCode = true;
                }
            }
            else if (element.fieldType === 2 || element.fieldType === 1) {
                this.isFieldCode = false;
            }
        }
    }
    /**
     * Gets underline y position.
     * @param {LineWidget} lineWidget
     * @private
     */
    getUnderlineYPosition(lineWidget) {
        let height = 0;
        let lineHeight = 0;
        for (let i = 0; i < lineWidget.children.length; i++) {
            if (lineWidget.children[i] instanceof FieldElementBox ||
                (lineWidget.children[i].width === 0 && lineWidget.children[i].height === 0)) {
                continue;
            }
            if (height < lineWidget.children[i].height + lineWidget.children[i].margin.top) {
                height = lineWidget.children[i].margin.top + lineWidget.children[i].height;
                lineHeight = lineWidget.children[i].height / 20;
            }
        }
        return height - 2 * lineHeight;
    }
    /**
     * Renders list element box
     * @param {ListTextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    renderListTextElementBox(elementBox, left, top, underlineY) {
        let topMargin = elementBox.margin.top;
        let leftMargin = elementBox.margin.left;
        let format = elementBox.listLevel.characterFormat;
        let breakCharacterFormat = elementBox.line.paragraph.characterFormat;
        let color = format.fontColor === '#000000' ? breakCharacterFormat.fontColor : format.fontColor;
        this.pageContext.textBaseline = 'alphabetic';
        let bold = '';
        let italic = '';
        let fontFamily = format.hasValue('fontFamily') ? format.fontFamily : breakCharacterFormat.fontFamily;
        let fontSize = format.fontSize === 11 ? breakCharacterFormat.fontSize : format.fontSize;
        // tslint:disable-next-line:max-line-length
        let baselineAlignment = format.baselineAlignment === 'Normal' ? breakCharacterFormat.baselineAlignment : format.baselineAlignment;
        bold = format.bold ? 'bold' : breakCharacterFormat.bold ? 'bold' : '';
        italic = format.italic ? 'italic' : breakCharacterFormat.italic ? 'italic' : '';
        fontSize = fontSize === 0 ? 0.5 : fontSize / (baselineAlignment === 'Normal' ? 1 : 1.5);
        fontSize = this.isPrinting ? fontSize : fontSize * this.viewer.zoomFactor;
        let strikethrough = format.strikethrough === 'None' ? breakCharacterFormat.strikethrough : format.strikethrough;
        let highlightColor = format.highlightColor === 'NoColor' ? breakCharacterFormat.highlightColor :
            format.highlightColor;
        if (highlightColor !== 'NoColor') {
            if (highlightColor.substring(0, 1) !== '#') {
                this.pageContext.fillStyle = HelperMethods.getHighlightColorCode(highlightColor);
            }
            else {
                this.pageContext.fillStyle = this.getColor(highlightColor);
            }
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
        }
        this.pageContext.font = bold + ' ' + italic + ' ' + fontSize + 'pt' + ' ' + fontFamily;
        if (baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - elementBox.height / 1.5;
        }
        let baselineOffset = elementBox.baselineOffset;
        topMargin = (format.baselineAlignment === 'Normal') ? topMargin + baselineOffset : (topMargin + (baselineOffset / 1.5));
        let text = elementBox.text;
        let followCharacter = text === '\t' || text === ' ';
        if (!followCharacter && (format.bidi || elementBox.line.paragraph.paragraphFormat.bidi)) {
            let index = text.indexOf('.');
            text = text.substr(index) + text.substring(0, index);
        }
        this.pageContext.fillStyle = this.getColor(color);
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillText(text, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width));
        if (format.underline !== 'None' && !isNullOrUndefined(format.underline)) {
            this.renderUnderline(elementBox, left, top, underlineY, color, format.underline, baselineAlignment);
        }
        if (strikethrough !== 'None') {
            this.renderStrikeThrough(elementBox, left, top, format.strikethrough, color, baselineAlignment);
        }
    }
    /**
     * Renders text element box.
     * @param {TextElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    // tslint:disable-next-line:max-line-length
    renderTextElementBox(elementBox, left, top, underlineY) {
        let isHeightType = false;
        let containerWidget = elementBox.line.paragraph.containerWidget;
        if (containerWidget instanceof TableCellWidget) {
            isHeightType = (containerWidget.ownerRow.rowFormat.heightType === 'Exactly');
        }
        let topMargin = elementBox.margin.top;
        let leftMargin = elementBox.margin.left;
        if (isHeightType) {
            // tslint:disable-next-line:max-line-length
            this.clipRect(containerWidget.x, containerWidget.y, this.getScaledValue(containerWidget.width), this.getScaledValue(containerWidget.height));
        }
        let format = elementBox.characterFormat;
        if (format.highlightColor !== 'NoColor') {
            if (format.highlightColor.substring(0, 1) !== '#') {
                this.pageContext.fillStyle = HelperMethods.getHighlightColorCode(format.highlightColor);
            }
            else {
                this.pageContext.fillStyle = this.getColor(format.highlightColor);
            }
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
        }
        let color = format.fontColor;
        this.pageContext.textBaseline = 'alphabetic';
        let bold = '';
        let italic = '';
        let fontSize = 11;
        bold = format.bold ? 'bold' : '';
        italic = format.italic ? 'italic' : '';
        fontSize = format.fontSize === 0 ? 0.5 : format.fontSize / (format.baselineAlignment === 'Normal' ? 1 : 1.5);
        fontSize = this.isPrinting ? fontSize : fontSize * this.viewer.zoomFactor;
        this.pageContext.font = bold + ' ' + italic + ' ' + fontSize + 'pt' + ' ' + format.fontFamily;
        if (format.baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - elementBox.height / 1.5;
        }
        let baselineOffset = elementBox.baselineOffset;
        topMargin = (format.baselineAlignment === 'Normal') ? topMargin + baselineOffset : (topMargin + (baselineOffset / 1.5));
        this.pageContext.fillStyle = this.getColor(color);
        let scaledWidth = this.getScaledValue(elementBox.width);
        let text = elementBox.text;
        if (elementBox instanceof TabElementBox) {
            let tabElement = elementBox;
            if (tabElement.tabText === '' && !isNullOrUndefined(tabElement.tabLeader) && tabElement.tabLeader !== 'None') {
                text = this.getTabLeader(elementBox);
                tabElement.tabText = text;
            }
            else if (tabElement.tabText !== '') {
                text = tabElement.tabText;
            }
        }
        let isRTL = format.bidi || this.viewer.textHelper.isRTLText(elementBox.text);
        text = this.viewer.textHelper.setText(text, isRTL, format.bdo, true);
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillText(text, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), scaledWidth);
        // tslint:disable-next-line:max-line-length
        if ((this.viewer.owner.enableSpellCheck && !this.spellChecker.removeUnderline) && (this.viewer.triggerSpellCheck || elementBox.canTrigger) && elementBox.text !== ' ' && !this.viewer.isScrollHandler && (isNullOrUndefined(elementBox.previousNode) || !(elementBox.previousNode instanceof FieldElementBox))) {
            elementBox.canTrigger = true;
            this.leftPosition = this.pageLeft;
            this.topPosition = this.pageTop;
            let errorDetails = this.spellChecker.checktextElementHasErrors(elementBox.text, elementBox, left);
            if (errorDetails.errorFound) {
                color = '#FF0000';
                for (let i = 0; i < errorDetails.elements.length; i++) {
                    let currentElement = errorDetails.elements[i];
                    // tslint:disable-next-line:max-line-length
                    if (elementBox.ignoreOnceItems.indexOf(this.spellChecker.manageSpecialCharacters(currentElement.text, undefined, true)) === -1) {
                        // tslint:disable-next-line:max-line-length
                        let backgroundColor = (containerWidget instanceof TableCellWidget) ? containerWidget.cellFormat.shading.backgroundColor : this.viewer.backgroundColor;
                        // tslint:disable-next-line:max-line-length
                        this.renderWavyline(currentElement, (isNullOrUndefined(currentElement.start)) ? left : currentElement.start.location.x, (isNullOrUndefined(currentElement.start)) ? top : currentElement.start.location.y - elementBox.margin.top, underlineY, color, 'Single', format.baselineAlignment, backgroundColor);
                    }
                }
            }
            else if (elementBox.ischangeDetected || this.viewer.triggerElementsOnLoading) {
                elementBox.ischangeDetected = false;
                this.handleChangeDetectedElements(elementBox, underlineY, left, top, format.baselineAlignment);
            }
        }
        if (format.underline !== 'None' && !isNullOrUndefined(format.underline)) {
            // tslint:disable-next-line:max-line-length
            this.renderUnderline(elementBox, left, top, underlineY, color, format.underline, format.baselineAlignment);
        }
        if (format.strikethrough !== 'None' && !isNullOrUndefined(format.strikethrough)) {
            this.renderStrikeThrough(elementBox, left, top, format.strikethrough, color, format.baselineAlignment);
        }
        if (isHeightType) {
            this.pageContext.restore();
        }
    }
    /**
     * Method to handle spell check for modified or newly added elements
     * @param {TextElementBox} elementBox
     * @param {number} underlineY
     * @param {number} left
     * @param {number} top
     * @param {number} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    handleChangeDetectedElements(elementBox, underlineY, left, top, baselineAlignment) {
        let checkText = elementBox.text.trim();
        let beforeIndex = this.pageIndex;
        if (elementBox.text === '\v') {
            return;
        }
        if (!this.spellChecker.checkElementCanBeCombined(elementBox, underlineY, beforeIndex, true)) {
            /* tslint:disable:no-any */
            let splittedText = checkText.split(/[\s]+/);
            let markindex = elementBox.line.getOffset(elementBox, 0);
            let spaceValue = 1;
            if (splittedText.length > 1) {
                for (let i = 0; i < splittedText.length; i++) {
                    let currentText = splittedText[i];
                    let retrievedText = this.spellChecker.manageSpecialCharacters(currentText, undefined, true);
                    // tslint:disable-next-line:max-line-length
                    if (this.spellChecker.ignoreAllItems.indexOf(retrievedText) === -1 && elementBox.ignoreOnceItems.indexOf(retrievedText) === -1) {
                        this.handleUnorderdElements(retrievedText, elementBox, underlineY, i, markindex, i === splittedText.length - 1, beforeIndex);
                        markindex += currentText.length + spaceValue;
                    }
                }
            }
            else {
                let retrievedText = this.spellChecker.manageSpecialCharacters(checkText, undefined, true);
                if (checkText.length > 0) {
                    // tslint:disable-next-line:max-line-length
                    if (this.spellChecker.ignoreAllItems.indexOf(retrievedText) === -1 && elementBox.ignoreOnceItems.indexOf(retrievedText) === -1) {
                        let indexInLine = elementBox.indexInOwner;
                        let indexinParagraph = elementBox.line.paragraph.indexInOwner;
                        let spellInfo = this.spellChecker.checkSpellingInPageInfo(retrievedText);
                        if (spellInfo.isElementPresent && this.spellChecker.enableOptimizedSpellCheck) {
                            let jsonObject = JSON.parse('{\"HasSpellingError\":' + spellInfo.hasSpellError + '}');
                            // tslint:disable-next-line:max-line-length
                            this.spellChecker.handleWordByWordSpellCheck(jsonObject, elementBox, left, top, underlineY, baselineAlignment, true);
                        }
                        else {
                            /* tslint:disable:no-any */
                            // tslint:disable-next-line:max-line-length
                            this.spellChecker.CallSpellChecker(this.spellChecker.languageID, checkText, true, this.spellChecker.allowSpellCheckAndSuggestion).then((data) => {
                                /* tslint:disable:no-any */
                                let jsonObject = JSON.parse(data);
                                // tslint:disable-next-line:max-line-length
                                let canUpdate = (beforeIndex === this.pageIndex || elementBox.isVisible) && (indexInLine === elementBox.indexInOwner) && (indexinParagraph === elementBox.line.paragraph.indexInOwner);
                                // tslint:disable-next-line:max-line-length
                                this.spellChecker.handleWordByWordSpellCheck(jsonObject, elementBox, left, top, underlineY, baselineAlignment, canUpdate);
                            });
                        }
                    }
                }
            }
        }
    }
    /**
     * Method to handle spell check combine and splitted text elements
     * @param {string} currentText
     * @param {TextElementBox} elementBox
     * @param {number} underlineY
     * @param {number} iteration
     * @private
     */
    // tslint:disable-next-line:max-line-length
    handleUnorderdElements(currentText, elementBox, underlineY, iteration, markindex, isLastItem, beforeIndex) {
        let indexInLine = elementBox.indexInOwner;
        let indexinParagraph = elementBox.line.paragraph.indexInOwner;
        if (currentText.length > 0) {
            let spellInfo = this.spellChecker.checkSpellingInPageInfo(currentText);
            if (spellInfo.isElementPresent && this.spellChecker.enableOptimizedSpellCheck) {
                let jsonObject = JSON.parse('{\"HasSpellingError\":' + spellInfo.hasSpellError + '}');
                // tslint:disable-next-line:max-line-length
                this.spellChecker.handleSplitWordSpellCheck(jsonObject, currentText, elementBox, true, underlineY, iteration, markindex, isLastItem);
            }
            else {
                /* tslint:disable:no-any */
                // tslint:disable-next-line:max-line-length
                this.spellChecker.CallSpellChecker(this.spellChecker.languageID, currentText, true, this.spellChecker.allowSpellCheckAndSuggestion).then((data) => {
                    /* tslint:disable:no-any */
                    let jsonObject = JSON.parse(data);
                    // tslint:disable-next-line:max-line-length
                    let canUpdate = (elementBox.isVisible) && (indexInLine === elementBox.indexInOwner) && (indexinParagraph === elementBox.line.paragraph.indexInOwner);
                    // tslint:disable-next-line:max-line-length
                    this.spellChecker.handleSplitWordSpellCheck(jsonObject, currentText, elementBox, canUpdate, underlineY, iteration, markindex, isLastItem);
                });
            }
        }
    }
    /**
     * Render Wavy Line
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {string} color
     * @param {Underline} underline
     * @param {BaselineAlignment} baselineAlignment
     * @private
     */
    // tslint:disable-next-line:max-line-length
    renderWavyline(elementBox, left, top, underlineY, color, underline, baselineAlignment, backgroundColor) {
        if (elementBox.text.length > 1) {
            let renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
            let topMargin = elementBox.margin.top;
            let underlineHeight = renderedHeight / 20;
            const frequencyRange = 0.5;
            const amplitudeRange = 1.0;
            const stepToCover = .7;
            let y = 0;
            if (baselineAlignment === 'Subscript' || elementBox instanceof ListTextElementBox) {
                y = (renderedHeight - 2 * underlineHeight) + top;
                topMargin += elementBox.height - renderedHeight;
                y += topMargin > 0 ? topMargin : 0;
            }
            else {
                y = underlineY + top;
            }
            // tslint:disable-next-line:max-line-length
            let specialCharacter = this.spellChecker.getSpecialCharactersInfo(elementBox.text, elementBox.characterFormat);
            // tslint:disable-next-line:max-line-length
            let whiteSpaceData = this.spellChecker.getWhiteSpaceCharacterInfo(elementBox.text, elementBox.characterFormat);
            // tslint:disable-next-line:max-line-length
            let x = left + specialCharacter.beginningWidth + ((whiteSpaceData.isBeginning) ? whiteSpaceData.width : 0) + elementBox.margin.left;
            let x1 = x * this.viewer.zoomFactor + this.leftPosition;
            let y1 = y * this.viewer.zoomFactor + this.topPosition;
            // tslint:disable-next-line:max-line-length
            let x2 = x1 + this.getScaledValue(elementBox.width - (specialCharacter.beginningWidth + specialCharacter.endWidth) - whiteSpaceData.width);
            let startingPoint = new Point(x1, y1);
            let endingPoint = new Point(x2, y1);
            // tslint:disable-next-line:max-line-length
            this.drawWavy(startingPoint, endingPoint, (x2 - x1) * frequencyRange, amplitudeRange, stepToCover, color, elementBox.height, backgroundColor);
        }
    }
    /**
     * Draw wavy line
     * @param {Point} from
     * @param {Point} to
     * @param {Number} frequency
     * @param {Number} amplitude
     * @param {Number} step
     * @param {string} color
     * @param {Number} negative
     * @private
     */
    // tslint:disable-next-line:max-line-length
    drawWavy(from, to, frequency, amplitude, step, color, height, backColor, negative) {
        this.pageContext.save();
        this.pageContext.fillStyle = (!isNullOrUndefined(backColor) ? backColor : this.viewer.backgroundColor);
        this.pageContext.fillRect(from.x, from.y - amplitude, (to.x - from.x), amplitude * 3);
        this.pageContext.restore();
        this.pageContext.lineWidth = 1;
        this.pageContext.lineCap = 'round';
        this.pageContext.strokeStyle = color;
        this.pageContext.beginPath();
        //this.pageContext.save();
        let cx = 0;
        let cy = 0;
        let fx = from.x;
        let fy = from.y;
        let tx = to.x;
        let ty = to.y;
        let i = 0;
        let waveOffsetLength = 0;
        let ang = Math.atan2(ty - fy, tx - fx);
        let distance = Math.sqrt((fx - tx) * (fx - tx) + (fy - ty) * (fy - ty));
        let a = amplitude * 1;
        let f = Math.PI * frequency;
        for (i; i <= distance; i += step) {
            waveOffsetLength = Math.sin((i / distance) * f) * a;
            cx = from.x + Math.cos(ang) * i + Math.cos(ang - Math.PI / 2) * waveOffsetLength;
            cy = from.y + Math.sin(ang) * i + Math.sin(ang - Math.PI / 2) * waveOffsetLength;
            i > 0 ? this.pageContext.lineTo(cx, cy) : this.pageContext.moveTo(cx, cy);
        }
        this.pageContext.stroke();
        this.pageContext.restore();
    }
    /**
     * Returns tab leader
     */
    getTabLeader(elementBox) {
        let textWidth = 0;
        let tabString = this.getTabLeaderString(elementBox.tabLeader);
        let tabText = tabString;
        textWidth = this.viewer.textHelper.getWidth(tabText, elementBox.characterFormat);
        let count = Math.floor(elementBox.width / textWidth);
        for (let i = 0; i <= count; i++) {
            tabText += tabString;
        }
        return tabText.slice(0, -1);
    }
    /**
     * Returns tab leader string.
     */
    getTabLeaderString(tabLeader) {
        let tabString = '';
        switch (tabLeader) {
            case 'Dot':
                tabString = '.';
                break;
            case 'Hyphen':
                tabString = '-';
                break;
            case 'Underscore':
                tabString = '_';
                break;
        }
        return tabString;
    }
    /**
     * Clips the rectangle with specified position.
     * @param {number} xPos
     * @param {number} yPos
     * @param {number} width
     * @param {number} height
     */
    clipRect(xPos, yPos, width, height) {
        this.pageContext.beginPath();
        this.pageContext.save();
        this.pageContext.rect(this.getScaledValue(xPos, 1), this.getScaledValue(yPos, 2), width, height);
        this.pageContext.clip();
    }
    /**
     * Renders underline.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     * @param {string} color
     * @param {Underline} underline
     * @param {BaselineAlignment} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    renderUnderline(elementBox, left, top, underlineY, color, underline, baselineAlignment) {
        let renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
        let topMargin = elementBox.margin.top;
        let underlineHeight = renderedHeight / 20;
        let y = 0;
        if (baselineAlignment === 'Subscript' || elementBox instanceof ListTextElementBox) {
            y = (renderedHeight - 2 * underlineHeight) + top;
            topMargin += elementBox.height - renderedHeight;
            y += topMargin > 0 ? topMargin : 0;
        }
        else {
            y = underlineY + top;
        }
        // tslint:disable-next-line:max-line-length
        this.pageContext.fillRect(this.getScaledValue(left + elementBox.margin.left, 1), this.getScaledValue(y, 2), this.getScaledValue(elementBox.width), this.getScaledValue(underlineHeight));
    }
    /**
     * Renders strike through.
     * @param {ElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {Strikethrough} strikethrough
     * @param {string} color
     * @param {BaselineAlignment} baselineAlignment
     */
    // tslint:disable-next-line:max-line-length
    renderStrikeThrough(elementBox, left, top, strikethrough, color, baselineAlignment) {
        let renderedHeight = elementBox.height / (baselineAlignment === 'Normal' ? 1 : 1.5);
        let topMargin = elementBox.margin.top;
        if (baselineAlignment === 'Subscript') {
            topMargin += elementBox.height - renderedHeight;
        }
        top += topMargin > 0 ? topMargin : 0;
        let lineHeight = renderedHeight / 20;
        let y = (renderedHeight / 2) + (0.5 * lineHeight);
        let lineCount = 0;
        if (strikethrough === 'DoubleStrike') {
            y -= lineHeight;
        }
        while (lineCount < (strikethrough === 'DoubleStrike' ? 2 : 1)) {
            lineCount++;
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left + elementBox.margin.left, 1), this.getScaledValue(y + top, 2), this.getScaledValue(elementBox.width), this.getScaledValue(lineHeight));
            y += 2 * lineHeight;
        }
    }
    /**
     * Renders image element box.
     * @param {ImageElementBox} elementBox
     * @param {number} left
     * @param {number} top
     * @param {number} underlineY
     */
    // tslint:disable-next-line:max-line-length
    renderImageElementBox(elementBox, left, top, underlineY) {
        let topMargin = elementBox.margin.top;
        let leftMargin = elementBox.margin.left;
        this.pageContext.textBaseline = 'top';
        let widgetWidth = 0;
        let isClipped = false;
        if (topMargin < 0 || elementBox.line.paragraph.width < elementBox.width) {
            let containerWid = elementBox.line.paragraph.containerWidget;
            // if (containerWid instanceof BodyWidget) {
            //     widgetWidth = containerWid.width + containerWid.x;
            // } else 
            if (containerWid instanceof TableCellWidget) {
                let leftIndent = 0;
                if (containerWid.childWidgets[0] instanceof ParagraphWidget) {
                    let paraAdv = containerWid.childWidgets[0];
                    leftIndent = paraAdv.paragraphFormat.leftIndent;
                }
                widgetWidth = containerWid.width + containerWid.margin.left - containerWid.leftBorderWidth - leftIndent;
                isClipped = true;
                // tslint:disable-next-line:max-line-length
                this.clipRect(left + leftMargin, top + topMargin, this.getScaledValue(widgetWidth), this.getScaledValue(containerWid.height));
            }
        }
        if (elementBox.isMetaFile) {
            /* tslint:disable:no-empty */
        }
        else {
            try {
                // tslint:disable-next-line:max-line-length
                this.pageContext.drawImage(elementBox.element, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
            }
            catch (e) {
                // tslint:disable-next-line:max-line-length
                elementBox.imageString = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAgVBMVEX///8AAADgAADY2Njl5eVcXFxjY2NZWVl/f3+wsLCmpqb4+PiioqKpqam7u7vV1dX2uLj2wsLhFRXzpKT3vb30sbHhCwv74+P40dH+9vbkIyO2trbBwcHLy8tsbGycnJz529v4zMzrbGzlLS3qZmblNzfrdXXoRkbvi4vvgYHlHh7CZsBOAAADpUlEQVR4nO3da1faQBSF4ekAUQlUEFs14AXxVv7/D6yaQiZx5mSEYXF2ut+PNKzyyK5diYDmR9czx34AB49C/CjE759w3jvvWr15Tdgz3atXE54f++EcIArxoxA/CvGjED8K8aMQPwrxoxA/CvGLEeZ9jPJdhfk4GyCUjb3ECGE/Q6m/q3DwfudjP0ERZYN9hKdn2hvd3+0jHJz5/kBVuTk96bbQUEjhYR9ckiikUH8UUqg/CinUH4UU6o9CCvVHIYX6o5BC/VFIof4opFB/FFKoPwop1B+FFOqPQgrjyxfjVC38Lxk9tnAxGqZqdKtSOE4GHA5/fuNJpDCtcNHbv4VqYYqPLjgfUViPQgrjozA2CptRSGF8/59w+Wrt+rr1btNna1cPzg0wwuXavncxabnX7PfHYYXzlYARvlobQZyUR9mXm+1NMEK7SSLONgcVV9vb8IQXv4J3KSeKKlxXxNCzONkeYp8AV3p9UT1+P3FWHVAsq5thhGZSEb1DrSZq7dS5HUdoLiuBZ6jORG3tCwAkNJfCUJ2Jrqe1P0ESCkMNTdSACYNDDU7UoAkDQw1P1MAJvUMVJmrwhJ6hShM1gMIvQxUnahCFjaHKEzWQQneoxR95ogZTWBuqPFEDKnSHKk/UoArdoYoTNbDC5lBDEzW4QjMpYiZqgIXG/S76JhwHK5zVVipcnkIVuv/RW/HyFKhwYhuFr6NiCmdNoDBUSGFjovJQEYXuRN9ahwoorJ8uSZenPsMTNk+X2q6jwgm/ntHL11HhhL4zenmoYEL/Gb04VCxh6KKTNFQoYfiikzBUJKF00Sk8VCChfF00OFQcYdt10dBQYYRT5xn0n9G7Q0X8GfCzNNEyZ6iPgD/HlydaVg11DfhajJaJlm2HugIUrlomWrYZKuJKHz6vHhbSM/hROdRnxNe1meuXYvW0DB6+aflYrB7dlzDiCM3N1dVN6GDhMCDhjlHYjEIK46MwNgqbUUhhfJ/vA07wO8N1vw94ONo/3e/lTpVOYfc/UyG//ZmqW52fi/FuTNW3/lZ+eguF+qOQQv1RSKH+KKRQfxRSqD8KKdQfhRTqj0IK9UchhfqjkEL9UUih/iikUH8UUqg/CmXh6Hsv3jlK+wnvD/vgkrSHMMuyu1P9ZdmuwnycDQYn+svG3n9KEUKT9zHyf6+IEWJHIX4U4kchfhTiRyF+FOJHIX4U4kchfnVhijeZa6sunCf4ZdPamteEHY5C/CjEr/vCv0ec0g+AtS1QAAAAAElFTkSuQmCC';
                // tslint:disable-next-line:max-line-length
                this.pageContext.drawImage(elementBox.element, this.getScaledValue(left + leftMargin, 1), this.getScaledValue(top + topMargin, 2), this.getScaledValue(elementBox.width), this.getScaledValue(elementBox.height));
            }
        }
        if (isClipped) {
            this.pageContext.restore();
        }
    }
    /**
     * Renders table outline.
     * @param {TableWidget} tableWidget
     */
    renderTableOutline(tableWidget) {
        let layout = new Layout(this.viewer);
        let table = tableWidget;
        tableWidget.width = this.viewer.layout.getTableWidth(table);
        let border = !table.isBidiTable ? layout.getTableLeftBorder(table.tableFormat.borders)
            : layout.getTableRightBorder(table.tableFormat.borders);
        let lineWidth = 0;
        //ToDo: Need to draw the borders based on the line style.
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth / 2, tableWidget.y, tableWidget.x - tableWidget.margin.left - lineWidth / 2, tableWidget.y + tableWidget.height, lineWidth);
        // }
        border = layout.getTableTopBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth, tableWidget.y - lineWidth / 2, tableWidget.x + tableWidget.width + lineWidth + tableWidget.margin.right, tableWidget.y - lineWidth / 2, lineWidth);
        // }
        border = !table.isBidiTable ? layout.getTableRightBorder(table.tableFormat.borders)
            : layout.getTableLeftBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x + tableWidget.width + tableWidget.margin.right + lineWidth / 2, tableWidget.y, tableWidget.x + tableWidget.width + tableWidget.margin.right + lineWidth / 2, tableWidget.y + tableWidget.height, lineWidth);
        // }
        border = layout.getTableBottomBorder(table.tableFormat.borders);
        lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, tableWidget.x - tableWidget.margin.left - lineWidth, tableWidget.y + tableWidget.height - lineWidth / 2, tableWidget.x + tableWidget.width + lineWidth + tableWidget.margin.right, tableWidget.y + tableWidget.height - lineWidth / 2, lineWidth);
        // }
    }
    /**
     * Renders table cell outline.
     * @param {LayoutViewer} viewer
     * @param {TableCellWidget} cellWidget
     */
    // tslint:disable: max-func-body-length
    renderTableCellOutline(viewer, cellWidget) {
        let layout = viewer.layout;
        let borders = undefined;
        let tableCell = cellWidget;
        let cellTopMargin = 0;
        let cellBottomMargin = 0;
        let cellLeftMargin = 0;
        let cellRightMargin = 0;
        let height = 0;
        let isBidiTable = cellWidget.ownerTable.isBidiTable;
        borders = tableCell.cellFormat.borders;
        if (cellWidget.containerWidget instanceof TableRowWidget) {
            cellBottomMargin = cellWidget.margin.bottom - cellWidget.containerWidget.bottomBorderWidth;
            cellTopMargin = cellWidget.margin.top - cellWidget.containerWidget.topBorderWidth;
        }
        cellLeftMargin = cellWidget.margin.left - cellWidget.leftBorderWidth;
        cellRightMargin = cellWidget.margin.right - cellWidget.rightBorderWidth;
        if (!isNullOrUndefined(tableCell.ownerRow) && tableCell.ownerRow.rowFormat.heightType === 'Exactly') {
            height = HelperMethods.convertPointToPixel(tableCell.ownerRow.rowFormat.height) + cellTopMargin + cellBottomMargin;
        }
        else {
            if (!isNullOrUndefined(tableCell.ownerRow) && [tableCell.ownerRow].length <= 1) {
                // tslint:disable-next-line:max-line-length
                height = Math.max(HelperMethods.convertPointToPixel(tableCell.ownerRow.rowFormat.height), cellWidget.height) + cellTopMargin + cellBottomMargin;
            }
            else {
                height = cellWidget.height + cellTopMargin + cellBottomMargin;
            }
        }
        let border = !isBidiTable ? TableCellWidget.getCellLeftBorder(tableCell) : TableCellWidget.getCellRightBorder(tableCell);
        let lineWidth = 0;
        // if (!isNullOrUndefined(border )) {
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth()); //Renders the cell left border.
        this.renderCellBackground(height, cellWidget, cellLeftMargin, lineWidth);
        let leftBorderWidth = lineWidth;
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, cellWidget.x - cellLeftMargin - lineWidth, cellWidget.y - cellTopMargin, cellWidget.x - cellLeftMargin - lineWidth, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
        // }
        border = TableCellWidget.getCellTopBorder(tableCell);
        // if (!isNullOrUndefined(border )) { //Renders the cell top border.        
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        // tslint:disable-next-line:max-line-length
        this.renderSingleBorder(border, cellWidget.x - cellWidget.margin.left - leftBorderWidth / 2, cellWidget.y - cellWidget.margin.top + lineWidth / 2, cellWidget.x + cellWidget.width + cellWidget.margin.right, cellWidget.y - cellWidget.margin.top + lineWidth / 2, lineWidth);
        // }
        let isLastCell = false;
        if (!isBidiTable) {
            isLastCell = tableCell.cellIndex === tableCell.ownerRow.childWidgets.length - 1;
        }
        else {
            isLastCell = tableCell.cellIndex === 0;
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0 || isLastCell) {
            border = isBidiTable ? TableCellWidget.getCellLeftBorder(tableCell) : TableCellWidget.getCellRightBorder(tableCell);
            // if (!isNullOrUndefined(border )) { //Renders the cell right border.           
            lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x + cellWidget.width + cellWidget.margin.right - lineWidth / 2, cellWidget.y - cellTopMargin, cellWidget.x + cellWidget.width + cellWidget.margin.right - lineWidth / 2, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
            // }
        }
        let nextRow = tableCell.ownerRow.nextWidget;
        //Specifies the next row is within the current table widget.
        //True means current row is not rendered at page end; Otherwise False.
        let nextRowIsInCurrentTableWidget = false;
        if (!isNullOrUndefined(nextRow)) {
            let nextRowWidget = undefined;
            // if (viewer.renderedElements.containsKey(nextRow) && viewer.renderedElements.get(nextRow).length > 0) {
            nextRowWidget = nextRow;
            // }
            if (nextRowWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                if (cellWidget.containerWidget instanceof TableRowWidget && cellWidget.containerWidget.containerWidget instanceof TableWidget) {
                    nextRowIsInCurrentTableWidget = cellWidget.containerWidget.containerWidget.childWidgets.indexOf(nextRowWidget) !== -1;
                }
            }
        }
        if (tableCell.ownerTable.tableFormat.cellSpacing > 0 || tableCell.ownerRow.rowIndex === tableCell.ownerTable.childWidgets.length - 1
            || (tableCell.cellFormat.rowSpan > 1
                && tableCell.ownerRow.rowIndex + tableCell.cellFormat.rowSpan >= tableCell.ownerTable.childWidgets.length) ||
            !nextRowIsInCurrentTableWidget) {
            // tslint:disable-next-line:max-line-length
            border = (tableCell.cellFormat.rowSpan > 1 && tableCell.ownerRow.rowIndex + tableCell.cellFormat.rowSpan === tableCell.ownerTable.childWidgets.length) ?
                //true part for vertically merged cells specifically.
                tableCell.getBorderBasedOnPriority(tableCell.cellFormat.borders.bottom, TableCellWidget.getCellBottomBorder(tableCell))
                //false part for remaining cases that has been handled inside method. 
                : TableCellWidget.getCellBottomBorder(tableCell);
            // if (!isNullOrUndefined(border )) {
            //Renders the cell bottom border.
            lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellWidget.margin.left - leftBorderWidth / 2, cellWidget.y + cellWidget.height + cellBottomMargin + lineWidth / 2, cellWidget.x + cellWidget.width + cellWidget.margin.right, cellWidget.y + cellWidget.height + cellBottomMargin + lineWidth / 2, lineWidth);
            // }
        }
        border = layout.getCellDiagonalUpBorder(tableCell);
        // if (!isNullOrUndefined(border )) {
        //Renders the cell diagonal up border.
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        if (lineWidth > 0) {
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellLeftMargin, cellWidget.y + cellWidget.height + cellBottomMargin, cellWidget.x + cellWidget.width + cellRightMargin, cellWidget.y - cellTopMargin, lineWidth);
            // }
        }
        border = layout.getCellDiagonalDownBorder(tableCell);
        // if (!isNullOrUndefined(border )) {
        //Renders the cell diagonal down border.
        lineWidth = HelperMethods.convertPointToPixel(border.getLineWidth());
        if (lineWidth > 0) {
            // tslint:disable-next-line:max-line-length
            this.renderSingleBorder(border, cellWidget.x - cellLeftMargin, cellWidget.y - cellTopMargin, cellWidget.x + cellWidget.width + cellRightMargin, cellWidget.y + cellWidget.height + cellBottomMargin, lineWidth);
        }
        // }
    }
    /**
     * Renders cell background.
     * @param {number} height
     * @param {TableCellWidget} cellWidget
     */
    renderCellBackground(height, cellWidget, leftMargin, lineWidth) {
        let cellFormat = cellWidget.cellFormat;
        let bgColor = cellFormat.shading.backgroundColor === '#ffffff' ?
            cellWidget.ownerTable.tableFormat.shading.backgroundColor : cellFormat.shading.backgroundColor;
        this.pageContext.beginPath();
        if (bgColor !== 'empty') {
            this.pageContext.fillStyle = this.getColor(bgColor);
            let left = cellWidget.x - leftMargin - lineWidth;
            let top = cellWidget.y - HelperMethods.convertPointToPixel(cellWidget.topMargin);
            // tslint:disable-next-line:max-line-length
            let width = cellWidget.width + leftMargin + lineWidth + cellWidget.margin.right;
            // tslint:disable-next-line:max-line-length
            this.pageContext.fillRect(this.getScaledValue(left, 1), this.getScaledValue(top, 2), this.getScaledValue(width), this.getScaledValue(height));
            this.pageContext.closePath();
        }
    }
    /**
     * Renders single border.
     * @param {WBorder} border
     * @param {number} startX
     * @param {number} startY
     * @param {number} endX
     * @param {number} endY
     * @param {number} lineWidth
     */
    // tslint:disable-next-line:max-line-length
    renderSingleBorder(border, startX, startY, endX, endY, lineWidth) {
        this.pageContext.beginPath();
        this.pageContext.moveTo(this.getScaledValue(startX, 1), this.getScaledValue(startY, 2));
        this.pageContext.lineTo(this.getScaledValue(endX, 1), this.getScaledValue(endY, 2));
        this.pageContext.lineWidth = this.getScaledValue(lineWidth);
        // set line color
        this.pageContext.strokeStyle = border.color;
        if (lineWidth > 0) {
            this.pageContext.stroke();
        }
        this.pageContext.closePath();
    }
    /**
     * Gets scaled value.
     * @param {number} value
     * @param {number} type
     * @private
     */
    getScaledValue(value, type) {
        if (this.isPrinting) {
            return value;
        }
        if (isNullOrUndefined(type)) {
            type = 0;
        }
        let x = value * this.viewer.zoomFactor;
        return x + (type === 1 ? this.pageLeft : (type === 2 ? this.pageTop : 0));
    }
    /**
     * Destroys the internal objects which is maintained.
     */
    destroy() {
        this.viewer = undefined;
        if (!isNullOrUndefined(this.pageCanvasIn)) {
            this.pageCanvasIn.innerHTML = '';
        }
        this.pageCanvasIn = undefined;
    }
}

/**
 * @private
 */
class TextHelper {
    constructor(viewer) {
        this.paragraphMarkInfo = {};
        this.owner = viewer;
        if (!isNullOrUndefined(viewer)) {
            this.context = viewer.containerContext;
        }
    }
    get paragraphMark() {
        return '¶';
    }
    get lineBreakMark() {
        return '↲';
    }
    /**
     * @private
     */
    getParagraphMarkWidth(characterFormat) {
        return this.getParagraphMarkSize(characterFormat).Width;
    }
    /**
     * @private
     */
    getParagraphMarkSize(characterFormat) {
        let format = this.getFormatText(characterFormat);
        if (this.paragraphMarkInfo[format]) {
            return this.paragraphMarkInfo[format];
        }
        // Gets the text element's width;
        let width = this.getWidth(this.paragraphMark, characterFormat);
        // Calculate the text element's height and baseline offset.
        let textHelper = this.getHeight(characterFormat);
        let textSizeInfo = {
            'Width': width, 'Height': textHelper.Height, 'BaselineOffset': textHelper.BaselineOffset
        };
        return this.paragraphMarkInfo[format] = textSizeInfo;
    }
    /**
     * @private
     */
    getTextSize(elementBox, characterFormat) {
        // Gets the text element's width;
        let textTrimEndWidth = 0;
        let isRTL = characterFormat.bidi || this.isRTLText(elementBox.text);
        let text = this.setText(elementBox.text, isRTL, characterFormat.bdo);
        textTrimEndWidth = this.getWidth(text, characterFormat);
        elementBox.width = textTrimEndWidth;
        // Calculate the text element's height and baseline offset.
        let textHelper = this.getHeight(characterFormat);
        elementBox.height = textHelper.Height;
        elementBox.baselineOffset = textHelper.BaselineOffset;
        if (elementBox.text[elementBox.text.length - 1] === ' ') {
            textTrimEndWidth = this.getWidth(HelperMethods.trimEnd(elementBox.text), characterFormat);
        }
        return textTrimEndWidth;
    }
    /**
     * @private
     */
    getHeight(characterFormat) {
        // Get character format property as  below predefined structure to make it easy to check and retrieve
        // Predefined static structure `[FontName];[FontSize];bold;italic` to maintain as key in the collection 
        let key = this.getFormatText(characterFormat);
        if (!isNullOrUndefined(this.owner.heightInfoCollection[key])) {
            return this.owner.heightInfoCollection[key];
        }
        let sizeInfo = this.getHeightInternal(characterFormat);
        this.owner.heightInfoCollection[key] = sizeInfo;
        return sizeInfo;
    }
    /**
     * @private
     */
    getFormatText(characterFormat) {
        let formatText = characterFormat.fontFamily.toLocaleLowerCase();
        formatText += ';' + characterFormat.fontSize;
        if (characterFormat.bold) {
            formatText += ';' + 'bold';
        }
        if (characterFormat.italic) {
            formatText += ';' + 'italic';
        }
        return formatText;
    }
    /**
     * @private
     */
    getHeightInternal(characterFormat) {
        let textHeight = 0;
        let baselineOffset = 0;
        let spanElement = document.createElement('span');
        spanElement.innerText = 'm';
        this.applyStyle(spanElement, characterFormat);
        let parentDiv = document.createElement('div');
        parentDiv.setAttribute('style', 'display:inline-block;position:absolute;');
        let tempDiv = document.createElement('div');
        tempDiv.setAttribute('style', 'display:inline-block;width: 1px; height: 0px;vertical-align: baseline;');
        parentDiv.appendChild(spanElement);
        parentDiv.appendChild(tempDiv);
        document.body.appendChild(parentDiv);
        // Sets the text element's height.
        textHeight = spanElement.offsetHeight;
        // Calculate the text element's baseline offset.
        let textTopVal = spanElement.offsetTop;
        let tempDivTopVal = tempDiv.offsetTop;
        let width = (parentDiv.offsetWidth - spanElement.offsetWidth);
        if ((textTopVal - width) === 1) {
            tempDivTopVal += width;
        }
        baselineOffset = tempDivTopVal - textTopVal;
        document.body.removeChild(parentDiv);
        return { 'Height': textHeight, 'BaselineOffset': baselineOffset };
    }
    /**
     * @private
     */
    measureTextExcludingSpaceAtEnd(text, characterFormat) {
        return this.getWidth(HelperMethods.trimEnd(text), characterFormat);
    }
    /**
     * @private
     */
    getWidth(text, characterFormat) {
        if (text.match('\v')) {
            text.replace('\v', this.lineBreakMark);
        }
        let bold = '';
        let italic = '';
        let fontFamily = '';
        let fontSize = characterFormat.fontSize;
        bold = characterFormat.bold ? 'bold' : '';
        italic = characterFormat.italic ? 'italic' : '';
        fontFamily = characterFormat.fontFamily;
        fontSize = fontSize === 0 ? 0.5 : fontSize / (characterFormat.baselineAlignment === 'Normal' ? 1 : 1.5);
        this.context.font = bold + ' ' + italic + ' ' + fontSize + 'pt' + ' ' + fontFamily;
        return this.context.measureText(text).width;
    }
    setText(textToRender, isBidi, bdo, isRender) {
        if (isNullOrUndefined(isRender)) {
            isRender = false;
        }
        if (textToRender.length === 0) {
            return '';
        }
        let isRtlText = isBidi;
        if ((!isRtlText && (bdo === 'RTL')) || (isRtlText && (bdo === 'LTR'))) {
            textToRender = HelperMethods.ReverseString(textToRender);
        }
        else if (isRender && isRtlText && HelperMethods.endsWith(textToRender)) {
            let spaceCount = textToRender.length - HelperMethods.trimEnd(textToRender).length;
            textToRender = HelperMethods.addSpace(spaceCount) + HelperMethods.trimEnd(textToRender);
        }
        return textToRender;
    }
    /**
     * @private
     */
    applyStyle(spanElement, characterFormat) {
        if (!isNullOrUndefined(spanElement) && !isNullOrUndefined(characterFormat)) {
            let style = 'white-space:nowrap;';
            if (characterFormat.fontFamily !== '') {
                style += 'font-family:' + characterFormat.fontFamily + ';';
            }
            let fontSize = characterFormat.fontSize;
            if (fontSize <= 0.5) {
                fontSize = 0.5;
            }
            style += 'font-size:' + fontSize.toString() + 'pt;';
            if (characterFormat.bold) {
                style += 'font-weight:bold;';
            }
            if (characterFormat.italic) {
                style += 'font-style:italic;';
            }
            spanElement.setAttribute('style', style);
        }
    }
    /**
     * @private
     */
    measureText(text, characterFormat) {
        // Gets the text element's width;
        let width = this.getWidth(text, characterFormat);
        let textHelper = this.getHeight(characterFormat);
        return {
            'Width': width, 'Height': textHelper.Height, 'BaselineOffset': textHelper.BaselineOffset
        };
    }
    /**
     * @private
     */
    updateTextSize(elementBox, paragraph) {
        let format = new WCharacterFormat(undefined);
        let listCharacterFormat = elementBox.listLevel.characterFormat;
        let breakCharacterFormat = paragraph.characterFormat;
        format.fontSize = listCharacterFormat.fontSize === 11 ? breakCharacterFormat.fontSize : listCharacterFormat.fontSize;
        format.fontFamily = listCharacterFormat.fontFamily === 'Verdana' ? breakCharacterFormat.fontFamily
            : listCharacterFormat.fontFamily;
        let bold = '';
        let italic = '';
        let baselineAlignment = listCharacterFormat.baselineAlignment === 'Normal' ?
            breakCharacterFormat.baselineAlignment : listCharacterFormat.baselineAlignment;
        bold = listCharacterFormat.bold ? 'bold' : breakCharacterFormat.bold ? 'bold' : '';
        italic = listCharacterFormat.italic ? 'italic' : breakCharacterFormat.italic ? 'italic' : '';
        format.baselineAlignment = baselineAlignment;
        if (bold) {
            format.bold = true;
        }
        if (italic) {
            format.italic = true;
        }
        let isRTL = format.bidi || this.isRTLText(elementBox.text);
        let text = this.setText(elementBox.text, isRTL, format.bdo);
        elementBox.width = this.getWidth(text, format);
        // Calculate the text element's height and baseline offset.
        let textHelper = this.getHeight(format);
        elementBox.height = textHelper.Height;
        elementBox.baselineOffset = textHelper.BaselineOffset;
    }
    /**
     * @private
     * @param text
     */
    containsSpecialCharAlone(text) {
        let specialChars = '*|.\:[]{}`\;()@&$#%!~';
        for (let i = 0; i < text.length; i++) {
            if (specialChars.indexOf(text.charAt(i)) === -1) {
                return false;
            }
        }
        return true;
    }
    /**
     * @private
     * @param text
     */
    containsSpecialChar(text) {
        let specialChars = '*|.\:[]{}`\;()@&$#%!~';
        for (let i = 0; i < text.length; i++) {
            if (specialChars.indexOf(text.charAt(i)) !== -1) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     */
    isRTLText(text) {
        let isRTL = false;
        if (!isNullOrUndefined(text)) {
            for (let i = 0; i < text.length; i++) {
                let temp = text[i];
                if ((temp >= '\u0590' && temp <= '\u05ff') //Hebrew characters
                    || (temp >= '\u0600' && temp <= '\u06ff') //Arabic - Urdu characters
                    || (temp >= '\u0750' && temp <= '\u077f') //Arabic - Urdu characters
                    || (temp >= '\u08a0' && temp <= '\u08ff') //Arabic characters
                    || (temp >= '\ufb50' && temp <= '\ufdff') //Arabic - Urdu characters
                    || (temp >= '\ufe70' && temp <= '\ufeff') //Arabic - Urdu characters
                    || (temp >= '\ua980' && temp <= '\ua9df') //Javanese characters
                    || (temp >= '\u0700' && temp <= '\u074f') //Syriac characters
                    || (temp >= '\u0780' && temp <= '\u07bf') //Thaana characters
                    || (temp >= '\u0840' && temp <= '\u085f') //Mandiac characters
                    || (temp >= '\u07c0' && temp <= '\u07ff') //N'Ko characters
                    || (temp >= '\u0800' && temp <= '\u083f') //Samaritan characters
                    //Tifinag characters 
                    || (temp >= '\u2d30' && temp <= '\u2d7f')) {
                    isRTL = true;
                    break;
                }
            }
        }
        return isRTL;
    }
    /**
     * @private
     */
    getRtlLanguage(text) {
        if (isNullOrUndefined(text) || text === '') {
            return { isRtl: false, id: 0 };
        }
        if (text >= '\u0590' && text <= '\u05ff') {
            return { isRtl: true, id: 1 };
            //Arabic - Urdu characters
        }
        else if ((text >= '\u0600' && text <= '\u06ff')
            || (text >= '\u0750' && text <= '\u077f')
            || (text >= '\u08a0' && text <= '\u08ff')
            || (text >= '\ufb50' && text <= '\ufdff')
            || (text >= '\ufe70' && text <= '\ufeff')) {
            return { isRtl: true, id: 2 };
        }
        else if (text >= '\ua980' && text <= '\ua9df') {
            return { isRtl: true, id: 3 };
        }
        else if (text >= '\u0700' && text <= '\u074f') {
            return { isRtl: true, id: 4 };
        }
        else if (text >= '\u0780' && text <= '\u07bf') {
            return { isRtl: true, id: 5 };
        }
        else if (text >= '\u0840' && text <= '\u085f') {
            return { isRtl: true, id: 6 };
        }
        else if (text >= '\u07c0' && text <= '\u07ff') {
            return { isRtl: true, id: 7 };
        }
        else if (text >= '\u0800' && text <= '\u083f') {
            return { isRtl: true, id: 8 };
        }
        else if (text >= '\u2d30' && text <= '\u2d7f') {
            return { isRtl: true, id: 9 };
        }
        return { isRtl: false, id: 0 };
    }
    destroy() {
        this.owner = undefined;
        this.context = undefined;
        this.paragraphMarkInfo = {};
        this.paragraphMarkInfo = undefined;
    }
}

/**
 * @private
 */
class Zoom {
    constructor(viewer) {
        this.onMouseWheelInternal = (event) => {
            if (event.ctrlKey === true) {
                event.preventDefault();
                let pageX = event.pageX - this.viewer.viewerContainer.offsetLeft;
                if (pageX < this.viewer.pageContainer.offsetWidth) {
                    let wheel = navigator.userAgent.match('Firefox') ? event.detail < 0 : event.wheelDelta > 0;
                    let zoomFactor = this.viewer.zoomFactor;
                    if (wheel) {
                        if (zoomFactor <= 4.90) {
                            zoomFactor += .10;
                        }
                        else {
                            zoomFactor = 5.00;
                        }
                    }
                    else {
                        if (zoomFactor >= .20) {
                            zoomFactor -= .10;
                        }
                        else {
                            zoomFactor = 0.10;
                        }
                    }
                    this.viewer.zoomFactor = zoomFactor;
                }
            }
        };
        this.viewer = viewer;
    }
    setZoomFactor(value) {
        this.onZoomFactorChanged();
        if (!isNullOrUndefined(this.viewer.selection)) {
            this.viewer.selection.updateCaretPosition();
        }
        this.viewer.updateTouchMarkPosition();
        if (!isNullOrUndefined(this.viewer.owner.imageResizerModule)) {
            this.viewer.owner.imageResizerModule.updateImageResizerPosition();
        }
        this.viewer.owner.fireZoomFactorChange();
    }
    //Zoom Implementation Starts
    onZoomFactorChanged() {
        if (this.viewer.zoomFactor > 5) {
            this.viewer.zoomFactor = 5;
        }
        else if (this.viewer.zoomFactor < 0.1) {
            this.viewer.zoomFactor = 0.1;
        }
        this.zoom();
    }
    zoom() {
        let viewer = this.viewer;
        viewer.clearContent();
        viewer.handleZoom();
        viewer.updateFocus();
    }
}

/**
 * @private
 */
class AddUserDialog {
    constructor(viewer, owner) {
        /**
         * @private
         */
        this.show = () => {
            let localObj = new L10n('documenteditor', this.viewer.owner.defaultLocale);
            localObj.setLocale(this.viewer.owner.locale);
            if (!this.target) {
                this.initUserDialog(localObj, this.viewer.owner.enableRtl);
            }
            this.viewer.dialog.header = localObj.getConstant('Add Users');
            this.viewer.dialog.height = 'auto';
            this.viewer.dialog.width = 'auto';
            this.viewer.dialog.content = this.target;
            this.viewer.dialog.beforeOpen = this.loadUserDetails;
            this.viewer.dialog.close = this.viewer.updateFocus;
            this.viewer.dialog.buttons = [
                {
                    click: this.okButtonClick,
                    buttonModel: {
                        content: localObj.getConstant('Ok'), cssClass: 'e-flat', isPrimary: true
                    }
                },
                {
                    click: this.hideDialog,
                    buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat' }
                }, {
                    click: this.deleteButtonClick,
                    buttonModel: { content: localObj.getConstant('Delete'), cssClass: 'e-flat e-user-delete' }
                }
            ];
            this.viewer.dialog.dataBind();
            this.viewer.dialog.show();
        };
        this.loadUserDetails = () => {
            this.viewer.restrictEditingPane.addedUser.dataSource = this.viewer.userCollection;
            this.viewer.restrictEditingPane.addedUser.refresh();
        };
        /**
         * @private
         */
        this.okButtonClick = () => {
            this.viewer.restrictEditingPane.showStopProtectionPane(false);
            this.viewer.restrictEditingPane.loadPaneValue();
            this.viewer.dialog.hide();
        };
        /**
         * @private
         */
        this.hideDialog = () => {
            this.textBoxInput.value = '';
            this.viewer.dialog.hide();
        };
        /**
         * @private
         */
        this.onKeyUpOnDisplayBox = () => {
            this.addButton.disabled = this.textBoxInput.value === '';
        };
        this.addButtonClick = () => {
            if (this.validateUserName(this.textBoxInput.value)) {
                if (this.viewer.userCollection.indexOf(this.textBoxInput.value) === -1) {
                    this.viewer.userCollection.push(this.textBoxInput.value);
                }
                this.userList.dataSource = this.viewer.userCollection;
                this.userList.refresh();
                this.textBoxInput.value = '';
            }
            else {
                DialogUtility.alert('Invalid user name');
            }
        };
        this.deleteButtonClick = () => {
            let index = this.viewer.userCollection.indexOf(this.userList.getSelectedItems().text);
            if (index > -1) {
                this.viewer.userCollection.splice(index, 1);
                this.userList.dataSource = this.viewer.userCollection;
                this.userList.refresh();
            }
        };
        this.viewer = viewer;
        this.owner = owner;
    }
    /**
     * @private
     */
    initUserDialog(localValue, isRtl) {
        let instance = this;
        let id = this.viewer.owner.containerId + '_addUser';
        this.target = createElement('div', { id: id, className: 'e-de-user-dlg' });
        let headerValue = localValue.getConstant('Enter User');
        let dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-bookmark-dlgfields' });
        this.target.appendChild(dlgFields);
        let commonDiv = createElement('div', { className: 'e-de-user-dlg-common' });
        this.target.appendChild(commonDiv);
        let adduserDiv = createElement('div', { className: 'e-de-user-dlg-list', styles: 'display:inline-flex' });
        commonDiv.appendChild(adduserDiv);
        if (isRtl) {
            adduserDiv.classList.add('e-de-rtl');
        }
        let textBoxDiv = createElement('div', { className: 'e-de-user-dlg-textboxdiv' });
        adduserDiv.appendChild(textBoxDiv);
        // tslint:disable-next-line:max-line-length
        this.textBoxInput = createElement('input', { className: 'e-input e-de-user-dlg-textbox-input', id: 'bookmark_text_box', attrs: { autofocus: 'true' } });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        this.textBoxInput.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        let addButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Add'), id: 'add',
            attrs: { type: 'button' }
        });
        adduserDiv.appendChild(addButtonElement);
        addButtonElement.addEventListener('click', this.addButtonClick);
        this.addButton = new Button({ cssClass: 'e-de-user-add-btn' });
        this.addButton.disabled = true;
        this.addButton.appendTo(addButtonElement);
        this.addButton.addEventListener('click', this.addButtonClick);
        let userCollectionDiv = createElement('div');
        commonDiv.appendChild(userCollectionDiv);
        let userDiv = createElement('div', { innerHTML: localValue.getConstant('Users'), className: 'e-de-user-dlg-user' });
        userCollectionDiv.appendChild(userDiv);
        let listviewDiv = createElement('div', { id: 'user_listView' });
        userCollectionDiv.appendChild(listviewDiv);
        this.userList = new ListView({
            cssClass: 'e-de-user-listview'
        });
        this.userList.appendTo(listviewDiv);
    }
    validateUserName(value) {
        if (value.indexOf('@') === -1) {
            return false;
        }
        else {
            let parts = value.split('@');
            let domain = parts[1];
            if (domain.indexOf('.') === -1) {
                return false;
            }
            else {
                let domainParts = domain.split('.');
                let ext = domainParts[1];
                if (domainParts.length > 2) {
                    return false;
                }
                if (ext.length > 4 || ext.length < 2) {
                    return false;
                }
            }
        }
        return true;
    }
}

/**
 * @private
 */
class EnforceProtectionDialog {
    constructor(viewer, owner) {
        /**
         * @private
         */
        this.show = () => {
            this.localeValue = new L10n('documenteditor', this.viewer.owner.defaultLocale);
            this.localeValue.setLocale(this.viewer.owner.locale);
            if (!this.target) {
                this.initDialog(this.localeValue, this.viewer.owner.enableRtl);
            }
            this.viewer.dialog.header = this.localeValue.getConstant('Start Enforcing Protection');
            this.viewer.dialog.height = 'auto';
            this.viewer.dialog.content = this.target;
            this.viewer.dialog.width = 'auto';
            this.viewer.dialog.buttons = [{
                    click: this.okButtonClick,
                    buttonModel: { content: this.localeValue.getConstant('Ok'), cssClass: 'e-flat', isPrimary: true }
                },
                {
                    click: this.hideDialog,
                    buttonModel: { content: this.localeValue.getConstant('Cancel'), cssClass: 'e-flat' }
                }];
            this.passwordTextBox.value = '';
            this.confirmPasswordTextBox.value = '';
            this.viewer.dialog.show();
        };
        this.hideDialog = () => {
            this.passwordTextBox.value = '';
            this.confirmPasswordTextBox.value = '';
            this.viewer.dialog.hide();
        };
        /**
         * @private
         */
        this.okButtonClick = () => {
            if (this.passwordTextBox.value !== this.confirmPasswordTextBox.value) {
                /* tslint:disable */
                DialogUtility.alert("The password don't match");
                /* tslint:enable */
            }
            else {
                this.password = this.passwordTextBox.value;
                this.viewer.owner.editor.addProtection(this.password);
            }
        };
        this.viewer = viewer;
        this.owner = owner;
    }
    /**
     * @private
     */
    initDialog(localValue, isRtl) {
        let id = this.viewer.owner.containerId + '_enforce_protection';
        this.target = createElement('div', { id: id, className: 'e-de-enforce' });
        let container = createElement('div');
        // tslint:disable-next-line:max-line-length
        let newPassWord = createElement('div', { className: 'e-de-enforce-dlg-title', innerHTML: localValue.getConstant('Enter new password') });
        // tslint:disable-next-line:max-line-length
        this.passwordTextBox = createElement('input', { attrs: { type: 'password', autofocus: 'true' }, id: this.viewer.owner.containerId + '_display_text', className: 'e-input e-de-enforce-dlg-input' });
        // this.passwordTextBox.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        container.appendChild(newPassWord);
        container.appendChild(this.passwordTextBox);
        // tslint:disable-next-line:max-line-length
        let confirmPassword = createElement('div', { className: 'e-de-enforce-dlg-title', innerHTML: localValue.getConstant('Reenter new password to confirm') });
        // tslint:disable-next-line:max-line-length
        this.confirmPasswordTextBox = createElement('input', { attrs: { type: 'password' }, id: this.viewer.owner.containerId + '_url_text', className: 'e-input e-de-enforce-dlg-input' });
        container.appendChild(confirmPassword);
        container.appendChild(this.confirmPasswordTextBox);
        this.target.appendChild(container);
    }
}
/**
 * @private
 */
class UnProtectDocumentDialog {
    constructor(viewer, owner) {
        /**
         * @private
         */
        this.show = () => {
            this.localObj = new L10n('documenteditor', this.viewer.owner.defaultLocale);
            this.localObj.setLocale(this.viewer.owner.locale);
            if (!this.target) {
                this.initDialog(this.localObj, this.viewer.owner.enableRtl);
            }
            this.viewer.dialog.header = 'Unprotect Document';
            this.viewer.dialog.height = 'auto';
            this.viewer.dialog.width = 'auto';
            this.viewer.dialog.content = this.target;
            this.viewer.dialog.buttons = [{
                    click: this.okButtonClick,
                    buttonModel: { content: this.localObj.getConstant('Ok'), cssClass: 'e-flat', isPrimary: true }
                },
                {
                    click: this.hideDialog,
                    buttonModel: { content: this.localObj.getConstant('Cancel'), cssClass: 'e-flat' }
                }];
            this.viewer.dialog.dataBind();
            this.passwordTextBox.value = '';
            this.viewer.dialog.show();
        };
        /**
         * @private
         */
        /* tslint:disable:no-any */
        this.okButtonClick = () => {
            let password = this.passwordTextBox.value;
            if (password === '') {
                return;
            }
            this.viewer.owner.editor.stopProtection(password);
        };
        /**
         * @private
         */
        this.hideDialog = () => {
            this.passwordTextBox.value = '';
            this.viewer.dialog.hide();
        };
        this.viewer = viewer;
        this.owner = owner;
    }
    /**
     * @private
     */
    initDialog(localValue, isRtl) {
        let id = this.viewer.owner.containerId + '_enforce_protection';
        this.target = createElement('div', { id: id, className: 'e-de-enforce' });
        let container = createElement('div');
        let newPassWord = createElement('div', {
            className: 'e-de-unprotect-dlg-title',
            innerHTML: localValue.getConstant('Password')
        });
        this.passwordTextBox = createElement('input', {
            attrs: { type: 'password' },
            id: this.viewer.owner.containerId + '_display_text', className: 'e-input e-de-enforce-dlg-input'
        });
        // this.passwordTextBox.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        container.appendChild(newPassWord);
        container.appendChild(this.passwordTextBox);
        this.target.appendChild(container);
    }
}

/**
 * @private
 */
class RestrictEditing {
    constructor(viewer) {
        this.addRemove = true;
        this.protectionType = 'NoProtection';
        this.restrictFormatting = false;
        this.isShowRestrictPane = false;
        this.usersCollection = ['Everyone'];
        this.closePane = () => {
            this.restrictPane.style.display = 'none';
            this.viewer.updateViewerSize();
        };
        /* tslint:disable:no-any */
        this.enableFormatting = (args) => {
            this.restrictFormatting = !args.checked;
        };
        this.readOnlyChanges = (args) => {
            if (args.checked) {
                this.protectionType = 'ReadOnly';
            }
            else {
                this.protectionType = 'NoProtection';
                this.addedUser.uncheckAllItems();
                this.viewer.owner.editor.removeAllEditRestrictions();
            }
        };
        this.selectHandler = (args) => {
            if (args.isChecked) {
                this.viewer.owner.editor.insertEditRangeElement(args.text);
                args.event.target.classList.add('e-check');
            }
            else {
                this.viewer.owner.editor.removeUserRestrictions(args.text);
            }
        };
        this.highlightClicked = (args) => {
            this.viewer.selection.isHighlightEditRegion = args.checked;
        };
        /* tslint:enable:no-any */
        this.protectDocument = () => {
            this.enforceProtectionDialog.show();
        };
        this.navigateNextRegion = () => {
            this.viewer.selection.navigateToNextEditingRegion();
        };
        this.showAllRegion = () => {
            this.viewer.selection.showAllEditingRegion();
        };
        this.viewer = viewer;
        this.addUserDialog = new AddUserDialog(viewer, this);
        this.enforceProtectionDialog = new EnforceProtectionDialog(viewer, this);
        this.unProtectDialog = new UnProtectDocumentDialog(viewer, this);
        this.base64 = new Base64();
    }
    showHideRestrictPane(isShow) {
        if (isShow) {
            this.localObj = new L10n('documenteditor', this.viewer.owner.defaultLocale);
            this.localObj.setLocale(this.viewer.owner.locale);
            if (!this.restrictPane) {
                this.initPane(this.localObj, true);
            }
            this.restrictPane.style.display = 'block';
            this.isShowRestrictPane = true;
            this.viewer.selection.isHighlightEditRegion = true;
            this.wireEvents();
            this.viewer.updateViewerSize();
            this.loadPaneValue();
        }
        else {
            this.closePane();
            this.viewer.updateFocus();
        }
    }
    initPane(localValue, initial) {
        this.restrictPane = createElement('div', { className: 'e-de-restrict-pane', styles: 'display:none' });
        let headerWholeDiv = createElement('div', { className: 'e-de-rp-whole-header' });
        let headerDiv1 = createElement('div', {
            styles: 'width:75%',
            innerHTML: localValue.getConstant('Restrict Editing'), className: 'e-de-rp-header'
        });
        this.closeButton = createElement('button', {
            className: 'e-de-rp-close-icon e-btn e-flat e-icon-btn', id: 'close',
            attrs: { type: 'button' }
        });
        headerWholeDiv.appendChild(this.closeButton);
        headerWholeDiv.appendChild(headerDiv1);
        let closeSpan = createElement('span', { className: 'e-de-op-close-icon e-btn-icon e-icons' });
        this.closeButton.appendChild(closeSpan);
        this.restrictPane.appendChild(headerWholeDiv);
        this.initRestrictEditingPane(localValue);
        this.viewer.optionsPaneContainer.setAttribute('style', 'display:inline-flex;');
        this.viewer.optionsPaneContainer.insertBefore(this.restrictPane, this.viewer.viewerContainer);
    }
    // tslint:disable:max-func-body-length
    initRestrictEditingPane(localObj) {
        this.restrictPaneWholeDiv = createElement('div');
        let formatWholeDiv = createElement('div', { className: 'e-de-rp-sub-div' });
        let formatDiv = createElement('div', {
            innerHTML: localObj.getConstant('Formatting restrictions'),
            className: 'e-de-rp-format'
        });
        formatWholeDiv.appendChild(formatDiv);
        let allowFormatting = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_allowFormat',
        });
        formatWholeDiv.appendChild(allowFormatting);
        this.allowFormat = this.createCheckBox(localObj.getConstant('Allow formatting'), allowFormatting);
        this.restrictPaneWholeDiv.appendChild(formatWholeDiv);
        // Editing restrictions
        let editRestrictWholeDiv = createElement('div', { className: 'e-de-rp-sub-div' });
        let editRestrict = createElement('div', {
            innerHTML: localObj.getConstant('Editing restrictions'),
            className: 'e-de-rp-format'
        });
        editRestrictWholeDiv.appendChild(editRestrict);
        let readOnly = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_readOnly'
        });
        editRestrictWholeDiv.appendChild(readOnly);
        this.readonly = this.createCheckBox('Read only', readOnly);
        // let allowPrint: HTMLInputElement = createElement('input', {
        //     attrs: { type: 'checkbox' },
        //     id: this.viewer.owner.containerId + '_allowPrint'
        // }) as HTMLInputElement;
        // editRestrictWholeDiv.appendChild(allowPrint);
        // this.allowPrint = this.createCheckBox('Allow Printing', allowPrint);
        // let allowCopy: HTMLInputElement = createElement('input', {
        //     attrs: { type: 'checkbox' },
        //     id: this.viewer.owner.containerId + '_allowCopy'
        // }) as HTMLInputElement;
        // editRestrictWholeDiv.appendChild(allowCopy);
        // this.allowCopy = this.createCheckBox('Allow Copy', allowCopy);
        this.restrictPaneWholeDiv.appendChild(editRestrictWholeDiv);
        // User Permissions
        let userWholeDiv = createElement('div', { className: 'e-de-rp-sub-div' });
        let userDiv = createElement('div', {
            innerHTML: localObj.getConstant('Exceptions (optional)'),
            className: 'e-de-rp-format'
        });
        userWholeDiv.appendChild(userDiv);
        let subContentDiv = createElement('div', {
            innerHTML: localObj.getConstant('Select parts of the document and choose users who are allowed to freely edit them.'),
            styles: 'margin-bottom:8px;'
        });
        userWholeDiv.appendChild(subContentDiv);
        let emptyuserDiv = createElement('div', { className: 'e-de-rp-user' });
        userWholeDiv.appendChild(emptyuserDiv);
        this.addedUser = new ListView({
            cssClass: 'e-de-user-listView',
            dataSource: [{ text: 'Everyone' }],
            showCheckBox: true,
            select: this.selectHandler
        });
        this.addedUser.appendTo(emptyuserDiv);
        this.addUser = createElement('button', {
            id: this.viewer.owner.containerId + '_addUser',
            className: 'e-btn e-primary e-flat',
            innerHTML: localObj.getConstant('More users')
        });
        userWholeDiv.appendChild(this.addUser);
        this.restrictPaneWholeDiv.appendChild(userWholeDiv);
        let lastDiv = createElement('div', { className: 'e-de-rp-enforce' });
        this.restrictPaneWholeDiv.appendChild(lastDiv);
        this.enforceProtection = createElement('button', {
            id: this.viewer.owner.containerId + '_addUser',
            innerHTML: localObj.getConstant('Yes, Start Enforcing Protection'),
            className: 'e-btn e-de-rp-btn-enforce'
        });
        lastDiv.appendChild(this.enforceProtection);
        this.restrictPane.appendChild(this.restrictPaneWholeDiv);
        this.stopProtectionDiv = createElement('div', { styles: 'display:none' });
        // tslint:disable-next-line:max-line-length
        let headerDiv = createElement('div', { innerHTML: localObj.getConstant('Your permissions'), className: 'e-de-rp-stop-div1' });
        this.stopProtectionDiv.appendChild(headerDiv);
        // tslint:disable-next-line:max-line-length
        let content = localObj.getConstant('This document is protected from unintentional editing.You may edit in this region.');
        let contentDiv1 = createElement('div', { innerHTML: content, className: 'e-de-rp-stop-div2' });
        this.stopProtectionDiv.appendChild(contentDiv1);
        // tslint:disable-next-line:max-line-length
        let contentDiv2 = createElement('div', { innerHTML: localObj.getConstant('You may format text only with certain styles.'), className: 'e-de-rp-stop-div3' });
        this.stopProtectionDiv.appendChild(contentDiv2);
        this.stopReadOnlyOptions = createElement('div');
        this.stopProtectionDiv.appendChild(this.stopReadOnlyOptions);
        let navigateNext = createElement('div', { className: 'e-de-rp-enforce-nav' });
        // tslint:disable-next-line:max-line-length
        let navigateNextButton = createElement('button', { innerHTML: localObj.getConstant('Find Next Region I Can Edit'), className: 'e-btn e-de-rp-nav-btn' });
        navigateNext.appendChild(navigateNextButton);
        navigateNextButton.addEventListener('click', this.navigateNextRegion);
        this.stopReadOnlyOptions.appendChild(navigateNext);
        let showAllRegion = createElement('div', { className: 'e-de-rp-enforce-nav' });
        // tslint:disable-next-line:max-line-length
        let showAllRegionButton = createElement('button', { innerHTML: localObj.getConstant('Show All Regions I Can Edit'), className: 'e-btn e-de-rp-nav-btn' });
        showAllRegion.appendChild(showAllRegionButton);
        showAllRegionButton.addEventListener('click', this.showAllRegion);
        this.stopReadOnlyOptions.appendChild(showAllRegion);
        let highlightRegion = createElement('div', { className: 'e-de-rp-enforce-nav e-de-rp-nav-lbl' });
        // tslint:disable-next-line:max-line-length
        let highlightRegionInput = createElement('input', { attrs: { type: 'checkbox' }, className: 'e-btn e-de-rp-nav-btn' });
        highlightRegion.appendChild(highlightRegionInput);
        this.stopReadOnlyOptions.appendChild(highlightRegion);
        this.highlightCheckBox = new CheckBox({ label: localObj.getConstant('Highlight the regions I can edit') }, highlightRegionInput);
        let lastButtonDiv = createElement('div', { className: 'e-de-rp-enforce' });
        this.stopProtection = createElement('button', {
            innerHTML: localObj.getConstant('Stop Protection'),
            className: 'e-btn e-de-rp-btn-stop-enforce'
        });
        lastButtonDiv.appendChild(this.stopProtection);
        this.stopProtectionDiv.appendChild(lastButtonDiv);
        this.restrictPane.appendChild(this.stopProtectionDiv);
    }
    showStopProtectionPane(show) {
        if (show) {
            this.stopProtectionDiv.style.display = 'block';
            this.restrictPaneWholeDiv.style.display = 'none';
        }
        else {
            this.stopProtectionDiv.style.display = 'none';
            this.restrictPaneWholeDiv.style.display = 'block';
        }
        if (this.viewer.protectionType === 'ReadOnly') {
            this.stopReadOnlyOptions.style.display = 'block';
        }
        else {
            this.stopReadOnlyOptions.style.display = 'none';
        }
    }
    wireEvents() {
        this.addUser.addEventListener('click', this.addUserDialog.show);
        this.enforceProtection.addEventListener('click', this.protectDocument);
        this.stopProtection.addEventListener('click', this.unProtectDialog.show);
        this.closeButton.addEventListener('click', this.closePane);
        this.allowFormat.addEventListener('change', this.enableFormatting);
        this.readonly.addEventListener('change', this.readOnlyChanges);
        this.highlightCheckBox.addEventListener('change', this.highlightClicked);
    }
    createCheckBox(label, element) {
        let checkBox = new CheckBox({ label: label });
        checkBox.appendTo(element);
        return checkBox;
    }
    loadPaneValue() {
        this.protectionType = this.viewer.protectionType;
        this.allowFormat.checked = !this.viewer.restrictFormatting;
        this.readonly.checked = this.viewer.protectionType === 'ReadOnly';
        this.highlightCheckBox.checked = true;
        this.addedUser.enablePersistence = true;
        this.addedUser.dataSource = this.viewer.userCollection;
        this.addedUser.refresh();
        this.showStopProtectionPane(this.viewer.isDocumentProtected);
    }
    addUserCollection() {
        if (this.viewer.selection && this.viewer.selection.editRangeCollection.length > 0) {
            for (let i = 0; i < this.viewer.selection.editRangeCollection.length; i++) {
                let editStart = this.viewer.selection.editRangeCollection[i];
                if (editStart.user !== '' && this.usersCollection.indexOf(editStart.user) === -1) {
                    this.usersCollection.push(editStart.user);
                }
                if (editStart.group !== '' && this.usersCollection.indexOf(editStart.group) === -1) {
                    this.usersCollection.push(editStart.group);
                }
            }
        }
        this.addedUser.dataSource = this.usersCollection;
        this.addedUser.refresh();
    }
    updateUserInformation() {
        this.addedUser.uncheckAllItems();
        if (this.viewer.selection.checkSelectionIsAtEditRegion) {
            let editRange = this.viewer.selection.getEditRangeStartElement();
            if (editRange) {
                let index = this.addedUser.dataSource.indexOf(editRange.user);
                if (index > -1) {
                    let listElement = this.addedUser.element.querySelectorAll('li')[index];
                    listElement.querySelector('.e-icons').classList.add('e-check');
                }
                index = this.addedUser.dataSource.indexOf(editRange.group);
                if (index > -1) {
                    let listElement = this.addedUser.element.querySelectorAll('li')[index];
                    listElement.querySelector('.e-icons').classList.add('e-check');
                }
            }
        }
    }
}

/**
 * @private
 */
class LayoutViewer {
    //#endregion
    constructor(owner) {
        /**
         * @private
         */
        this.textWrap = true;
        /**
         * @private
         */
        this.currentPage = undefined;
        this.selectionStartPageIn = undefined;
        this.selectionEndPageIn = undefined;
        /**
         * @private
         */
        this.fieldStacks = [];
        /**
         * @private
         */
        this.splittedCellWidgets = [];
        /**
         * @private
         */
        this.tableLefts = [];
        this.tapCount = 0;
        this.timer = -1;
        this.isTimerStarted = false;
        /**
         * @private
         */
        this.isFirstLineFitInShiftWidgets = false;
        /**
         * @private
         */
        this.preZoomFactor = 0;
        /**
         * @private
         */
        this.preDifference = -1;
        /**
         * @private
         */
        this.fieldEndParagraph = undefined;
        /**
         * @private
         */
        this.fieldToLayout = undefined;
        /**
         * @private
         */
        this.backgroundColor = '#FFFFFF';
        /**
         * @private
         */
        this.containerTop = 0;
        /**
         * @private
         */
        this.containerLeft = 0;
        // Event 
        /**
         * @private
         */
        this.isMouseDown = false;
        this.isMouseEntered = false;
        // tslint:disable-next-line
        this.scrollMoveTimer = 0;
        /**
         * @private
         */
        this.isSelectionChangedOnMouseMoved = false;
        /**
         * @private
         */
        this.isControlPressed = false;
        /**
         * @private
         */
        this.isTouchInput = false;
        /**
         * @private
         */
        this.useTouchSelectionMark = false;
        /**
         * @private
         */
        this.touchDownOnSelectionMark = 0;
        /**
         * @private
         */
        this.isComposingIME = false;
        /**
         * @private
         */
        this.lastComposedText = '';
        /**
         * @private
         */
        this.isCompositionStart = false;
        /**
         * @private
         */
        this.isCompositionUpdated = false;
        /**
         * @private
         */
        this.isCompositionCanceled = false;
        /**
         * @private
         */
        this.isCompositionEnd = false;
        /**
         * @private
         */
        this.prefix = '';
        /**
         * @private
         */
        this.suffix = '';
        /**
         * @private
         */
        this.fields = [];
        /**
         * @private
         */
        this.heightInfoCollection = {};
        /**
         * @private
         */
        this.defaultTabWidth = 36;
        /**
         * @private
         */
        this.lists = [];
        /**
         * @private
         */
        this.comments = [];
        /**
         * @private
         */
        this.commentUserOptionId = 1;
        /**
         * @private
         */
        this.abstractLists = [];
        /**
         * @private
         */
        this.styles = new WStyles();
        /**
         * @private
         */
        this.preDefinedStyles = undefined;
        /**
         * @private
         */
        this.isRowOrCellResizing = false;
        this.isMouseDownInFooterRegion = false;
        this.pageFitTypeIn = 'None';
        /**
         * @private
         */
        this.fieldCollection = [];
        /**
         * @private
         */
        this.isPageField = false;
        /**
         * @private
         */
        this.mouseDownOffset = new Point(0, 0);
        this.zoomFactorInternal = 1;
        /**
         * If movecaretposition is 1, Home key is pressed
         * If moveCaretPosition is 2, End key is pressed
         * @private
         */
        this.moveCaretPosition = 0;
        /**
         * @private
         */
        this.isTextInput = false;
        /**
         * @private
         */
        this.isScrollHandler = false;
        /**
         * @private
         */
        this.triggerElementsOnLoading = false;
        /**
         * @private
         */
        this.triggerSpellCheck = false;
        //Document Protection Properties Starts
        /**
         * preserve the format
         * @private
         */
        this.restrictFormatting = false;
        /**
         * preserve the document protection type either readonly or no protection
         * @private
         */
        this.protectionType = 'NoProtection';
        /**
         * Preserve the password protection is enforced or not
         * @private
         */
        this.isDocumentProtected = false;
        /**
         * preserve the hash value of password
         * @private
         */
        this.hashValue = '';
        /**
         * @private
         */
        this.saltValue = '';
        /**
         * @private
         */
        this.userCollection = [];
        /**
         * @private
         */
        this.cachedPages = [];
        /**
         * @private
         */
        this.skipScrollToPosition = false;
        this.onIframeLoad = () => {
            if (!isNullOrUndefined(this.iframe) && this.iframe.contentDocument.body.children.length === 0) {
                this.initIframeContent();
                this.wireInputEvents();
            }
        };
        /**
         * @private
         */
        this.onTextInput = (event) => {
            if (!this.isComposingIME) {
                event.preventDefault();
                let text = event.data;
                this.owner.editor.handleTextInput(text);
            }
        };
        //#region Composition Event
        /**
         * Fires when composition starts.
         * @private
         */
        this.compositionStart = (event) => {
            if (!Browser.isDevice && !this.owner.isReadOnlyMode) {
                this.isComposingIME = true;
                this.positionEditableTarget();
                if (this.owner.editorHistory) {
                    this.owner.editor.initComplexHistory('IMEInput');
                }
            }
            this.isCompositionStart = true;
        };
        /**
         * Fires on every input during composition.
         * @private
         */
        this.compositionUpdated = (event) => {
            if (this.isComposingIME && !this.owner.isReadOnlyMode) {
                /* tslint:disable:align */
                setTimeout(() => {
                    this.owner.editor.insertIMEText(this.getEditableDivTextContent(), true);
                }, 0);
            }
            this.isCompositionUpdated = true;
        };
        /**
         * Fires when user selects a character/word and finalizes the input.
         * @private
         */
        this.compositionEnd = (event) => {
            if (this.isComposingIME && !this.owner.isReadOnlyMode) {
                let text = this.getEditableDivTextContent();
                if (text !== '') {
                    this.owner.editor.insertIMEText(text, false);
                }
                this.isComposingIME = false;
                this.lastComposedText = '';
                // tslint:disable-next-line:max-line-length
                this.iframe.setAttribute('style', 'pointer-events:none;position:absolute;left:' + this.containerLeft + 'px;top:' + this.containerTop + 'px;outline:none;background-color:transparent;width:0px;height:0px;overflow:hidden');
                this.editableDiv.innerHTML = '';
                if (this.owner.editorHistory) {
                    this.owner.editorHistory.updateComplexHistory();
                    if (text === '') {
                        // tslint:disable-next-line:max-line-length
                        //When the composition in live. The Undo operation will terminate the composition and empty text will be return from text box.
                        //At that time the the history should be updated. Undo the operation and clear the redo stack. This undo operation will not be saved for redo operation.
                        this.owner.editorHistory.undo();
                        this.owner.editorHistory.redoStack.pop();
                    }
                }
            }
            event.preventDefault();
            this.isCompositionUpdated = false;
            this.isCompositionEnd = true;
        };
        // tslint:disable:no-any 
        this.onImageResizer = (args) => {
            if (!isNullOrUndefined(this.owner.imageResizerModule) && this.owner.imageResizerModule.isImageResizerVisible
                && this.owner.imageResizerModule.isImageResizing) {
                if (args instanceof MouseEvent) {
                    this.onMouseUpInternal(args);
                }
                else if (args instanceof TouchEvent) {
                    this.onTouchUpInternal(args);
                }
            }
        };
        // tslint:enable:no-any 
        this.onKeyPressInternal = (event) => {
            let key = event.which || event.keyCode;
            this.triggerElementsOnLoading = false;
            let ctrl = (event.ctrlKey || event.metaKey) ? true : ((key === 17) ? true : false); // ctrl detection
            if (ctrl && event.key === 'v' || ctrl && event.key === 'a') {
                return;
            }
            if (!this.owner.isReadOnlyMode) {
                let key = event.keyCode || event.charCode;
                let char = '';
                if (key) {
                    char = String.fromCharCode(key);
                }
                else if (event.key) {
                    char = event.key;
                }
                // tslint:disable-next-line:max-line-length
                if (char !== ' ' && char !== '\r' && char !== '\b' && char !== '\u001B' && !this.owner.isReadOnlyMode && event.ctrlKey === false) {
                    this.owner.editorModule.handleTextInput(char);
                }
                else if (char === ' ') {
                    this.triggerSpellCheck = true;
                    this.owner.editorModule.handleTextInput(' ');
                    this.triggerSpellCheck = false;
                }
                event.preventDefault();
            }
        };
        this.onTextInputInternal = (event) => {
            if (!this.owner.isReadOnlyMode) {
                this.owner.editorModule.onTextInputInternal(event);
            }
            else {
                this.editableDiv.innerText = '';
            }
        };
        /**
         * Fired on paste.
         * @param {ClipboardEvent} event
         * @private
         */
        this.onPaste = (event) => {
            if (!this.owner.isReadOnlyMode) {
                this.owner.editorModule.pasteInternal(event);
            }
            this.editableDiv.innerText = '';
            event.preventDefault();
        };
        /**
         * Fires when editable div loses focus.
         * @private
         */
        this.onFocusOut = () => {
            if (!isNullOrUndefined(this.selection)) {
                if (this.owner.contextMenuModule && this.owner.contextMenuModule.contextMenuInstance &&
                    this.owner.contextMenuModule.contextMenuInstance.element.style.display === 'block') {
                    return;
                }
                this.selection.hideCaret();
            }
        };
        /**
         * Updates focus to editor area.
         * @private
         */
        this.updateFocus = () => {
            if (this.selection) {
                this.editableDiv.focus();
                this.selection.showCaret();
            }
        };
        /**
         * Fires on scrolling.
         */
        this.scrollHandler = () => {
            if (this.scrollTimer) {
                clearTimeout(this.scrollTimer);
            }
            this.clearContent();
            this.isScrollHandler = true;
            if (!Browser.isDevice && !this.isComposingIME) {
                this.iframe.style.top = this.containerTop + 'px';
                this.iframe.style.left = this.containerLeft + 'px';
            }
            this.updateScrollBars();
            let vtHeight = this.containerTop + this.visibleBounds.height;
            if (vtHeight > this.pageContainer.offsetHeight) {
                this.viewerContainer.scrollTop = this.containerTop - (vtHeight - this.pageContainer.offsetHeight);
            }
            let viewer = this;
            if (viewer instanceof PageLayoutViewer && !isNullOrUndefined(this.owner)) {
                this.owner.fireViewChange();
            }
            this.isScrollHandler = false;
            this.scrollTimer = setTimeout(() => {
                if (!this.isScrollHandler && !isNullOrUndefined(this.owner) && this.owner.enableSpellCheck) {
                    this.isScrollToSpellCheck = true;
                    this.updateScrollBars();
                }
            }, 200);
        };
        /**
         * Fires when the window gets resized.
         * @private
         */
        this.onWindowResize = () => {
            let viewer = this;
            let resizeTimer;
            /* tslint:disable:align */
            resizeTimer = setTimeout(() => {
                if (!isNullOrUndefined(viewer.owner) && !isNullOrUndefined(viewer.owner.element)) {
                    viewer.updateViewerSizeInternal(viewer.owner.element);
                    viewer.updateScrollBars();
                    if (!isNullOrUndefined(this.selection)) {
                        this.selection.updateCaretPosition();
                    }
                    viewer.updateTouchMarkPosition();
                    if (viewer.owner.contextMenuModule && viewer.owner.contextMenuModule.contextMenuInstance) {
                        viewer.owner.contextMenuModule.contextMenuInstance.close();
                    }
                    if (resizeTimer) {
                        clearTimeout(resizeTimer);
                    }
                }
            }, 200);
        };
        /**
         * @private
         */
        this.onContextMenu = (event) => {
            if (this.owner.contextMenuModule) {
                this.owner.contextMenuModule.onContextMenuInternal(event);
            }
        };
        /**
         * Called on mouse down.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseDownInternal = (event) => {
            if ((event.target && event.target.classList.contains('e-de-cmt-mark-icon')) || this.isTouchInput ||
                event.offsetX > (this.visibleBounds.width - (this.visibleBounds.width - this.viewerContainer.clientWidth))
                || event.offsetY > (this.visibleBounds.height - (this.visibleBounds.height - this.viewerContainer.clientHeight))) {
                return;
            }
            if (!isNullOrUndefined(this.selection)) {
                this.updateCursor(event);
                // tslint:disable-next-line:max-line-length
                if (this.isLeftButtonPressed(event) && !this.owner.isReadOnlyMode && this.owner.enableImageResizerMode && !isNullOrUndefined(this.owner.imageResizerModule.selectedResizeElement)) {
                    this.owner.imageResizerModule.isImageResizing = true;
                }
                event.preventDefault();
                if (!this.isTouchInput) {
                    this.selection.hideCaret();
                }
                let cursorPoint = new Point(event.offsetX, event.offsetY);
                let touchPoint = this.findFocusedPage(cursorPoint, true);
                this.mouseDownOffset.x = touchPoint.x;
                this.mouseDownOffset.y = touchPoint.y;
                // tslint:disable-next-line:max-line-length
                this.isMouseDownInFooterRegion = this.selection.isCursorInsidePageRect(cursorPoint, this.currentPage) && this.selection.isCursorInFooterRegion(cursorPoint, this.currentPage);
                this.isSelectionChangedOnMouseMoved = false;
                if (!this.owner.isReadOnlyMode && (this.owner.editorModule.tableResize.isInCellResizerArea(touchPoint) ||
                    this.owner.editorModule.tableResize.isInRowResizerArea(touchPoint))) {
                    this.selection.hideCaret();
                    this.isMouseDown = true;
                    this.isSelectionChangedOnMouseMoved = false;
                    if (this.isLeftButtonPressed(event)) {
                        this.owner.editorModule.tableResize.startingPoint.x = touchPoint.x;
                        this.owner.editorModule.tableResize.startingPoint.y = touchPoint.y;
                        this.owner.editorModule.tableResize.handleResize(touchPoint);
                    }
                    return;
                }
                if (event.ctrlKey) {
                    this.isControlPressed = true;
                }
                if (this.owner.selection.isEmpty) {
                    this.useTouchSelectionMark = false;
                }
                if (event.which === 3 && !this.owner.selection.isEmpty
                    && this.selection.checkCursorIsInSelection(this.getLineWidget(touchPoint), touchPoint)) {
                    event.preventDefault();
                    return;
                }
                this.isTouchInput = false;
                this.isMouseDown = true;
                this.updateFocus();
                /* tslint:disable:align */
                this.timer = setTimeout(() => {
                    this.tapCount++;
                    if (this.tapCount === 4) {
                        this.tapCount = 1;
                    }
                }, 200);
            }
        };
        /**
         * Called on mouse move.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseMoveInternal = (event) => {
            event.preventDefault();
            if (!isNullOrUndefined(this.selection)) {
                //For image Resizing
                if (!this.owner.isReadOnlyMode && this.owner.enableImageResizerMode
                    && this.owner.imageResizerModule.isImageResizing) {
                    if (!this.owner.imageResizerModule.isImageMoveToNextPage) {
                        this.owner.imageResizerModule.handleImageResizingOnMouse(event);
                    }
                    return;
                }
                let cursorPoint = new Point(event.offsetX, event.offsetY);
                let touchPoint = this.findFocusedPage(cursorPoint, !this.owner.enableHeaderAndFooter);
                if (this.isMouseDown) {
                    if (!isNullOrUndefined(this.currentPage)) {
                        let xPosition = touchPoint.x;
                        let yPosition = touchPoint.y;
                        if (!this.owner.isReadOnlyMode && this.isRowOrCellResizing) {
                            this.owner.editorModule.tableResize.handleResizing(touchPoint);
                        }
                        else {
                            if (!(this.isTouchInput || this.isSelectionChangedOnMouseMoved || this.touchDownOnSelectionMark > 0)) {
                                this.updateTextPositionForSelection(touchPoint, 1);
                            }
                            if (this.isLeftButtonPressed(event)) {
                                event.preventDefault();
                                let touchY = yPosition;
                                let textPosition = this.owner.selection.end;
                                let touchPoint = new Point(xPosition, touchY);
                                if (!this.owner.enableImageResizerMode || !this.owner.imageResizerModule.isImageResizerVisible) {
                                    this.owner.selection.moveTextPosition(touchPoint, textPosition);
                                }
                                this.isSelectionChangedOnMouseMoved = true;
                            }
                        }
                    }
                    this.selection.checkForCursorVisibility();
                }
                if (!this.isRowOrCellResizing && !this.isSelectionChangedOnMouseMoved) {
                    this.updateCursor(event);
                }
                if (this.isRowOrCellResizing) {
                    this.selection.hideCaret();
                }
            }
        };
        /**
         * @private
         */
        this.onMouseLeaveInternal = (event) => {
            event.preventDefault();
            if (this.isMouseDown) {
                let viewerTop = this.viewerContainer.scrollTop;
                if (event.offsetY + viewerTop > viewerTop) {
                    this.scrollMoveTimer = setInterval(() => { this.scrollForwardOnSelection(); }, 500);
                }
                else {
                    this.scrollMoveTimer = setInterval(() => { this.scrollBackwardOnSelection(); }, 500);
                }
                if (this.isMouseEntered) {
                    this.isMouseEntered = false;
                }
            }
        };
        /**
         * @private
         */
        this.onMouseEnterInternal = () => {
            if (!this.isMouseEntered) {
                this.updateScrollBars();
            }
            this.isMouseEntered = true;
            if (this.scrollMoveTimer) {
                clearInterval(this.scrollMoveTimer);
            }
        };
        /**
         * Fired on double tap.
         * @param {MouseEvent} event
         * @private
         */
        this.onDoubleTap = (event) => {
            if (!isNullOrUndefined(this.selection)) {
                this.isTouchInput = false;
                let cursorPoint = new Point(event.offsetX, event.offsetY);
                if (this.selection.checkAndEnableHeaderFooter(cursorPoint, this.findFocusedPage(cursorPoint, true))) {
                    return;
                }
                // tslint:disable-next-line:max-line-length
                if (this.selection.isEmpty && !isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
                    this.owner.selection.selectCurrentWord();
                    this.selection.checkForCursorVisibility();
                    this.tapCount = 2;
                }
            }
        };
        /**
         * Called on mouse up.
         * @param {MouseEvent} event
         * @private
         */
        this.onMouseUpInternal = (event) => {
            event.preventDefault();
            this.isListTextSelected = false;
            let cursorPoint = new Point(event.offsetX, event.offsetY);
            let touchPoint = this.findFocusedPage(cursorPoint, true);
            if (!isNullOrUndefined(this.selection)) {
                let tapCount = 1;
                if (!Browser.isIE) {
                    if (event.detail > 2) {
                        tapCount = event.detail;
                    }
                }
                else {
                    tapCount = this.tapCount;
                }
                if (this.isRowOrCellResizing) {
                    this.owner.editorModule.tableResize.updateResizingHistory(touchPoint);
                }
                if (this.isMouseDown && !this.isSelectionChangedOnMouseMoved
                    && !isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)
                    && (!this.owner.enableImageResizerMode || !this.owner.imageResizerModule.isImageResizing)) {
                    if (this.touchDownOnSelectionMark === 0 && !this.isRowOrCellResizing) {
                        this.updateTextPositionForSelection(touchPoint, tapCount);
                        if (Browser.isIE && tapCount === 2) {
                            this.selection.checkAndEnableHeaderFooter(cursorPoint, touchPoint);
                        }
                    }
                    this.selection.checkForCursorVisibility();
                    if (!isNullOrUndefined(this.currentSelectedComment) && this.owner.commentReviewPane
                        && !this.owner.commentReviewPane.commentPane.isEditMode) {
                        this.currentSelectedComment = undefined;
                    }
                }
                if (!isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)
                    && (this.owner.selection.isEmpty || this.owner.selection.isImageSelected) &&
                    (((event.ctrlKey && this.owner.useCtrlClickToFollowHyperlink ||
                        !this.owner.useCtrlClickToFollowHyperlink) && this.isLeftButtonPressed(event) === true))) {
                    this.selection.navigateHyperLinkOnEvent(touchPoint, false);
                }
                if (!this.owner.isReadOnlyMode && this.isSelectionInListText(touchPoint)) {
                    this.selection.selectListText();
                }
                // tslint:disable-next-line:max-line-length
                if (!this.owner.isReadOnlyMode && this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing) {
                    this.owner.imageResizerModule.mouseUpInternal();
                    this.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
                    this.owner.imageResizerModule.isImageResizing = false;
                    this.owner.imageResizerModule.updateHistoryForImageResizer();
                }
                // tslint:disable-next-line:max-line-length
                if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizerVisible && !isNullOrUndefined(this.selection.caret)) {
                    this.selection.caret.style.display = 'none';
                }
                this.isMouseDown = false;
                this.isSelectionChangedOnMouseMoved = false;
                this.isTouchInput = false;
                this.useTouchSelectionMark = true;
                this.isControlPressed = false;
                this.updateFocus();
                if (this.isListTextSelected) {
                    this.selection.hideCaret();
                }
                if (this.owner.enableImageResizerMode) {
                    let imageResizer = this.owner.imageResizerModule;
                    imageResizer.isImageResizing = false;
                    imageResizer.isImageMoveToNextPage = false;
                    imageResizer.leftValue = undefined;
                    imageResizer.topValue = undefined;
                }
                this.isMouseDownInFooterRegion = false;
            }
        };
        /**
         * Fired on touch start.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchStartInternal = (event) => {
            if (this.selection) {
                this.isCompositionStart = false;
                this.isCompositionEnd = false;
                this.isCompositionUpdated = false;
                this.isCompositionCanceled = true;
                this.isTouchInput = true;
                if (this.isTimerStarted) {
                    if (this.tapCount === 1) {
                        this.tapCount = 2;
                    }
                    else {
                        this.tapCount = 3;
                        this.isTimerStarted = false;
                    }
                }
                else {
                    this.isTimerStarted = true;
                    this.tapCount = 1;
                }
                if (event.touches.length === 1) {
                    this.zoomX = event.touches[0].clientX;
                    this.zoomY = event.touches[0].clientY;
                    if (this.owner.selection.isEmpty) {
                        this.useTouchSelectionMark = false;
                    }
                    this.isMouseDown = true;
                    this.isSelectionChangedOnMouseMoved = false;
                    let point;
                    if (this.isMouseDown) {
                        point = this.getTouchOffsetValue(event);
                    }
                    point = this.findFocusedPage(point, true);
                    if (this.owner.enableImageResizerMode) {
                        let resizeObj = this.owner.imageResizerModule.getImagePointOnTouch(point);
                        this.owner.imageResizerModule.selectedResizeElement = resizeObj.selectedElement;
                    }
                    // tslint:disable-next-line:max-line-length
                    if (this.owner.enableImageResizerMode && !isNullOrUndefined(this.owner.imageResizerModule.selectedResizeElement)) {
                        this.owner.imageResizerModule.isImageResizing = true;
                    }
                    let x = this.owner.selection.end.location.x;
                    let y = this.selection.getCaretBottom(this.owner.selection.end, this.owner.selection.isEmpty) + 9;
                    //TouchDownOnSelectionMark will be 2 when touch end is pressed
                    this.touchDownOnSelectionMark = ((point.y <= y && point.y >= y - 20 || point.y >= y && point.y <= y + 20)
                        && (point.x <= x && point.x >= x - 20 || point.x >= x && point.x <= x + 20)) ? 1 : 0;
                    if (!this.owner.selection.isEmpty && this.touchDownOnSelectionMark === 0) {
                        x = this.owner.selection.start.location.x;
                        y = this.selection.getCaretBottom(this.owner.selection.start, false) + 9;
                        //TouchDownOnSelectionMark will be 1 when touch start is pressed
                        this.touchDownOnSelectionMark = ((point.y <= y && point.y >= y - 20 || point.y >= y && point.y <= y + 20)
                            && (point.x <= x && point.x >= x - 20 || point.x >= x && point.x <= x + 20)) ? 2 : 0;
                    }
                }
                if (!isNullOrUndefined(this.owner.contextMenuModule) && this.owner.contextMenuModule.contextMenuInstance) {
                    this.owner.contextMenuModule.contextMenuInstance.close();
                }
                if (this.touchDownOnSelectionMark || event.touches.length > 1) {
                    event.preventDefault();
                }
                this.longTouchTimer = setTimeout(this.onLongTouch, 500, event);
                this.timer = setTimeout(() => {
                    this.isTimerStarted = false;
                }, 200);
            }
        };
        /**
         * Fired on long touch
         * @param {TouchEvent} event
         * @private
         */
        this.onLongTouch = (event) => {
            if (isNullOrUndefined(this.owner) || isNullOrUndefined(this.viewerContainer)) {
                return;
            }
            let point = this.getTouchOffsetValue(event);
            let pointRelToPage = this.findFocusedPage(point, true);
            let selStart = this.selection.start;
            let selEnd = this.selection.end;
            let updateSel = false;
            if (!this.selection.isForward) {
                selStart = this.selection.end;
                selEnd = this.selection.start;
            }
            let selStartPt = selStart.location;
            let selEndPt = selEnd.location;
            if (selStart.currentWidget !== selEnd.currentWidget) {
                updateSel = !(pointRelToPage.x >= selStartPt.x && pointRelToPage.x <= selEndPt.x)
                    && !(pointRelToPage.y >= selStartPt.y && pointRelToPage.y <= selEndPt.y);
            }
            else {
                updateSel = !(pointRelToPage.x >= selStartPt.x && pointRelToPage.x <= selEndPt.x)
                    || !(pointRelToPage.y >= selStartPt.y && pointRelToPage.y <= selEndPt.y);
            }
            if (event.changedTouches.length === 1 && updateSel) {
                this.updateSelectionOnTouch(point, pointRelToPage);
                this.isMouseDown = false;
                this.touchDownOnSelectionMark = 0;
                this.useTouchSelectionMark = true;
                this.isSelectionChangedOnMouseMoved = false;
            }
            if (this.selection.isEmpty) {
                this.selection.selectCurrentWord();
            }
            if (!isNullOrUndefined(this.owner.contextMenuModule) && this.owner.contextMenuModule.contextMenuInstance) {
                this.owner.contextMenuModule.onContextMenuInternal(event);
            }
        };
        /**
         * Fired on touch move.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchMoveInternal = (event) => {
            let touch = event.touches;
            let cursorPoint;
            if (!isNullOrUndefined(this.selection)) {
                // tslint:disable-next-line:max-line-length
                if (this.owner.editorModule && this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing) {
                    event.preventDefault();
                    if (!this.owner.imageResizerModule.isImageMoveToNextPage) {
                        this.owner.imageResizerModule.handleImageResizingOnTouch(event);
                        this.selection.caret.style.display = 'none';
                    }
                    return;
                }
                if (this.isMouseDown) {
                    cursorPoint = this.getTouchOffsetValue(event);
                    let touchPoint = this.findFocusedPage(cursorPoint, true);
                    if (this.touchDownOnSelectionMark > 0 /*|| !this.useTouchSelectionMark*/) {
                        event.preventDefault();
                        let touchY = touchPoint.y;
                        let textPosition = this.owner.selection.end;
                        if (touchPoint.y <= 26) {
                            touchY -= touchPoint.y < 0 ? 0 : touchPoint.y + 0.5;
                        }
                        else {
                            touchY -= 36.5;
                        }
                        textPosition = this.touchDownOnSelectionMark === 2 ? this.selection.start : this.selection.end;
                        touchPoint = new Point(touchPoint.x, touchY);
                        this.owner.selection.moveTextPosition(touchPoint, textPosition);
                        this.isSelectionChangedOnMouseMoved = true;
                    }
                    this.selection.checkForCursorVisibility();
                }
            }
            if (touch.length > 1) {
                event.preventDefault();
                this.isMouseDown = false;
                this.zoomX = (touch[0].clientX + touch[1].clientX) / 2;
                this.zoomY = (touch[0].clientY + touch[1].clientY) / 2;
                // tslint:disable-next-line:max-line-length
                let currentDiff = Math.sqrt(Math.pow((touch[0].clientX - touch[1].clientX), 2) + Math.pow((touch[0].clientY - touch[1].clientY), 2));
                if (this.preDifference > -1) {
                    if (currentDiff > this.preDifference) {
                        this.onPinchOutInternal(event);
                    }
                    else if (currentDiff < this.preDifference) {
                        this.onPinchInInternal(event);
                    }
                }
                else if (this.zoomFactor < 2) {
                    if (this.preDifference !== -1) {
                        if (currentDiff > this.preDifference) {
                            this.onPinchInInternal(event);
                        }
                    }
                }
                else if (this.preDifference === -1) {
                    if (this.zoomFactor > 2) {
                        if (currentDiff > this.preDifference) {
                            this.onPinchInInternal(event);
                        }
                    }
                }
                this.preDifference = currentDiff;
            }
            if (this.longTouchTimer) {
                clearTimeout(this.longTouchTimer);
                this.longTouchTimer = undefined;
            }
        };
        /**
         * Fired on touch up.
         * @param {TouchEvent} event
         * @private
         */
        this.onTouchUpInternal = (event) => {
            if (!isNullOrUndefined(this.selection)) {
                let point = this.getTouchOffsetValue(event);
                let touchPoint = this.findFocusedPage(point, true);
                if (event.changedTouches.length === 1) {
                    this.updateSelectionOnTouch(point, touchPoint);
                    if (!isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.selection.start)
                        && !this.isSelectionChangedOnMouseMoved && (this.selection.isEmpty ||
                        this.selection.isImageField() && (!this.owner.enableImageResizerMode ||
                            this.owner.enableImageResizerMode && !this.owner.imageResizerModule.isImageResizing))) {
                        this.selection.navigateHyperLinkOnEvent(touchPoint, true);
                    }
                    this.isMouseDown = false;
                    this.touchDownOnSelectionMark = 0;
                    this.useTouchSelectionMark = true;
                    this.isSelectionChangedOnMouseMoved = false;
                }
                if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing) {
                    this.owner.imageResizerModule.mouseUpInternal();
                    this.owner.imageResizerModule.isImageResizing = false;
                    this.owner.imageResizerModule.isImageMoveToNextPage = false;
                    this.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
                    this.owner.imageResizerModule.updateHistoryForImageResizer();
                }
                // tslint:disable-next-line:max-line-length
                if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizerVisible && this.isTouchInput) {
                    this.touchStart.style.display = 'none';
                    this.touchEnd.style.display = 'none';
                }
                // if (!this.owner.isReadOnlyMode && this.isSelectionInListText(touchPoint)) {
                //     this.selection.selectListText();
                // }
                event.preventDefault();
            }
            this.preDifference = -1;
            this.isTouchInput = false;
            if (this.longTouchTimer) {
                clearTimeout(this.longTouchTimer);
                this.longTouchTimer = undefined;
            }
            if (!this.isTimerStarted) {
                this.tapCount = 1;
            }
            if (this.isListTextSelected) {
                this.selection.hideCaret();
            }
        };
        /**
         * Fired on keyup event.
         * @private
         */
        this.onKeyUpInternal = (event) => {
            if (Browser.isDevice && event.target === this.editableDiv) {
                if (window.getSelection().anchorOffset !== this.prefix.length) {
                    this.selection.setEditableDivCaretPosition(this.editableDiv.innerText.length);
                }
            }
            if (event.ctrlKey || (event.keyCode === 17 || event.which === 17)) {
                this.isControlPressed = false;
            }
        };
        /**
         * Fired on keydown.
         * @private
         */
        this.onKeyDownInternal = (event) => {
            let isHandled = false;
            let keyEventArgs = { 'event': event, 'isHandled': false, source: this.owner };
            this.owner.trigger('keyDown', keyEventArgs);
            if (keyEventArgs.isHandled) {
                return;
            }
            let key = event.which || event.keyCode;
            let ctrl = (event.ctrlKey || event.metaKey) ? true : ((key === 17) ? true : false); // ctrl detection       
            let shift = event.shiftKey ? event.shiftKey : ((key === 16) ? true : false); // Shift Key detection        
            let alt = event.altKey ? event.altKey : ((key === 18) ? true : false); // alt key detection
            if (ctrl && !shift && !alt) {
                switch (key) {
                    case 80:
                        event.preventDefault();
                        this.owner.print();
                        isHandled = true;
                        break;
                    case 83:
                        event.preventDefault();
                        this.owner.save(this.owner.documentName === '' ? 'sample' : this.owner.documentName, 'Sfdt');
                        isHandled = true;
                        break;
                }
            }
            if (!isHandled && !isNullOrUndefined(this.selection)) {
                this.selection.onKeyDownInternal(event, ctrl, shift, alt);
            }
            if (isHandled) {
                event.preventDefault();
            }
        };
        this.owner = owner;
        this.pages = [];
        this.render = new Renderer(this);
        this.lists = [];
        this.abstractLists = [];
        this.characterFormat = new WCharacterFormat(this);
        this.paragraphFormat = new WParagraphFormat(this);
        this.renderedLists = new Dictionary();
        this.headersFooters = [];
        this.styles = new WStyles();
        this.preDefinedStyles = new Dictionary();
        this.initalizeStyles();
        this.bookmarks = new Dictionary();
        this.editRanges = new Dictionary();
    }
    //Document Protection Properties Ends
    //#region Properties
    /**
     * Gets container canvas.
     * @private
     */
    get containerCanvas() {
        if (isNullOrUndefined(this.containerCanvasIn)) {
            this.containerCanvasIn = document.createElement('canvas');
            this.containerCanvasIn.getContext('2d').save();
        }
        if (!isNullOrUndefined(this.pageContainer)
            && this.containerCanvasIn.parentElement !== this.pageContainer) {
            this.pageContainer.appendChild(this.containerCanvasIn);
        }
        return this.containerCanvasIn;
    }
    /**
     * Gets selection canvas.
     * @private
     */
    get selectionCanvas() {
        if (isNullOrUndefined(this.selectionCanvasIn)) {
            this.selectionCanvasIn = document.createElement('canvas');
            this.selectionCanvas.getContext('2d').save();
        }
        if (!isNullOrUndefined(this.pageContainer)
            && this.selectionCanvasIn.parentElement !== this.pageContainer) {
            this.pageContainer.appendChild(this.selectionCanvasIn);
        }
        return this.selectionCanvasIn;
    }
    /**
     * Gets container context.
     * @private
     */
    get containerContext() {
        return this.containerCanvas.getContext('2d');
    }
    /**
     * Gets selection context.
     * @private
     */
    get selectionContext() {
        return this.selectionCanvas.getContext('2d');
    }
    /**
     * Gets the current rendering page.
     */
    get currentRenderingPage() {
        if (this.pages.length === 0) {
            return undefined;
        }
        return this.pages[this.pages.length - 1];
    }
    /**
     * Gets visible bounds.
     * @private
     */
    get visibleBounds() {
        return this.visibleBoundsIn;
    }
    /**
     * Gets or sets zoom factor.
     * @private
     */
    get zoomFactor() {
        return this.zoomFactorInternal;
    }
    set zoomFactor(value) {
        if (this.zoomFactorInternal !== value) {
            this.preZoomFactor = this.zoomFactor;
            this.zoomFactorInternal = value;
            this.zoomModule.setZoomFactor(value);
            this.owner.zoomFactor = value;
        }
    }
    /**
     * Gets the selection.
     * @private
     */
    get selection() {
        return this.owner.selection;
    }
    /**
     * Gets or sets selection start page.
     * @private
     */
    get selectionStartPage() {
        return this.selectionStartPageIn;
    }
    set selectionStartPage(value) {
        this.selectionStartPageIn = value;
    }
    /**
     * Gets or sets selection end page.
     * @private
     */
    get selectionEndPage() {
        return this.selectionEndPageIn;
    }
    set selectionEndPage(value) {
        this.selectionEndPageIn = value;
    }
    /**
     * Gets the initialized default dialog.
     * @private
     */
    get dialog() {
        if (!this.dialogInternal) {
            this.initDialog(this.owner.enableRtl);
        }
        return this.dialogInternal;
    }
    /**
     * Gets the initialized default dialog.
     * @private
     */
    get dialog2() {
        if (!this.dialogInternal2) {
            this.initDialog2(this.owner.enableRtl);
        }
        return this.dialogInternal2;
    }
    /**
     * Gets or sets page fit type.
     * @private
     */
    get pageFitType() {
        return this.pageFitTypeIn;
    }
    set pageFitType(value) {
        this.pageFitTypeIn = value;
        this.onPageFitTypeChanged(this.pageFitTypeIn);
    }
    /**
     * @private
     */
    get currentSelectedComment() {
        return this.currentSelectedCommentInternal;
    }
    /**
     * @private
     */
    set currentSelectedComment(value) {
        if (this.owner && this.owner.commentReviewPane) {
            this.owner.commentReviewPane.previousSelectedComment = this.currentSelectedCommentInternal;
        }
        this.currentSelectedCommentInternal = value;
    }
    initalizeStyles() {
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Normal', '{"type":"Paragraph","name":"Normal","next":"Normal"}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 1', '{"type":"Paragraph","name":"Heading 1","basedOn":"Normal","next":"Normal","link":"Heading 1 Char","characterFormat":{"fontSize":16.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":12.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level1"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 2', '{"type":"Paragraph","name":"Heading 2","basedOn":"Normal","next":"Normal","link":"Heading 2 Char","characterFormat":{"fontSize":13.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level2"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 3', '{"type":"Paragraph","name":"Heading 3","basedOn":"Normal","next":"Normal","link":"Heading 3 Char","characterFormat":{"fontSize":12.0,"fontFamily":"Calibri Light","fontColor":"#1F3763"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level3"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 4', '{"type":"Paragraph","name":"Heading 4","basedOn":"Normal","next":"Normal","link":"Heading 4 Char","characterFormat":{"italic":true,"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level4"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 5', '{"type":"Paragraph","name":"Heading 5","basedOn":"Normal","next":"Normal","link":"Heading 5 Char","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#2F5496"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level5"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 6', '{"type":"Paragraph","name":"Heading 6","basedOn":"Normal","next":"Normal","link":"Heading 6 Char","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#1F3763"},"paragraphFormat":{"leftIndent":0.0,"rightIndent":0.0,"firstLineIndent":0.0,"beforeSpacing":2.0,"afterSpacing":0.0,"lineSpacing":1.0791666507720947,"lineSpacingType":"Multiple","textAlignment":"Left","outlineLevel":"Level6"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Default Paragraph Font', '{"type":"Character","name":"Default Paragraph Font"}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 1 Char', '{"type":"Character","name":"Heading 1 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":16.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 2 Char', '{"type":"Character","name":"Heading 2 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":13.0,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 3 Char', '{"type":"Character","name":"Heading 3 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontSize":12.0,"fontFamily":"Calibri Light","fontColor": "#1F3763"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 4 Char', '{"type":"Character","name":"Heading 4 Char","basedOn":"Default Paragraph Font","characterFormat":{"italic":true,"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 5 Char', '{"type":"Character","name":"Heading 5 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#2F5496"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Heading 6 Char', '{"type":"Character","name":"Heading 6 Char","basedOn":"Default Paragraph Font","characterFormat":{"fontFamily":"Calibri Light","fontColor":"#1F3763"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Hyperlink', '{"type":"Character","name":"Hyperlink","basedOn":"Default Paragraph Font","next":"Normal","characterFormat":{"fontColor":"#0563C1","underline": "Single"}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc1', '{"type":"Paragraph","name":"Toc1","basedOn":"Normal","next":"Normal","paragraphFormat":{"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc2', '{"type":"Paragraph","name":"Toc2","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :11.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc3', '{"type":"Paragraph","name":"Toc3","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :22.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc4', '{"type":"Paragraph","name":"Toc4","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :33.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc5', '{"type":"Paragraph","name":"Toc5","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :44.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc6', '{"type":"Paragraph","name":"Toc6","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :55.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc7', '{"type":"Paragraph","name":"Toc7","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :66.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc8', '{"type":"Paragraph","name":"Toc8","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :77.0,"afterSpacing":5.0}}');
        /* tslint:disable-next-line:max-line-length */
        this.preDefinedStyles.add('Toc9', '{"type":"Paragraph","name":"Toc9","basedOn":"Normal","next":"Normal","paragraphFormat":{"leftIndent" :88.0,"afterSpacing":5.0}}');
    }
    /**
     * @private
     */
    clearDocumentItems() {
        this.editRanges.clear();
        this.headersFooters = [];
        this.fields = [];
        this.currentSelectedComment = undefined;
        for (let i = 0; i < this.comments.length; i++) {
            let commentStart = this.comments[i].commentStart;
            commentStart.destroy();
        }
        this.comments = [];
        this.bookmarks.clear();
        this.styles.clear();
        this.characterFormat.clearFormat();
        this.paragraphFormat.clearFormat();
        this.setDefaultCharacterValue(this.characterFormat);
        this.setDefaultParagraphValue(this.paragraphFormat);
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.clear();
        }
        this.defaultTabWidth = 36;
        this.isDocumentProtected = false;
        this.protectionType = 'NoProtection';
        this.restrictFormatting = false;
        this.hashValue = '';
        this.saltValue = '';
        this.userCollection = [];
    }
    /**
     * @private
     */
    setDefaultDocumentFormat() {
        this.owner.parser.parseCharacterFormat(this.owner.characterFormat, this.characterFormat);
        this.owner.parser.parseParagraphFormat(this.owner.paragraphFormat, this.paragraphFormat);
    }
    setDefaultCharacterValue(characterFormat) {
        characterFormat.bold = false;
        characterFormat.italic = false;
        characterFormat.fontFamily = 'Calibri';
        characterFormat.fontSize = 11;
        characterFormat.underline = 'None';
        characterFormat.strikethrough = 'None';
        characterFormat.fontSizeBidi = 11;
        characterFormat.fontFamilyBidi = 'Calibri';
        characterFormat.baselineAlignment = 'Normal';
        characterFormat.highlightColor = 'NoColor';
        characterFormat.fontColor = '#000000';
    }
    setDefaultParagraphValue(paragraphFormat) {
        paragraphFormat.leftIndent = 0;
        paragraphFormat.rightIndent = 0;
        paragraphFormat.firstLineIndent = 0;
        paragraphFormat.textAlignment = 'Left';
        paragraphFormat.beforeSpacing = 0;
        paragraphFormat.afterSpacing = 0;
        paragraphFormat.lineSpacing = 1;
        paragraphFormat.lineSpacingType = 'Multiple';
        paragraphFormat.bidi = false;
    }
    /**
     * @private
     */
    getAbstractListById(id) {
        if (isNullOrUndefined(this.abstractLists)) {
            return undefined;
        }
        for (let i = 0; i < this.abstractLists.length; i++) {
            let abstractList = this.abstractLists[i];
            if (abstractList instanceof WAbstractList && abstractList.abstractListId === id) {
                return abstractList;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getListById(id) {
        if (isNullOrUndefined(this.lists)) {
            return undefined;
        }
        for (let i = 0; i < this.lists.length; i++) {
            if (!isNullOrUndefined(this.lists[i]) && this.lists[i].listId === id) {
                return this.lists[i];
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    static getListLevelNumber(listLevel) {
        if (listLevel.ownerBase instanceof WLevelOverride) {
            return listLevel.ownerBase.levelNumber;
        }
        else if (listLevel.ownerBase instanceof WAbstractList && !isNullOrUndefined(listLevel.ownerBase.levels)) {
            return listLevel.ownerBase.levels.indexOf(listLevel);
        }
        else {
            return -1;
        }
    }
    /**
     * Gets the bookmarks.
     * @private
     */
    getBookmarks(includeHidden) {
        let bookmarks = [];
        for (let i = 0; i < this.bookmarks.keys.length; i++) {
            let bookmark = this.bookmarks.keys[i];
            if (includeHidden || bookmark.indexOf('_') !== 0) {
                bookmarks.push(bookmark);
            }
        }
        return bookmarks;
    }
    /**
     * @private
     */
    selectComment(comment) {
        if (this.owner.selection && this.owner.commentReviewPane) {
            this.owner.showComments = true;
            setTimeout(() => {
                if (this.owner && this.owner.selection) {
                    this.owner.selection.selectComment(comment);
                }
            });
        }
    }
    /**
     * @private
     */
    showComments(show) {
        if (this.owner && show) {
            let eventArgs = { type: 'Comment' };
            this.owner.trigger('beforePaneSwitch', eventArgs);
        }
        this.owner.commentReviewPane.showHidePane(show);
    }
    /**
     * Initializes components.
     * @private
     */
    initializeComponents() {
        let element = this.owner.element;
        if (isNullOrUndefined(element)) {
            return;
        }
        this.optionsPaneContainer = createElement('div', {
            className: 'e-documenteditor-optionspane'
        });
        element.appendChild(this.optionsPaneContainer);
        let isRtl = this.owner.enableRtl;
        let viewerContainerStyle;
        if (isRtl) {
            viewerContainerStyle = 'direction:ltr;';
        }
        this.viewerContainer = createElement('div', { id: this.owner.containerId + '_viewerContainer' });
        this.viewerContainer.style.cssText = 'position:relative;backgroundColor:#FBFBFB;overflow:auto;' + viewerContainerStyle;
        this.optionsPaneContainer.appendChild(this.viewerContainer);
        this.viewerContainer.tabIndex = 0;
        this.viewerContainer.style.outline = 'none';
        this.pageContainer = createElement('div', { id: this.owner.containerId + '_pageContainer', className: 'e-de-background' });
        this.viewerContainer.appendChild(this.pageContainer);
        this.pageContainer.style.top = '0px';
        this.pageContainer.style.left = '0px';
        this.pageContainer.style.position = 'relative';
        this.pageContainer.style.pointerEvents = 'none';
        if (Browser.isDevice) {
            this.createEditableDiv(element);
        }
        else {
            this.createEditableIFrame();
        }
        if (this.owner.enableImageResizerMode) {
            this.owner.imageResizerModule.initializeImageResizer();
        }
        this.updateViewerSizeInternal(element);
        this.layout = new Layout(this);
        this.textHelper = new TextHelper(this);
        this.zoomModule = new Zoom(this);
        this.initTouchEllipse();
        this.wireEvent();
        this.restrictEditingPane = new RestrictEditing(this);
        this.owner.commentReviewPane = new CommentReviewPane(this.owner);
        createSpinner({ target: this.owner.element, cssClass: 'e-spin-overlay' });
    }
    /**
     * @private
     */
    createEditableDiv(element) {
        this.editableDiv = document.createElement('div');
        this.editableDiv.contentEditable = 'true';
        this.editableDiv.style.position = 'fixed';
        this.editableDiv.style.left = '-150em';
        this.editableDiv.style.width = '100%';
        this.editableDiv.style.height = '100%';
        this.editableDiv.id = element.id + '_editableDiv';
        document.body.appendChild(this.editableDiv);
    }
    /**
     * @private
     */
    createEditableIFrame() {
        this.iframe = createElement('iframe', {
            attrs: {
                'scrolling': 'no',
                // tslint:disable-next-line:max-line-length
                'style': 'pointer-events:none;position:absolute;left:0px;top:0px;outline:none;background-color:transparent;width:0px;height:0px;overflow:hidden'
            },
            className: 'e-de-text-target'
        });
        this.viewerContainer.appendChild(this.iframe);
        this.initIframeContent();
    }
    initIframeContent() {
        let style = 'background-color:transparent;width:100%;height:100%;padding: 0px; margin: 0px;';
        let innerHtml = '<!DOCTYPE html>'
            + '<html><head></head>'
            + '<body spellcheck="false" style=' + style + ' >'
            + '<div contenteditable="true" style=' + style + '></div>'
            + '</body>'
            + '</html>';
        this.iframe.contentDocument.open();
        this.iframe.contentDocument.write(innerHtml);
        this.iframe.contentDocument.close();
        this.editableDiv = this.iframe.contentDocument.body.children[0];
    }
    /**
     * Wires events and methods.
     */
    wireEvent() {
        if (!isNullOrUndefined(this.selection)) {
            this.selection.initCaret();
        }
        this.wireInputEvents();
        if (!isNullOrUndefined(this.iframe)) {
            this.iframe.addEventListener('load', this.onIframeLoad);
        }
        this.viewerContainer.addEventListener('scroll', this.scrollHandler);
        this.viewerContainer.addEventListener('mousedown', this.onMouseDownInternal);
        this.viewerContainer.addEventListener('keydown', this.onKeyDownInternal);
        this.viewerContainer.addEventListener('mousemove', this.onMouseMoveInternal);
        this.viewerContainer.addEventListener('mouseleave', this.onMouseLeaveInternal);
        this.viewerContainer.addEventListener('mouseenter', this.onMouseEnterInternal);
        this.viewerContainer.addEventListener('contextmenu', this.onContextMenu);
        this.viewerContainer.addEventListener('dblclick', this.onDoubleTap);
        this.viewerContainer.addEventListener('mouseup', this.onMouseUpInternal);
        window.addEventListener('resize', this.onWindowResize);
        window.addEventListener('keyup', this.onKeyUpInternal);
        window.addEventListener('mouseup', this.onImageResizer);
        window.addEventListener('touchend', this.onImageResizer);
        this.viewerContainer.addEventListener('touchstart', this.onTouchStartInternal);
        this.viewerContainer.addEventListener('touchmove', this.onTouchMoveInternal);
        this.viewerContainer.addEventListener('touchend', this.onTouchUpInternal);
        if (navigator.userAgent.match('Firefox')) {
            this.viewerContainer.addEventListener('DOMMouseScroll', this.zoomModule.onMouseWheelInternal);
        }
        this.viewerContainer.addEventListener('mousewheel', this.zoomModule.onMouseWheelInternal);
    }
    wireInputEvents() {
        if (isNullOrUndefined(this.editableDiv)) {
            return;
        }
        this.editableDiv.addEventListener('paste', this.onPaste);
        if (!Browser.isDevice) {
            this.editableDiv.addEventListener('keypress', this.onKeyPressInternal);
            if (Browser.info.name === 'chrome') {
                this.editableDiv.addEventListener('textInput', this.onTextInput);
            }
        }
        else {
            this.editableDiv.addEventListener('input', this.onTextInputInternal);
        }
        this.editableDiv.addEventListener('blur', this.onFocusOut);
        this.editableDiv.addEventListener('keydown', this.onKeyDownInternal);
        this.editableDiv.addEventListener('compositionstart', this.compositionStart);
        this.editableDiv.addEventListener('compositionupdate', this.compositionUpdated);
        this.editableDiv.addEventListener('compositionend', this.compositionEnd);
    }
    getEditableDivTextContent() {
        return this.editableDiv.textContent;
    }
    /**
     * @private
     */
    positionEditableTarget() {
        let point = this.selection.getRect(this.selection.start);
        let page = this.selection.getSelectionPage(this.selection.start);
        let caretInfo = this.selection.updateCaretSize(this.owner.selection.start);
        let sectionFormat = page.bodyWidgets[0].sectionFormat;
        let left = page.boundingRectangle.x + (HelperMethods.convertPointToPixel(sectionFormat.leftMargin) * this.zoomFactor);
        let top = point.y;
        let pageWidth = sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin;
        let iframeStyle = 'left:' + left + 'px;';
        iframeStyle += 'top:' + top + 'px;';
        iframeStyle += 'width:' + (HelperMethods.convertPointToPixel(pageWidth) * this.zoomFactor) + 'px;';
        iframeStyle += 'height:250px;outline-style:none;position:absolute';
        this.iframe.setAttribute('style', iframeStyle);
        let style = 'background-color:transparent;width:100%;height:250px;padding: 0px; margin: 0px;';
        style += 'text-indent:' + (point.x - left) + 'px;';
        style += 'color:transparent;pointer-events:none;outline-style:none;';
        style += 'font-size:' + (HelperMethods.convertPointToPixel(this.selection.characterFormat.fontSize) * this.zoomFactor) + 'px;';
        style += 'font-family' + this.selection.characterFormat.fontFamily + ';';
        style += 'overflow:hidden;text-decoration:none;white-space:normal;';
        this.editableDiv.setAttribute('style', style);
    }
    /**
     * Initializes dialog template.
     */
    initDialog(isRtl) {
        if (!this.dialogInternal) {
            this.dialogTarget1 = createElement('div', { className: 'e-de-dlg-target' });
            document.body.appendChild(this.dialogTarget1);
            if (isRtl) {
                this.dialogTarget1.classList.add('e-de-rtl');
            }
            this.dialogInternal = new Dialog({
                target: document.body, showCloseIcon: true,
                allowDragging: true, enableRtl: isRtl, visible: false,
                width: '1px', isModal: true, position: { X: 'center', Y: 'center' }, zIndex: this.owner.zIndex + 10,
                animationSettings: { effect: 'None' }
            });
            this.dialogInternal.open = this.selection.hideCaret;
            this.dialogInternal.beforeClose = this.updateFocus;
            this.dialogInternal.appendTo(this.dialogTarget1);
        }
    }
    /**
     * Initializes dialog template.
     */
    initDialog2(isRtl) {
        if (!this.dialogInternal2) {
            this.dialogTarget2 = createElement('div', { className: 'e-de-dlg-target' });
            document.body.appendChild(this.dialogTarget2);
            if (isRtl) {
                this.dialogTarget2.classList.add('e-de-rtl');
            }
            this.dialogInternal2 = new Dialog({
                target: document.body, showCloseIcon: true,
                allowDragging: true, enableRtl: isRtl, visible: false,
                width: '1px', isModal: true, position: { X: 'center', Y: 'Top' }, zIndex: this.owner.zIndex
            });
            this.dialogInternal2.appendTo(this.dialogTarget2);
        }
    }
    /**
     * Clears the context.
     * @private
     */
    clearContent() {
        this.containerContext.clearRect(0, 0, this.containerCanvas.width, this.containerCanvas.height);
        this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        // Hide comment mark
        if (this.pageContainer) {
            let commentMarkElement = this.pageContainer.getElementsByClassName('e-de-cmt-mark');
            for (let i = 0; i < commentMarkElement.length; i++) {
                commentMarkElement[i].style.display = 'none';
            }
        }
    }
    /**
     * Fired when the document gets changed.
     * @param {WordDocument} document
     */
    onDocumentChanged(sections) {
        this.clearContent();
        if (this.owner.editorModule) {
            this.owner.editorModule.tocStyles = {};
            this.owner.editorModule.tocBookmarkId = 0;
        }
        this.heightInfoCollection = {};
        this.owner.isDocumentLoaded = false;
        for (let i = 0; i < this.pages.length; i++) {
            this.pages[i].bodyWidgets[0].destroy();
        }
        this.pages = [];
        if (!isNullOrUndefined(this.renderedLists)) {
            this.renderedLists.clear();
        }
        if (!isNullOrUndefined(this.owner.editorHistory)) {
            this.owner.editorHistory.destroy();
        }
        this.owner.isDocumentLoaded = true;
        this.layout.isInitialLoad = true;
        this.layout.layoutItems(sections);
        if (this.owner.selection) {
            this.owner.selection.editRangeCollection = [];
            this.owner.selection.selectRange(this.owner.documentStart, this.owner.documentStart);
            if (this.isDocumentProtected) {
                this.restrictEditingPane.showHideRestrictPane(true);
            }
        }
        if (this.owner.optionsPaneModule) {
            this.owner.optionsPaneModule.showHideOptionsPane(false);
        }
        if (this.restrictEditingPane.restrictPane && !this.isDocumentProtected) {
            this.restrictEditingPane.showHideRestrictPane(false);
        }
        this.owner.fireDocumentChange();
    }
    /**
     * Initialize touch ellipse.
     */
    initTouchEllipse() {
        let style = 'height: 30px;width: 30px;position: absolute;background-color: transparent;margin: 0px;padding: 0px;z-index:5';
        // tslint:disable-next-line:max-line-length
        let ellipse = ' height: 12px;width: 12px;border-radius: 50%;background-color: white;position: absolute;margin: 0px 6px 0px 6px;border-width: 2px;border-style: solid;border-color: #000000;';
        this.touchStart = createElement('div', { className: 'e-touch-ellipse', styles: style });
        let start = createElement('div', { styles: ellipse });
        this.touchEnd = createElement('div', { className: 'e-touch-ellipse', styles: style });
        this.touchStart.style.display = 'none';
        let end = createElement('div', { styles: ellipse });
        this.touchStart.appendChild(start);
        this.touchEnd.appendChild(end);
        this.touchEnd.style.display = 'none';
        this.viewerContainer.appendChild(this.touchStart);
        this.viewerContainer.appendChild(this.touchEnd);
    }
    /**
     * Updates touch mark position.
     * @private
     */
    updateTouchMarkPosition() {
        if (this.touchStart.style.display !== 'none' && !isNullOrUndefined(this.selection)) {
            if (!this.selection.isEmpty) {
                let y = this.selection.getCaretBottom(this.selection.start, false);
                let page = this.selection.getPage(this.selection.start.paragraph);
                let viewer = this;
                // tslint:disable-next-line:max-line-length
                let pageTop = (page.boundingRectangle.y - viewer.pageGap * (this.pages.indexOf(page) + 1)) * this.zoomFactor + viewer.pageGap * (this.pages.indexOf(page) + 1);
                // tslint:disable-next-line:max-line-length
                this.touchStart.style.left = page.boundingRectangle.x + (Math.round(this.selection.start.location.x) * this.zoomFactor - 14) + 'px';
                this.touchStart.style.top = pageTop + ((y) * this.zoomFactor) + 'px';
                if (!this.selection.isEmpty) {
                    y = this.selection.getCaretBottom(this.selection.end, false);
                    page = this.selection.getPage(this.selection.end.paragraph);
                }
                // tslint:disable-next-line:max-line-length
                this.touchEnd.style.left = page.boundingRectangle.x + (Math.round(this.selection.end.location.x) * this.zoomFactor - 14) + 'px';
                this.touchEnd.style.top = pageTop + (y * this.zoomFactor) + 'px';
            }
            else {
                this.selection.updateCaretPosition();
            }
        }
    }
    scrollForwardOnSelection() {
        this.viewerContainer.scrollTop = this.viewerContainer.scrollTop + 200;
    }
    scrollBackwardOnSelection() {
        this.viewerContainer.scrollTop = this.viewerContainer.scrollTop - 200;
    }
    isSelectionInListText(cursorPoint) {
        let widget = this.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget) && widget.children[0] instanceof ListTextElementBox) {
            let left = this.getLeftValue(widget);
            let width = widget.children[0].width;
            let height = widget.children[0].height;
            if (this.isInsideRect(left, widget.paragraph.y, width, height, cursorPoint)) {
                this.selectionLineWidget = widget;
                return true;
            }
        }
        return false;
    }
    /**
     * Check whether touch point is inside the rectangle or not.
     * @param x
     * @param y
     * @param width
     * @param height
     * @param touchPoint
     * @private
     */
    isInsideRect(x, y, width, height, touchPoint) {
        if ((touchPoint.x > x && touchPoint.x <= x + width) && (touchPoint.y > y && touchPoint.y <= y + height)) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    getLeftValue(widget) {
        let left = widget.paragraph.x;
        let paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.selection.isParagraphFirstLine(widget)) {
            if (paragraphFormat.textAlignment === 'Right') {
                left -= HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
                left -= HelperMethods.convertPointToPixel(paragraphFormat.leftIndent);
            }
            else {
                left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
            }
        }
        let element = widget.children[0];
        if (element instanceof ListTextElementBox) {
            left += element.margin.left;
        }
        return left;
    }
    /**
     * Checks whether left mouse button is pressed or not.
     */
    isLeftButtonPressed(event) {
        this.isTouchInput = false;
        let button = event.which || event.button;
        return button === 1;
    }
    /**
     * Updates selection for touch position.
     * @param point
     * @param touchPoint
     */
    updateSelectionOnTouch(point, touchPoint) {
        this.zoomX = undefined;
        this.zoomY = undefined;
        // tslint:disable-next-line:max-line-length
        if (this.isMouseDown && !this.isSelectionChangedOnMouseMoved && !isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
            if (this.touchDownOnSelectionMark === 0) {
                this.updateTextPositionForSelection(new Point(touchPoint.x, touchPoint.y), this.tapCount);
                if (this.tapCount === 2) {
                    this.selection.checkAndEnableHeaderFooter(point, touchPoint);
                }
            }
            if (this.owner.selection.isEmpty) {
                this.selection.updateCaretPosition();
            }
            this.selection.checkForCursorVisibility();
            if (!isNullOrUndefined(this.currentSelectedComment) && this.owner.commentReviewPane
                && !this.owner.commentReviewPane.commentPane.isEditMode) {
                this.currentSelectedComment = undefined;
            }
        }
    }
    /**
     * Gets touch offset value.
     * @private
     */
    getTouchOffsetValue(event) {
        let targetElement = this.viewerContainer;
        let offset = targetElement.getBoundingClientRect();
        let touchOffsetValues = event.touches[0];
        if (isNullOrUndefined(touchOffsetValues)) {
            touchOffsetValues = event.changedTouches[0];
        }
        let offsetX = touchOffsetValues.pageX - offset.left;
        let offsetY = touchOffsetValues.pageY - offset.top;
        return new Point(offsetX, offsetY);
    }
    /**
     * Fired on pinch zoom in.
     * @param {TouchEvent} event
     */
    onPinchInInternal(event) {
        this.preZoomFactor = this.zoomFactor;
        let updatedZoomFactor = this.zoomFactor - 0.01;
        if (updatedZoomFactor < 5 && updatedZoomFactor > 2) {
            updatedZoomFactor = updatedZoomFactor - 0.01;
        }
        if (updatedZoomFactor < 0.1) {
            updatedZoomFactor = 0.1;
        }
        this.zoomFactor = updatedZoomFactor;
    }
    /**
     * Fired on pinch zoom out.
     * @param {TouchEvent} event
     */
    onPinchOutInternal(event) {
        this.preZoomFactor = this.zoomFactor;
        let updatedZoomFactor = this.zoomFactor + 0.01;
        if (updatedZoomFactor > 2) {
            updatedZoomFactor = updatedZoomFactor + 0.01;
        }
        if (updatedZoomFactor > 5) {
            updatedZoomFactor = 5;
        }
        this.zoomFactor = updatedZoomFactor;
    }
    /**
     * Gets page width.
     * @private
     */
    getPageWidth(page) {
        let width = page.boundingRectangle.width;
        return width;
    }
    /**
     * Removes specified page.
     * @private
     */
    removePage(page) {
        if (this.currentPage === page) {
            this.currentPage = undefined;
        }
        let index = this.pages.indexOf(page);
        // if (index > -1) {
        this.pages.splice(index, 1);
        // }        
        //this.removeRenderedPages();
        let viewer = this;
        if (!isNullOrUndefined(viewer.visiblePages)) {
            if ((viewer.visiblePages).indexOf(page) > -1) {
                let pageIndex = (viewer.visiblePages).indexOf(page);
                (viewer.visiblePages).splice(pageIndex, 1);
            }
        }
        //(viewer as PageLayoutViewer).visiblePages.remove(page);
        let height = 0;
        for (let i = 0; i < this.pages.length; i++) {
            height = height + this.pages[i].boundingRectangle.height;
        }
        //Updates the vertical height.
        height -= page.boundingRectangle.height + 20;
        //ToDo:Update horizontal width, if removed page has max width.
        let top = 20;
        if (index > 0) {
            top += this.pages[index - 1].boundingRectangle.bottom;
        }
        if (index !== -1) {
            for (let i = index; i < this.pages.length; i++) {
                //Update bounding rectangle of next pages in collection.
                page = this.pages[i];
                // tslint:disable-next-line:max-line-length
                page.boundingRectangle = new Rect(page.boundingRectangle.x, top, page.boundingRectangle.width, page.boundingRectangle.height);
                top = page.boundingRectangle.bottom + 20;
                page.repeatHeaderRowTableWidget = false;
            }
        }
    }
    // private removeRenderedPages(): void {
    //     for (let i: number = 0; i < this.pages.length; i++) {
    //         this.clearContainer(this.pages[i]);
    //     }
    // }
    /**
     * Updates viewer size on window resize.
     * @private
     */
    updateViewerSize() {
        let viewer = this;
        let element = this.owner.getDocumentEditorElement();
        viewer.updateViewerSizeInternal(element);
        viewer.updateScrollBars();
        if (!isNullOrUndefined(this.selection)) {
            this.selection.updateCaretPosition();
        }
    }
    /**
     * Updates viewer size.
     */
    updateViewerSizeInternal(element) {
        if (!isNullOrUndefined(element)) {
            let rect = element.getBoundingClientRect();
            let width = 0;
            let height = 0;
            height = rect.height > 0 ? rect.height : 200;
            let restrictPaneRect = this.restrictEditingPane && this.restrictEditingPane.isShowRestrictPane ?
                this.restrictEditingPane.restrictPane.getBoundingClientRect() : undefined;
            let optionsRect = this.owner.optionsPaneModule && this.owner.optionsPaneModule.isOptionsPaneShow ?
                this.owner.optionsPaneModule.optionsPane.getBoundingClientRect() : undefined;
            let commentPane = this.owner.commentReviewPane && this.owner.commentReviewPane.reviewPane ?
                this.owner.commentReviewPane.reviewPane.getBoundingClientRect() : undefined;
            if (restrictPaneRect || optionsRect || commentPane) {
                let paneWidth = restrictPaneRect ? restrictPaneRect.width : 0;
                paneWidth += optionsRect ? optionsRect.width : 0;
                paneWidth += commentPane ? commentPane.width : 0;
                width = (rect.width - paneWidth) > 0 ? (rect.width - paneWidth) : 200;
            }
            else {
                width = rect.width > 0 ? rect.width : 200;
            }
            this.viewerContainer.style.height = height.toString() + 'px';
            this.viewerContainer.style.width = Math.ceil(width) + 'px';
            this.visibleBoundsIn = new Rect(0, 0, width, height);
            this.containerCanvas.width = width;
            this.containerCanvas.height = height;
            this.selectionCanvas.width = width;
            this.selectionCanvas.height = height;
        }
    }
    /**
     * Updates client area for block.
     * @private
     */
    updateClientAreaForBlock(block, beforeLayout, tableCollection) {
        let leftIndent = HelperMethods.convertPointToPixel(block.leftIndent);
        let rightIndent = HelperMethods.convertPointToPixel(block.rightIndent);
        let bidi = block.bidi;
        let width = 0;
        if (beforeLayout) {
            if (block instanceof TableWidget && tableCollection) {
                let tableWidget = tableCollection[0];
                this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
                this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
                //Updates the location of last item.
                tableWidget = tableCollection[tableCollection.length - 1];
                tableWidget.x = this.clientActiveArea.x;
                tableWidget.y = this.clientActiveArea.y;
            }
            else {
                // tslint:disable-next-line:max-line-length
                if (block instanceof TableWidget && !isNullOrUndefined(block.tableFormat)) {
                    if (!block.isGridUpdated) {
                        block.buildTableColumns();
                        block.isGridUpdated = true;
                    }
                    let tableAlignment = this.tableAlignmentForBidi(block, bidi);
                    if (tableAlignment !== 'Left') {
                        let tableWidth = 0;
                        // If the grid is calculated, we can direclty get the width from the grid.
                        // Otherwise, calculate the width.
                        tableWidth = HelperMethods.convertPointToPixel(block.tableHolder.getTotalWidth(0));
                        tableWidth = tableWidth === 0 ? block.tableHolder.tableWidth === 0 ?
                            block.getTableClientWidth(block.getOwnerWidth(false)) : block.tableHolder.tableWidth : tableWidth;
                        // Fore resizing table, the tableholder table width taken for updated width. 
                        // Since, the columns will be cleared if we performed resizing.
                        if (this.owner.editor && this.owner.editor.tableResize.currentResizingTable === block
                            && this.owner.editor.tableResize.resizerPosition === 0) {
                            tableWidth = HelperMethods.convertPointToPixel(block.tableHolder.tableWidth);
                        }
                        if (tableAlignment === 'Center') {
                            leftIndent = (this.clientArea.width - tableWidth) / 2;
                        }
                        else {
                            leftIndent = this.clientArea.width - tableWidth;
                        }
                        if (bidi) {
                            leftIndent = leftIndent - HelperMethods.convertPointToPixel(block.leftIndent);
                            rightIndent = leftIndent;
                        }
                        this.tableLefts.push(leftIndent);
                    }
                }
                width = this.clientArea.width - (leftIndent + HelperMethods.convertPointToPixel(block.rightIndent));
                this.clientActiveArea.x = this.clientArea.x = this.clientArea.x + (bidi ? rightIndent : leftIndent);
                this.clientActiveArea.width = this.clientArea.width = width > 0 ? width : 0;
            }
        }
        else {
            // Clears table left for table with right or center alignment.
            if (block instanceof TableWidget && !isNullOrUndefined(block.tableFormat)) {
                let tableAlignment = this.tableAlignmentForBidi(block, bidi);
                if (!block.isGridUpdated) {
                    block.buildTableColumns();
                    block.isGridUpdated = true;
                }
                if (tableAlignment !== 'Left' && this.tableLefts.length > 0) {
                    leftIndent = this.tableLefts.pop();
                    if (bidi) {
                        rightIndent = leftIndent;
                    }
                }
            }
            width = this.clientArea.width + leftIndent + HelperMethods.convertPointToPixel(block.rightIndent);
            this.clientActiveArea.width = this.clientArea.width = width > 0 ? width : 0;
            this.clientActiveArea.x = this.clientArea.x = this.clientArea.x - (bidi ? rightIndent : leftIndent);
        }
        this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
        // tslint:disable-next-line:max-line-length
        this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
    }
    tableAlignmentForBidi(block, bidi) {
        let tableAlignment = block.tableFormat.tableAlignment;
        if (bidi) {
            if (tableAlignment === 'Left') {
                tableAlignment = 'Right';
            }
            else if (tableAlignment === 'Right') {
                tableAlignment = 'Left';
            }
        }
        return tableAlignment;
    }
    /**
     * Updates client active area left.
     * @private
     */
    cutFromLeft(x) {
        if (x < this.clientActiveArea.x) {
            x = this.clientActiveArea.x;
        }
        if (x > this.clientActiveArea.right && this.textWrap) {
            x = this.clientActiveArea.right;
        }
        this.clientActiveArea.width = this.clientActiveArea.right > x ? this.clientActiveArea.right - x : 0;
        this.clientActiveArea.x = x;
    }
    /**
     * Updates client active area top.
     * @private
     */
    cutFromTop(y) {
        if (y < this.clientActiveArea.y) {
            y = this.clientActiveArea.y;
        }
        if (y > this.clientActiveArea.bottom) {
            y = this.clientActiveArea.bottom;
        }
        this.clientActiveArea.height = this.clientActiveArea.bottom - y;
        this.clientActiveArea.x = this.clientArea.x;
        this.clientActiveArea.width = this.clientArea.width;
        this.clientActiveArea.y = y;
    }
    /**
     * Updates client width.
     * @private
     */
    updateClientWidth(width) {
        this.clientActiveArea.x -= width;
        if (this.clientActiveArea.width + width > 0) {
            this.clientActiveArea.width += width;
        }
        else {
            this.clientActiveArea.width = 0;
        }
    }
    /**
     * Inserts page in specified index.
     * @private
     */
    insertPage(index, page) {
        if (this.pages.indexOf(page) > -1) {
            this.pages.splice(this.pages.indexOf(page), 1);
        }
        this.pages.splice(index, 0, page);
        let top = 20;
        if (index > 0) {
            top += this.pages[index - 1].boundingRectangle.bottom;
        }
        for (let i = index; i < this.pages.length; i++) {
            //Update bounding rectangle of next pages in collection.
            page = this.pages[i];
            page.boundingRectangle = new Rect(page.boundingRectangle.x, top, page.boundingRectangle.width, page.boundingRectangle.height);
            top = page.boundingRectangle.bottom + 20;
        }
    }
    /**
     * Updates client area.
     * @private
     */
    updateClientArea(sectionFormat, page) {
        let top = 0;
        let headerDistance = 48;
        let footerDistance = 48;
        let pageHeight = HelperMethods.convertPointToPixel(sectionFormat.pageHeight);
        let bottomMargin = HelperMethods.convertPointToPixel(sectionFormat.bottomMargin);
        if (!isNullOrUndefined(sectionFormat)) {
            top = HelperMethods.convertPointToPixel(sectionFormat.topMargin);
            headerDistance = HelperMethods.convertPointToPixel(sectionFormat.headerDistance);
            footerDistance = HelperMethods.convertPointToPixel(sectionFormat.footerDistance);
        }
        let isEmptyWidget = false;
        if (!isNullOrUndefined(page.headerWidget)) {
            isEmptyWidget = page.headerWidget.isEmpty;
            if (!isEmptyWidget || isEmptyWidget && this.owner.enableHeaderAndFooter) {
                top = Math.min(Math.max(headerDistance + page.headerWidget.height, top), pageHeight / 100 * 40);
            }
        }
        let bottom = 0.667 + bottomMargin;
        if (!isNullOrUndefined(page.footerWidget)) {
            isEmptyWidget = page.footerWidget.isEmpty;
            if (!isEmptyWidget || isEmptyWidget && this.owner.enableHeaderAndFooter) {
                bottom = 0.667 + Math.min(pageHeight / 100 * 40, Math.max(footerDistance + page.footerWidget.height, bottomMargin));
            }
        }
        let width = 0;
        if (!isNullOrUndefined(sectionFormat)) {
            width = HelperMethods.convertPointToPixel(sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin);
            
        }
        if (width < 0) {
            width = 0;
        }
        this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), top, width, pageHeight - top - bottom);
        this.clientActiveArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
    }
    /**
     * Updates client area left or top position.
     * @private
     */
    updateClientAreaTopOrLeft(tableWidget, beforeLayout) {
        if (beforeLayout) {
            this.clientActiveArea.y = this.clientActiveArea.y + tableWidget.topBorderWidth;
            this.clientActiveArea.x = this.clientActiveArea.x + tableWidget.leftBorderWidth;
        }
    }
    /**
     * Updates client area for table.
     * @private
     */
    updateClientAreaForTable(tableWidget) {
        this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
        this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
    }
    /**
     * Updates client area for row.
     * @private
     */
    updateClientAreaForRow(row, beforeLayout) {
        // tslint:disable-next-line:max-line-length
        let tableWidget = row.ownerTable;
        if (beforeLayout) {
            //tslint:disable:no-empty
        }
        else {
            this.clientActiveArea.x = this.clientArea.x = tableWidget.x;
            this.clientActiveArea.width = this.clientArea.width = tableWidget.width;
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
    }
    /**
     * Updates client area for cell.
     * @private
     */
    updateClientAreaForCell(cell, beforeLayout) {
        // tslint:disable-next-line:max-line-length
        let rowWidget = cell.ownerRow;
        let cellWidget = cell;
        if (beforeLayout) {
            this.clientActiveArea.x = this.clientArea.x = cellWidget.x;
            this.clientActiveArea.y = cellWidget.y;
            this.clientActiveArea.width = this.clientArea.width = cellWidget.width > 0 ? cellWidget.width : 0;
            if (this instanceof PageLayoutViewer) {
                this.clientActiveArea.height = Number.POSITIVE_INFINITY;
            }
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
        else {
            this.clientActiveArea.x = this.clientArea.x = cellWidget.x + cellWidget.width + cellWidget.margin.right;
            if (rowWidget.x + rowWidget.width - this.clientArea.x < 0) {
                this.clientActiveArea.width = this.clientArea.width = 0;
            }
            else {
                this.clientActiveArea.width = this.clientArea.width = rowWidget.x + rowWidget.width - this.clientArea.x;
            }
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea.y = cellWidget.y - cellWidget.margin.top - HelperMethods.convertPointToPixel(cell.ownerTable.tableFormat.cellSpacing);
            if (!cell.ownerTable.isInsideTable) {
                this.clientActiveArea.height = this.clientArea.bottom - rowWidget.y > 0 ? this.clientArea.bottom - rowWidget.y : 0;
            }
            this.clientArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
            // tslint:disable-next-line:max-line-length
            this.clientActiveArea = new Rect(this.clientActiveArea.x, this.clientActiveArea.y, this.clientActiveArea.width, this.clientActiveArea.height);
        }
    }
    /**
     * Updates the client area based on widget.
     * @private
     */
    updateClientAreaByWidget(widget) {
        this.clientArea.x = widget.x;
        this.clientArea.y = widget.y;
        this.clientActiveArea.x = widget.x;
        this.clientActiveArea.y = widget.y;
    }
    //Widget
    /**
     * Updates client area location.
     * @param widget
     * @param area
     * @private
     */
    updateClientAreaLocation(widget, area) {
        widget.x = area.x;
        widget.y = area.y;
        widget.width = area.width;
    }
    /**
     * Updates text position for selection.
     * @param cursorPoint
     * @param tapCount
     * @param clearMultiSelection
     * @private
     */
    updateTextPositionForSelection(cursorPoint, tapCount) {
        let widget = this.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget)) {
            this.selection.updateTextPosition(widget, cursorPoint);
        }
        if (tapCount > 1) {
            this.isMouseDown = false;
            this.useTouchSelectionMark = false;
            if (this.pages.length === 0) {
                return;
            }
            //Double tap/triple tap selection
            if (!isNullOrUndefined(this.currentPage) && !isNullOrUndefined(this.owner.selection.start)) {
                if (tapCount % 2 === 0) {
                    this.owner.selection.selectCurrentWord();
                }
                else {
                    this.owner.selection.selectParagraph();
                }
            }
        }
    }
    /**
     * Scrolls to specified position.
     * @param startPosition
     * @param endPosition
     * @private
     */
    scrollToPosition(startPosition, endPosition, skipCursorUpdate) {
        if (this.skipScrollToPosition) {
            this.skipScrollToPosition = false;
            return;
        }
        if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizing
            || this.isMouseDownInFooterRegion || this.isRowOrCellResizing) {
            return;
        }
        let lineWidget = this.selection.getLineWidgetInternal(endPosition.currentWidget, endPosition.offset, true);
        if (isNullOrUndefined(lineWidget)) {
            return;
        }
        let top = this.selection.getTop(lineWidget);
        if (this.isMouseDown) {
            let prevLineWidget = this.selection.getLineWidgetInternal(endPosition.currentWidget, endPosition.offset, false);
            let prevTop = this.selection.getTop(prevLineWidget);
            if (prevLineWidget !== lineWidget && endPosition.location.y >= prevTop) {
                lineWidget = prevLineWidget;
            }
        }
        let height = lineWidget.height;
        //Gets current page.
        let endPage = this.selection.getPage(lineWidget.paragraph);
        this.currentPage = endPage;
        let x = 0;
        let y = 0;
        let viewer = this;
        let isPageLayout = viewer instanceof PageLayoutViewer;
        if (isPageLayout) {
            if (isNullOrUndefined(endPage)) {
                return;
            }
            let pageWidth = endPage.boundingRectangle.width;
            x = (this.visibleBounds.width - pageWidth * this.zoomFactor) / 2;
            if (x < 30) {
                x = 30;
            }
            // tslint:disable-next-line:max-line-length
            y = endPage.boundingRectangle.y * this.zoomFactor + (this.pages.indexOf(endPage) + 1) * viewer.pageGap * (1 - this.zoomFactor);
        }
        let scrollTop = this.containerTop;
        let scrollLeft = this.containerLeft;
        let pageHeight = this.visibleBounds.height;
        let caretInfo = this.selection.updateCaretSize(this.owner.selection.end, true);
        let topMargin = caretInfo.topMargin;
        let caretHeight = caretInfo.height;
        x += (endPosition.location.x) * this.zoomFactor;
        y += (endPosition.location.y + topMargin) * this.zoomFactor;
        //vertical scroll bar update
        if ((scrollTop + 20) > y) {
            this.viewerContainer.scrollTop = (y - 10);
        }
        else if (scrollTop + pageHeight < y + caretHeight) {
            this.viewerContainer.scrollTop = y + caretHeight - pageHeight + 10;
        }
        if (!skipCursorUpdate) {
            this.selection.updateCaretToPage(startPosition, endPage);
        }
        let scrollBarWidth = this.viewerContainer.offsetWidth - this.viewerContainer.clientWidth;
        if (scrollLeft > x) {
            this.viewerContainer.scrollLeft = x - (viewer.pageContainer.offsetWidth / 100) * 20;
        }
        else if (scrollLeft + this.visibleBounds.width < x + scrollBarWidth) {
            this.viewerContainer.scrollLeft = scrollLeft + (viewer.pageContainer.offsetWidth / 100) * 15 + scrollBarWidth;
        }
    }
    /**
     * Gets line widget using cursor point.
     * @private
     */
    getLineWidget(cursorPoint) {
        return this.getLineWidgetInternal(cursorPoint, false);
    }
    /**
     * Gets line widget.
     * @private
     */
    getLineWidgetInternal(cursorPoint, isMouseDragged) {
        let widget = undefined;
        if (!isNullOrUndefined(this.currentPage)) {
            let childWidgets;
            if (this.owner.enableHeaderAndFooter) {
                let page = this.currentPage;
                let pageTop = this.selection.getPageTop(page);
                let pageBottom = page.boundingRectangle.height;
                let headerHeight = Math.max((page.headerWidget.y + page.headerWidget.height), HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin)) * this.zoomFactor;
                let footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
                let footerHeight = (page.boundingRectangle.height -
                    Math.max(page.footerWidget.height + footerDistance, footerDistance * 2));
                if (isMouseDragged) {
                    if (this.isBlockInHeader(this.selection.start.paragraph)) {
                        childWidgets = this.currentPage.headerWidget;
                    }
                    else {
                        childWidgets = this.currentPage.footerWidget;
                    }
                }
                else {
                    if (cursorPoint.y <= pageBottom && cursorPoint.y >= footerHeight) {
                        childWidgets = this.currentPage.footerWidget;
                    }
                    else if ((cursorPoint.y) >= 0 && (cursorPoint.y) <= headerHeight) {
                        childWidgets = this.currentPage.headerWidget;
                    }
                }
                if (isNullOrUndefined(childWidgets)) {
                    return undefined;
                }
                return this.selection.getLineWidgetBodyWidget(childWidgets, cursorPoint);
            }
            else {
                for (let i = 0; i < this.currentPage.bodyWidgets.length; i++) {
                    let bodyWidgets = this.currentPage.bodyWidgets[i];
                    widget = this.selection.getLineWidgetBodyWidget(bodyWidgets, cursorPoint);
                    if (!isNullOrUndefined(widget)) {
                        break;
                    }
                }
            }
        }
        return widget;
    }
    /**
     * @private
     */
    isBlockInHeader(block) {
        while (!(block.containerWidget instanceof HeaderFooterWidget)) {
            if (!block.containerWidget) {
                return false;
            }
            block = block.containerWidget;
        }
        return block.containerWidget.headerFooterType.indexOf('Header') !== -1;
    }
    /**
     * Clears selection highlight.
     * @private
     */
    clearSelectionHighlight() {
        let canClear = true;
        canClear = (!this.isControlPressed || !this.isMouseDown);
        // if (this.owner.selection.selectionRanges.length > 0 && canClear) {
        if (this.owner.selection.clearSelectionHighlightInSelectedWidgets()) {
            this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        }
        // } else if (!isNullOrUndefined(this.owner.selection.currentSelectionRange) && this.isMouseDown) {
        //     this.owner.selection.currentSelectionRange.clearSelectionHighlight();
        // }
        //this.renderVisiblePages();
    }
    /**
     * @private
     */
    removeEmptyPages() {
        let scrollToLastPage = false;
        let viewer = this;
        for (let j = 0; j < this.pages.length; j++) {
            let page = this.pages[j];
            if (page.bodyWidgets.length === 0 || page.bodyWidgets[0].childWidgets.length === 0) {
                // tslint:disable-next-line:max-line-length
                if (j === this.pages.length - 1 && viewer instanceof PageLayoutViewer && viewer.visiblePages.indexOf(this.pages[j]) !== -1) {
                    scrollToLastPage = true;
                }
                this.removePage(this.pages[j]);
                j--;
            }
        }
        if (scrollToLastPage) {
            this.scrollToBottom();
        }
    }
    /**
     * @private
     */
    scrollToBottom() {
        if (this.selection.start.paragraph && this.selection.start.paragraph.bodyWidget) {
            let page = this.selection.start.paragraph.bodyWidget.page;
            let containerHeight = this.visibleBounds.height;
            this.viewerContainer.scrollTop = page.boundingRectangle.bottom - containerHeight;
        }
    }
    /**
     * Returns the field code result.
     * @private
     */
    getFieldResult(fieldBegin, page) {
        if (!isNullOrUndefined(page) && !isNullOrUndefined(this.selection)) {
            let fieldCode = this.selection.getFieldCode(fieldBegin);
            let fieldCodes = fieldCode.split('\*');
            let fieldCategory = fieldCodes[0].replace(/[^\w\s]/gi, '').trim().toLowerCase();
            let fieldPattern = '';
            if (fieldCodes.length > 1) {
                fieldPattern = fieldCodes[1].replace(/[^\w\s]/gi, '').trim();
            }
            switch (fieldCategory) {
                case 'page':
                    if (page.bodyWidgets[0].sectionFormat.restartPageNumbering && page.sectionIndex !== 0) {
                        let currentSectionIndex = page.sectionIndex;
                        let previousPage = page.previousPage;
                        if (currentSectionIndex !== previousPage.sectionIndex) {
                            page.currentPageNum = (page.bodyWidgets[0].sectionFormat.pageStartingNumber);
                            return this.getFieldText(fieldPattern, page.currentPageNum);
                        }
                        if (previousPage.currentPageNum === 0) {
                            previousPage.currentPageNum = (page.bodyWidgets[0].sectionFormat.pageStartingNumber);
                        }
                        page.currentPageNum = previousPage.currentPageNum + 1;
                        return this.getFieldText(fieldPattern, page.currentPageNum);
                    }
                    page.currentPageNum = page.index + 1;
                    return this.getFieldText(fieldPattern, page.currentPageNum);
                case 'numpages':
                    return this.getFieldText(fieldPattern, page.viewer.pages.length);
                case 'sectionpages':
                    let currentSectionIndex = page.sectionIndex;
                    let currentPageCount = 0;
                    for (let i = 0; i < page.viewer.pages.length; i++) {
                        if (page.viewer.pages[i].sectionIndex === currentSectionIndex) {
                            currentPageCount++;
                        }
                        else if (currentPageCount !== 0) {
                            break;
                        }
                    }
                    return this.getFieldText(fieldPattern, currentPageCount);
                default:
                    break;
            }
        }
        return '';
    }
    /**
     * Returns field text.
     */
    getFieldText(pattern, value) {
        switch (pattern) {
            case 'ALPHABETIC':
                return this.layout.getAsLetter(value).toUpperCase();
            case 'alphabetic':
                return this.layout.getAsLetter(value).toLowerCase();
            case 'roman':
                return this.layout.getAsRoman(value).toLowerCase();
            case 'ROMAN':
                return this.layout.getAsRoman(value).toUpperCase();
            default:
                return value.toString();
        }
    }
    /**
     * Destroys the internal objects maintained for control.
     */
    destroy() {
        if (!isNullOrUndefined(this.owner)) {
            this.unWireEvent();
        }
        this.pages = [];
        this.pages = undefined;
        this.fieldStacks = [];
        this.fieldStacks = undefined;
        this.splittedCellWidgets = [];
        this.splittedCellWidgets = undefined;
        this.fields = [];
        this.fields = undefined;
        if (this.layout) {
            this.layout.destroy();
        }
        this.layout = undefined;
        if (!isNullOrUndefined(this.render)) {
            this.render.destroy();
        }
        this.render = undefined;
        if (this.dialogInternal) {
            this.dialogInternal.destroy();
        }
        this.dialogInternal = undefined;
        if (this.dialogInternal2) {
            this.dialogInternal2.destroy();
            this.dialogInternal2 = undefined;
        }
        if (this.dialogTarget1 && this.dialogTarget1.parentElement) {
            this.dialogTarget1.parentElement.removeChild(this.dialogTarget1);
        }
        this.dialogTarget1 = undefined;
        if (this.dialogTarget2 && this.dialogTarget2.parentElement) {
            this.dialogTarget2.parentElement.removeChild(this.dialogTarget2);
        }
        this.dialogTarget2 = undefined;
        if (!isNullOrUndefined(this.touchStart)) {
            this.touchStart.innerHTML = '';
        }
        if (this.textHelper) {
            this.textHelper.destroy();
        }
        this.textHelper = undefined;
        this.touchStart = undefined;
        if (!isNullOrUndefined(this.touchEnd)) {
            this.touchEnd.innerHTML = '';
        }
        this.touchEnd = undefined;
        if (!isNullOrUndefined(this.containerCanvasIn)) {
            this.containerCanvasIn.innerHTML = '';
        }
        this.containerCanvasIn = undefined;
        if (!isNullOrUndefined(this.selectionCanvasIn)) {
            this.selectionCanvasIn.innerHTML = '';
        }
        this.selectionCanvasIn = undefined;
        if (!isNullOrUndefined(this.editableDiv)) {
            this.editableDiv.innerHTML = '';
            this.editableDiv.parentElement.removeChild(this.editableDiv);
        }
        this.editableDiv = undefined;
        if (!isNullOrUndefined(this.pageContainer)) {
            this.pageContainer.innerHTML = '';
        }
        this.pageContainer = undefined;
        if (!isNullOrUndefined(this.viewerContainer)) {
            this.viewerContainer.innerHTML = '';
        }
        this.viewerContainer = undefined;
        this.owner = undefined;
        this.heightInfoCollection = undefined;
    }
    /**
     * Un-Wires events and methods
     */
    unWireEvent() {
        this.viewerContainer.removeEventListener('scroll', this.scrollHandler);
        this.viewerContainer.removeEventListener('mousedown', this.onMouseDownInternal);
        this.viewerContainer.removeEventListener('mousemove', this.onMouseMoveInternal);
        if (!Browser.isDevice) {
            this.editableDiv.removeEventListener('keypress', this.onKeyPressInternal);
            if (Browser.info.name === 'chrome') {
                this.editableDiv.removeEventListener('textInput', this.onTextInput);
            }
        }
        else {
            this.editableDiv.removeEventListener('input', this.onTextInputInternal);
        }
        this.editableDiv.removeEventListener('paste', this.onPaste);
        this.viewerContainer.removeEventListener('contextmenu', this.onContextMenu);
        this.editableDiv.removeEventListener('blur', this.onFocusOut);
        this.editableDiv.removeEventListener('keydown', this.onKeyDownInternal);
        this.editableDiv.removeEventListener('compositionstart', this.compositionStart);
        this.editableDiv.removeEventListener('compositionupdate', this.compositionUpdated);
        this.editableDiv.removeEventListener('compositionend', this.compositionEnd);
        this.viewerContainer.removeEventListener('mouseup', this.onMouseUpInternal);
        if (!isNullOrUndefined(this.iframe)) {
            this.iframe.removeEventListener('load', this.onIframeLoad);
        }
        this.viewerContainer.removeEventListener('dblclick', this.onDoubleTap);
        window.removeEventListener('resize', this.onWindowResize);
        window.removeEventListener('keyup', this.onKeyUpInternal);
        window.removeEventListener('mouseup', this.onImageResizer);
        window.removeEventListener('touchend', this.onImageResizer);
    }
}
/**
 * @private
 */
class PageLayoutViewer extends LayoutViewer {
    /**
     * Initialize the constructor of PageLayoutViewer
     */
    constructor(owner) {
        super(owner);
        this.pageLeft = 30;
        /**
         * @private
         */
        this.visiblePages = [];
        if (isNullOrUndefined(owner) || isNullOrUndefined(owner.element)) {
            return;
        }
    }
    /**
     * @private
     */
    get pageGap() {
        return this.owner.pageGap;
    }
    /**
     * Creates new page.
     * @private
     */
    createNewPage(section, index) {
        let viewer = this;
        let yPos = this.pageGap;
        if (this.pages.length > 0) {
            yPos = this.pages[this.pages.length - 1].boundingRectangle.bottom + this.pageGap;
        }
        let page = new Page();
        page.viewer = this;
        // tslint:disable-next-line:max-line-length
        let pageWidth = !isNullOrUndefined(section.sectionFormat) ? HelperMethods.convertPointToPixel(section.sectionFormat.pageWidth) : 816;
        // tslint:disable-next-line:max-line-length
        let pageHeight = !isNullOrUndefined(section.sectionFormat) ? HelperMethods.convertPointToPixel(section.sectionFormat.pageHeight) : 1056;
        let xPos = (this.visibleBounds.width - pageWidth * this.zoomFactor) / 2;
        if (xPos < this.pageLeft) {
            xPos = this.pageLeft;
        }
        page.boundingRectangle = new Rect(xPos, yPos, pageWidth, pageHeight);
        if (isNullOrUndefined(index)) {
            this.pages.push(page);
        }
        else {
            this.pages.splice(index, 0, page);
        }
        this.updateClientArea(section.sectionFormat, page);
        page.bodyWidgets.push(section);
        page.bodyWidgets[page.bodyWidgets.length - 1].page = page;
        this.layout.layoutHeaderFooter(section, viewer, page);
        this.updateClientArea(section.sectionFormat, page);
        return page;
    }
    /**
     * Updates cursor.
     */
    updateCursor(event) {
        let hyperlinkField = undefined;
        let div = this.viewerContainer;
        let point = new Point(event.offsetX, event.offsetY);
        let touchPoint = this.findFocusedPage(point, true);
        let widget = this.getLineWidget(touchPoint);
        let widgetInfo;
        let left;
        let top;
        let editor = !this.owner.isReadOnlyMode ? this.owner.editorModule : undefined;
        let isRowResize = editor ? editor.tableResize.isInRowResizerArea(touchPoint) : false;
        let isCellResize = editor ? editor.tableResize.isInCellResizerArea(touchPoint) : false;
        let resizePosition = '';
        if (this.owner.enableImageResizerMode) {
            let resizeObj = this.owner.imageResizerModule.getImagePoint(touchPoint);
            this.owner.imageResizerModule.selectedResizeElement = resizeObj.selectedElement;
            resizePosition = resizeObj.resizePosition;
        }
        let lineLeft = 0;
        if (!isNullOrUndefined(widget)) {
            lineLeft = this.selection.getLineStartLeft(widget);
            hyperlinkField = this.selection.getHyperLinkFieldInCurrentSelection(widget, touchPoint);
            widgetInfo = this.selection.updateTextPositionIn(widget, undefined, 0, touchPoint, true);
            left = this.selection.getLeft(widget);
            top = this.selection.getTop(widget);
            this.selection.setHyperlinkContentToToolTip(hyperlinkField, widget, touchPoint.x);
        }
        if (!isNullOrUndefined(hyperlinkField) && (event.ctrlKey &&
            this.owner.useCtrlClickToFollowHyperlink || !this.owner.useCtrlClickToFollowHyperlink)) {
            div.style.cursor = 'pointer';
            return;
        }
        else if (touchPoint.x >= lineLeft &&
            event.offsetX < (this.visibleBounds.width - (this.visibleBounds.width - this.viewerContainer.clientWidth)) &&
            event.offsetY < (this.visibleBounds.height - (this.visibleBounds.height - this.viewerContainer.clientHeight))) {
            if (this.selection.isEmpty) {
                div.style.cursor = 'text';
            }
            else {
                div.style.cursor = this.selection.checkCursorIsInSelection(widget, touchPoint) ? 'default' : 'text';
            }
        }
        else {
            div.style.cursor = 'default';
        }
        if (!isNullOrUndefined(resizePosition) && resizePosition !== '') {
            div.style.cursor = resizePosition;
        }
        else if (!isNullOrUndefined(widgetInfo) && widgetInfo.isImageSelected && left < touchPoint.x && top < touchPoint.y &&
            left + widget.width > touchPoint.x && top + widget.height > touchPoint.y) {
            div.style.cursor = 'move';
        }
        if (isRowResize) {
            div.style.cursor = 'row-resize';
        }
        else if (isCellResize) {
            div.style.cursor = 'col-resize';
        }
    }
    /**
     * Finds focused page.
     * @private
     */
    findFocusedPage(currentPoint, updateCurrentPage) {
        let point = new Point(currentPoint.x, currentPoint.y);
        point.x += this.viewerContainer.scrollLeft;
        point.y += this.viewerContainer.scrollTop;
        for (let i = 0; i < this.pages.length; i++) {
            let page = this.pages[i];
            let pageTop = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            let pageHeight = (page.boundingRectangle.height * this.zoomFactor) + this.pageGap;
            let pageLeft = page.boundingRectangle.x;
            let pageRight = ((page.boundingRectangle.right - pageLeft) * this.zoomFactor) + pageLeft;
            if (pageTop <= point.y && pageTop + pageHeight >= point.y) {
                if (updateCurrentPage) {
                    this.currentPage = page;
                }
                point.y = (point.y - (pageTop)) / this.zoomFactor;
                if (point.x > pageRight) {
                    point.x = page.boundingRectangle.right;
                }
                else if (point.x < pageLeft) {
                    point.x = 0;
                }
                else {
                    point.x = (point.x - pageLeft) / this.zoomFactor;
                }
                return point;
            }
        }
        return point;
    }
    /**
     * Fired when page fit type changed.
     * @private
     */
    onPageFitTypeChanged(pageFitType) {
        let width = this.visibleBounds.width;
        let height = this.visibleBounds.height;
        let section = this.visiblePages[0].bodyWidgets[0];
        let pageWidth = HelperMethods.convertPointToPixel(section.sectionFormat.pageWidth);
        let pageHeight = HelperMethods.convertPointToPixel(section.sectionFormat.pageHeight);
        switch (pageFitType) {
            case 'FitOnePage':
                if (height > 0 && pageHeight > 0) {
                    let zoomFactor = (this.visibleBounds.height - 2 * this.pageGap - (this.pageGap - 2)) / pageHeight;
                    if (zoomFactor === this.zoomFactor) {
                        if (!isNullOrUndefined(this.owner.selection) && !isNullOrUndefined(this.owner.selection.start) &&
                            !isNullOrUndefined(this.owner.selection.end)) {
                            this.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
                        }
                    }
                    else {
                        this.zoomFactor = zoomFactor;
                    }
                }
                break;
            case 'FitPageWidth':
                if (width > 0 && pageWidth > 0) {
                    this.zoomFactor = (this.visibleBounds.width - 80) / pageWidth;
                }
                break;
            default:
                this.zoomFactor = 100 / 100;
                break;
        }
    }
    /**
     * @private
     */
    handleZoom() {
        let prevScaleFactor = this.preZoomFactor;
        let page = null;
        let verticalHeight = 0;
        let scrollToPosition = false;
        if (this.selection && isNullOrUndefined(this.zoomX && isNullOrUndefined(this.zoomY))) {
            let x = 0;
            let y = 0;
            let endPage = this.selection.getPage(this.selection.end.currentWidget.paragraph);
            x = (this.visibleBounds.width - endPage.boundingRectangle.width * prevScaleFactor) / 2;
            if (x < 30) {
                x = 30;
            }
            // tslint:disable-next-line:max-line-length
            y = endPage.boundingRectangle.y * prevScaleFactor + (this.pages.indexOf(endPage) + 1) * this.pageGap * (1 - prevScaleFactor);
            let caretInfo = this.selection.updateCaretSize(this.owner.selection.end, true);
            let topMargin = caretInfo.topMargin;
            let caretHeight = caretInfo.height;
            x += (this.selection.end.location.x) * prevScaleFactor;
            y += (this.selection.end.location.y + topMargin) * prevScaleFactor;
            if (x >= this.containerLeft && x <= this.visibleBounds.width &&
                y >= this.containerTop && y <= this.containerTop + this.visibleBounds.height) {
                scrollToPosition = true;
            }
        }
        for (let i = 0; i < this.pages.length; i++) {
            verticalHeight = verticalHeight + this.pages[i].boundingRectangle.height;
        }
        let horizontalWidth = 0;
        for (let i = 0; i < this.pages.length; i++) {
            if (horizontalWidth < this.pages[i].boundingRectangle.width) {
                horizontalWidth = this.pages[i].boundingRectangle.width;
            }
        }
        // tslint:disable-next-line:max-line-length
        let height = (verticalHeight * this.zoomFactor + (this.pages.length + 1) * this.pageGap * (1 - this.zoomFactor)) - this.visibleBounds.height;
        let horWidth = horizontalWidth * this.zoomFactor - this.visibleBounds.width;
        if (this.visibleBounds.width - horizontalWidth * this.zoomFactor < 60) {
            horWidth += 60;
        }
        //Update Vertical Scroll bar
        if (height > 0) {
            let value = this.containerTop;
            if (this.visiblePages.length > 0) {
                page = this.visiblePages[0];
                // tslint:disable-next-line:max-line-length
                let prevPageTop = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * prevScaleFactor + (page.index + 1) * this.pageGap;
                let zoomY = this.zoomY;
                if (isNullOrUndefined) {
                    zoomY = this.visibleBounds.height / 2;
                }
                let prevY = value + zoomY;
                while (prevY > prevPageTop + (page.boundingRectangle.height * prevScaleFactor)) {
                    let pageIndex = page.index + 1;
                    if (pageIndex === this.pages.length) {
                        break;
                    }
                    page = this.pages[pageIndex];
                    // tslint:disable-next-line:max-line-length
                    prevPageTop = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * prevScaleFactor + (page.index + 1) * this.pageGap;
                }
                // tslint:disable-next-line:max-line-length
                let currentY = (page.boundingRectangle.y - (page.index + 1) * this.pageGap) * this.zoomFactor + (page.index + 1) * this.pageGap
                    + ((prevY - prevPageTop) < 0 ? prevY - prevPageTop : (prevY - prevPageTop) * (this.zoomFactor / prevScaleFactor));
                value = currentY - zoomY;
                zoomY = this.visibleBounds.height / 2;
            }
            this.viewerContainer.scrollTop = value;
        }
        else {
            this.viewerContainer.scrollTop = 0;
        }
        // update Horizontal Scroll Bar
        if (horWidth > 0) {
            let value = this.containerLeft;
            if (this.visiblePages.length > 0) {
                if (page === null) {
                    page = this.visiblePages[0];
                }
                let zoomX = this.zoomX;
                if (isNullOrUndefined(zoomX)) {
                    zoomX = this.visibleBounds.width / 2;
                }
                let prevValue = (page.boundingRectangle.width * prevScaleFactor) / page.boundingRectangle.width;
                let prevX = value + zoomX;
                // tslint:disable-next-line:max-line-length
                let currentX = page.boundingRectangle.x
                    + ((prevX - page.boundingRectangle.x) < 0 ? prevX - page.boundingRectangle.x : (prevX - page.boundingRectangle.x) * (this.zoomFactor / prevValue));
                value = currentX - zoomX;
                zoomX = this.visibleBounds.width / 2;
            }
            this.viewerContainer.scrollLeft = value;
        }
        else {
            this.viewerContainer.scrollLeft = 0;
        }
        this.updateScrollBars();
        if (scrollToPosition) {
            this.scrollToPosition(this.selection.start, this.selection.end);
        }
    }
    /**
     * Gets current page header footer.
     * @private
     */
    getCurrentPageHeaderFooter(section, isHeader) {
        return this.getCurrentHeaderFooter(this.getHeaderFooterType(section, isHeader), section.index);
    }
    /**
     * Get header footer type
     * @private
     */
    getHeaderFooterType(section, isHeader) {
        let type;
        type = isHeader ? 'OddHeader' : 'OddFooter';
        let page = section.page;
        // tslint:disable-next-line:max-line-length
        if (section.sectionFormat.differentFirstPage && (isNullOrUndefined(page.previousPage) || page.sectionIndex !== page.previousPage.sectionIndex)) {
            type = isHeader ? 'FirstPageHeader' : 'FirstPageFooter';
        }
        else if (section.sectionFormat.differentOddAndEvenPages && this.pages.length % 2 === 0) {
            type = isHeader ? 'EvenHeader' : 'EvenFooter';
        }
        return type;
    }
    /**
     * Gets current header footer.
     * @param type
     * @param section
     * @private
     */
    getCurrentHeaderFooter(type, sectionIndex) {
        if (this.headersFooters[sectionIndex]) {
            let index = this.getHeaderFooter(type);
            let headerFooter = this.headersFooters[sectionIndex][index];
            if (!headerFooter) {
                if (this.headersFooters[0][index]) {
                    headerFooter = this.headersFooters[0][index];
                }
                else {
                    headerFooter = this.createHeaderFooterWidget(type);
                    headerFooter.isEmpty = true;
                }
                this.headersFooters[sectionIndex][index] = headerFooter;
            }
            return headerFooter;
        }
        else if (sectionIndex > 0) {
            return this.getCurrentHeaderFooter(type, sectionIndex - 1);
        }
        return undefined;
    }
    createHeaderFooterWidget(type) {
        let headerFooter = new HeaderFooterWidget(type);
        let paragraph = new ParagraphWidget();
        paragraph.childWidgets.push(new LineWidget(paragraph));
        return headerFooter;
    }
    /**
     * Gets header footer.
     * @param type
     * @private
     */
    getHeaderFooter(type) {
        switch (type) {
            case 'OddHeader':
                return 0;
            case 'OddFooter':
                return 1;
            case 'EvenHeader':
                return 2;
            case 'EvenFooter':
                return 3;
            case 'FirstPageHeader':
                return 4;
            case 'FirstPageFooter':
                return 5;
        }
    }
    /**
     * Updates header footer client area.
     * @private
     */
    updateHFClientArea(sectionFormat, isHeader) {
        // tslint:disable-next-line:max-line-length
        let width = HelperMethods.convertPointToPixel(sectionFormat.pageWidth - sectionFormat.leftMargin - sectionFormat.rightMargin);
        if (width < 0) {
            width = 0;
        }
        if (isHeader) {
            // tslint:disable-next-line:max-line-length
            this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), HelperMethods.convertPointToPixel(sectionFormat.headerDistance), width, Number.POSITIVE_INFINITY);
        }
        else {
            // tslint:disable-next-line:max-line-length
            this.clientArea = new Rect(HelperMethods.convertPointToPixel(sectionFormat.leftMargin), HelperMethods.convertPointToPixel(sectionFormat.pageHeight - sectionFormat.footerDistance), width, Number.POSITIVE_INFINITY);
        }
        this.clientActiveArea = new Rect(this.clientArea.x, this.clientArea.y, this.clientArea.width, this.clientArea.height);
    }
    /**
     * @private
     */
    updateHCFClientAreaWithTop(sectionFormat, isHeader, page) {
        this.updateHFClientArea(sectionFormat, isHeader);
        if (!isHeader) {
            if (page.footerWidget.y < this.clientActiveArea.y) {
                this.clientActiveArea.y = page.footerWidget.y;
                this.clientActiveArea.height = Number.POSITIVE_INFINITY;
            }
        }
    }
    /**
     * Scrolls to the specified page
     * @private
     */
    scrollToPage(pageIndex) {
        let top = 0;
        for (let i = 0; i < this.pages.length; i++) {
            top = this.pages[i].boundingRectangle.y - (this.pageGap / 2);
            if (i === pageIndex) {
                break;
            }
        }
        this.viewerContainer.scrollTop = top;
        this.updateScrollBars();
    }
    /**
     * Updates scroll bars.
     * @private
     */
    updateScrollBars() {
        let height = 0;
        for (let i = 0; i < this.pages.length; i++) {
            height = height + this.pages[i].boundingRectangle.height;
        }
        let width = 0;
        for (let i = 0; i < this.pages.length; i++) {
            if (width < this.pages[i].boundingRectangle.width) {
                width = this.pages[i].boundingRectangle.width;
            }
        }
        let containerWidth = (width * this.zoomFactor) + (this.pageLeft * 2);
        let containerHeight = (height * this.zoomFactor) + (this.pages.length + 1) * this.pageGap;
        let viewerWidth = this.visibleBounds.width;
        let viewerHeight = this.visibleBounds.height;
        if (this.visibleBounds.width !== this.viewerContainer.clientWidth) {
            viewerWidth -= (this.visibleBounds.width - this.viewerContainer.clientWidth);
        }
        else if (containerHeight > viewerHeight) {
            viewerWidth -= this.viewerContainer.offsetWidth - this.viewerContainer.clientWidth;
        }
        if (containerWidth > viewerWidth) {
            viewerHeight -= (this.visibleBounds.height - this.viewerContainer.clientHeight);
        }
        width = containerWidth > viewerWidth ? containerWidth : viewerWidth;
        height = containerHeight > viewerHeight ? containerHeight : viewerHeight;
        if (parseInt(this.pageContainer.style.width.replace('px', ''), 10) !== width ||
            parseInt(this.pageContainer.style.height.replace('px', ''), 10) !== width) {
            this.pageContainer.style.width = width.toString() + 'px';
            this.pageContainer.style.height = height.toString() + 'px';
        }
        // if (!isNullOrUndefined(this.selection) && !this.selection.isEmpty) {
        //     this.selectionContext.clearRect(0, 0, this.selectionCanvas.width, this.selectionCanvas.height);
        // }
        let displayPixelRatio = Math.max(1, window.devicePixelRatio || 1);
        if (this.containerCanvas.width !== Math.floor(viewerWidth * displayPixelRatio)
            || this.containerCanvas.height !== Math.floor(viewerHeight * displayPixelRatio)) {
            this.containerCanvas.width = viewerWidth * displayPixelRatio;
            this.containerCanvas.height = viewerHeight * displayPixelRatio;
            this.containerCanvas.style.width = viewerWidth + 'px';
            this.containerCanvas.style.height = viewerHeight + 'px';
            this.containerContext.scale(displayPixelRatio, displayPixelRatio);
            this.selectionCanvas.width = viewerWidth * displayPixelRatio;
            this.selectionCanvas.height = viewerHeight * displayPixelRatio;
            this.selectionCanvas.style.width = viewerWidth + 'px';
            this.selectionCanvas.style.height = viewerHeight + 'px';
            this.selectionContext.scale(displayPixelRatio, displayPixelRatio);
        }
        this.containerContext.globalAlpha = 1;
        this.selectionContext.globalAlpha = 0.4;
        for (let i = 0; i < this.pages.length; i++) {
            let left = (width - this.pages[i].boundingRectangle.width * this.zoomFactor) / 2;
            if (left > this.pageLeft) {
                // tslint:disable-next-line:max-line-length
                this.pages[i].boundingRectangle = new Rect(left, this.pages[i].boundingRectangle.y, this.pages[i].boundingRectangle.width, this.pages[i].boundingRectangle.height);
            }
            else {
                // tslint:disable-next-line:max-line-length
                this.pages[i].boundingRectangle = new Rect(this.pageLeft, this.pages[i].boundingRectangle.y, this.pages[i].boundingRectangle.width, this.pages[i].boundingRectangle.height);
            }
        }
        this.updateScrollBarPosition(containerWidth, containerHeight, viewerWidth, viewerHeight, width, height);
        this.isScrollToSpellCheck = false;
    }
    // tslint:disable-next-line:max-line-length
    updateScrollBarPosition(containerWidth, containerHeight, viewerWidth, viewerHeight, width, height) {
        let viewerHeight1 = parseFloat(this.viewerContainer.style.height);
        let containerHeight1 = parseFloat(this.pageContainer.style.height);
        this.containerTop = this.viewerContainer.scrollTop;
        this.containerCanvas.style.position = 'absolute';
        this.containerCanvas.style.top = this.containerTop.toString() + 'px';
        this.selectionCanvas.style.position = 'absolute';
        this.selectionCanvas.style.top = this.containerTop.toString() + 'px';
        this.containerLeft = this.viewerContainer.scrollLeft;
        this.containerCanvas.style.left = this.containerLeft + 'px';
        this.selectionCanvas.style.left = this.containerLeft + 'px';
        this.updateVisiblePages();
    }
    /**
     * Updates visible pages.
     * @private
     */
    updateVisiblePages() {
        this.visiblePages = [];
        let height = this.visibleBounds.height;
        let vertical = this.viewerContainer.scrollTop;
        for (let i = 0; i < this.pages.length; i++) {
            let page = this.pages[i];
            let y = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            let pageH = page.boundingRectangle.height * this.zoomFactor;
            let left = page.boundingRectangle.x;
            let isTopFit = y >= vertical && y <= vertical + height;
            let isBottomFit = y + pageH >= vertical && y + pageH <= vertical + height;
            let isMiddleFit = y <= vertical && y + pageH >= vertical + height;
            //UI Virtualization
            if (isTopFit || isBottomFit || isMiddleFit) {
                this.addVisiblePage(page, left, y);
            }
        }
    }
    /**
     * Adds visible pages.
     */
    addVisiblePage(page, x, y) {
        let width = page.boundingRectangle.width * this.zoomFactor;
        let height = page.boundingRectangle.height * this.zoomFactor;
        // tslint:disable-next-line:max-line-length
        if (this.owner.enableImageResizerMode && this.owner.imageResizerModule.currentPage !== undefined && this.owner.imageResizerModule.currentPage === page && this.owner.imageResizerModule.isImageResizerVisible) {
            this.owner.imageResizerModule.setImageResizerPositions(x, y, width, height);
        }
        this.visiblePages.push(page);
        // tslint:disable-next-line:max-line-length
        if (this.owner.enableSpellCheck && this.owner.spellChecker.enableOptimizedSpellCheck && (this.triggerElementsOnLoading || this.isScrollHandler) && this.cachedPages.indexOf(page.index) < 0) {
            page.allowNextPageRendering = false;
            this.cachedPages.push(page.index);
            let content = this.owner.spellChecker.getPageContent(page);
            if (content.trim().length > 0) {
                // tslint:disable-next-line:max-line-length
                /* tslint:disable:no-any */
                this.owner.spellChecker.CallSpellChecker(this.owner.spellChecker.languageID, content, true, false, false, true).then((data) => {
                    /* tslint:disable:no-any */
                    let jsonObject = JSON.parse(data);
                    this.owner.spellChecker.updateUniqueWords(jsonObject.SpellCollection);
                    page.allowNextPageRendering = true;
                    this.triggerSpellCheck = true;
                    this.renderPage(page, x, y, width, height);
                    this.triggerSpellCheck = false;
                    this.triggerElementsOnLoading = false;
                });
            }
            else {
                this.renderPage(page, x, y, width, height);
            }
        }
        else {
            this.renderPage(page, x, y, width, height);
        }
    }
    /**
     * Render specified page widgets.
     */
    renderPage(page, x, y, width, height) {
        this.render.renderWidgets(page, x - this.containerLeft, y - this.containerTop, width, height);
    }
    /**
     * Renders visible pages.
     * @private
     */
    renderVisiblePages() {
        if (isNullOrUndefined(this.visiblePages) || this.visiblePages.length < 1) {
            return;
        }
        this.clearContent();
        for (let i = 0; i < this.visiblePages.length; i++) {
            let page = this.visiblePages[i];
            let width = page.boundingRectangle.width * this.zoomFactor;
            let height = page.boundingRectangle.height * this.zoomFactor;
            let x = page.boundingRectangle.x;
            let y = (page.boundingRectangle.y - this.pageGap * (i + 1)) * this.zoomFactor + this.pageGap * (i + 1);
            this.renderPage(page, x, y, width, height);
        }
    }
}

/**
 * @private
 */
class SfdtReader {
    constructor(viewer) {
        /* tslint:disable:no-any */
        this.viewer = undefined;
        this.commentStarts = undefined;
        this.commentEnds = undefined;
        this.commentsCollection = undefined;
        this.isPageBreakInsideTable = false;
        this.viewer = viewer;
        this.editableRanges = new Dictionary();
    }
    get isPasting() {
        return this.viewer && this.viewer.owner.isPastingContent;
    }
    /**
     * @private
     * @param json
     */
    convertJsonToDocument(json) {
        this.commentStarts = new Dictionary();
        this.commentEnds = new Dictionary();
        this.commentsCollection = new Dictionary();
        let sections = [];
        let jsonObject = json;
        jsonObject = (jsonObject instanceof Object) ? jsonObject : JSON.parse(jsonObject);
        let characterFormat = isNullOrUndefined(jsonObject.characterFormat) ?
            this.viewer.owner.characterFormat : jsonObject.characterFormat;
        this.parseCharacterFormat(characterFormat, this.viewer.characterFormat);
        let paragraphFormat = isNullOrUndefined(jsonObject.paragraphFormat) ?
            this.viewer.owner.paragraphFormat : jsonObject.paragraphFormat;
        this.parseParagraphFormat(paragraphFormat, this.viewer.paragraphFormat);
        this.parseDocumentProtection(jsonObject);
        if (!isNullOrUndefined(jsonObject.defaultTabWidth)) {
            this.viewer.defaultTabWidth = jsonObject.defaultTabWidth;
        }
        if (!isNullOrUndefined(jsonObject.background)) {
            this.viewer.backgroundColor = this.getColor(jsonObject.background.color);
        }
        if (!isNullOrUndefined(jsonObject.abstractLists)) {
            this.parseAbstractList(jsonObject, this.viewer.abstractLists);
        }
        if (!isNullOrUndefined(jsonObject.lists)) {
            this.parseList(jsonObject, this.viewer.lists);
        }
        if (!isNullOrUndefined(jsonObject.styles)) {
            this.parseStyles(jsonObject, this.viewer.styles);
        }
        if (!isNullOrUndefined(jsonObject.comments)) {
            this.parseComments(jsonObject, this.viewer.comments);
        }
        if (!isNullOrUndefined(jsonObject.sections)) {
            this.parseSections(jsonObject.sections, sections);
        }
        return sections;
    }
    parseDocumentProtection(data) {
        if (!isNullOrUndefined(data.formatting)) {
            this.viewer.restrictFormatting = data.formatting;
        }
        if (!isNullOrUndefined(data.enforcement)) {
            this.viewer.isDocumentProtected = data.enforcement;
        }
        if (!isNullOrUndefined(data.protectionType)) {
            this.viewer.protectionType = data.protectionType;
        }
        if (!isNullOrUndefined(data.hashValue)) {
            this.viewer.hashValue = data.hashValue;
        }
        if (!isNullOrUndefined(data.saltValue)) {
            this.viewer.saltValue = data.saltValue;
        }
    }
    parseStyles(data, styles) {
        for (let i = 0; i < data.styles.length; i++) {
            if (isNullOrUndefined(this.viewer.styles.findByName(data.styles[i].name))) {
                this.parseStyle(data, data.styles[i], styles);
            }
        }
    }
    parseComments(data, comments) {
        let count = 0;
        for (let i = 0; i < data.comments.length; i++) {
            let commentData = data.comments[i];
            let commentElement = undefined;
            commentElement = this.parseComment(commentData, commentElement);
            while (count < commentData.replyComments.length) {
                let replyComment = undefined;
                replyComment = this.parseComment(commentData.replyComments[count], replyComment);
                replyComment.ownerComment = commentElement;
                replyComment.isReply = true;
                commentElement.replyComments.push(replyComment);
                this.commentsCollection.add(replyComment.commentId, replyComment);
                count++;
            }
            this.commentsCollection.add(commentElement.commentId, commentElement);
            comments.push(commentElement);
            count = 0;
        }
    }
    parseComment(commentData, commentElement) {
        commentElement = new CommentElementBox(commentData.date);
        commentElement.author = commentData.author;
        commentElement.initial = commentData.initial;
        commentElement.commentId = commentData.commentId;
        commentElement.isResolved = commentData.done;
        commentElement.text = this.parseCommentText(commentData.blocks);
        return commentElement;
    }
    parseCommentText(blocks) {
        let text = '';
        for (let i = 0; i < blocks.length; i++) {
            if (i !== 0) {
                text += '\n';
            }
            for (let j = 0; j < blocks[i].inlines.length; j++) {
                text = text + blocks[i].inlines[j].text;
            }
        }
        return text;
    }
    parseStyle(data, style, styles) {
        let wStyle;
        if (!isNullOrUndefined(style.type)) {
            if (style.type === 'Paragraph') {
                wStyle = new WParagraphStyle();
                wStyle.type = 'Paragraph';
            }
            if (style.type === 'Character') {
                wStyle = new WCharacterStyle();
                wStyle.type = 'Character';
            }
            if (!isNullOrUndefined(style.name)) {
                wStyle.name = style.name;
            }
            styles.push(wStyle);
            if (!isNullOrUndefined(style.basedOn)) {
                let basedOn = styles.findByName(style.basedOn);
                if (!isNullOrUndefined(basedOn)) {
                    if (basedOn.type === wStyle.type) {
                        wStyle.basedOn = basedOn;
                    }
                }
                else {
                    let basedStyle = this.getStyle(style.basedOn, data);
                    let styleString;
                    if (!isNullOrUndefined(basedStyle) && basedStyle.type === wStyle.type) {
                        styleString = basedStyle;
                    }
                    else {
                        if (wStyle.type === 'Paragraph') {
                            styleString = JSON.parse('{"type":"Paragraph","name":"Normal","next":"Normal"}');
                        }
                        else {
                            styleString = JSON.parse('{"type": "Character","name": "Default Paragraph Font"}');
                        }
                    }
                    this.parseStyle(data, styleString, styles);
                    wStyle.basedOn = styles.findByName(styleString.name);
                }
            }
            if (!isNullOrUndefined(style.link)) {
                let link = styles.findByName(style.link);
                let linkStyle = this.getStyle(style.link, data);
                let styleString;
                if (isNullOrUndefined(link)) {
                    if (isNullOrUndefined(linkStyle)) {
                        //Construct the CharacterStyle string
                        let charaStyle = {};
                        charaStyle.characterFormat = style.characterFormat;
                        charaStyle.name = style.name + ' Char';
                        charaStyle.type = 'Character';
                        //TODO: Implement basedOn
                        charaStyle.basedOn = style.basedOn === 'Normal' ? 'Default Paragraph Font' : (style.basedOn + ' Char');
                        styleString = charaStyle;
                    }
                    else {
                        styleString = linkStyle;
                    }
                    this.parseStyle(data, styleString, styles);
                    wStyle.link = isNullOrUndefined(styles.findByName(styleString.name)) ? style.link : styles.findByName(styleString.name);
                }
                else {
                    wStyle.link = link;
                }
            }
            if (!isNullOrUndefined(style.characterFormat)) {
                this.parseCharacterFormat(style.characterFormat, wStyle.characterFormat);
            }
            if (!isNullOrUndefined(style.paragraphFormat)) {
                this.parseParagraphFormat(style.paragraphFormat, wStyle.paragraphFormat);
            }
            if (!isNullOrUndefined(style.next)) {
                if (style.next === style.name) {
                    wStyle.next = wStyle;
                }
                else {
                    let next = styles.findByName(style.next);
                    if (!isNullOrUndefined(next) && next.type === wStyle.type) {
                        wStyle.next = next;
                    }
                    else {
                        let nextStyleString = this.getStyle(style.next, data);
                        if (!isNullOrUndefined(nextStyleString)) {
                            this.parseStyle(data, nextStyleString, styles);
                            wStyle.next = styles.findByName(nextStyleString.name);
                        }
                        else {
                            wStyle.next = wStyle;
                        }
                    }
                }
            }
        }
    }
    getStyle(name, data) {
        for (let i = 0; i < data.styles.length; i++) {
            if (data.styles[i].name === name) {
                return data.styles[i];
            }
        }
        return undefined;
    }
    /**
     * @private
     * @param data
     * @param abstractLists
     */
    parseAbstractList(data, abstractLists) {
        for (let i = 0; i < data.abstractLists.length; i++) {
            let abstractList = new WAbstractList();
            let abstract = data.abstractLists[i];
            abstractLists.push(abstractList);
            if (!isNullOrUndefined(abstract)) {
                if (!isNullOrUndefined(abstract.abstractListId)) {
                    abstractList.abstractListId = abstract.abstractListId;
                }
                if (!isNullOrUndefined(abstract.levels)) {
                    for (let j = 0; j < abstract.levels.length; j++) {
                        let level = abstract.levels[j];
                        if (!isNullOrUndefined(level)) {
                            let listLevel = this.parseListLevel(level, abstractList);
                            abstractList.levels.push(listLevel);
                        }
                    }
                }
            }
        }
    }
    parseListLevel(data, owner) {
        let listLevel = new WListLevel(owner);
        if (data.listLevelPattern === 'Bullet') {
            listLevel.listLevelPattern = 'Bullet';
            listLevel.numberFormat = !isNullOrUndefined(data.numberFormat) ? data.numberFormat : '';
        }
        else {
            listLevel.listLevelPattern = data.listLevelPattern;
            listLevel.startAt = data.startAt;
            listLevel.numberFormat = !isNullOrUndefined(data.numberFormat) ? data.numberFormat : '';
            if (data.restartLevel >= 0) {
                listLevel.restartLevel = data.restartLevel;
            }
            else {
                listLevel.restartLevel = data.levelNumber;
            }
        }
        listLevel.followCharacter = data.followCharacter;
        this.parseCharacterFormat(data.characterFormat, listLevel.characterFormat);
        this.parseParagraphFormat(data.paragraphFormat, listLevel.paragraphFormat);
        return listLevel;
    }
    /**
     * @private
     * @param data
     * @param listCollection
     */
    parseList(data, listCollection) {
        for (let i = 0; i < data.lists.length; i++) {
            let list = new WList();
            let lists = data.lists[i];
            if (!isNullOrUndefined(lists.abstractListId)) {
                list.abstractListId = lists.abstractListId;
                list.abstractList = this.viewer.getAbstractListById(lists.abstractListId);
            }
            listCollection.push(list);
            if (!isNullOrUndefined(lists.listId)) {
                list.listId = lists.listId;
            }
            if (lists.hasOwnProperty('levelOverrides')) {
                this.parseLevelOverride(lists.levelOverrides, list);
            }
        }
    }
    parseLevelOverride(data, list) {
        if (isNullOrUndefined(data)) {
            return;
        }
        for (let i = 0; i < data.length; i++) {
            let levelOverrides = new WLevelOverride();
            let levelOverride = data[i];
            levelOverrides.startAt = levelOverride.startAt;
            levelOverrides.levelNumber = levelOverride.levelNumber;
            if (!isNullOrUndefined(levelOverride.overrideListLevel)) {
                levelOverrides.overrideListLevel = this.parseListLevel(levelOverride.overrideListLevel, levelOverrides);
            }
            list.levelOverrides.push(levelOverrides);
        }
    }
    parseSections(data, sections) {
        for (let i = 0; i < data.length; i++) {
            let section = new BodyWidget();
            section.sectionFormat = new WSectionFormat(section);
            section.index = i;
            let item = data[i];
            if (!isNullOrUndefined(item.sectionFormat)) {
                this.parseSectionFormat(item.sectionFormat, section.sectionFormat);
            }
            if (isNullOrUndefined(item.headersFooters)) {
                item.headersFooters = {};
            }
            this.viewer.headersFooters.push(this.parseHeaderFooter(item.headersFooters, this.viewer.headersFooters));
            this.parseTextBody(item.blocks, section, i + 1 < data.length);
            for (let i = 0; i < section.childWidgets.length; i++) {
                section.childWidgets[i].containerWidget = section;
            }
            sections.push(section);
        }
    }
    /**
     * @private
     */
    parseHeaderFooter(data, headersFooters) {
        let hfs = {};
        if (!isNullOrUndefined(data.header)) {
            let oddHeader = new HeaderFooterWidget('OddHeader');
            hfs[0] = oddHeader;
            this.parseTextBody(data.header.blocks, oddHeader);
        }
        if (!isNullOrUndefined(data.footer)) {
            let oddFooter = new HeaderFooterWidget('OddFooter');
            hfs[1] = oddFooter;
            this.parseTextBody(data.footer.blocks, oddFooter);
        }
        if (!isNullOrUndefined(data.evenHeader)) {
            let evenHeader = new HeaderFooterWidget('EvenHeader');
            hfs[2] = evenHeader;
            this.parseTextBody(data.evenHeader.blocks, evenHeader);
        }
        if (!isNullOrUndefined(data.evenFooter)) {
            let evenFooter = new HeaderFooterWidget('EvenFooter');
            hfs[3] = evenFooter;
            this.parseTextBody(data.evenFooter.blocks, evenFooter);
        }
        if (!isNullOrUndefined(data.firstPageHeader)) {
            let firstPageHeader = new HeaderFooterWidget('FirstPageHeader');
            hfs[4] = firstPageHeader;
            this.parseTextBody(data.firstPageHeader.blocks, firstPageHeader);
        }
        if (!isNullOrUndefined(data.firstPageFooter)) {
            let firstPageFooter = new HeaderFooterWidget('FirstPageFooter');
            hfs[5] = firstPageFooter;
            this.parseTextBody(data.firstPageFooter.blocks, firstPageFooter);
        }
        return hfs;
    }
    parseTextBody(data, section, isSectionBreak) {
        this.parseBody(data, section.childWidgets, section, isSectionBreak);
    }
    parseBody(data, blocks, container, isSectionBreak) {
        if (!isNullOrUndefined(data)) {
            for (let i = 0; i < data.length; i++) {
                let block = data[i];
                let hasValidElmts = false;
                if (block.hasOwnProperty('inlines')) {
                    let writeInlineFormat = false;
                    //writeInlineFormat = this.isPasting && i === data.length - 1;
                    let paragraph = new ParagraphWidget();
                    paragraph.characterFormat = new WCharacterFormat(paragraph);
                    paragraph.paragraphFormat = new WParagraphFormat(paragraph);
                    if (block.inlines.length > 0) {
                        hasValidElmts = this.parseParagraph(block.inlines, paragraph, writeInlineFormat);
                    }
                    if (!(isSectionBreak && block === data[data.length - 1] && !hasValidElmts)) {
                        this.parseCharacterFormat(block.characterFormat, paragraph.characterFormat);
                        this.parseParagraphFormat(block.paragraphFormat, paragraph.paragraphFormat);
                        let styleObj;
                        if (!isNullOrUndefined(block.paragraphFormat) && !isNullOrUndefined(block.paragraphFormat.styleName)) {
                            styleObj = this.viewer.styles.findByName(block.paragraphFormat.styleName, 'Paragraph');
                            if (!isNullOrUndefined(styleObj)) {
                                paragraph.paragraphFormat.ApplyStyle(styleObj);
                            }
                        }
                        blocks.push(paragraph);
                    }
                    else if (isSectionBreak && data.length === 1) {
                        blocks.push(paragraph);
                    }
                    paragraph.index = i;
                    paragraph.containerWidget = container;
                }
                else if (block.hasOwnProperty('rows')) {
                    this.parseTable(block, blocks, i, container);
                }
            }
        }
    }
    parseTable(block, blocks, index, section) {
        let table = new TableWidget();
        table.index = index;
        table.tableFormat = new WTableFormat(table);
        if (!isNullOrUndefined(block.tableFormat)) {
            this.parseTableFormat(block.tableFormat, table.tableFormat);
        }
        table.title = block.title;
        table.description = block.description;
        for (let i = 0; i < block.rows.length; i++) {
            let row = new TableRowWidget();
            row.rowFormat = new WRowFormat(row);
            let tableRow = block.rows[i];
            if (tableRow.hasOwnProperty('rowFormat')) {
                this.parseRowFormat(tableRow.rowFormat, row.rowFormat);
                this.parseRowGridValues(tableRow, row.rowFormat);
                this.parseRowGridValues(tableRow.rowFormat, row.rowFormat);
                row.index = i;
                for (let j = 0; j < block.rows[i].cells.length; j++) {
                    let cell = new TableCellWidget();
                    cell.cellFormat = new WCellFormat(cell);
                    row.childWidgets.push(cell);
                    cell.containerWidget = row;
                    cell.index = j;
                    cell.rowIndex = i;
                    cell.columnIndex = j;
                    if (block.rows[i].cells[j].hasOwnProperty('cellFormat')) {
                        this.parseCellFormat(block.rows[i].cells[j].cellFormat, cell.cellFormat);
                    }
                    this.isPageBreakInsideTable = true;
                    this.parseTextBody(block.rows[i].cells[j].blocks, cell, false);
                    this.isPageBreakInsideTable = false;
                }
            }
            table.childWidgets.push(row);
            row.containerWidget = table;
        }
        table.containerWidget = section;
        blocks.push(table);
        table.isGridUpdated = false;
    }
    parseRowGridValues(data, rowFormat) {
        if (!isNullOrUndefined(data.gridBefore)) {
            rowFormat.gridBefore = data.gridBefore;
        }
        if (!isNullOrUndefined(data.gridBeforeWidth)) {
            rowFormat.gridBeforeWidth = data.gridBeforeWidth;
        }
        if (!isNullOrUndefined(data.gridBeforeWidthType)) {
            rowFormat.gridBeforeWidthType = data.gridBeforeWidthType;
        }
        if (!isNullOrUndefined(data.gridAfter)) {
            rowFormat.gridAfter = data.gridAfter;
        }
        if (!isNullOrUndefined(data.gridAfterWidth)) {
            rowFormat.gridAfterWidth = data.gridAfterWidth;
        }
        if (!isNullOrUndefined(data.gridAfterWidthType)) {
            rowFormat.gridAfterWidthType = data.gridAfterWidthType;
        }
    }
    // tslint:disable:max-func-body-length
    parseParagraph(data, paragraph, writeInlineFormat) {
        let lineWidget = new LineWidget(paragraph);
        let hasValidElmts = false;
        for (let i = 0; i < data.length; i++) {
            let inline = data[i];
            if (inline.hasOwnProperty('text')) {
                let textElement = undefined;
                if (this.viewer.isPageField) {
                    textElement = new FieldTextElementBox();
                    textElement.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                }
                else if (inline.text === '\t') {
                    textElement = new TabElementBox();
                }
                else if (inline.text === '\f' && this.isPageBreakInsideTable) {
                    continue;
                }
                else {
                    textElement = new TextElementBox();
                }
                textElement.characterFormat = new WCharacterFormat(textElement);
                this.parseCharacterFormat(inline.characterFormat, textElement.characterFormat, writeInlineFormat);
                this.applyCharacterStyle(inline, textElement);
                textElement.text = inline.text;
                textElement.line = lineWidget;
                lineWidget.children.push(textElement);
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('chartType')) {
                // chartPreservation
                let chartElement = new ChartElementBox();
                chartElement.title = inline.chartTitle;
                chartElement.type = inline.chartType;
                chartElement.chartGapWidth = inline.gapWidth;
                chartElement.chartOverlap = inline.overlap;
                this.parseChartTitleArea(inline.chartTitleArea, chartElement.chartTitleArea);
                this.parseChartArea(inline.chartArea, chartElement.chartArea);
                this.parseChartArea(inline.plotArea, chartElement.chartPlotArea);
                this.parseChartLegend(inline.chartLegend, chartElement.chartLegend);
                this.parseChartData(inline, chartElement);
                this.parseChartCategoryAxis(inline.chartPrimaryCategoryAxis, chartElement.chartPrimaryCategoryAxis);
                this.parseChartCategoryAxis(inline.chartPrimaryValueAxis, chartElement.chartPrimaryValueAxis);
                if (inline.chartDataTable != null) {
                    this.parseChartDataTable(inline.chartDataTable, chartElement.chartDataTable);
                }
                chartElement.line = lineWidget;
                lineWidget.children.push(chartElement);
                chartElement.height = HelperMethods.convertPointToPixel(inline.height);
                chartElement.width = HelperMethods.convertPointToPixel(inline.width);
                let officeChart = new ChartComponent();
                officeChart.chartRender(inline);
                chartElement.officeChart = officeChart;
                officeChart.chart.appendTo(chartElement.targetElement);
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('imageString')) {
                let image = new ImageElementBox(data[i].isInlineImage);
                image.isMetaFile = data[i].isMetaFile;
                image.characterFormat = new WCharacterFormat(image);
                image.line = lineWidget;
                lineWidget.children.push(image);
                let imageString = HelperMethods.formatClippedString(inline.imageString).formatClippedString;
                let isValidImage = this.validateImageUrl(imageString);
                if (!isValidImage) {
                    // tslint:disable-next-line:max-line-length
                    image.imageString = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOEAAADhCAMAAAAJbSJIAAAAgVBMVEX///8AAADgAADY2Njl5eVcXFxjY2NZWVl/f3+wsLCmpqb4+PiioqKpqam7u7vV1dX2uLj2wsLhFRXzpKT3vb30sbHhCwv74+P40dH+9vbkIyO2trbBwcHLy8tsbGycnJz529v4zMzrbGzlLS3qZmblNzfrdXXoRkbvi4vvgYHlHh7CZsBOAAADpUlEQVR4nO3da1faQBSF4ekAUQlUEFs14AXxVv7/D6yaQiZx5mSEYXF2ut+PNKzyyK5diYDmR9czx34AB49C/CjE759w3jvvWr15Tdgz3atXE54f++EcIArxoxA/CvGjED8K8aMQPwrxoxA/CvGLEeZ9jPJdhfk4GyCUjb3ECGE/Q6m/q3DwfudjP0ERZYN9hKdn2hvd3+0jHJz5/kBVuTk96bbQUEjhYR9ckiikUH8UUqg/CinUH4UU6o9CCvVHIYX6o5BC/VFIof4opFB/FFKoPwop1B+FFOqPQgrjyxfjVC38Lxk9tnAxGqZqdKtSOE4GHA5/fuNJpDCtcNHbv4VqYYqPLjgfUViPQgrjozA2CptRSGF8/59w+Wrt+rr1btNna1cPzg0wwuXavncxabnX7PfHYYXzlYARvlobQZyUR9mXm+1NMEK7SSLONgcVV9vb8IQXv4J3KSeKKlxXxNCzONkeYp8AV3p9UT1+P3FWHVAsq5thhGZSEb1DrSZq7dS5HUdoLiuBZ6jORG3tCwAkNJfCUJ2Jrqe1P0ESCkMNTdSACYNDDU7UoAkDQw1P1MAJvUMVJmrwhJ6hShM1gMIvQxUnahCFjaHKEzWQQneoxR95ogZTWBuqPFEDKnSHKk/UoArdoYoTNbDC5lBDEzW4QjMpYiZqgIXG/S76JhwHK5zVVipcnkIVuv/RW/HyFKhwYhuFr6NiCmdNoDBUSGFjovJQEYXuRN9ahwoorJ8uSZenPsMTNk+X2q6jwgm/ntHL11HhhL4zenmoYEL/Gb04VCxh6KKTNFQoYfiikzBUJKF00Sk8VCChfF00OFQcYdt10dBQYYRT5xn0n9G7Q0X8GfCzNNEyZ6iPgD/HlydaVg11DfhajJaJlm2HugIUrlomWrYZKuJKHz6vHhbSM/hROdRnxNe1meuXYvW0DB6+aflYrB7dlzDiCM3N1dVN6GDhMCDhjlHYjEIK46MwNgqbUUhhfJ/vA07wO8N1vw94ONo/3e/lTpVOYfc/UyG//ZmqW52fi/FuTNW3/lZ+eguF+qOQQv1RSKH+KKRQfxRSqD8KKdQfhRTqj0IK9UchhfqjkEL9UUih/iikUH8UUqg/CmXh6Hsv3jlK+wnvD/vgkrSHMMuyu1P9ZdmuwnycDQYn+svG3n9KEUKT9zHyf6+IEWJHIX4U4kchfhTiRyF+FOJHIX4U4kchfnVhijeZa6sunCf4ZdPamteEHY5C/CjEr/vCv0ec0g+AtS1QAAAAAElFTkSuQmCC';
                }
                else {
                    image.imageString = inline.imageString;
                }
                image.width = HelperMethods.convertPointToPixel(inline.width);
                image.height = HelperMethods.convertPointToPixel(inline.height);
                this.parseCharacterFormat(inline.characterFormat, image.characterFormat);
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('hasFieldEnd') || (inline.hasOwnProperty('fieldType') && inline.fieldType === 0)) {
                let fieldBegin = new FieldElementBox(0);
                this.parseCharacterFormat(inline.characterFormat, fieldBegin.characterFormat, writeInlineFormat);
                this.applyCharacterStyle(inline, fieldBegin);
                fieldBegin.fieldCodeType = inline.fieldCodeType;
                fieldBegin.hasFieldEnd = inline.hasFieldEnd;
                this.viewer.fieldStacks.push(fieldBegin);
                fieldBegin.line = lineWidget;
                this.viewer.fields.push(fieldBegin);
                lineWidget.children.push(fieldBegin);
            }
            else if (inline.hasOwnProperty('fieldType')) {
                let field = undefined;
                if (inline.fieldType === 2) {
                    field = new FieldElementBox(2);
                    this.fieldSeparator = field;
                    if (this.viewer.fieldStacks.length > 0) {
                        field.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                        field.fieldBegin.fieldSeparator = field;
                        //finds the whether the field is page filed or not
                        let lineWidgetCount = lineWidget.children.length;
                        if (lineWidgetCount >= 2 && (lineWidget.children[lineWidgetCount - 2] instanceof FieldElementBox)
                            && lineWidget.children[lineWidgetCount - 2].hasFieldEnd
                            && (lineWidget.children[lineWidgetCount - 1] instanceof TextElementBox)) {
                            let fieldElementText = lineWidget.children[lineWidgetCount - 1].text;
                            if (fieldElementText.match('PAGE')) {
                                this.viewer.isPageField = true;
                            }
                        }
                    }
                }
                else if (inline.fieldType === 1) {
                    field = new FieldElementBox(1);
                    this.parseCharacterFormat(inline.characterFormat, field.characterFormat, writeInlineFormat);
                    this.applyCharacterStyle(inline, field);
                    //For Field End Updated begin and separator.                                      
                    if (this.viewer.fieldStacks.length > 0) {
                        field.fieldBegin = this.viewer.fieldStacks[this.viewer.fieldStacks.length - 1];
                        field.fieldBegin.fieldEnd = field;
                    }
                    if (!isNullOrUndefined(field.fieldBegin) && field.fieldBegin.fieldSeparator) {
                        field.fieldSeparator = field.fieldBegin.fieldSeparator;
                        field.fieldBegin.fieldSeparator.fieldEnd = field;
                        hasValidElmts = true;
                    }
                    //After setting all the property clear the field values
                    this.viewer.fieldStacks.splice(this.viewer.fieldStacks.length - 1, 1);
                    this.fieldSeparator = undefined;
                    this.viewer.isPageField = false;
                    this.viewer.fieldCollection.push(field.fieldBegin);
                }
                field.line = lineWidget;
                lineWidget.children.push(field);
            }
            else if (inline.hasOwnProperty('bookmarkType')) {
                let bookmark = undefined;
                bookmark = new BookmarkElementBox(inline.bookmarkType);
                bookmark.name = inline.name;
                lineWidget.children.push(bookmark);
                bookmark.line = lineWidget;
                if (inline.bookmarkType === 0) {
                    this.viewer.bookmarks.add(bookmark.name, bookmark);
                }
                else if (inline.bookmarkType === 1) {
                    if (this.viewer.bookmarks.containsKey(bookmark.name)) {
                        let bookmarkStart = this.viewer.bookmarks.get(bookmark.name);
                        bookmarkStart.reference = bookmark;
                        bookmark.reference = bookmarkStart;
                    }
                }
                if (bookmark.name.indexOf('_') !== 0) {
                    hasValidElmts = true;
                }
            }
            else if (inline.hasOwnProperty('editRangeId')) {
                if (inline.hasOwnProperty('editableRangeStart')) {
                    let permEnd = new EditRangeEndElementBox();
                    if (this.editableRanges.containsKey(inline.editRangeId)) {
                        let start = this.editableRanges.get(inline.editRangeId);
                        permEnd.editRangeStart = start;
                        start.editRangeEnd = permEnd;
                        this.editableRanges.remove(inline.editRangeId);
                    }
                    lineWidget.children.push(permEnd);
                    permEnd.line = lineWidget;
                }
                else {
                    let permStart = this.parseEditableRangeStart(inline);
                    lineWidget.children.push(permStart);
                    permStart.line = lineWidget;
                    if (!this.editableRanges.containsKey(inline.editRangeId)) {
                        this.editableRanges.add(inline.editRangeId, permStart);
                    }
                }
                hasValidElmts = true;
            }
            else if (inline.hasOwnProperty('commentId')) {
                let commentID = inline.commentId;
                let commentStart = undefined;
                if (this.commentStarts.containsKey(commentID)) {
                    commentStart = this.commentStarts.get(commentID);
                }
                let commentEnd = undefined;
                if (this.commentEnds.containsKey(commentID)) {
                    commentEnd = this.commentEnds.get(commentID);
                }
                if (inline.hasOwnProperty('commentCharacterType')) {
                    if (inline.commentCharacterType === 0) {
                        let commentStartElement = new CommentCharacterElementBox(0);
                        commentStartElement.commentId = commentID;
                        if (!this.commentStarts.containsKey(commentID)) {
                            this.commentStarts.add(commentID, commentStartElement);
                        }
                        commentStartElement.line = lineWidget;
                        lineWidget.children.push(commentStartElement);
                        let comment = this.commentsCollection.get(commentID);
                        if (!isNullOrUndefined(comment)) {
                            comment.commentStart = commentStartElement;
                            commentStartElement.comment = comment;
                        }
                    }
                    else {
                        let commentEndElement = new CommentCharacterElementBox(1);
                        commentEndElement.commentId = commentID;
                        if (!this.commentEnds.containsKey(commentID)) {
                            this.commentEnds.add(commentID, commentEndElement);
                        }
                        commentEndElement.line = lineWidget;
                        lineWidget.children.push(commentEndElement);
                        let comment = this.commentsCollection.get(commentID);
                        if (!isNullOrUndefined(comment)) {
                            comment.commentEnd = commentEndElement;
                            commentEndElement.comment = comment;
                        }
                    }
                }
            }
        }
        paragraph.childWidgets.push(lineWidget);
        return hasValidElmts;
    }
    applyCharacterStyle(inline, elementbox) {
        /*�tslint:disable-next-line:max-line-length */
        if (!isNullOrUndefined(inline.characterFormat) && !isNullOrUndefined(inline.characterFormat.styleName)) {
            let charStyle = this.viewer.styles.findByName(inline.characterFormat.styleName, 'Character');
            elementbox.characterFormat.ApplyStyle(charStyle);
        }
    }
    parseEditableRangeStart(data) {
        let permStart = new EditRangeStartElementBox();
        if (!isNullOrUndefined(data.columnFirst)) {
            permStart.columnFirst = data.columnFirst;
        }
        if (!isNullOrUndefined(data.columnLast)) {
            permStart.columnLast = data.columnLast;
        }
        if (!isNullOrUndefined(data.user)) {
            permStart.user = data.user;
            if (this.viewer.userCollection.indexOf(permStart.user) === -1) {
                this.viewer.userCollection.push(permStart.user);
            }
            this.addEditRangeCollection(permStart.user, permStart);
        }
        if (!isNullOrUndefined(data.group)) {
            permStart.group = data.group;
            permStart.group = permStart.group === 'everyone' ? 'Everyone' : permStart.group;
            if (this.viewer.userCollection.indexOf(permStart.group) === -1) {
                this.viewer.userCollection.push(permStart.group);
            }
            this.addEditRangeCollection(permStart.group, permStart);
        }
        return permStart;
    }
    addEditRangeCollection(name, permStart) {
        if (this.viewer.editRanges.containsKey(name)) {
            let editStartCollection = this.viewer.editRanges.get(name);
            editStartCollection.push(permStart);
        }
        else {
            let newEditStartCollection = [];
            newEditStartCollection.push(permStart);
            this.viewer.editRanges.add(name, newEditStartCollection);
        }
    }
    parseChartTitleArea(titleArea, chartTitleArea) {
        chartTitleArea.chartfontName = titleArea.fontName;
        chartTitleArea.chartFontSize = titleArea.fontSize;
        this.parseChartDataFormat(titleArea.dataFormat, chartTitleArea.dataFormat);
        this.parseChartLayout(titleArea.layout, chartTitleArea.layout);
    }
    parseChartDataFormat(format, dataFormat) {
        dataFormat.fill.color = format.fill.foreColor;
        dataFormat.fill.rgb = format.fill.rgb;
        dataFormat.line.color = format.line.color;
        dataFormat.line.rgb = format.line.rgb;
    }
    parseChartLayout(layout, chartLayout) {
        chartLayout.chartLayoutLeft = layout.layoutX;
        chartLayout.chartLayoutTop = layout.layoutY;
    }
    parseChartLegend(legend, chartLegend) {
        chartLegend.chartLegendPostion = legend.position;
        this.parseChartTitleArea(legend.chartTitleArea, chartLegend.chartTitleArea);
    }
    parseChartCategoryAxis(categoryAxis, primaryAxis) {
        primaryAxis.categoryAxisType = categoryAxis.categoryType;
        primaryAxis.categoryNumberFormat = categoryAxis.numberFormat;
        primaryAxis.interval = categoryAxis.majorUnit;
        primaryAxis.axisFontSize = categoryAxis.fontSize;
        primaryAxis.axisFontName = categoryAxis.fontName;
        primaryAxis.max = categoryAxis.maximumValue;
        primaryAxis.min = categoryAxis.minimumValue;
        primaryAxis.majorGridLines = categoryAxis.hasMajorGridLines;
        primaryAxis.minorGridLines = categoryAxis.hasMinorGridLines;
        primaryAxis.majorTick = categoryAxis.majorTickMark;
        primaryAxis.minorTick = categoryAxis.minorTickMark;
        primaryAxis.tickPosition = categoryAxis.tickLabelPosition;
        primaryAxis.categoryAxisTitle = categoryAxis.chartTitle;
        if (categoryAxis.chartTitle != null) {
            this.parseChartTitleArea(categoryAxis.chartTitleArea, primaryAxis.chartTitleArea);
        }
    }
    parseChartDataTable(dataTable, chartDataTable) {
        chartDataTable.showSeriesKeys = dataTable.showSeriesKeys;
        chartDataTable.hasHorzBorder = dataTable.hasHorzBorder;
        chartDataTable.hasVertBorder = dataTable.hasVertBorder;
        chartDataTable.hasBorders = dataTable.hasBorders;
    }
    parseChartArea(area, chartArea) {
        chartArea.chartForeColor = area.foreColor;
    }
    parseChartData(inline, chart) {
        for (let i = 0; i < inline.chartCategory.length; i++) {
            let chartCategory = new ChartCategory();
            let xData = inline.chartCategory[i];
            if (xData.hasOwnProperty('categoryXName')) {
                chartCategory.xName = xData.categoryXName;
            }
            for (let j = 0; j < xData.chartData.length; j++) {
                let chartData = new ChartData();
                let yData = xData.chartData[j];
                chartData.yAxisValue = yData.yValue;
                if (inline.chartType === 'Bubble') {
                    chartData.bubbleSize = yData.size;
                }
                chartCategory.chartData.push(chartData);
            }
            chart.chartCategory.push(chartCategory);
        }
        this.parseChartSeries(inline, chart);
    }
    parseChartSeries(inline, chart) {
        let chartType = inline.chartType;
        let isPieType = (chartType === 'Pie' || chartType === 'Doughnut');
        for (let i = 0; i < inline.chartSeries.length; i++) {
            let chartSeries = new ChartSeries();
            let xData = inline.chartSeries[i];
            if (xData.hasOwnProperty('seriesName')) {
                chartSeries.seriesName = xData.seriesName;
                if (isPieType) {
                    if (xData.hasOwnProperty('firstSliceAngle')) {
                        chartSeries.firstSliceAngle = xData.firstSliceAngle;
                    }
                    if (chartType === 'Doughnut') {
                        chartSeries.doughnutHoleSize = xData.holeSize;
                    }
                }
                if (xData.hasOwnProperty('dataLabel')) {
                    this.parseChartDataLabels(xData.dataLabel, chartSeries);
                }
                if (xData.hasOwnProperty('seriesFormat')) {
                    let seriesFormat = new ChartSeriesFormat();
                    let format = xData.seriesFormat;
                    seriesFormat.markerStyle = format.markerStyle;
                    seriesFormat.markerColor = format.markerColor;
                    seriesFormat.numberValue = format.markerSize;
                    chartSeries.seriesFormat = seriesFormat;
                }
                if (xData.hasOwnProperty('errorBar')) {
                    let errorBar = chartSeries.errorBar;
                    errorBar.errorType = xData.errorBar.type;
                    errorBar.errorDirection = xData.errorBar.direction;
                    errorBar.errorEndStyle = xData.errorBar.endStyle;
                    errorBar.numberValue = xData.errorBar.numberValue;
                }
                if (xData.hasOwnProperty('trendLines')) {
                    this.parseChartTrendLines(xData.trendLines, chartSeries);
                }
                this.parseChartSeriesDataPoints(xData.dataPoints, chartSeries);
            }
            chart.chartSeries.push(chartSeries);
        }
    }
    parseChartDataLabels(dataLabels, series) {
        let dataLabel = new ChartDataLabels();
        dataLabel.labelPosition = dataLabels.position;
        dataLabel.fontName = dataLabels.fontName;
        dataLabel.fontColor = dataLabels.fontColor;
        dataLabel.fontSize = dataLabels.fontSize;
        dataLabel.isLegendKey = dataLabels.isLegendKey;
        dataLabel.isBubbleSize = dataLabels.isBubbleSize;
        dataLabel.isCategoryName = dataLabels.isCategoryName;
        dataLabel.isSeriesName = dataLabels.isSeriesName;
        dataLabel.isValue = dataLabels.isValue;
        dataLabel.isPercentage = dataLabels.isPercentage;
        dataLabel.isLeaderLines = dataLabels.isLeaderLines;
        series.dataLabels = dataLabel;
    }
    parseChartSeriesDataPoints(dataPoints, series) {
        for (let i = 0; i < dataPoints.length; i++) {
            let chartFormat = new ChartDataFormat();
            this.parseChartDataFormat(dataPoints[i], chartFormat);
            series.chartDataFormat.push(chartFormat);
        }
    }
    parseChartTrendLines(trendLines, series) {
        for (let i = 0; i < trendLines.length; i++) {
            let data = trendLines[i];
            let trendLine = new ChartTrendLines();
            trendLine.trendLineName = data.name;
            trendLine.trendLineType = data.type;
            trendLine.forwardValue = data.forward;
            trendLine.backwardValue = data.backward;
            trendLine.interceptValue = data.intercept;
            trendLine.isDisplayEquation = data.isDisplayEquation;
            trendLine.isDisplayRSquared = data.isDisplayRSquared;
            series.trendLines.push(trendLine);
        }
    }
    parseTableFormat(sourceFormat, tableFormat) {
        this.parseBorders(sourceFormat.borders, tableFormat.borders);
        if (!isNullOrUndefined(sourceFormat.allowAutoFit)) {
            tableFormat.allowAutoFit = sourceFormat.allowAutoFit;
        }
        if (!isNullOrUndefined(sourceFormat.cellSpacing)) {
            tableFormat.cellSpacing = sourceFormat.cellSpacing;
        }
        if (!isNullOrUndefined(sourceFormat.leftMargin)) {
            tableFormat.leftMargin = sourceFormat.leftMargin;
        }
        if (!isNullOrUndefined(sourceFormat.topMargin)) {
            tableFormat.topMargin = sourceFormat.topMargin;
        }
        if (!isNullOrUndefined(sourceFormat.rightMargin)) {
            tableFormat.rightMargin = sourceFormat.rightMargin;
        }
        if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
            tableFormat.bottomMargin = sourceFormat.bottomMargin;
        }
        if (!isNullOrUndefined(sourceFormat.leftIndent)) {
            tableFormat.leftIndent = sourceFormat.leftIndent;
        }
        this.parseShading(sourceFormat.shading, tableFormat.shading);
        if (!isNullOrUndefined(sourceFormat.tableAlignment)) {
            tableFormat.tableAlignment = sourceFormat.tableAlignment;
        }
        if (!isNullOrUndefined(sourceFormat.preferredWidth)) {
            tableFormat.preferredWidth = sourceFormat.preferredWidth;
        }
        if (!isNullOrUndefined(sourceFormat.preferredWidthType)) {
            tableFormat.preferredWidthType = sourceFormat.preferredWidthType;
        }
        if (!isNullOrUndefined(sourceFormat.bidi)) {
            tableFormat.bidi = sourceFormat.bidi;
        }
    }
    parseCellFormat(sourceFormat, cellFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            this.parseBorders(sourceFormat.borders, cellFormat.borders);
            if (!sourceFormat.isSamePaddingAsTable) {
                //    cellFormat.ClearMargins();
                //else
                this.parseCellMargin(sourceFormat, cellFormat);
            }
            if (!isNullOrUndefined(sourceFormat.cellWidth)) {
                cellFormat.cellWidth = sourceFormat.cellWidth;
            }
            if (!isNullOrUndefined(sourceFormat.columnSpan)) {
                cellFormat.columnSpan = sourceFormat.columnSpan;
            }
            if (!isNullOrUndefined(sourceFormat.rowSpan)) {
                cellFormat.rowSpan = sourceFormat.rowSpan;
            }
            this.parseShading(sourceFormat.shading, cellFormat.shading);
            if (!isNullOrUndefined(sourceFormat.verticalAlignment)) {
                cellFormat.verticalAlignment = sourceFormat.verticalAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.preferredWidthType)) {
                cellFormat.preferredWidthType = sourceFormat.preferredWidthType;
            }
            if (!isNullOrUndefined(sourceFormat.preferredWidth)) {
                cellFormat.preferredWidth = sourceFormat.preferredWidth;
            }
        }
    }
    parseCellMargin(sourceFormat, cellFormat) {
        if (!isNullOrUndefined(sourceFormat.leftMargin)) {
            cellFormat.leftMargin = sourceFormat.leftMargin;
        }
        if (!isNullOrUndefined(sourceFormat.rightMargin)) {
            cellFormat.rightMargin = sourceFormat.rightMargin;
        }
        if (!isNullOrUndefined(sourceFormat.topMargin)) {
            cellFormat.topMargin = sourceFormat.topMargin;
        }
        if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
            cellFormat.bottomMargin = sourceFormat.bottomMargin;
        }
    }
    parseRowFormat(sourceFormat, rowFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (!isNullOrUndefined(sourceFormat.allowBreakAcrossPages)) {
                rowFormat.allowBreakAcrossPages = sourceFormat.allowBreakAcrossPages;
            }
            if (!isNullOrUndefined(sourceFormat.isHeader)) {
                rowFormat.isHeader = sourceFormat.isHeader;
            }
            if (!isNullOrUndefined(sourceFormat.heightType)) {
                rowFormat.heightType = sourceFormat.heightType;
            }
            if (!isNullOrUndefined(sourceFormat.height)) {
                rowFormat.height = sourceFormat.height;
            }
            if (!isNullOrUndefined(sourceFormat.leftMargin)) {
                rowFormat.leftMargin = sourceFormat.leftMargin;
            }
            if (!isNullOrUndefined(sourceFormat.topMargin)) {
                rowFormat.topMargin = sourceFormat.topMargin;
            }
            if (!isNullOrUndefined(sourceFormat.rightMargin)) {
                rowFormat.rightMargin = sourceFormat.rightMargin;
            }
            if (!isNullOrUndefined(sourceFormat.bottomMargin)) {
                rowFormat.bottomMargin = sourceFormat.bottomMargin;
            }
            if (!isNullOrUndefined(sourceFormat.leftIndent)) {
                rowFormat.leftIndent = sourceFormat.leftIndent;
            }
            this.parseBorders(sourceFormat.borders, rowFormat.borders);
        }
    }
    parseBorders(sourceBorders, destBorder) {
        if (!isNullOrUndefined(sourceBorders)) {
            this.parseBorder(sourceBorders.left, destBorder.left);
            this.parseBorder(sourceBorders.right, destBorder.right);
            this.parseBorder(sourceBorders.top, destBorder.top);
            this.parseBorder(sourceBorders.bottom, destBorder.bottom);
            this.parseBorder(sourceBorders.vertical, destBorder.vertical);
            this.parseBorder(sourceBorders.horizontal, destBorder.horizontal);
            this.parseBorder(sourceBorders.diagonalDown, destBorder.diagonalDown);
            this.parseBorder(sourceBorders.diagonalUp, destBorder.diagonalUp);
        }
    }
    parseBorder(sourceBorder, destBorder) {
        if (!isNullOrUndefined(sourceBorder)) {
            if (!isNullOrUndefined(sourceBorder.color)) {
                destBorder.color = this.getColor(sourceBorder.color);
            }
            if (!isNullOrUndefined(sourceBorder.lineStyle)) {
                destBorder.lineStyle = sourceBorder.lineStyle;
            }
            if (!isNullOrUndefined(sourceBorder.lineWidth)) {
                destBorder.lineWidth = sourceBorder.lineWidth;
            }
            if (!isNullOrUndefined(sourceBorder.hasNoneStyle)) {
                destBorder.hasNoneStyle = sourceBorder.hasNoneStyle;
            }
        }
    }
    parseShading(sourceShading, destShading) {
        if (!isNullOrUndefined(sourceShading)) {
            if (!isNullOrUndefined(sourceShading.backgroundColor)) {
                destShading.backgroundColor = this.getColor(sourceShading.backgroundColor);
            }
            if (!isNullOrUndefined(sourceShading.foregroundColor)) {
                destShading.foregroundColor = this.getColor(sourceShading.foregroundColor);
            }
            if (!isNullOrUndefined(sourceShading.texture) || !isNullOrUndefined(sourceShading.textureStyle)) {
                destShading.textureStyle = !isNullOrUndefined(sourceShading.texture) ? sourceShading.texture : sourceShading.textureStyle;
            }
        }
    }
    /**
     * @private
     */
    parseCharacterFormat(sourceFormat, characterFormat, writeInlineFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (writeInlineFormat && sourceFormat.hasOwnProperty('inlineFormat')) {
                this.parseCharacterFormat(sourceFormat.inlineFormat, characterFormat);
                return;
            }
            if (!isNullOrUndefined(sourceFormat.baselineAlignment)) {
                characterFormat.baselineAlignment = sourceFormat.baselineAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.underline)) {
                characterFormat.underline = sourceFormat.underline;
            }
            if (!isNullOrUndefined(sourceFormat.strikethrough)) {
                characterFormat.strikethrough = sourceFormat.strikethrough;
            }
            if (!isNullOrUndefined(sourceFormat.fontSize)) {
                characterFormat.fontSize = sourceFormat.fontSize;
            }
            if (!isNullOrUndefined(sourceFormat.fontFamily)) {
                if (sourceFormat.fontFamily.indexOf('"') !== -1) {
                    sourceFormat.fontFamily = sourceFormat.fontFamily.replace('"', '');
                }
                characterFormat.fontFamily = sourceFormat.fontFamily;
            }
            if (!isNullOrUndefined(sourceFormat.bold)) {
                characterFormat.bold = sourceFormat.bold;
            }
            if (!isNullOrUndefined(sourceFormat.italic)) {
                characterFormat.italic = sourceFormat.italic;
            }
            if (!isNullOrUndefined(sourceFormat.highlightColor)) {
                characterFormat.highlightColor = sourceFormat.highlightColor;
            }
            if (!isNullOrUndefined(sourceFormat.fontColor)) {
                characterFormat.fontColor = this.getColor(sourceFormat.fontColor);
            }
            if (!isNullOrUndefined(sourceFormat.bidi)) {
                characterFormat.bidi = sourceFormat.bidi;
            }
            if (!isNullOrUndefined(sourceFormat.bdo)) {
                characterFormat.bdo = sourceFormat.bdo;
            }
            if (!isNullOrUndefined(sourceFormat.fontSizeBidi)) {
                characterFormat.fontSizeBidi = sourceFormat.fontSizeBidi;
            }
            if (!isNullOrUndefined(sourceFormat.fontFamilyBidi)) {
                characterFormat.fontFamilyBidi = sourceFormat.fontFamilyBidi;
            }
            if (!isNullOrUndefined(sourceFormat.boldBidi)) {
                characterFormat.boldBidi = sourceFormat.boldBidi;
            }
            if (!isNullOrUndefined(sourceFormat.italicBidi)) {
                characterFormat.italicBidi = sourceFormat.italicBidi;
            }
        }
    }
    getColor(color) {
        let convertColor = color;
        return convertColor || '#ffffff';
    }
    /**
     * @private
     */
    parseParagraphFormat(sourceFormat, paragraphFormat) {
        if (!isNullOrUndefined(sourceFormat)) {
            if (!isNullOrUndefined(sourceFormat.bidi)) {
                paragraphFormat.bidi = sourceFormat.bidi;
            }
            if (!isNullOrUndefined(sourceFormat.leftIndent)) {
                paragraphFormat.leftIndent = sourceFormat.leftIndent;
            }
            if (!isNullOrUndefined(sourceFormat.rightIndent)) {
                paragraphFormat.rightIndent = sourceFormat.rightIndent;
            }
            if (!isNullOrUndefined(sourceFormat.firstLineIndent)) {
                paragraphFormat.firstLineIndent = sourceFormat.firstLineIndent;
            }
            if (!isNullOrUndefined(sourceFormat.afterSpacing)) {
                paragraphFormat.afterSpacing = sourceFormat.afterSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.beforeSpacing)) {
                paragraphFormat.beforeSpacing = sourceFormat.beforeSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.lineSpacing)) {
                paragraphFormat.lineSpacing = sourceFormat.lineSpacing;
            }
            if (!isNullOrUndefined(sourceFormat.lineSpacingType)) {
                paragraphFormat.lineSpacingType = sourceFormat.lineSpacingType;
            }
            if (!isNullOrUndefined(sourceFormat.textAlignment)) {
                paragraphFormat.textAlignment = sourceFormat.textAlignment;
            }
            if (!isNullOrUndefined(sourceFormat.outlineLevel)) {
                paragraphFormat.outlineLevel = sourceFormat.outlineLevel;
            }
            if (!isNullOrUndefined(sourceFormat.contextualSpacing)) {
                paragraphFormat.contextualSpacing = sourceFormat.contextualSpacing;
            }
            paragraphFormat.listFormat = new WListFormat();
            if (sourceFormat.hasOwnProperty('listFormat')) {
                this.parseListFormat(sourceFormat, paragraphFormat.listFormat);
            }
            if (sourceFormat.hasOwnProperty('tabs')) {
                this.parseTabStop(sourceFormat.tabs, paragraphFormat.tabs);
            }
        }
    }
    parseListFormat(block, listFormat) {
        if (!isNullOrUndefined(block.listFormat)) {
            if (!isNullOrUndefined(block.listFormat.listId)) {
                listFormat.listId = block.listFormat.listId;
                listFormat.list = this.viewer.getListById(block.listFormat.listId);
            }
            if (!isNullOrUndefined(block.listFormat.listLevelNumber)) {
                listFormat.listLevelNumber = block.listFormat.listLevelNumber;
            }
        }
    }
    /**
     *
     * @param data @private
     * @param sectionFormat
     */
    parseSectionFormat(data, sectionFormat) {
        if (!isNullOrUndefined(data.pageWidth)) {
            sectionFormat.pageWidth = data.pageWidth;
        }
        if (!isNullOrUndefined(data.pageHeight)) {
            sectionFormat.pageHeight = data.pageHeight;
        }
        if (!isNullOrUndefined(data.leftMargin)) {
            sectionFormat.leftMargin = data.leftMargin;
        }
        if (!isNullOrUndefined(data.topMargin)) {
            sectionFormat.topMargin = data.topMargin;
        }
        if (!isNullOrUndefined(data.rightMargin)) {
            sectionFormat.rightMargin = data.rightMargin;
        }
        if (!isNullOrUndefined(data.bottomMargin)) {
            sectionFormat.bottomMargin = data.bottomMargin;
        }
        if (!isNullOrUndefined(data.headerDistance)) {
            sectionFormat.headerDistance = data.headerDistance;
        }
        if (!isNullOrUndefined(data.footerDistance)) {
            sectionFormat.footerDistance = data.footerDistance;
        }
        if (!isNullOrUndefined(data.differentFirstPage)) {
            sectionFormat.differentFirstPage = data.differentFirstPage;
        }
        if (!isNullOrUndefined(data.differentOddAndEvenPages)) {
            sectionFormat.differentOddAndEvenPages = data.differentOddAndEvenPages;
        }
        if (!isNullOrUndefined(data.bidi)) {
            sectionFormat.bidi = data.bidi;
        }
        if (!isNullOrUndefined(data.restartPageNumbering)) {
            sectionFormat.restartPageNumbering = data.restartPageNumbering;
        }
        if (!isNullOrUndefined(data.pageStartingNumber)) {
            sectionFormat.pageStartingNumber = data.pageStartingNumber;
        }
    }
    parseTabStop(wTabs, tabs) {
        for (let i = 0; i < wTabs.length; i++) {
            let tabStop = new WTabStop();
            tabStop.position = wTabs[i].position;
            tabStop.tabLeader = wTabs[i].tabLeader;
            tabStop.deletePosition = wTabs[i].deletePosition;
            tabStop.tabJustification = wTabs[i].tabJustification;
            tabs.push(tabStop);
        }
    }
    validateImageUrl(imagestr) {
        let keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        imagestr = imagestr.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        let totalLength = imagestr.length * 3 / 4;
        if (imagestr.charAt(imagestr.length - 1) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (imagestr.charAt(imagestr.length - 2) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (totalLength % 1 !== 0) {
            // totalLength is not an integer, the length does not match a valid
            // base64 content. That can happen if:
            // - the imagestr is not a base64 content
            // - the imagestr is *almost* a base64 content, with a extra chars at the
            // beginning or at the end
            // - the imagestr uses a base64 variant (base64url for example)
            return false;
        }
        return true;
    }
}

/**
 * Viewer Export
 */

/**
 * Selection character format implementation
 */
class SelectionCharacterFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.highlightColorIn = undefined;
        this.fontSizeIn = 0;
        this.fontColorIn = undefined;
        /**
         * @private
         */
        this.boldBidi = undefined;
        /**
         * @private
         */
        this.italicBidi = undefined;
        /**
         * @private
         */
        this.fontSizeBidi = 0;
        /**
         * @private
         */
        this.bidi = undefined;
        /**
         * @private
         */
        this.bdo = undefined;
        this.selection = selection;
    }
    /**
     * Gets the font size of selected contents.
     * @aspType int
     * @blazorType int
     */
    get fontSize() {
        return this.fontSizeIn;
    }
    /**
     * Sets the font size of selected contents.
     * @aspType int
     * @blazorType int
     */
    set fontSize(value) {
        if (value === this.fontSizeIn) {
            return;
        }
        this.fontSizeIn = value;
        this.notifyPropertyChanged('fontSize');
    }
    /**
     * Gets or sets the font family of selected contents.
     * @aspType string
     * @blazorType string
     */
    get fontFamily() {
        return this.fontFamilyIn;
    }
    /**
     * Sets the font family of selected contents.
     * @aspType string
     * @blazorType string
     */
    set fontFamily(value) {
        if (value === this.fontFamilyIn) {
            return;
        }
        this.fontFamilyIn = value;
        this.notifyPropertyChanged('fontFamily');
    }
    /**
     * Gets or sets the font color of selected contents.
     * @aspType string
     * @blazorType string
     */
    get fontColor() {
        return this.fontColorIn;
    }
    /**
     * Sets the font color of selected contents.
     * @aspType string
     * @blazorType string
     */
    set fontColor(value) {
        if (value === this.fontColorIn) {
            return;
        }
        this.fontColorIn = value;
        this.notifyPropertyChanged('fontColor');
    }
    /**
     * Gets or sets the bold formatting of selected contents.
     * @aspType bool
     * @blazorType bool
     */
    get bold() {
        return this.boldIn;
    }
    /**
     * Sets the bold formatting of selected contents.
     * @aspType bool
     * @blazorType bool
     */
    set bold(value) {
        if (value === this.boldIn) {
            return;
        }
        this.boldIn = value;
        this.notifyPropertyChanged('bold');
    }
    /**
     * Gets or sets the italic formatting of selected contents.
     * @aspType bool
     * @blazorType bool
     */
    get italic() {
        return this.italicIn;
    }
    /**
     * Sets the italic formatting of selected contents.
     * @aspType bool
     * @blazorType bool
     */
    set italic(value) {
        if (value === this.italic) {
            return;
        }
        this.italicIn = value;
        this.notifyPropertyChanged('italic');
    }
    /**
     * Gets or sets the strikethrough property of selected contents.
     */
    get strikethrough() {
        return this.strikeThroughIn;
    }
    /**
     * Sets the strikethrough property of selected contents.
     */
    set strikethrough(value) {
        if (value === this.strikeThroughIn) {
            return;
        }
        this.strikeThroughIn = value;
        this.notifyPropertyChanged('strikethrough');
    }
    /**
     * Gets or sets the baseline alignment property of selected contents.
     */
    get baselineAlignment() {
        return this.baselineAlignmentIn;
    }
    /**
     * Sets the baseline alignment property of selected contents.
     */
    set baselineAlignment(value) {
        if (value === this.baselineAlignmentIn) {
            return;
        }
        this.baselineAlignmentIn = value;
        this.notifyPropertyChanged('baselineAlignment');
    }
    /**
     * Gets or sets the underline style of selected contents.
     */
    get underline() {
        return this.underlineIn;
    }
    /**
     * Sets the underline style of selected contents.
     */
    set underline(value) {
        if (value === this.underlineIn) {
            return;
        }
        this.underlineIn = value;
        this.notifyPropertyChanged('underline');
    }
    /**
     * Gets or sets the highlight color of selected contents.
     */
    get highlightColor() {
        return this.highlightColorIn;
    }
    /**
     * Sets the highlight color of selected contents.
     */
    set highlightColor(value) {
        if (value === this.highlightColorIn) {
            return;
        }
        this.highlightColorIn = value;
        this.notifyPropertyChanged('highlightColor');
    }
    getPropertyValue(property) {
        switch (property) {
            case 'bold':
                return this.bold;
            case 'italic':
                return this.italic;
            case 'fontSize':
                if (this.fontSize >= 1) {
                    return this.fontSize;
                }
                return undefined;
            case 'fontFamily':
                return this.fontFamily;
            case 'strikethrough':
                return this.strikethrough;
            case 'baselineAlignment':
                return this.baselineAlignment;
            case 'highlightColor':
                return this.highlightColor;
            case 'underline':
                return this.underline;
            case 'fontColor':
                return this.fontColor;
            default:
                return undefined;
        }
    }
    /**
     * Notifies whenever property gets changed.
     * @param  {string} propertyName
     */
    notifyPropertyChanged(propertyName) {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.selection) && (this.selection.isCleared || this.selection.owner.isReadOnlyMode || !this.selection.owner.isDocumentLoaded || this.selection.owner.isPastingContent) && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            let propertyValue = this.getPropertyValue(propertyName);
            if (!isNullOrUndefined(propertyValue)) {
                this.selection.owner.editorModule.onApplyCharacterFormat(propertyName, propertyValue);
            }
        }
    }
    /**
     * Copies the source format.
     * @param  {WCharacterFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.styleName = !isNullOrUndefined(format.baseCharStyle) ? format.baseCharStyle.name : 'Default Paragraph Font';
        this.fontSize = format.fontSize;
        this.fontFamily = format.fontFamily;
        this.bold = format.bold;
        this.italic = format.italic;
        this.baselineAlignment = format.baselineAlignment;
        this.underline = format.underline;
        this.fontColor = format.fontColor;
        this.highlightColor = format.highlightColor;
        this.strikethrough = format.strikethrough;
        this.bidi = format.bidi;
        this.bdo = format.bdo;
        this.boldBidi = format.boldBidi;
        this.italicBidi = format.italicBidi;
        this.fontFamilyBidi = format.fontFamilyBidi;
        this.fontSizeBidi = format.fontSizeBidi;
    }
    /**
     * Combines the format.
     * @param  {WCharacterFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.bold) && this.bold !== format.bold) {
            this.bold = undefined;
        }
        if (!isNullOrUndefined(this.italic) && this.italic !== format.italic) {
            this.italic = undefined;
        }
        if (this.fontSize !== 0 && this.fontSize !== format.fontSize) {
            this.fontSize = 0;
        }
        if (!isNullOrUndefined(this.fontFamily) && this.fontFamily !== format.fontFamily) {
            this.fontFamily = undefined;
        }
        if (!isNullOrUndefined(this.highlightColor) && this.highlightColor !== format.highlightColor) {
            this.highlightColor = undefined;
        }
        if (!isNullOrUndefined(this.baselineAlignment) && this.baselineAlignment !== format.baselineAlignment) {
            this.baselineAlignment = undefined;
        }
        if (!isNullOrUndefined(this.fontColor) && (this.fontColor !== format.fontColor)) {
            this.fontColor = undefined;
        }
        if (!isNullOrUndefined(this.underline) && this.underline !== format.underline) {
            this.underline = undefined;
        }
        if (!isNullOrUndefined(this.strikethrough) && this.strikethrough !== format.strikethrough) {
            this.strikethrough = undefined;
        }
        if (!isNullOrUndefined(this.boldBidi) && this.boldBidi !== format.boldBidi) {
            this.boldBidi = undefined;
        }
        if (!isNullOrUndefined(this.italicBidi) && this.italicBidi !== format.italicBidi) {
            this.italicBidi = undefined;
        }
        if (this.fontSizeBidi !== 0 && this.fontSizeBidi !== format.fontSizeBidi) {
            this.fontSizeBidi = 0;
        }
        if (!isNullOrUndefined(this.fontFamilyBidi) && this.fontFamilyBidi !== format.fontFamilyBidi) {
            this.fontFamilyBidi = undefined;
        }
        if (!isNullOrUndefined(this.bidi) && this.bidi !== format.bidi) {
            this.bidi = undefined;
        }
        if (!isNullOrUndefined(this.bdo) && this.bdo !== format.bdo) {
            this.bdo = undefined;
        }
    }
    /**
     * Clones the format.
     * @param  {SelectionCharacterFormat} selectionCharacterFormat
     * @returns void
     * @private
     */
    cloneFormat(selectionCharacterFormat) {
        this.bold = selectionCharacterFormat.bold;
        this.italic = selectionCharacterFormat.italic;
        this.underline = selectionCharacterFormat.underline;
        this.strikethrough = selectionCharacterFormat.strikethrough;
        this.baselineAlignment = selectionCharacterFormat.baselineAlignment;
        this.highlightColor = selectionCharacterFormat.highlightColor;
        this.fontSize = selectionCharacterFormat.fontSize;
        this.fontFamily = selectionCharacterFormat.fontFamily;
        this.fontColor = selectionCharacterFormat.fontColor;
        this.styleName = selectionCharacterFormat.styleName;
        this.bidi = selectionCharacterFormat.bidi;
        this.bdo = selectionCharacterFormat.bdo;
        this.boldBidi = selectionCharacterFormat.boldBidi;
        this.italicBidi = selectionCharacterFormat.italicBidi;
        this.fontSizeBidi = selectionCharacterFormat.fontSizeBidi;
        this.fontFamilyBidi = selectionCharacterFormat.fontFamilyBidi;
    }
    /**
     * Checks whether current format is equal to the source format or not.
     * @param  {SelectionCharacterFormat} format
     * @returns boolean
     * @private
     */
    isEqualFormat(format) {
        return (this.fontSize === format.fontSize
            && this.strikethrough === format.strikethrough
            && this.bold === format.bold
            && this.fontFamily === format.fontFamily
            && this.underline === format.underline
            && this.highlightColor === format.highlightColor
            && this.italic === format.italic
            && this.baselineAlignment === format.baselineAlignment
            && this.fontColor === format.fontColor);
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.fontSizeIn = 0;
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.fontFamilyIn = undefined;
        this.fontColorIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.highlightColorIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.styleName = undefined;
        this.bidi = undefined;
        this.bdo = undefined;
        this.boldBidi = undefined;
        this.italicBidi = undefined;
        this.fontFamilyBidi = undefined;
        this.fontSizeBidi = undefined;
    }
    /**
     * Destroys the maintained resources.
     * @returns void
     * @private
     */
    destroy() {
        this.fontSizeIn = undefined;
        this.boldIn = undefined;
        this.italicIn = undefined;
        this.fontFamilyIn = undefined;
        this.fontColorIn = undefined;
        this.underlineIn = undefined;
        this.strikeThroughIn = undefined;
        this.baselineAlignmentIn = undefined;
        this.highlightColorIn = undefined;
        this.selection = undefined;
        this.styleName = undefined;
        this.bidi = undefined;
        this.bdo = undefined;
        this.boldBidi = undefined;
        this.italicBidi = undefined;
        this.fontFamilyBidi = undefined;
        this.fontSizeBidi = undefined;
    }
}
/**
 * Selection paragraph format implementation
 */
class SelectionParagraphFormat {
    /**
     * @private
     */
    constructor(selection, viewer) {
        // Declaring the character format properties.
        this.leftIndentIn = 0;
        this.rightIndentIn = 0;
        this.beforeSpacingIn = 0;
        this.afterSpacingIn = 0;
        this.textAlignmentIn = undefined;
        this.firstLineIndentIn = 0;
        this.lineSpacingIn = 1;
        this.lineSpacingTypeIn = undefined;
        this.bidiIn = undefined;
        this.contextualSpacingIn = undefined;
        this.listLevelNumberIn = -1;
        this.selection = selection;
        this.viewer = viewer;
    }
    /**
     * Gets or Sets the left indent for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get leftIndent() {
        return this.leftIndentIn;
    }
    /**
     * Sets the left indent for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set leftIndent(value) {
        if (value === this.leftIndentIn) {
            return;
        }
        this.leftIndentIn = value;
        this.notifyPropertyChanged('leftIndent');
    }
    /**
     * Gets or Sets the right indent for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get rightIndent() {
        return this.rightIndentIn;
    }
    /**
     * Sets the right indent for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set rightIndent(value) {
        if (value === this.rightIndentIn) {
            return;
        }
        this.rightIndentIn = value;
        this.notifyPropertyChanged('rightIndent');
    }
    /**
     * Gets or Sets the first line indent for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get firstLineIndent() {
        return this.firstLineIndentIn;
    }
    /**
     * Sets the first line indent for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set firstLineIndent(value) {
        if (value === this.firstLineIndentIn) {
            return;
        }
        this.firstLineIndentIn = value;
        this.notifyPropertyChanged('firstLineIndent');
    }
    /**
     * Gets or Sets the text alignment for selected paragraphs.
     * @default undefined
     */
    get textAlignment() {
        return this.textAlignmentIn;
    }
    /**
     * Sets the text alignment for selected paragraphs.
     * @default undefined
     */
    set textAlignment(value) {
        if (value === this.textAlignmentIn) {
            return;
        }
        this.textAlignmentIn = value;
        this.notifyPropertyChanged('textAlignment');
    }
    /**
     * Sets the after spacing for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get afterSpacing() {
        return this.afterSpacingIn;
    }
    /**
     * Gets or Sets the after spacing for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set afterSpacing(value) {
        if (value === this.afterSpacingIn) {
            return;
        }
        this.afterSpacingIn = value;
        this.notifyPropertyChanged('afterSpacing');
    }
    /**
     * Gets or Sets the before spacing for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get beforeSpacing() {
        return this.beforeSpacingIn;
    }
    /**
     * Sets the before spacing for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set beforeSpacing(value) {
        if (value === this.beforeSpacingIn) {
            return;
        }
        this.beforeSpacingIn = value;
        this.notifyPropertyChanged('beforeSpacing');
    }
    /**
     * Gets or Sets the line spacing for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get lineSpacing() {
        return this.lineSpacingIn;
    }
    /**
     * Sets the line spacing for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set lineSpacing(value) {
        if (value === this.lineSpacingIn) {
            return;
        }
        this.lineSpacingIn = value;
        this.notifyPropertyChanged('lineSpacing');
    }
    /**
     * Gets or Sets the line spacing type for selected paragraphs.
     * @default undefined
     */
    get lineSpacingType() {
        return this.lineSpacingTypeIn;
    }
    /**
     * Gets or Sets the line spacing type for selected paragraphs.
     * @default undefined
     */
    set lineSpacingType(value) {
        if (value === this.lineSpacingTypeIn) {
            return;
        }
        this.lineSpacingTypeIn = value;
        this.notifyPropertyChanged('lineSpacingType');
    }
    /**
     * Sets the list level number for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get listLevelNumber() {
        return this.listLevelNumberIn;
    }
    /**
     * Gets or Sets the list level number for selected paragraphs.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set listLevelNumber(value) {
        if (value === this.listLevelNumberIn) {
            return;
        }
        this.listLevelNumberIn = value;
        this.notifyPropertyChanged('listLevelNumber');
    }
    /**
     * Gets or Sets the bidirectional property for selected paragraphs
     * @aspType bool
     * @blazorType bool
     */
    get bidi() {
        return this.bidiIn;
    }
    /**
     * Sets the bidirectional property for selected paragraphs
     * @aspType bool
     * @blazorType bool
     */
    set bidi(value) {
        this.bidiIn = value;
        this.notifyPropertyChanged('bidi');
    }
    /**
     * Gets or sets a value indicating whether to add space between the paragraphs of same style.
     * @aspType bool
     * @blazorType bool
     */
    get contextualSpacing() {
        return this.contextualSpacingIn;
    }
    /**
     * Sets a value indicating whether to add space between the paragraphs of same style.
     * @aspType bool
     * @blazorType bool
     */
    set contextualSpacing(value) {
        this.contextualSpacingIn = value;
        this.notifyPropertyChanged('contextualSpacing');
    }
    validateLineSpacing() {
        if (this.lineSpacingType !== 'Multiple' && this.lineSpacingIn < 12) {
            return true;
        }
        return false;
    }
    /**
     * Gets the list text for selected paragraphs.
     * @aspType string
     * @blazorType string
     */
    get listText() {
        let listFormat = undefined;
        let list = this.viewer.getListById(this.listId);
        if (list instanceof WList && this.listLevelNumberIn > -1 && this.listLevelNumberIn < 9) {
            let listLevel = list.getListLevel(this.listLevelNumber);
            if (listLevel instanceof WListLevel) {
                if (listLevel.listLevelPattern === 'Bullet') {
                    listFormat = listLevel.numberFormat;
                }
                else {
                    listFormat = listLevel.numberFormat;
                    for (let i = 0; i < 9; i++) {
                        let levelPattern = '%' + (i + 1);
                        if (listFormat.indexOf(levelPattern) > -1) {
                            let level = i === this.listLevelNumberIn ? listLevel : list.getListLevel(i);
                            let listTextElement = this.selection.getListTextElementBox(this.selection.start.paragraph);
                            let listText = listTextElement ? listTextElement.text : '';
                            listFormat = listText;
                        }
                    }
                }
            }
        }
        return listFormat;
    }
    getPropertyValue(property) {
        switch (property) {
            case 'leftIndent':
                return this.leftIndent;
            case 'rightIndent':
                return this.rightIndent;
            case 'firstLineIndent':
                return this.firstLineIndent;
            case 'beforeSpacing':
                return this.beforeSpacing;
            case 'afterSpacing':
                return this.afterSpacing;
            case 'textAlignment':
                return this.textAlignment;
            case 'lineSpacing':
                return this.lineSpacing;
            case 'lineSpacingType':
                return this.lineSpacingType;
            case 'bidi':
                return this.bidi;
            case 'contextualSpacing':
                return this.contextualSpacing;
            default:
                return undefined;
        }
    }
    /**
     * Notifies whenever the property gets changed.
     * @param  {string} propertyName
     */
    notifyPropertyChanged(propertyName) {
        if (!isNullOrUndefined(this.selection) &&
            (this.selection.owner.isReadOnlyMode || !this.selection.owner.isDocumentLoaded)
            && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            let editorModule = this.selection.owner.editorModule;
            if (propertyName === 'lineSpacing' || propertyName === 'lineSpacingType') {
                let editorHistory = this.selection.owner.editorHistory;
                if (!(editorHistory && (editorHistory.isUndoing || editorHistory.isRedoing)) && this.validateLineSpacing()) {
                    this.selection.owner.editorHistory.initComplexHistory(this.selection, 'LineSpacing');
                    if (propertyName === 'lineSpacing') {
                        this.lineSpacingTypeIn = 'Multiple';
                        let value = this.getPropertyValue('lineSpacingType');
                        editorModule.onApplyParagraphFormat('lineSpacingType', value, false, false);
                        editorModule.onApplyParagraphFormat(propertyName, this.getPropertyValue(propertyName), false, false);
                    }
                    else {
                        editorModule.onApplyParagraphFormat(propertyName, this.getPropertyValue(propertyName), false, false);
                        this.lineSpacingIn = 12;
                        editorModule.onApplyParagraphFormat('lineSpacing', this.getPropertyValue('lineSpacing'), false, false);
                    }
                    this.selection.owner.editorHistory.updateComplexHistory();
                    return;
                }
            }
            let value = this.getPropertyValue(propertyName);
            if ((propertyName === 'leftIndent' || propertyName === 'rightIndent' || propertyName === 'firstLineIndent')
                && !(value >= -1056 && value < 1056)) {
                return;
            }
            if (propertyName === 'listLevelNumber') {
                editorModule.onApplyListInternal(this.viewer.getListById(this.listId), this.listLevelNumber);
            }
            else {
                editorModule.onApplyParagraphFormat(propertyName, value, propertyName === 'textAlignment' ? true : false, false);
            }
        }
    }
    /**
     * Copies the format.
     * @param  {WParagraphFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.styleName = !isNullOrUndefined(format.baseStyle) ? format.baseStyle.name : 'Normal';
        this.leftIndent = format.leftIndent;
        this.rightIndent = format.rightIndent;
        this.firstLineIndent = format.firstLineIndent;
        this.afterSpacing = format.afterSpacing;
        this.beforeSpacing = format.beforeSpacing;
        this.lineSpacing = format.lineSpacing;
        this.lineSpacingType = format.lineSpacingType;
        this.textAlignment = format.textAlignment;
        this.bidi = format.bidi;
        this.contextualSpacing = format.contextualSpacing;
        if (!isNullOrUndefined(format.listFormat) && !isNullOrUndefined(format.listFormat.listId)) {
            this.listId = format.listFormat.listId;
            this.listLevelNumber = format.listFormat.listLevelNumber;
        }
        else {
            this.listId = undefined;
            this.listLevelNumber = 0;
        }
    }
    /**
     * Copies to format.
     * @param  {WParagraphFormat} format
     * @private
     */
    copyToFormat(format) {
        if (isNullOrUndefined(format)) {
            return;
        }
        if (!isNullOrUndefined(this.afterSpacing)) {
            format.afterSpacing = this.afterSpacing;
        }
        if (!isNullOrUndefined(this.beforeSpacing)) {
            format.beforeSpacing = this.beforeSpacing;
        }
        if (!isNullOrUndefined(this.leftIndent)) {
            format.leftIndent = this.leftIndent;
        }
        if (!isNullOrUndefined(this.rightIndent)) {
            format.rightIndent = this.rightIndent;
        }
        if (!isNullOrUndefined(this.textAlignment)) {
            format.textAlignment = this.textAlignment;
        }
        if (!isNullOrUndefined(this.lineSpacing)) {
            format.lineSpacing = this.lineSpacing;
        }
        if (!isNullOrUndefined(this.lineSpacingType)) {
            format.lineSpacingType = this.lineSpacingType;
        }
        if (!isNullOrUndefined(this.firstLineIndent)) {
            format.firstLineIndent = this.firstLineIndent;
        }
        if (!isNullOrUndefined(this.bidi)) {
            format.bidi = this.bidi;
        }
        if (!isNullOrUndefined(this.contextualSpacing)) {
            format.contextualSpacing = this.contextualSpacing;
        }
    }
    /**
     * Combines the format.
     * @param  {WParagraphFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.leftIndent) && this.leftIndent !== format.leftIndent) {
            this.leftIndent = undefined;
        }
        if (!isNullOrUndefined(this.rightIndent) && this.rightIndent !== format.rightIndent) {
            this.rightIndent = undefined;
        }
        if (!isNullOrUndefined(this.firstLineIndent) && this.firstLineIndent !== format.firstLineIndent) {
            this.firstLineIndent = undefined;
        }
        if (this.lineSpacing !== 0 && this.lineSpacing !== format.lineSpacing) {
            this.lineSpacing = 0;
        }
        if (this.beforeSpacing !== -1 && this.beforeSpacing !== format.beforeSpacing) {
            this.beforeSpacing = -1;
        }
        if (this.afterSpacing !== -1 && this.afterSpacing !== format.afterSpacing) {
            this.afterSpacing = -1;
        }
        if (!isNullOrUndefined(this.lineSpacingType) && this.lineSpacingType !== format.lineSpacingType) {
            this.lineSpacingType = undefined;
        }
        if (!isNullOrUndefined(this.textAlignment) && this.textAlignment !== format.textAlignment) {
            this.textAlignment = undefined;
        }
        // tslint:disable-next-line:max-line-length
        if (this.listLevelNumber >= 0 && !isNullOrUndefined(this.listId) && (isNullOrUndefined(format.listFormat) || format.listFormat.listLevelNumber !== this.listLevelNumber)) {
            this.listLevelNumber = -1;
        }
        // tslint:disable-next-line:max-line-length
        if (isNullOrUndefined(format.listFormat) || isNullOrUndefined(format.listFormat.listId) || (!isNullOrUndefined(this.listId) && this.listId !== format.listFormat.listId)) {
            this.listId = undefined;
        }
        if (!isNullOrUndefined(this.bidi) && this.bidi !== format.bidi) {
            this.bidi = undefined;
        }
        if (!isNullOrUndefined(this.contextualSpacing) && this.contextualSpacing !== format.contextualSpacing) {
            this.contextualSpacing = undefined;
        }
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.leftIndent = 0;
        this.rightIndent = 0;
        this.beforeSpacing = 0;
        this.afterSpacing = 0;
        this.firstLineIndent = 0;
        this.lineSpacing = 1;
        this.textAlignment = undefined;
        this.lineSpacingType = undefined;
        this.listId = undefined;
        this.listLevelNumber = -1;
        this.styleName = undefined;
        this.bidi = undefined;
        this.contextualSpacing = undefined;
    }
    /**
     * Gets the clone of list at current selection.
     * @returns WList
     * @private
     */
    getList() {
        let list = this.viewer.getListById(this.listId);
        if (!isNullOrUndefined(list)) {
            let listAdv = new WList();
            let abstractList = new WAbstractList();
            let currentAbstractList = this.viewer.getAbstractListById(list.abstractListId);
            let editor = this.selection.owner.editorModule;
            if (!isNullOrUndefined(currentAbstractList)) {
                for (let i = 0; i < currentAbstractList.levels.length; i++) {
                    let level = editor.cloneListLevel(currentAbstractList.levels[i]);
                    abstractList.levels.push(level);
                    level.ownerBase = abstractList;
                }
            }
            else {
                abstractList.levels.push(new WListLevel(abstractList));
            }
            if (!isNullOrUndefined(list.levelOverrides)) {
                for (let i = 0; i < list.levelOverrides.length; i++) {
                    let levelOverride = editor.cloneLevelOverride(list.levelOverrides[i]);
                    listAdv.levelOverrides.push(levelOverride);
                }
            }
            listAdv.abstractList = abstractList;
            listAdv.abstractListId = abstractList.abstractListId;
            listAdv.sourceListId = list.listId;
            return listAdv;
        }
        return undefined;
    }
    /**
     * Modifies the list at current selection.
     * @param  {WList} listAdv
     * @private
     */
    setList(listAdv) {
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        let list = this.viewer.getListById(this.listId);
        let collection = undefined;
        let currentAbstractList = listAdv ? this.viewer.getAbstractListById(listAdv.abstractListId) : undefined;
        if (!isNullOrUndefined(list) && !isNullOrUndefined(listAdv)
            && !isNullOrUndefined(currentAbstractList) && listAdv.sourceListId === list.listId) {
            let history = this.viewer.owner.editorHistory;
            let listLevel = this.viewer.layout.getListLevel(list, 1);
            this.selection.owner.isLayoutEnabled = false;
            this.viewer.owner.editorModule.setOffsetValue(this.selection);
            if (history) {
                collection = history.updateListChangesInHistory(currentAbstractList, list);
            }
            this.viewer.owner.editorModule.updateListParagraphs();
            if (history) {
                history.applyListChanges(this.selection, collection);
            }
            this.selection.owner.isLayoutEnabled = true;
            this.viewer.renderedLists.clear();
            // this.viewer.pages = [];
            this.viewer.owner.editorModule.layoutWholeDocument();
            this.viewer.owner.editorModule.updateSelectionTextPosition(false);
            if (history && history.currentBaseHistoryInfo) {
                if (history.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                    history.currentBaseHistoryInfo.updateSelection();
                }
                history.updateHistory();
            }
            this.viewer.owner.editorModule.fireContentChange();
        }
        else if (!isNullOrUndefined(listAdv)) {
            this.selection.owner.isLayoutEnabled = false;
            if (!isNullOrUndefined(currentAbstractList) && this.viewer.abstractLists.indexOf(currentAbstractList) === -1) {
                this.viewer.abstractLists.push(currentAbstractList);
            }
            if (this.viewer.lists.indexOf(listAdv) === -1) {
                this.viewer.lists.push(listAdv);
            }
            //currentAbstractList.listType = 'Numbering';
            this.selection.owner.isLayoutEnabled = true;
            this.selection.owner.editorModule.onApplyList(listAdv);
        }
        else {
            this.selection.owner.editorModule.onApplyList(undefined);
        }
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.leftIndentIn = undefined;
        this.rightIndentIn = undefined;
        this.beforeSpacingIn = undefined;
        this.afterSpacingIn = undefined;
        this.firstLineIndentIn = undefined;
        this.lineSpacingIn = undefined;
        this.textAlignmentIn = undefined;
        this.lineSpacingTypeIn = undefined;
        this.listId = undefined;
        this.listLevelNumberIn = undefined;
        this.viewer = undefined;
        this.selection = undefined;
        this.styleName = undefined;
        this.bidi = undefined;
        this.contextualSpacing = undefined;
    }
}
/**
 * Selection section format implementation
 */
class SelectionSectionFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.differentFirstPageIn = undefined;
        this.differentOddAndEvenPagesIn = undefined;
        /**
         * private
         */
        this.bidi = undefined;
        this.selection = selection;
    }
    /**
     * Gets or sets the page height.
     * @aspType int
     * @blazorType int
     */
    get pageHeight() {
        return this.pageHeightIn;
    }
    /**
     * Gets or sets the page height.
     * @aspType int
     * @blazorType int
     */
    set pageHeight(value) {
        this.pageHeightIn = value;
        this.notifyPropertyChanged('pageHeight');
    }
    /**
     * Gets or sets the page width.
     * @aspType int
     * @blazorType int
     */
    get pageWidth() {
        return this.pageWidthIn;
    }
    /**
     * Gets or sets the page width.
     * @aspType int
     * @blazorType int
     */
    set pageWidth(value) {
        this.pageWidthIn = value;
        this.notifyPropertyChanged('pageWidth');
    }
    /**
     * Gets or sets the page left margin.
     * @aspType int
     * @blazorType int
     */
    get leftMargin() {
        return this.leftMarginIn;
    }
    /**
     * Gets or sets the page left margin.
     * @aspType int
     * @blazorType int
     */
    set leftMargin(value) {
        this.leftMarginIn = value;
        this.notifyPropertyChanged('leftMargin');
    }
    /**
     * Gets or sets the page bottom margin.
     * @aspType int
     * @blazorType int
     */
    get bottomMargin() {
        return this.bottomMarginIn;
    }
    /**
     * Gets or sets the page bottom margin.
     * @aspType int
     * @blazorType int
     */
    set bottomMargin(value) {
        this.bottomMarginIn = value;
        this.notifyPropertyChanged('bottomMargin');
    }
    /**
     * Gets or sets the page top margin.
     * @aspType int
     * @blazorType int
     */
    get topMargin() {
        return this.topMarginIn;
    }
    /**
     * Gets or sets the page top margin.
     * @aspType int
     * @blazorType int
     */
    set topMargin(value) {
        this.topMarginIn = value;
        this.notifyPropertyChanged('topMargin');
    }
    /**
     * Gets or sets the page right margin.
     * @aspType int
     * @blazorType int
     */
    get rightMargin() {
        return this.rightMarginIn;
    }
    /**
     * Gets or sets the page right margin.
     * @aspType int
     * @blazorType int
     */
    set rightMargin(value) {
        this.rightMarginIn = value;
        this.notifyPropertyChanged('rightMargin');
    }
    /**
     * Gets or sets the header distance.
     * @aspType int
     * @blazorType int
     */
    get headerDistance() {
        return this.headerDistanceIn;
    }
    /**
     * Gets or sets the header distance.
     * @aspType int
     * @blazorType int
     */
    set headerDistance(value) {
        this.headerDistanceIn = value;
        this.notifyPropertyChanged('headerDistance');
    }
    /**
     * Gets or sets the footer distance.
     * @aspType int
     * @blazorType int
     */
    get footerDistance() {
        return this.footerDistanceIn;
    }
    /**
     * Gets or sets the footer distance.
     * @aspType int
     * @blazorType int
     */
    set footerDistance(value) {
        this.footerDistanceIn = value;
        this.notifyPropertyChanged('footerDistance');
    }
    /**
     * Gets or sets a value indicating whether the section has different first page.
     * @aspType bool
     * @blazorType bool
     */
    get differentFirstPage() {
        return this.differentFirstPageIn;
    }
    /**
     * Gets or sets a value indicating whether the section has different first page.
     * @aspType bool
     * @blazorType bool
     */
    set differentFirstPage(value) {
        this.differentFirstPageIn = value;
        this.notifyPropertyChanged('differentFirstPage');
    }
    /**
     * Gets or sets a value indicating whether the section has different odd and even page.
     * @aspType bool
     * @blazorType bool
     */
    get differentOddAndEvenPages() {
        return this.differentOddAndEvenPagesIn;
    }
    /**
     * Gets or sets a value indicating whether the section has different odd and even page.
     * @aspType bool
     * @blazorType bool
     */
    set differentOddAndEvenPages(value) {
        this.differentOddAndEvenPagesIn = value;
        this.notifyPropertyChanged('differentOddAndEvenPages');
    }
    /**
     * Copies the format.
     * @param  {WSectionFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.pageHeight = format.pageHeight;
        this.pageWidth = format.pageWidth;
        this.leftMargin = format.leftMargin;
        this.topMargin = format.topMargin;
        this.rightMargin = format.rightMargin;
        this.bottomMargin = format.bottomMargin;
        this.headerDistance = format.headerDistance;
        this.footerDistance = format.footerDistance;
        this.differentFirstPage = format.differentFirstPage;
        this.differentOddAndEvenPages = format.differentOddAndEvenPages;
        this.bidi = format.bidi;
    }
    notifyPropertyChanged(propertyName) {
        let selection = this.selection;
        if (!isNullOrUndefined(selection) && (selection.isCleared || selection.owner.isPastingContent
            || selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded)
            && !selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(selection) && !isNullOrUndefined(selection.start) && !selection.isRetrieveFormatting) {
            let value = this.getPropertyvalue(propertyName);
            if (!isNullOrUndefined(value)) {
                selection.owner.editorModule.onApplySectionFormat(propertyName, value);
            }
        }
    }
    getPropertyvalue(propertyName) {
        switch (propertyName) {
            case 'pageHeight':
                if (this.pageHeight > 0) {
                    return this.pageHeight;
                }
                return undefined;
            case 'pageWidth':
                if (this.pageWidth > 0) {
                    return this.pageWidth;
                }
                return undefined;
            case 'leftMargin':
                if (this.leftMargin >= 0) {
                    return this.leftMargin;
                }
                return undefined;
            case 'rightMargin':
                if (this.rightMargin >= 0) {
                    return this.rightMargin;
                }
                return undefined;
            case 'topMargin':
                if (this.topMargin >= 0) {
                    return this.topMargin;
                }
                return undefined;
            case 'bottomMargin':
                if (this.bottomMargin >= 0) {
                    return this.bottomMargin;
                }
                return undefined;
            case 'differentFirstPage':
                if (!isNullOrUndefined(this.differentFirstPage)) {
                    return this.differentFirstPage;
                }
                return undefined;
            case 'differentOddAndEvenPages':
                if (!isNullOrUndefined(this.differentOddAndEvenPages)) {
                    return this.differentOddAndEvenPages;
                }
                return undefined;
            case 'headerDistance':
                return this.headerDistanceIn;
            case 'footerDistance':
                return this.footerDistance;
            default:
                return undefined;
        }
    }
    /**
     * Combines the format.
     * @param  {WSectionFormat} format
     * @private
     */
    combineFormat(format) {
        if (this.pageHeight > 0 && this.pageHeight !== format.pageHeight) {
            this.pageHeight = 0;
        }
        if (this.pageWidth > 0 && this.pageWidth !== format.pageWidth) {
            this.pageWidth = 0;
        }
        if (this.leftMargin > -1 && this.leftMargin !== format.leftMargin) {
            this.leftMargin = -1;
        }
        if (this.topMargin > -1 && this.topMargin !== format.topMargin) {
            this.topMargin = -1;
        }
        if (this.rightMargin > -1 && this.rightMargin !== format.rightMargin) {
            this.rightMargin = -1;
        }
        if (this.bottomMargin > -1 && this.bottomMargin !== format.bottomMargin) {
            this.bottomMargin = -1;
        }
        if (this.headerDistance !== 0 && this.headerDistance !== format.headerDistance) {
            this.headerDistance = 0;
        }
        if (this.footerDistance !== 0 && this.footerDistance !== format.footerDistance) {
            this.footerDistance = 0;
        }
        if (!isNullOrUndefined(this.differentFirstPage) && this.differentFirstPage !== format.differentFirstPage) {
            this.differentFirstPage = undefined;
        }
        if (!isNullOrUndefined(this.differentOddAndEvenPages) && this.differentOddAndEvenPages !== format.differentOddAndEvenPages) {
            this.differentOddAndEvenPages = undefined;
        }
        if (!isNullOrUndefined(this.bidi) && this.bidi !== format.bidi) {
            this.bidi = undefined;
        }
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.headerDistance = 0;
        this.footerDistance = 0;
        this.pageHeight = 0;
        this.pageWidth = 0;
        this.leftMargin = -1;
        this.rightMargin = -1;
        this.topMargin = -1;
        this.bottomMargin = -1;
        this.differentFirstPage = undefined;
        this.differentOddAndEvenPages = undefined;
        this.bidi = undefined;
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.headerDistanceIn = undefined;
        this.footerDistanceIn = undefined;
        this.pageHeightIn = undefined;
        this.pageWidthIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.bottomMarginIn = undefined;
        this.differentFirstPageIn = undefined;
        this.differentOddAndEvenPagesIn = undefined;
        this.selection = undefined;
        this.bidi = undefined;
    }
}
/**
 * Selection table format implementation
 */
class SelectionTableFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.leftIndentIn = 0;
        this.backgroundIn = undefined;
        this.tableAlignmentIn = undefined;
        this.cellSpacingIn = 0;
        this.leftMarginIn = 0;
        this.rightMarginIn = 0;
        this.topMarginIn = 0;
        this.bottomMarginIn = 0;
        this.preferredWidthIn = 0;
        this.bidiIn = undefined;
        this.selection = selection;
    }
    /**
     * Gets or sets the table.
     * @private
     */
    get table() {
        return this.tableIn;
    }
    set table(value) {
        this.tableIn = value;
    }
    /**
     * Gets or Sets the left indent for selected table.
     * @aspType int
     * @blazorType int
     */
    get leftIndent() {
        return this.leftIndentIn;
    }
    /**
     * Gets or Sets the left indent for selected table.
     * @aspType int
     * @blazorType int
     */
    set leftIndent(value) {
        if (value === this.leftIndentIn) {
            return;
        }
        this.leftIndentIn = value;
        this.notifyPropertyChanged('leftIndent');
    }
    /**
     * Gets or Sets the default top margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get topMargin() {
        return this.topMarginIn;
    }
    /**
     * Gets or Sets the default top margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set topMargin(value) {
        if (value === this.topMarginIn) {
            return;
        }
        this.topMarginIn = value;
        this.notifyPropertyChanged('topMargin');
    }
    /**
     * Gets or Sets the background for selected table.
     * @default undefined
     * @aspType string
     * @blazorType string
     */
    get background() {
        return this.backgroundIn;
    }
    /**
     * Gets or Sets the background for selected table.
     * @default undefined
     * @aspType string
     * @blazorType string
     */
    set background(value) {
        if (value === this.backgroundIn) {
            return;
        }
        this.backgroundIn = value;
        this.notifyPropertyChanged('background');
    }
    /**
     * Gets or Sets the table alignment for selected table.
     * @default undefined
     */
    get tableAlignment() {
        return this.tableAlignmentIn;
    }
    /**
     * Gets or Sets the table alignment for selected table.
     * @default undefined
     */
    set tableAlignment(value) {
        if (value === this.tableAlignmentIn) {
            return;
        }
        this.tableAlignmentIn = value;
        this.notifyPropertyChanged('tableAlignment');
    }
    /**
     * Gets or Sets the default left margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get leftMargin() {
        return this.leftMarginIn;
    }
    /**
     * Gets or Sets the default left margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set leftMargin(value) {
        if (value === this.leftMarginIn) {
            return;
        }
        this.leftMarginIn = value;
        this.notifyPropertyChanged('leftMargin');
    }
    /**
     * Gets or Sets the default bottom margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get bottomMargin() {
        return this.bottomMarginIn;
    }
    /**
     * Gets or Sets the default bottom margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set bottomMargin(value) {
        if (value === this.bottomMarginIn) {
            return;
        }
        this.bottomMarginIn = value;
        this.notifyPropertyChanged('bottomMargin');
    }
    /**
     * Gets or Sets the cell spacing for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get cellSpacing() {
        return this.cellSpacingIn;
    }
    /**
     * Gets or Sets the cell spacing for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set cellSpacing(value) {
        if (value === this.cellSpacingIn) {
            return;
        }
        this.cellSpacingIn = value;
        this.notifyPropertyChanged('cellSpacing');
    }
    /**
     * Gets or Sets the default right margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get rightMargin() {
        return this.rightMarginIn;
    }
    /**
     * Gets or Sets the default right margin of cell for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set rightMargin(value) {
        if (value === this.rightMarginIn) {
            return;
        }
        this.rightMarginIn = value;
        this.notifyPropertyChanged('rightMargin');
    }
    /**
     * Gets or Sets the preferred width for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get preferredWidth() {
        return this.preferredWidthIn;
    }
    /**
     * Gets or Sets the preferred width for selected table.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set preferredWidth(value) {
        if (value === this.preferredWidthIn) {
            return;
        }
        this.preferredWidthIn = value;
        this.notifyPropertyChanged('preferredWidth');
    }
    /**
     * Gets or Sets the preferred width type for selected table.
     * @default undefined
     */
    get preferredWidthType() {
        return this.preferredWidthTypeIn;
    }
    /**
     * Gets or Sets the preferred width type for selected table.
     * @default undefined
     */
    set preferredWidthType(value) {
        if (value === this.preferredWidthTypeIn) {
            return;
        }
        this.preferredWidthTypeIn = value;
        this.notifyPropertyChanged('preferredWidthType');
    }
    /**
     * Gets or sets the bidi property
     * @aspType bool
     * @blazorType bool
     */
    get bidi() {
        return this.bidiIn;
    }
    /**
     * Gets or sets the bidi property
     * @aspType bool
     * @blazorType bool
     */
    set bidi(value) {
        this.bidiIn = value;
        this.notifyPropertyChanged('bidi');
    }
    getPropertyValue(propertyName) {
        switch (propertyName) {
            case 'tableAlignment':
                return this.tableAlignment;
            case 'leftIndent':
                return this.leftIndent;
            case 'cellSpacing':
                return this.cellSpacing;
            case 'leftMargin':
                return this.leftMargin;
            case 'rightMargin':
                return this.rightMargin;
            case 'topMargin':
                return this.topMargin;
            case 'bottomMargin':
                return this.bottomMargin;
            case 'background':
                let shading = new WShading();
                shading.backgroundColor = this.background;
                return shading;
            case 'preferredWidth':
                return this.preferredWidth;
            case 'preferredWidthType':
                return this.preferredWidthType;
            case 'bidi':
                return this.bidi;
            default:
                return undefined;
        }
    }
    notifyPropertyChanged(propertyName) {
        if (!isNullOrUndefined(this.selection) && (this.selection.isCleared
            || !this.selection.owner.isDocumentLoaded || this.selection.owner.isReadOnlyMode
            || this.selection.owner.isPastingContent) && !this.selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(this.selection) && !isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
            let value = this.getPropertyValue(propertyName);
            if (propertyName === 'background') {
                propertyName = 'shading';
            }
            if (!isNullOrUndefined(value)) {
                this.selection.owner.editorModule.onApplyTableFormat(propertyName, value);
            }
        }
    }
    /**
     * Copies the format.
     * @param  {WTableFormat} format Format to copy.
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.leftIndent = format.leftIndent;
        this.background = format.shading.backgroundColor;
        this.tableAlignment = format.tableAlignment;
        this.leftMargin = format.leftMargin;
        this.rightMargin = format.rightMargin;
        this.topMargin = format.topMargin;
        this.bottomMargin = format.bottomMargin;
        this.cellSpacing = format.cellSpacing;
        this.preferredWidth = format.preferredWidth;
        this.preferredWidthType = format.preferredWidthType;
        this.bidi = format.bidi;
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.table = undefined;
        this.leftIndent = 0;
        this.background = undefined;
        this.leftIndent = 0;
        this.leftMargin = 0;
        this.rightMargin = 0;
        this.topMargin = 0;
        this.bottomMargin = 0;
        this.cellSpacing = 0;
        this.tableAlignment = undefined;
        this.bidi = undefined;
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.leftIndentIn = undefined;
        this.backgroundIn = undefined;
        this.leftIndentIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.bottomMarginIn = undefined;
        this.cellSpacingIn = undefined;
        this.tableAlignmentIn = undefined;
        this.tableIn = undefined;
        this.selection = undefined;
        this.bidi = undefined;
    }
}
/**
 * Selection cell format implementation
 */
class SelectionCellFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.verticalAlignmentIn = undefined;
        this.leftMarginIn = 0;
        this.rightMarginIn = 0;
        this.topMarginIn = 0;
        this.bottomMarginIn = 0;
        this.backgroundIn = undefined;
        this.preferredWidthTypeIn = undefined;
        this.selection = selection;
    }
    /**
     * Gets or sets the vertical alignment of the selected cells.
     * @default undefined
     */
    get verticalAlignment() {
        return this.verticalAlignmentIn;
    }
    /**
     * Gets or sets the vertical alignment of the selected cells.
     * @default undefined
     */
    set verticalAlignment(value) {
        if (value === this.verticalAlignmentIn) {
            return;
        }
        this.verticalAlignmentIn = value;
        this.notifyPropertyChanged('verticalAlignment');
    }
    /**
     * Gets or Sets the left margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    /* tslint:disable */
    get leftMargin() {
        return this.leftMarginIn;
    }
    /**
     * Gets or Sets the left margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set leftMargin(value) {
        if (value === this.leftMarginIn) {
            return;
        }
        this.leftMarginIn = value;
        this.notifyPropertyChanged('leftMargin');
    }
    /**
     * Gets or Sets the right margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get rightMargin() {
        return this.rightMarginIn;
    }
    /**
     * Gets or Sets the right margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set rightMargin(value) {
        if (value === this.rightMarginIn) {
            return;
        }
        this.rightMarginIn = value;
        this.notifyPropertyChanged('rightMargin');
    }
    /**
     * Gets or Sets the top margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get topMargin() {
        return this.topMarginIn;
    }
    /**
     * Gets or Sets the top margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set topMargin(value) {
        if (value === this.topMarginIn) {
            return;
        }
        this.topMarginIn = value;
        this.notifyPropertyChanged('topMargin');
    }
    /**
     * Gets or Sets the bottom margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get bottomMargin() {
        return this.bottomMarginIn;
    }
    /**
     * Gets or Sets the bottom margin for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set bottomMargin(value) {
        if (value === this.bottomMarginIn) {
            return;
        }
        this.bottomMarginIn = value;
        this.notifyPropertyChanged('bottomMargin');
    }
    /**
     * Gets or Sets the background for selected cells.
     * @default undefined
     * @aspType string
     * @blazorType string
     */
    get background() {
        return this.backgroundIn;
    }
    /**
     * Gets or Sets the background for selected cells.
     * @default undefined
     * @aspType string
     * @blazorType string
     */
    /* tslint:enable */
    set background(value) {
        if (value === this.backgroundIn) {
            return;
        }
        this.backgroundIn = value;
        this.notifyPropertyChanged('background');
    }
    /* tslint:disable */
    /**
     * Gets or Sets the preferred width type for selected cells.
     * @default undefined
     */
    get preferredWidthType() {
        return this.preferredWidthTypeIn;
    }
    /**
     * Gets or Sets the preferred width type for selected cells.
     * @default undefined
     */
    set preferredWidthType(value) {
        if (value === this.preferredWidthTypeIn) {
            return;
        }
        this.preferredWidthTypeIn = value;
        this.notifyPropertyChanged('preferredWidthType');
    }
    /**
     * Gets or Sets the preferred width  for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get preferredWidth() {
        return this.preferredWidthIn;
    }
    /**
     * Gets or Sets the preferred width  for selected cells.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set preferredWidth(value) {
        if (value === this.preferredWidthIn) {
            return;
        }
        this.preferredWidthIn = value;
        this.notifyPropertyChanged('preferredWidth');
    }
    /* tslint:enable */
    notifyPropertyChanged(propertyName) {
        let selection = this.selection;
        if (!isNullOrUndefined(selection)) {
            if ((selection.isCleared || !selection.owner.isDocumentLoaded
                || selection.owner.isReadOnlyMode || selection.owner.isPastingContent) && !selection.isRetrieveFormatting) {
                return;
            }
            if (!isNullOrUndefined(this.selection.start) && !this.selection.isRetrieveFormatting) {
                let value = this.getPropertyValue(propertyName);
                if (propertyName === 'background') {
                    propertyName = 'shading';
                }
                if (!isNullOrUndefined(value)) {
                    this.selection.owner.editorModule.onApplyTableCellFormat(propertyName, value);
                }
            }
        }
    }
    getPropertyValue(propertyName) {
        switch (propertyName) {
            case 'verticalAlignment':
                return this.verticalAlignment;
            case 'leftMargin':
                return this.leftMargin;
            case 'rightMargin':
                return this.rightMargin;
            case 'topMargin':
                return this.topMargin;
            case 'bottomMargin':
                return this.bottomMargin;
            case 'preferredWidth':
                return this.preferredWidth;
            case 'preferredWidthType':
                return this.preferredWidthType;
            case 'background':
                let shading = new WShading();
                shading.backgroundColor = this.background;
                return shading;
            default:
                return undefined;
        }
    }
    /**
     * Copies the format.
     * @param  {WCellFormat} format Source Format to copy.
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.leftMargin = format.leftMargin;
        this.rightMargin = format.rightMargin;
        this.topMargin = format.topMargin;
        this.bottomMargin = format.bottomMargin;
        this.background = format.shading.backgroundColor;
        this.verticalAlignment = format.verticalAlignment;
        this.preferredWidth = format.preferredWidth;
        this.preferredWidthType = format.preferredWidthType;
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearCellFormat() {
        this.leftMargin = undefined;
        this.rightMargin = undefined;
        this.topMargin = undefined;
        this.bottomMargin = undefined;
        this.background = undefined;
        this.verticalAlignment = undefined;
    }
    /**
     * Combines the format.
     * @param  {WCellFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.leftMargin) && this.leftMargin !== format.leftMargin) {
            this.leftMargin = undefined;
        }
        if (!isNullOrUndefined(this.topMargin) && this.topMargin !== format.topMargin) {
            this.topMargin = undefined;
        }
        if (!isNullOrUndefined(this.rightMargin) && this.rightMargin !== format.rightMargin) {
            this.rightMargin = undefined;
        }
        if (!isNullOrUndefined(this.bottomMargin) && this.bottomMargin !== format.bottomMargin) {
            this.bottomMargin = undefined;
        }
        if (!isNullOrUndefined(this.background) && this.background !== format.shading.backgroundColor) {
            this.background = undefined;
        }
        if (!isNullOrUndefined(this.verticalAlignment) && this.verticalAlignment !== format.verticalAlignment) {
            this.verticalAlignment = undefined;
        }
        if (!isNullOrUndefined(this.preferredWidth) && this.preferredWidth !== format.preferredWidth) {
            this.preferredWidth = undefined;
        }
        if (!isNullOrUndefined(this.preferredWidthType) && this.preferredWidthType !== format.preferredWidthType) {
            this.preferredWidthType = undefined;
        }
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.background = undefined;
        this.bottomMargin = 0;
        this.leftMargin = 0;
        this.rightMargin = 0;
        this.topMargin = 0;
        this.verticalAlignment = undefined;
    }
    /**
     * Destroys the manages resources.
     * @returns void
     * @private
     */
    destroy() {
        this.backgroundIn = undefined;
        this.verticalAlignmentIn = undefined;
        this.bottomMarginIn = undefined;
        this.leftMarginIn = undefined;
        this.rightMarginIn = undefined;
        this.topMarginIn = undefined;
        this.selection = undefined;
    }
}
/**
 * Selection row format implementation
 */
class SelectionRowFormat {
    /**
     * @private
     */
    constructor(selection) {
        this.heightIn = undefined;
        this.heightTypeIn = undefined;
        this.isHeaderIn = undefined;
        this.allowRowBreakAcrossPagesIn = undefined;
        this.selection = selection;
    }
    /**
     * Gets or Sets the height for selected rows.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    get height() {
        return this.heightIn;
    }
    /**
     * Gets or Sets the height for selected rows.
     * @default undefined
     * @aspType int
     * @blazorType int
     */
    set height(value) {
        if (value === this.heightIn) {
            return;
        }
        this.heightIn = value;
        this.notifyPropertyChanged('height');
    }
    /**
     * Gets or Sets the height type for selected rows.
     * @default undefined
     */
    get heightType() {
        return this.heightTypeIn;
    }
    /**
     * Gets or Sets the height type for selected rows.
     * @default undefined
     */
    set heightType(value) {
        if (value === this.heightTypeIn) {
            return;
        }
        this.heightTypeIn = value;
        this.notifyPropertyChanged('heightType');
    }
    /**
     * Gets or Sets a value indicating whether the selected rows are header rows or not.
     * @default undefined
     * @aspType bool
     * @blazorType bool
     */
    get isHeader() {
        return this.isHeaderIn;
    }
    /**
     * Gets or Sets a value indicating whether the selected rows are header rows or not.
     * @default undefined
     * @aspType bool
     * @blazorType bool
     */
    set isHeader(value) {
        if (value === this.isHeaderIn) {
            return;
        }
        this.isHeaderIn = value;
        this.notifyPropertyChanged('isHeader');
    }
    /**
     * Gets or Sets a value indicating whether to allow break across pages for selected rows.
     * @default undefined
     * @aspType bool
     * @blazorType bool
     */
    get allowBreakAcrossPages() {
        return this.allowRowBreakAcrossPagesIn;
    }
    /**
     * Gets or Sets a value indicating whether to allow break across pages for selected rows.
     * @default undefined
     * @aspType bool
     * @blazorType bool
     */
    set allowBreakAcrossPages(value) {
        if (value === this.allowRowBreakAcrossPagesIn) {
            return;
        }
        this.allowRowBreakAcrossPagesIn = value;
        this.notifyPropertyChanged('allowBreakAcrossPages');
    }
    notifyPropertyChanged(propertyName) {
        let selection = this.selection;
        if (!isNullOrUndefined(selection) && (selection.isCleared || selection.owner.isReadOnlyMode
            || !selection.owner.isDocumentLoaded || selection.owner.isPastingContent) && !selection.isRetrieveFormatting) {
            return;
        }
        if (!isNullOrUndefined(selection) && !isNullOrUndefined(selection.start) && !selection.isRetrieveFormatting) {
            let value = this.getPropertyValue(propertyName);
            if (!isNullOrUndefined(value)) {
                selection.owner.editorModule.onApplyTableRowFormat(propertyName, value);
            }
        }
    }
    getPropertyValue(propertyName) {
        switch (propertyName) {
            case 'height':
                return this.height;
            case 'heightType':
                return this.heightType;
            case 'isHeader':
                return this.isHeader;
            case 'allowBreakAcrossPages':
                return this.allowBreakAcrossPages;
            default:
                return undefined;
        }
    }
    /**
     * Copies the format.
     * @param  {WRowFormat} format
     * @returns void
     * @private
     */
    copyFormat(format) {
        this.height = format.height;
        this.heightType = format.heightType;
        this.allowBreakAcrossPages = format.allowBreakAcrossPages;
        this.isHeader = format.isHeader;
    }
    /**
     * Combines the format.
     * @param  {WRowFormat} format
     * @private
     */
    combineFormat(format) {
        if (!isNullOrUndefined(this.height) && this.height !== format.height) {
            this.height = undefined;
        }
        if (!isNullOrUndefined(this.heightType) && this.heightType !== format.heightType) {
            this.heightType = undefined;
        }
        if (!isNullOrUndefined(this.allowBreakAcrossPages) && this.allowBreakAcrossPages !== format.allowBreakAcrossPages) {
            this.allowBreakAcrossPages = undefined;
        }
        if (!isNullOrUndefined(this.isHeader) && this.isHeader !== format.isHeader) {
            this.isHeader = undefined;
        }
    }
    /**
     * Clears the row format.
     * @returns void
     * @private
     */
    clearRowFormat() {
        this.height = undefined;
        this.heightType = undefined;
        this.allowBreakAcrossPages = undefined;
        this.isHeader = undefined;
    }
    /**
     * Clears the format.
     * @returns void
     * @private
     */
    clearFormat() {
        this.height = 0;
        this.heightType = undefined;
        this.allowBreakAcrossPages = undefined;
        this.isHeader = undefined;
    }
    /**
     * Destroys the managed resources.
     * @returns void
     * @private
     */
    destroy() {
        this.heightIn = undefined;
        this.heightTypeIn = undefined;
        this.allowRowBreakAcrossPagesIn = undefined;
        this.isHeaderIn = undefined;
        this.selection = undefined;
    }
}
/**
 * Selection image format implementation
 */
class SelectionImageFormat {
    /**
     * Gets the width of the image.
     * @aspType int
     * @blazorType int
     */
    get width() {
        if (this.image) {
            return this.image.width;
        }
        return 0;
    }
    /**
     * Gets the height of the image.
     * @aspType int
     * @blazorType int
     */
    get height() {
        if (this.image) {
            return this.image.height;
        }
        return 0;
    }
    /**
     * @private
     */
    constructor(selection) {
        this.selection = selection;
    }
    /**
     * Resizes the image based on given size.
     * @param width
     * @param height
     */
    resize(width, height) {
        this.updateImageFormat(width, height);
    }
    /**
     * Update image width and height
     * @private
     */
    updateImageFormat(width, height) {
        if (this.image) {
            if (this.selection.owner.editorModule) {
                this.selection.owner.editorModule.onImageFormat(this.image, width, height);
            }
        }
    }
    /**
     * @private
     */
    copyImageFormat(image) {
        this.image = image;
    }
    /**
     * @private
     */
    clearImageFormat() {
        this.image = undefined;
    }
}
/* tslint:enable */

/**
 * @private
 */
class HtmlExport {
    constructor() {
        /* tslint:disable:no-any */
        this.document = undefined;
        this.prevListLevel = undefined;
        this.isOrdered = undefined;
        /* tslint:disable:no-any */
        /**
         * @private
         */
        this.fieldCheck = 0;
        /* tslint:enable:no-any */
    }
    /* tslint:disable:no-any */
    /**
     * @private
     */
    writeHtml(document) {
        this.document = document;
        let html = '';
        for (let i = 0; i < document.sections.length; i++) {
            html = this.serializeSection(document.sections[i]);
        }
        return html;
    }
    /**
     * @private
     */
    serializeSection(section) {
        let string = '';
        for (let i = 0; i < section.blocks.length; i++) {
            let block = section.blocks[i];
            if (block.hasOwnProperty('inlines')) {
                string += this.serializeParagraph(block);
            }
            else {
                string += this.closeList();
                string += this.serializeTable(block);
            }
        }
        string += this.closeList();
        this.prevListLevel = undefined;
        this.isOrdered = undefined;
        return string;
    }
    // Serialize Paragraph 
    /**
     * @private
     */
    serializeParagraph(paragraph) {
        let blockStyle = '';
        let isList = false;
        let isPreviousList = false;
        if (!isNullOrUndefined(this.prevListLevel)) {
            isPreviousList = true;
        }
        let tagAttributes = [];
        let listLevel = undefined;
        if (!isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            listLevel = this.getListLevel(paragraph);
            if (!isPreviousList) {
                this.prevListLevel = listLevel;
            }
            if (this.prevListLevel !== listLevel) {
                isPreviousList = false;
            }
            this.prevListLevel = listLevel;
        }
        if (!isPreviousList) {
            blockStyle += this.closeList();
        }
        if (!isNullOrUndefined(listLevel)) {
            isList = true;
        }
        if (isList && !isPreviousList) {
            blockStyle += this.getHtmlList(listLevel, paragraph.paragraphFormat.listFormat.listLevelNumber);
        }
        tagAttributes.push('style="' + this.serializeParagraphStyle(paragraph, '', isList) + '"');
        if (isList) {
            blockStyle += this.createAttributesTag('li', tagAttributes);
        }
        else {
            this.prevListLevel = undefined;
            this.isOrdered = undefined;
            blockStyle += this.createAttributesTag('p', tagAttributes);
        }
        if (paragraph.inlines.length === 0) {
            //Handled to preserve non breaking space for empty paragraphs similar to MS Word behavior.
            blockStyle += '&nbsp';
        }
        else {
            blockStyle = this.serializeInlines(paragraph, blockStyle);
        }
        if (isList) {
            blockStyle += this.endTag('li');
            if (blockStyle.indexOf('<ul') > -1) {
                this.isOrdered = false;
            }
            else if (blockStyle.indexOf('<ol') > -1) {
                this.isOrdered = true;
            }
        }
        else {
            blockStyle += this.endTag('p');
        }
        return blockStyle;
    }
    closeList() {
        let blockStyle = '';
        if (!isNullOrUndefined(this.isOrdered)) {
            if (this.isOrdered) {
                blockStyle = this.endTag('ol');
            }
            else {
                blockStyle = this.endTag('ul');
            }
            this.isOrdered = undefined;
        }
        return blockStyle;
    }
    getListLevel(paragraph) {
        let listLevel = undefined;
        let list = undefined;
        for (let i = 0; i < this.document.lists.length; i++) {
            if (this.document.lists[i].listId === paragraph.paragraphFormat.listFormat.listId) {
                list = this.document.lists[i];
                break;
            }
        }
        if (list) {
            for (let j = 0; j < this.document.abstractLists.length; j++) {
                if (this.document.abstractLists[j].abstractListId === list.abstractListId) {
                    listLevel = this.document.abstractLists[j].levels[paragraph.paragraphFormat.listFormat.listLevelNumber];
                    break;
                }
            }
        }
        return listLevel;
    }
    getHtmlList(listLevel, levelNumer) {
        //if (start == null || (start != null && start.Paragraph != this)) {
        //    let block: BlockAdv = this.GetPreviousBlock();
        //    if (block instanceof ParagraphAdv) {
        //        let previousListLevel: ListLevelAdv = (block as ParagraphAdv).ParagraphFormat.ListFormat.ListLevel;
        //        if (previousListLevel == listLevel)
        //            return "";
        //    }
        //}
        let html = '';
        if (listLevel.listLevelPattern === 'Bullet') {
            html += '<ul type=\"';
            switch (levelNumer) {
                case 0:
                    html += 'disc';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                    break;
                case 1:
                    html += 'circle';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                    break;
                case 2:
                    html += 'square';
                    listLevel.characterFormat.fontFamily = 'Wingdings';
                    break;
                default:
                    html += 'disc';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                    break;
            }
            html += '\">';
        }
        else {
            html += '<ol type=\"';
            switch (listLevel.listLevelPattern) {
                case 'LowLetter':
                    html += 'a';
                    break;
                case 'UpLetter':
                    html += 'A';
                    break;
                case 'LowRoman':
                    html += 'i';
                    break;
                case 'UpRoman':
                    html += 'I';
                    break;
                default:
                    html += '1';
                    break;
            }
            html += '\" start=\"' + listLevel.startAt.toString() + '\">';
        }
        return html;
    }
    //SerializeInlines
    /**
     * @private
     */
    serializeInlines(paragraph, blockStyle) {
        let inline = undefined;
        let i = 0;
        while (paragraph.inlines.length > i) {
            inline = paragraph.inlines[i];
            if (inline.hasOwnProperty('imageString')) {
                blockStyle += this.serializeImageContainer(inline);
            }
            else if (inline.hasOwnProperty('fieldType')) {
                if (inline.fieldType === 0) {
                    let fieldCode = paragraph.inlines[i + 1];
                    if (!isNullOrUndefined(fieldCode) && (fieldCode.text.indexOf('TOC') >= 0 || fieldCode.text.indexOf('HYPERLINK') >= 0)) {
                        this.fieldCheck = 1;
                        let tagAttributes = [];
                        tagAttributes.push('style="' + this.serializeInlineStyle(inline.characterFormat, '') + '"');
                        blockStyle += this.createAttributesTag('a', tagAttributes);
                    }
                    else {
                        this.fieldCheck = undefined;
                    }
                }
                else if (inline.fieldType === 2) {
                    if (!isNullOrUndefined(this.fieldCheck)) {
                        this.fieldCheck = 2;
                    }
                    else {
                        this.fieldCheck = 0;
                    }
                }
                else {
                    if (!isNullOrUndefined(this.fieldCheck) && this.fieldCheck !== 0) {
                        blockStyle += this.endTag('a');
                    }
                    this.fieldCheck = 0;
                }
            }
            else {
                let text = isNullOrUndefined(inline.text) ? '' : inline.text;
                if (this.fieldCheck === 0) {
                    blockStyle += this.serializeSpan(text, inline.characterFormat);
                }
                if (this.fieldCheck === 1) {
                    let hyperLink = text.replace(/"/g, '');
                    blockStyle += ' href= \"' + hyperLink.replace('HYPERLINK', '').trim();
                    blockStyle += '\"';
                    blockStyle += '>';
                }
                if (this.fieldCheck === 2) {
                    blockStyle += text;
                }
            }
            i++;
        }
        return blockStyle;
    }
    // Serialize Span
    /**
     * @private
     */
    serializeSpan(spanText, characterFormat) {
        let spanClass = '';
        if (spanText.indexOf('\v') !== -1) {
            spanClass += '<br>';
            return spanClass.toString();
        }
        else if (spanText.indexOf('\f') !== -1) {
            spanClass += '<br style = "page-break-after:always;"/>';
            return spanClass.toString();
        }
        let tagAttributes = [];
        this.serializeInlineStyle(characterFormat, '');
        tagAttributes.push('style="' + this.serializeInlineStyle(characterFormat, '') + '"');
        spanClass += this.createAttributesTag('span', tagAttributes);
        let text = this.decodeHtmlNames(spanText.toString());
        if (text.length === 0) {
            text = '&nbsp';
        }
        spanClass += text;
        spanClass += this.endTag('span');
        return spanClass.toString();
    }
    //Serialize Image
    /**
     * @private
     */
    serializeImageContainer(image) {
        let imageStyle = '';
        let tagAttributes = [];
        this.serializeInlineStyle(image.characterFormat, '');
        let imageSource = '';
        if (!isNullOrUndefined(image.imageString)) {
            imageSource = image.imageString;
        }
        let width = HelperMethods.convertPointToPixel(image.width);
        let height = HelperMethods.convertPointToPixel(image.height);
        tagAttributes.push('width="', width.toString() + '"');
        tagAttributes.push('height="', height.toString() + '"');
        tagAttributes.push('src="', imageSource + '"');
        imageStyle += this.createAttributesTag('img', tagAttributes);
        imageStyle += (this.endTag('img'));
        return imageStyle.toString();
    }
    // Serialize Table Cell
    /**
     * @private
     */
    serializeCell(cell) {
        let blockStyle = '';
        let tagAttributes = [];
        let cellHtml = '';
        tagAttributes = [];
        if (!isNullOrUndefined(cell.cellFormat)) {
            //if (cell.cellFormat.shading.backgroundColor !== Color.FromArgb(0, 0, 0, 0)) {
            tagAttributes.push('bgcolor="' + cell.cellFormat.shading.backgroundColor + '"');
            // }
            if (!isNullOrUndefined(cell.cellFormat.columnSpan) && cell.cellFormat.columnSpan > 1) {
                tagAttributes.push('colspan="' + cell.cellFormat.columnSpan.toString() + '"');
            }
            if (!isNullOrUndefined(cell.cellFormat.rowSpan) && cell.cellFormat.rowSpan > 1) {
                tagAttributes.push('rowspan="' + cell.cellFormat.rowSpan.toString() + '"');
            }
            if (!isNullOrUndefined(cell.cellFormat.cellWidth) && cell.cellFormat.cellWidth !== 0) {
                tagAttributes.push('width="' + cell.cellFormat.cellWidth.toString() + '"');
            }
            if (!isNullOrUndefined(cell.cellFormat.verticalAlignment) && cell.cellFormat.verticalAlignment !== 'Top') {
                tagAttributes.push('valign="' + cell.cellFormat.verticalAlignment.toString().toLowerCase() + '"');
            }
            if (!isNullOrUndefined(cell.cellFormat.leftMargin) && cell.cellFormat.leftMargin !== 0) {
                cellHtml += ('padding-left:' + cell.cellFormat.leftMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.rightMargin) && cell.cellFormat.rightMargin !== 0) {
                cellHtml += ('padding-right:' + cell.cellFormat.rightMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.topMargin) && cell.cellFormat.topMargin !== 0) {
                cellHtml += ('padding-top:' + cell.cellFormat.topMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.bottomMargin) && cell.cellFormat.bottomMargin !== 0) {
                cellHtml += ('padding-bottom:' + cell.cellFormat.bottomMargin.toString() + 'pt;');
            }
            if (!isNullOrUndefined(cell.cellFormat.borders)) {
                cellHtml += this.serializeCellBordersStyle(cell.cellFormat.borders);
            }
        }
        if (cellHtml.length !== 0) {
            tagAttributes.push('style="' + cellHtml + '"');
        }
        blockStyle += (this.createAttributesTag('td', tagAttributes));
        for (let k = 0; k < cell.blocks.length; k++) {
            let block = cell.blocks[k];
            if (block.hasOwnProperty('rows')) {
                blockStyle += this.serializeTable(block);
            }
            else {
                blockStyle += this.serializeParagraph(block);
            }
        }
        blockStyle += (this.endTag('td'));
        return blockStyle;
    }
    // Serialize Table
    /**
     * @private
     */
    serializeTable(table) {
        let html = '';
        html += this.createTableStartTag(table);
        for (let j = 0; j < table.rows.length; j++) {
            html += this.serializeRow(table.rows[j]);
        }
        html += this.createTableEndTag();
        return html;
    }
    // Serialize Row
    /**
     * @private
     */
    serializeRow(row) {
        let html = '';
        html += this.createRowStartTag(row);
        for (let k = 0; k < row.cells.length; k++) {
            html += this.serializeCell(row.cells[k]);
        }
        return html;
    }
    // Serialize Styles
    /**
     * @private
     */
    serializeParagraphStyle(paragraph, className, isList) {
        let paragraphClass = '';
        paragraphClass += this.serializeCharacterFormat(paragraph.characterFormat);
        paragraphClass += this.serializeParagraphFormat(paragraph.paragraphFormat, isList);
        return paragraphClass;
    }
    /**
     * @private
     */
    serializeInlineStyle(characterFormat, className) {
        return this.serializeCharacterFormat(characterFormat);
    }
    /**
     * @private
     */
    serializeTableBorderStyle(borders) {
        let borderStyle = '';
        if (!isNullOrUndefined(borders.left.lineStyle)) {
            borderStyle += ('border-left-style:' + this.convertBorderLineStyle(borders.left.lineStyle));
            borderStyle += ';';
        }
        if (borders.left.lineWidth) {
            borderStyle += ('border-left-width:' + borders.left.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (borders.left.color) {
            borderStyle += ('border-left-color:' + borders.left.color);
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.right.lineStyle)) {
            borderStyle += ('border-right-style:' + this.convertBorderLineStyle(borders.right.lineStyle));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.right.lineWidth)) {
            borderStyle += ('border-right-width:' + borders.right.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.right.color)) {
            borderStyle += ('border-right-color:' + borders.right.color);
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.top.lineStyle)) {
            borderStyle += ('border-top-style:' + this.convertBorderLineStyle(borders.top.lineStyle));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.top.lineWidth)) {
            borderStyle += ('border-top-width:' + borders.top.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.top.color)) {
            borderStyle += ('border-top-color:' + borders.top.color);
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.bottom.lineStyle)) {
            borderStyle += ('border-bottom-style:' + this.convertBorderLineStyle(borders.bottom.lineStyle));
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.bottom.lineWidth)) {
            borderStyle += ('border-bottom-width:' + borders.bottom.lineWidth.toString() + 'pt');
            borderStyle += ';';
        }
        if (!isNullOrUndefined(borders.bottom.color)) {
            borderStyle += ('border-bottom-color:' + borders.bottom.color);
            borderStyle += ';';
        }
        return borderStyle;
    }
    /**
     * @private
     */
    serializeCellBordersStyle(borders) {
        let borderStyle = '';
        borderStyle = 'border:solid 1px;';
        // Todo: handle
        // let border: WBorder = undefined;
        // //LeftBorder
        // border = WCell.getCellLeftBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'left');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-left-style:none;');
        // }
        // //RightBorder
        // border = WCell.getCellRightBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'right');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-right-style:none');
        // }
        // //TopBorder
        // border = WCell.getCellTopBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'top');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-top-style:none');
        // }
        // //BottomBorder
        // border = WCell.getCellBottomBorder(WCell.getCellOf(borders));
        // if (!isNullOrUndefined(border) && border.lineStyle !== 'None') {
        //     borderStyle += this.serializeBorderStyle(border, 'bottom');
        // } else if (!isNullOrUndefined(border) && border.hasNoneStyle) {
        //     borderStyle += ('border-bottom-style:none');
        // }
        return borderStyle;
    }
    /**
     * @private
     */
    serializeBorderStyle(border, borderPosition) {
        let borderStyle = '';
        borderStyle += ('border-' + borderPosition + '-style:' + this.convertBorderLineStyle(border.lineStyle));
        borderStyle += ';';
        if (border.lineWidth > 0) {
            borderStyle += ('border-' + borderPosition + '-width:' + border.lineWidth.toString() + 'pt;');
        }
        //if (border.color !== Color.FromArgb(0, 0, 0, 0))
        borderStyle += ('border-' + borderPosition + '-color:' + border.color + ';');
        return borderStyle;
    }
    /**
     * @private
     */
    convertBorderLineStyle(lineStyle) {
        switch (lineStyle) {
            case 'None':
                return 'none';
            case 'Single':
                return 'solid';
            case 'Dot':
                return 'dotted';
            case 'DashSmallGap':
            case 'DashLargeGap':
            case 'DashDot':
            case 'DashDotDot':
                return 'dashed';
            case 'Double':
            case 'Triple':
            case 'ThinThickSmallGap':
            case 'ThickThinSmallGap':
            case 'ThinThickThinSmallGap':
            case 'ThinThickMediumGap':
            case 'ThickThinMediumGap':
            case 'ThinThickThinMediumGap':
            case 'ThinThickLargeGap':
            case 'ThickThinLargeGap':
            case 'ThinThickThinLargeGap':
                return 'double';
            case 'SingleWavy':
                return 'solid';
            case 'DoubleWavy':
                return 'double';
            case 'DashDotStroked':
                return 'solid';
            case 'Emboss3D':
                return 'ridge';
            case 'Engrave3D':
                return 'groove';
            case 'Outset':
                return 'outset';
            case 'Inset':
                return 'inset';
            default:
                return 'solid';
        }
    }
    // Serialize Format
    /**
     * @private
     */
    serializeCharacterFormat(characterFormat) {
        if (!isNullOrUndefined(characterFormat.inlineFormat)) {
            return this.serializeCharacterFormat(characterFormat.inlineFormat);
        }
        let propertyValue;
        let charStyle = '';
        if (characterFormat.bold) {
            charStyle += 'font-weight';
            charStyle += ':';
            charStyle += 'bold';
            charStyle += ';';
        }
        charStyle += 'font-style';
        charStyle += ':';
        if (characterFormat.italic) {
            charStyle += 'italic';
        }
        else {
            charStyle += 'normal';
        }
        charStyle += ';';
        // Double strike through will become Single strike through while saving HTML using MS Word.
        if (characterFormat.strikethrough === 'SingleStrike' || characterFormat.strikethrough === 'DoubleStrike') {
            charStyle += 'text-decoration';
            charStyle += ':';
            charStyle += 'line-through';
            charStyle += ';';
        }
        //Text Baseline Alignment
        // tslint:disable-next-line:max-line-length
        if (characterFormat.baselineAlignment === 'Superscript' || characterFormat.baselineAlignment === 'Subscript') {
            charStyle += 'vertical-align';
            charStyle += ':';
            charStyle += characterFormat.baselineAlignment === 'Superscript' ? 'super' : 'sub';
            charStyle += ';';
        }
        //Text Foreground and Background Color 
        if (!isNullOrUndefined(characterFormat.highlightColor)) {
            charStyle += 'background-color';
            charStyle += ':';
            charStyle += characterFormat.highlightColor.toString();
            charStyle += ';';
        }
        //Font Color
        propertyValue = characterFormat.fontColor;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'color';
            charStyle += ':';
            charStyle += propertyValue;
            charStyle += ';';
        }
        if (!isNullOrUndefined(characterFormat.underline) && characterFormat.underline !== 'None') {
            charStyle += 'text-decoration';
            charStyle += ':';
            charStyle += 'underline';
            charStyle += ';';
        }
        propertyValue = characterFormat.fontSize;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'font-size';
            charStyle += ':';
            charStyle += propertyValue.toString();
            charStyle += 'pt';
            charStyle += ';';
        }
        propertyValue = characterFormat.fontFamily;
        if (!isNullOrUndefined(propertyValue)) {
            charStyle += 'font-family';
            charStyle += ':';
            charStyle += propertyValue.toString();
            charStyle += ';';
        }
        return charStyle.toString();
    }
    /**
     * @private
     */
    serializeParagraphFormat(paragraphFormat, isList) {
        if (!isNullOrUndefined(paragraphFormat.inlineFormat)) {
            return this.serializeParagraphFormat(paragraphFormat.inlineFormat, isList);
        }
        let propertyValue;
        let paraStyle = '';
        propertyValue = paragraphFormat.textAlignment;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'text-align:' + propertyValue.toLowerCase() + ';';
        }
        propertyValue = paragraphFormat.beforeSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-top:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.rightIndent;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-right:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.afterSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-bottom:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.leftIndent;
        if (isList) {
            // if (isNullOrUndefined(propertyValue)) {
            //     propertyValue = -36;
            // } else {
            //     propertyValue -= 36;
            // }
            propertyValue = 0;
        }
        if (!isNullOrUndefined(propertyValue)) {
            paraStyle += 'margin-left:' + propertyValue.toString() + 'pt; ';
        }
        propertyValue = paragraphFormat.firstLineIndent;
        if (isList) {
            // if (isNullOrUndefined(propertyValue)) {
            //     propertyValue = 18;
            // } else {
            //     propertyValue += 18;
            // }
            propertyValue = 0;
        }
        if (!isNullOrUndefined(propertyValue) && propertyValue !== 0) {
            paraStyle += 'text-indent:' + propertyValue.toString() + 'pt;';
        }
        propertyValue = paragraphFormat.lineSpacing;
        if (!isNullOrUndefined(propertyValue)) {
            if (paragraphFormat.lineSpacingType === 'Multiple') {
                propertyValue = (propertyValue * 100).toString() + '%;';
            }
            else {
                propertyValue = propertyValue.toString() + 'pt;';
            }
            paraStyle += 'line-height:' + propertyValue;
        }
        return paraStyle.toString();
    }
    /**
     * @private
     */
    createAttributesTag(tagValue, localProperties) {
        let sb = '';
        sb += '<';
        sb += tagValue;
        for (let i = 0; i < localProperties.length; i++) {
            sb += ' ';
            sb += localProperties[i];
        }
        if (tagValue !== 'a') {
            sb += '>';
        }
        return sb;
    }
    /**
     * @private
     */
    createTag(tagValue) {
        let s = '';
        s += '<';
        s += tagValue;
        s += '>';
        return s;
    }
    /**
     * @private
     */
    endTag(tagValue) {
        let sb = '';
        sb += '<';
        sb += '/';
        sb += tagValue;
        sb += '>';
        return sb;
    }
    /**
     * @private
     */
    createTableStartTag(table) {
        let blockStyle = '';
        let tableStyle = '';
        let tagAttributes = [];
        tagAttributes.push('border="' + '1"');
        if (!isNullOrUndefined(table.tableFormat)) {
            //if (table.tableFormat.shading.backgroundColor !== Color.FromArgb(0, 0, 0, 0)) {
            if (!isNullOrUndefined(table.tableFormat.shading) && !isNullOrUndefined(table.tableFormat.shading.backgroundColor)) {
                tagAttributes.push('bgcolor="' + table.tableFormat.shading.backgroundColor + '"');
            }
            //}
            if (!isNullOrUndefined(table.tableFormat.leftIndent) && table.tableFormat.leftIndent !== 0) {
                tagAttributes.push('left-indent="' + table.tableFormat.leftIndent.toString() + 'pt;');
            }
            if (!isNullOrUndefined(table.tableFormat.cellSpacing) && table.tableFormat.cellSpacing > 0) {
                tagAttributes.push('cellspacing="' + (((table.tableFormat.cellSpacing * 72) / 96) * 2).toString() + '"');
            }
            else {
                tableStyle += ('border-collapse:collapse;');
            }
            tagAttributes.push('cellpadding="' + '0"');
            if (!isNullOrUndefined(table.tableFormat.borders)) {
                tableStyle += this.serializeTableBorderStyle(table.tableFormat.borders);
            }
        }
        if (tableStyle.length !== 0) {
            tagAttributes.push('style="', tableStyle.toString() + '"');
        }
        return blockStyle += (this.createAttributesTag('table', tagAttributes));
    }
    /**
     * @private
     */
    createTableEndTag() {
        let blockStyle = '';
        blockStyle += (this.endTag('table'));
        return blockStyle;
    }
    /**
     * @private
     */
    createRowStartTag(row) {
        let blockStyle = '';
        let tagAttributes = [];
        if (row.rowFormat.isHeader) {
            blockStyle += (this.createTag('thead'));
        }
        if (!isNullOrUndefined(row.rowFormat.height) && row.rowFormat.height > 0) {
            tagAttributes.push('height="' + row.rowFormat.height + '"');
        }
        return blockStyle + this.createAttributesTag('tr', tagAttributes);
    }
    /**
     * @private
     */
    createRowEndTag(row) {
        let blockStyle = '';
        blockStyle += (this.endTag('tr'));
        if (row.rowFormat.isHeader) {
            blockStyle += (this.endTag('thead'));
        }
        return blockStyle;
    }
    /**
     * @private
     */
    decodeHtmlNames(text) {
        if (text === '\t') {
            return '&emsp;';
        }
        let splittedText = text.split(' ');
        let htmlText = '';
        if (splittedText.length > 0) {
            htmlText = splittedText[0];
            for (let i = 0; i < splittedText.length - 1; i++) {
                htmlText += ' ' + splittedText[i + 1];
            }
        }
        return htmlText;
    }
}

/**
 * @private
 */
class TextPosition {
    constructor(owner) {
        /**
         * @private
         */
        this.location = new Point(0, 0);
        /**
         * @private
         */
        this.isUpdateLocation = true;
        this.owner = owner;
        this.viewer = this.owner.viewer;
    }
    /**
     * @private
     */
    get paragraph() {
        return this.currentWidget.paragraph;
    }
    /**
     * @private
     */
    get isAtParagraphStart() {
        return this.offset === this.owner.selection.getStartOffset(this.paragraph);
    }
    /**
     * @private
     */
    get isAtParagraphEnd() {
        return this.owner.selection.isParagraphLastLine(this.currentWidget)
            && this.offset === this.owner.selection.getLineLength(this.currentWidget);
    }
    /**
     * @private
     */
    get isCurrentParaBidi() {
        if (!isNullOrUndefined(this.currentWidget.paragraph)) {
            return this.currentWidget.paragraph.paragraphFormat.bidi;
        }
        return false;
    }
    /**
     * @private
     */
    get selection() {
        return this.owner.selection;
    }
    /**
     * Gets the hierarchical position of logical text position in the document
     * @returns {string}
     */
    get hierarchicalPosition() {
        return this.getHierarchicalIndexInternal();
    }
    /**
     * Return clone of current text position
     * @private
     */
    clone() {
        let textPosition = new TextPosition(this.owner);
        textPosition.currentWidget = this.currentWidget;
        textPosition.offset = this.offset;
        textPosition.location = this.location;
        return textPosition;
    }
    /**
     * @private
     */
    containsRtlText(widget) {
        for (let i = 0; i < widget.children.length; i++) {
            if (widget.children[i].isRightToLeft) {
                return true;
            }
        }
        return false;
    }
    /**
     * Set text position for paragraph and inline
     * @private
     */
    setPositionForSelection(line, element, index, physicalLocation) {
        //Set the start end position
        let isParagraphEnd = false;
        if (isNullOrUndefined(element)) {
            this.currentWidget = line;
        }
        else {
            this.currentWidget = element.line;
            if (element.nextNode instanceof FieldElementBox && index > element.length) {
                isParagraphEnd = this.selection.isLastRenderedInline(element, element.length);
            }
        }
        this.location = physicalLocation;
        if (isParagraphEnd) {
            this.offset = this.selection.getParagraphLength(this.currentWidget.paragraph) + 1;
        }
        else {
            this.offset = this.currentWidget.getOffset(element, index);
        }
    }
    /**
     * Set text position
     * @private
     */
    setPositionFromLine(line, offset, location) {
        this.currentWidget = line;
        this.offset = offset;
        if (location instanceof Point) {
            this.location.copy(location);
        }
    }
    /**
     * Set text position
     * @private
     */
    setPosition(line, positionAtStart) {
        this.currentWidget = line;
        this.offset = positionAtStart ? this.selection.getStartOffset(line.paragraph)
            : line.paragraph.lastChild.getEndOffset() + 1;
        this.updatePhysicalPosition(true);
    }
    /**
     * Set position for text position
     * @private
     */
    setPositionInternal(textPosition) {
        this.currentWidget = textPosition.currentWidget;
        this.offset = textPosition.offset;
        this.location = textPosition.location;
    }
    /**
     * Set position for current index
     * @private
     */
    setPositionForCurrentIndex(hierarchicalIndex) {
        let index = { index: hierarchicalIndex };
        let paragraph = this.getParagraphWidget(index); //ref hierarchicalIndex
        this.offset = parseFloat(index.index);
        this.setPositionParagraph(paragraph, this.offset);
    }
    /**
     * Get Page
     */
    getPage(position) {
        let page;
        let index = position.index.indexOf(';');
        let newValue = '0';
        if (index >= 0) {
            newValue = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        index = parseInt(newValue, 10);
        page = this.viewer.pages[index];
        return page;
    }
    /**
     * @private
     */
    getParagraphWidget(position) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        let page = this.getPage(position);
        let child = this.getLineWidget(undefined, position, page);
        return child;
    }
    /**
     * @private
     */
    getLineWidget(widget, position, page) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        let index = position.index.indexOf(';');
        let value = '0';
        if (index >= 0) {
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        if (value === 'H' || value === 'F') {
            if (value === 'H') {
                widget = page.headerWidget;
            }
            else {
                widget = page.footerWidget;
            }
        }
        else if (!isNullOrUndefined(page)) {
            widget = page.bodyWidgets[0];
        }
        index = parseInt(value, 10);
        if (widget instanceof BlockContainer) {
            index = position.index.indexOf(';');
            value = '0';
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
            index = parseInt(value, 10);
        }
        if (widget instanceof TableRowWidget && index >= widget.childWidgets.length) {
            position.index = '0;0';
            index = widget.childWidgets.length - 1;
        }
        if (index >= 0 && index < widget.childWidgets.length) {
            let child = widget.childWidgets[index];
            if (child instanceof LineWidget) {
                if (position.index.indexOf(';') > 0) {
                    position.index = '0';
                }
                return child;
            }
            if (child instanceof Widget) {
                if (position.index.indexOf(';') > 0) {
                    return this.getLineWidget(child, position);
                }
                else {
                    //If table is shifted to previous text position then return the first paragraph within table.
                    if (child instanceof TableWidget) {
                        return this.getLineWidget(this.selection.getFirstParagraphInFirstCell(child), position);
                    }
                    else if (child instanceof TableRowWidget && position.index.indexOf(';') === -1) {
                        return this.selection.getFirstParagraphInFirstCell(child.ownerTable).childWidgets[0];
                    }
                    return undefined;
                }
            }
        }
        else if (widget.nextRenderedWidget instanceof Widget) {
            position.index = '0';
            if (widget.nextRenderedWidget instanceof TableWidget) {
                return this.selection.getFirstParagraphInFirstCell(widget.nextRenderedWidget).firstChild;
            }
            return this.getLineWidget(widget.nextRenderedWidget, position);
        }
        return undefined;
    }
    /**
     * Update physical location of paragraph
     * @private
     */
    updatePhysicalPosition(moveNextLine) {
        if (this.currentWidget && this.owner.isLayoutEnabled && this.isUpdateLocation) {
            this.location = this.selection.getPhysicalPositionInternal(this.currentWidget, this.offset, moveNextLine);
        }
    }
    /**
     * Return true if text position are in same paragraph and offset
     * @private
     */
    isAtSamePosition(textPosition) {
        return this.currentWidget === textPosition.currentWidget
            && this.offset === textPosition.offset;
    }
    /**
     * Return true if text position is in same paragraph
     * @private
     */
    isInSameParagraph(textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        return this.paragraph === textPosition.paragraph;
    }
    /**
     * Return true is current text position exist before given text position
     * @private
     */
    isExistBefore(textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        if (this.currentWidget === textPosition.currentWidget) {
            return this.offset < textPosition.offset;
        }
        let currentParagraph = this.currentWidget.paragraph;
        let paragraph = textPosition.currentWidget.paragraph;
        if (currentParagraph === paragraph) {
            return currentParagraph.childWidgets.indexOf(this.currentWidget) < paragraph.childWidgets.indexOf(textPosition.currentWidget);
        }
        if (currentParagraph.containerWidget === paragraph.containerWidget) {
            if (currentParagraph.isInsideTable) {
                return currentParagraph.associatedCell.childWidgets.indexOf(currentParagraph) <
                    paragraph.associatedCell.childWidgets.indexOf(paragraph);
                //handle after header footer implementation
                // } else if ((this.currentParagraph).owner instanceof WHeaderFooter) {
                //     return ((this.currentParagraph).owner as WHeaderFooter).blocks.indexOf((this.currentParagraph)) <
                //         ((textPosition.currentParagraph).owner as WHeaderFooter).blocks.indexOf((textPosition.currentParagraph));
            }
            else {
                return (currentParagraph.containerWidget.childWidgets.indexOf(currentParagraph)) <
                    (paragraph.containerWidget.childWidgets.indexOf(paragraph));
            }
        }
        return this.owner.selection.isExistBefore(currentParagraph, paragraph);
    }
    /**
     * Return true is current text position exist after given text position
     * @private
     */
    isExistAfter(textPosition) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        if (this.currentWidget === textPosition.currentWidget) {
            return this.offset > textPosition.offset;
        }
        if (this.currentWidget.paragraph === textPosition.currentWidget.paragraph) {
            return this.currentWidget.paragraph.childWidgets.indexOf(this.currentWidget) >
                textPosition.currentWidget.paragraph.childWidgets.indexOf(textPosition.currentWidget);
        }
        let startParagraph = this.currentWidget.paragraph;
        let endParagraph = textPosition.currentWidget.paragraph;
        if (startParagraph.containerWidget instanceof BodyWidget && endParagraph.containerWidget instanceof BodyWidget &&
            startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable && endParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) >
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
                // } else if ((this.currentParagraph).owner instanceof WHeaderFooter) {
                //     return ((this.currentParagraph).owner as WHeaderFooter).blocks.indexOf((this.currentParagraph)) >
                //         ((textPosition.currentParagraph).owner as WHeaderFooter).blocks.indexOf((textPosition.currentParagraph));
            }
            else {
                return (startParagraph.containerWidget.childWidgets.indexOf(startParagraph) >
                    (endParagraph.containerWidget.childWidgets.indexOf(endParagraph)));
            }
        }
        return this.owner.selection.isExistAfter(startParagraph, endParagraph);
    }
    /**
     * Return hierarchical index of current text position
     * @private
     */
    getHierarchicalIndexInternal() {
        return this.getHierarchicalIndex(this.currentWidget, this.offset.toString());
    }
    /**
     * @private
     */
    getHierarchicalIndex(line, hierarchicalIndex) {
        let node = line;
        if (node) {
            return node.getHierarchicalIndex(hierarchicalIndex);
        }
        return hierarchicalIndex;
    }
    /**
     * @private
     */
    setPositionParagraph(line, offsetInLine) {
        this.currentWidget = line;
        this.offset = offsetInLine;
        this.updatePhysicalPosition(true);
    }
    /**
     * @private
     */
    setPositionForLineWidget(lineWidget, offset) {
        let lineLength = this.selection.getLineLength(lineWidget);
        let lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        if (lineWidget.isLastLine()) {
            lineLength = lineLength + 1;
        }
        if (offset > lineLength) {
            let nextLineWidget;
            if (lineIndex >= lineWidget.paragraph.childWidgets.length - 1) {
                let nextBlock = this.selection.getNextRenderedBlock(lineWidget.paragraph);
                if (nextBlock && nextBlock.index === lineWidget.paragraph.index) {
                    nextLineWidget = nextBlock.firstChild;
                }
            }
            else {
                nextLineWidget = lineWidget.paragraph.childWidgets[lineIndex + 1];
            }
            this.setPositionForLineWidget(nextLineWidget, offset - lineLength);
            return;
        }
        else if (offset < 0) {
            let prevLine = lineWidget.paragraph.childWidgets[lineIndex - 1];
            let currentOffSet = this.selection.getLineLength(prevLine) + offset;
            this.setPositionForLineWidget(prevLine, currentOffSet);
            return;
        }
        else {
            this.currentWidget = lineWidget;
            this.offset = offset;
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * move to next text position
     * @private
     */
    moveNextPosition(isNavigate) {
        if (isNullOrUndefined(isNavigate)) {
            isNavigate = true;
        }
        let inline = this.selection.getNextStartInline(this.currentWidget, this.offset);
        if (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
            if (isNavigate) {
                this.moveNextPositionInternal(inline);
                this.moveNextPosition();
                return;
            }
            else {
                let line = inline.fieldEnd.line;
                let fieldEnd = inline.fieldEnd;
                let fieldEndOffset = line.getOffset(fieldEnd, 1);
                let fieldEndIndex = this.getHierarchicalIndex(line, fieldEndOffset.toString());
                if (TextPosition.isForwardSelection(this.selection.end.getHierarchicalIndexInternal(), fieldEndIndex)) {
                    //If field end is after selection end, extend selection end to field end.
                    this.selection.end.moveToInline(inline.fieldEnd, 1);
                    return;
                }
                this.moveToInline(inline.fieldEnd, 1);
            }
        }
        let nextOffset = this.selection.getNextValidOffset(this.currentWidget, this.offset);
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        let index = 0;
        if (nextOffset > this.offset) {
            this.offset = nextOffset;
            let info = this.currentWidget.getInline(this.offset, index);
            inline = info.element;
            index = info.index;
            if (!isNullOrUndefined(inline) && index === inline.length && inline.nextNode instanceof FieldElementBox) {
                let nextValidInline = this.selection.getNextValidElement(inline.nextNode);
                //Moves to field end mark.
                if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 1) {
                    inline = nextValidInline;
                    this.offset = this.currentWidget.getOffset(inline, 1);
                }
            }
        }
        else if (lineIndex + 1 < this.paragraph.childWidgets.length) {
            let nextLineWidget = this.paragraph.childWidgets[lineIndex + 1];
            if (nextLineWidget) {
                this.currentWidget = nextLineWidget;
                this.offset = this.selection.getStartLineOffset(this.currentWidget);
            }
            let inlineObj = this.currentWidget.getInline(this.offset, index);
            inline = inlineObj.element;
            index = inlineObj.index;
            if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                this.offset++;
            }
        }
        else {
            this.updateOffsetToNextParagraph(index, false);
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Move text position to previous paragraph inside table
     * @private
     */
    moveToPreviousParagraphInTable(selection) {
        let previousParagraph;
        let currentPara = this.currentWidget.paragraph;
        if (currentPara.isInsideTable) {
            previousParagraph = selection.getPreviousSelectionCell(currentPara.associatedCell);
        }
        else {
            previousParagraph = selection.getPreviousParagraphBlock(currentPara);
        }
        if (isNullOrUndefined(previousParagraph)) {
            return;
        }
        this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
        this.offset = this.currentWidget.getEndOffset() + 1;
    }
    updateOffsetToNextParagraph(indexInInline, isHighlight) {
        //Moves to owner and get next paragraph.
        let inline;
        let positionAtStart = false;
        let nextParagraph = undefined;
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        if (!isHighlight) {
            nextParagraph = this.selection.getNextParagraphBlock(this.paragraph);
        }
        else if (lineIndex + 1 < this.paragraph.childWidgets.length) {
            let nextLineWidget = this.paragraph.childWidgets[lineIndex + 1];
            if (nextLineWidget) {
                this.currentWidget = nextLineWidget;
                this.offset = 1;
            }
        }
        else {
            nextParagraph = this.selection.getNextSelectionBlock(this.paragraph);
            if (!isNullOrUndefined(nextParagraph)) {
                if (nextParagraph.containerWidget instanceof TableCellWidget) {
                    if (this.selection.start.paragraph.isInsideTable) {
                        // tslint:disable-next-line:max-line-length
                        let containerCell = this.selection.getContainerCellOf(this.selection.start.paragraph.associatedCell, nextParagraph.associatedCell);
                        positionAtStart = !containerCell.ownerTable.contains(nextParagraph.associatedCell);
                    }
                    else {
                        positionAtStart = true;
                    }
                }
            }
        }
        if (!isNullOrUndefined(nextParagraph) && nextParagraph.childWidgets.length > 0) {
            if (!positionAtStart) {
                this.currentWidget = nextParagraph.firstChild;
                this.offset = isHighlight ? 1 : this.selection.getStartLineOffset(this.currentWidget);
            }
            else {
                this.currentWidget = nextParagraph.childWidgets[nextParagraph.childWidgets.length - 1];
                this.offset = this.selection.getLineLength(this.currentWidget) + 1;
            }
        }
        let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            this.offset++;
        }
    }
    updateOffsetToPrevPosition(index, isHighlight) {
        let inlineInfo;
        let inline;
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        let prevOffset = this.selection.getPreviousValidOffset(this.currentWidget.paragraph, this.offset);
        if (this.offset > prevOffset) {
            this.offset = prevOffset;
        }
        else if (lineIndex > 0) {
            let prevLineWidget = this.paragraph.childWidgets[lineIndex - 1];
            if (prevLineWidget) {
                this.currentWidget = prevLineWidget;
                let endOffset = this.currentWidget.getEndOffset();
                this.offset = endOffset > 0 ? endOffset - 1 : endOffset;
            }
        }
        else {
            //Moves to owner and get previous paragraph.
            let previousParagraph = undefined;
            let positionAtStart = false;
            if (!isHighlight) {
                previousParagraph = this.selection.getPreviousParagraphBlock(this.paragraph);
            }
            else {
                previousParagraph = this.selection.getPreviousSelectionBlock(this.paragraph);
                if (!isNullOrUndefined(previousParagraph)) {
                    if (previousParagraph.containerWidget instanceof TableCellWidget) {
                        if (this.selection.start.paragraph.isInsideTable) {
                            // tslint:disable-next-line:max-line-length
                            let containerCell = this.selection.getContainerCellOf(this.selection.start.paragraph.associatedCell, previousParagraph.associatedCell);
                            positionAtStart = !containerCell.ownerTable.contains(previousParagraph.associatedCell);
                        }
                        else {
                            positionAtStart = true;
                        }
                    }
                }
            }
            if (!isNullOrUndefined(previousParagraph)) {
                if (!positionAtStart) {
                    this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
                    this.offset = this.currentWidget.getEndOffset();
                }
                else {
                    this.currentWidget = previousParagraph.firstChild;
                    this.offset = this.selection.getStartLineOffset(this.currentWidget);
                }
            }
        }
        index = 0;
        inlineInfo = this.currentWidget.getInline(this.offset, index);
        inline = inlineInfo.element;
        index = inlineInfo.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            this.offset++;
        }
        if (inline instanceof FieldElementBox) {
            //Checks if field character is part of rendered field, otherwise moves to previous rendered content.
            let previousInline = this.selection.getPreviousValidElement(inline);
            if (!isNullOrUndefined(previousInline)) {
                inline = previousInline;
                this.currentWidget = inline.line;
                this.offset = this.currentWidget.getOffset(inline, inline.length);
                if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                    this.offset--;
                }
            }
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Moves the text position to start of the next paragraph.
     */
    moveToNextParagraphStartInternal() {
        let paragraph = this.currentWidget.paragraph;
        if (!isNullOrUndefined(this.selection.getNextParagraphBlock(paragraph))) {
            // tslint:disable-next-line:max-line-length
            this.currentWidget = this.selection.getNextParagraphBlock(paragraph).firstChild;
            this.offset = this.selection.getStartOffset(paragraph);
            this.updatePhysicalPosition(true);
        }
    }
    /**
     * Move to previous position
     * @private
     */
    movePreviousPosition() {
        let index = 0;
        let inlineInfo = this.currentWidget.getInline(this.offset, index);
        let inline = inlineInfo.element;
        index = inlineInfo.index;
        let lineIndex = this.paragraph.childWidgets.indexOf(this.currentWidget);
        if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
            this.movePreviousPositionInternal(inline);
        }
        this.updateOffsetToPrevPosition(index, false);
    }
    /**
     * Move to next position
     * @private
     */
    moveNextPositionInternal(fieldBegin) {
        let inline;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            inline = fieldBegin.fieldEnd;
        }
        else {
            inline = fieldBegin.fieldSeparator;
            this.currentWidget = inline.line;
            // tslint:disable-next-line:max-line-length
            if (this.currentWidget === fieldBegin.fieldEnd.line && !this.selection.hasValidInline(this.paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
        }
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, 1);
    }
    /**
     * Move text position backward
     * @private
     */
    moveBackward() {
        let indexInInline = 0;
        let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!this.owner.selection.isEmpty && !isNullOrUndefined(inline)) {
            let nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
            if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
                let hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
                // tslint:disable-next-line:max-line-length
                let fieldEndOffset = nextInline.fieldEnd.line.getOffset(nextInline.fieldEnd, 1);
                // tslint:disable-next-line:max-line-length
                let fieldEndIndex = this.getHierarchicalIndex(nextInline.fieldEnd.line, fieldEndOffset.toString());
                if (!TextPosition.isForwardSelection(fieldEndIndex, hierarchicalIndex)) {
                    //If field end is after selection start, move selection start to field end.
                    // tslint:disable-next-line:max-line-length
                    this.owner.selection.start.setPositionParagraph(nextInline.fieldEnd.line, fieldEndOffset);
                    return;
                }
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
            let hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
            let fieldEndOffset = inline.line.getOffset(inline, 1);
            let fieldEndIndex = this.getHierarchicalIndex(inline.line, fieldEndOffset.toString());
            if (!TextPosition.isForwardSelection(hierarchicalIndex, fieldEndIndex)) {
                //If field end is after selection start, extend selection end to field begin.
                // tslint:disable-next-line:max-line-length
                let fieldBeginOffset = inline.fieldBegin.line.getOffset(inline.fieldBegin, 0);
                this.currentWidget = inline.fieldBegin.line;
                this.offset = fieldBeginOffset;
                //Updates physical position in current page.
                this.updatePhysicalPosition(true);
                return;
            }
            this.movePreviousPositionInternal(inline);
        }
        this.updateOffsetToPrevPosition(indexInInline, true);
    }
    /**
     * Move text position forward
     * @private
     */
    moveForward() {
        let indexInInline = 0;
        let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!isNullOrUndefined(inline)) {
            if (!this.owner.selection.isEmpty && indexInInline === inline.length && inline instanceof FieldElementBox
                && inline.fieldType === 1) {
                let hierarchicalIndex = this.owner.selection.start.getHierarchicalIndexInternal();
                // tslint:disable-next-line:max-line-length
                let fieldBeginOffset = inline.fieldBegin.line.getOffset(inline.fieldBegin, 0);
                // tslint:disable-next-line:max-line-length
                let fieldBeginIndex = this.getHierarchicalIndex(inline.fieldBegin.line, fieldBeginOffset.toString());
                if (!TextPosition.isForwardSelection(hierarchicalIndex, fieldBeginIndex)) {
                    //If field begin is before selection start, move selection start to field begin.
                    // tslint:disable-next-line:max-line-length
                    this.owner.selection.start.setPositionParagraph(inline.fieldBegin.line, fieldBeginOffset);
                    return;
                }
            }
            inline = this.selection.getNextRenderedElementBox(inline, indexInInline);
        }
        if (inline instanceof FieldElementBox && !isNullOrUndefined(inline.fieldEnd)) {
            let selectionStartParagraph = this.owner.selection.start.paragraph;
            let selectionStartIndex = 0;
            // tslint:disable-next-line:max-line-length
            let selectionStartInlineObj = selectionStartParagraph.getInline(this.owner.selection.start.offset, selectionStartIndex);
            let selectionStartInline = selectionStartInlineObj.element;
            selectionStartIndex = selectionStartInlineObj.index;
            let nextRenderInline = this.selection.getNextRenderedElementBox(selectionStartInline, selectionStartIndex);
            if (nextRenderInline === inline) {
                this.moveNextPositionInternal(inline);
            }
            else {
                //If selection start is before field begin, extend selection end to field end.
                inline = inline.fieldEnd;
                this.currentWidget = inline.line;
                this.offset = this.currentWidget.getOffset(inline, 1);
                //Updates physical position in current page.
                this.updatePhysicalPosition(true);
                return;
            }
        }
        else if ((inline instanceof FieldElementBox)
            && (inline.fieldType === 0 || inline.fieldType === 1)) {
            this.currentWidget = inline.line;
            this.offset = this.currentWidget.getOffset(inline, 1);
        }
        indexInInline = 0;
        let nextOffset = this.selection.getNextValidOffset(this.currentWidget, this.offset);
        let length = this.selection.getLineLength(this.currentWidget);
        let isParagraphEnd = this.selection.isParagraphLastLine(this.currentWidget);
        if (this.offset < nextOffset) {
            this.offset = nextOffset;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
                let nextValidInline = this.selection.getNextValidElement(inline.nextNode);
                //Moves to field end mark.
                if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 1) {
                    inline = nextValidInline;
                    this.offset = this.currentWidget.getOffset(inline, 1);
                }
            }
        }
        else if (this.offset === nextOffset && this.offset < length + 1 && isParagraphEnd) {
            this.offset = length + 1;
        }
        else {
            this.updateOffsetToNextParagraph(indexInInline, true);
        }
        //Gets physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Move to given inline
     * @private
     */
    moveToInline(inline, index) {
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, index);
        //Updates physical position in current page.
        this.updatePhysicalPosition(true);
    }
    /**
     * Return true is start element exist before end element
     * @private
     */
    static isForwardSelection(start, end) {
        if (start === end) {
            return true;
        }
        start = start.replace(/C;/g, '');
        end = end.replace(/C;/g, '');
        start = start.replace(/H;/g, '');
        end = end.replace(/H;/g, '');
        start = start.replace(/F;/g, '');
        end = end.replace(/F;/g, '');
        let selectionStart = start.split(';');
        let selectionEnd = end.split(';');
        let length = selectionStart.length;
        if (length > selectionEnd.length) {
            length = selectionEnd.length - 1;
        }
        for (let i = 0; i < length; i++) {
            let startOffset = parseFloat(selectionStart[i]);
            let endOffset = parseFloat(selectionEnd[i]);
            if (startOffset !== endOffset) {
                return startOffset < endOffset;
            }
        }
        return false;
    }
    /**
     * Move to previous position offset
     * @private
     */
    movePreviousPositionInternal(fieldEnd) {
        let inline;
        if (isNullOrUndefined(fieldEnd.fieldSeparator)) {
            inline = this.selection.getPreviousValidElement(fieldEnd.fieldBegin);
        }
        else {
            inline = this.selection.getPreviousValidElement(fieldEnd);
        }
        this.currentWidget = inline.line;
        this.offset = this.currentWidget.getOffset(inline, inline instanceof FieldElementBox ? 0 : inline.length);
    }
    /**
     * Moves the text position to start of the word.
     * @private
     */
    moveToWordStartInternal(type) {
        let endOffset = this.currentWidget.getEndOffset();
        let currentPara = this.currentWidget.paragraph;
        let selection = this.selection;
        if (type === 2 && (this.offset === endOffset || this.offset === endOffset + 1)) {
            return;
        }
        if (this.offset === endOffset + 1) {
            this.offset = endOffset;
        }
        else if (this.offset === selection.getStartOffset(currentPara) && this.currentWidget === currentPara.childWidgets[0]) {
            let previousParagraph = selection.getPreviousParagraphBlock(currentPara);
            if (isNullOrUndefined(previousParagraph)) {
                return;
            }
            this.currentWidget = previousParagraph.childWidgets[previousParagraph.childWidgets.length - 1];
            this.offset = this.currentWidget.getEndOffset();
        }
        else {
            if (this.offset === selection.getStartLineOffset(this.currentWidget)) {
                let lineIndex = currentPara.childWidgets.indexOf(this.currentWidget);
                if (lineIndex - 1 >= 0) {
                    this.currentWidget = currentPara.childWidgets[lineIndex - 1];
                    this.offset = this.currentWidget.getEndOffset();
                }
            }
            let isStarted = false;
            let endSelection = false;
            let indexInInline = 0;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            // tslint:disable-next-line:max-line-length           
            this.getPreviousWordOffset(inline, selection, indexInInline, type, (inline instanceof FieldElementBox && inline.fieldType === 1), isStarted, endSelection, this);
        }
        if (type === 1) {
            this.calculateOffset();
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Get next word offset
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffset(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (inline instanceof TextElementBox) {
            this.getNextWordOffsetSpan(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof ImageElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetImage(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldBegin(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2 || inline instanceof BookmarkElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldSeperator(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldEnd(inline, indexInInline, type, isInField, endSelection, endPosition, excludeSpace);
        }
    }
    /**
     * get next word offset from field begin
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetFieldBegin(fieldBegin, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        let startOffset = fieldBegin.line.getOffset(fieldBegin, 0);
        let endOffset = startOffset + fieldBegin.length;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            this.getNextWordOffsetFieldEnd(fieldBegin.fieldEnd, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (type === 0) {
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffsetFieldSeperator(fieldBegin.fieldSeparator, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
        else if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
            let inline = fieldBegin.fieldSeparator;
            // tslint:disable-next-line:max-line-length
            if (inline.line.paragraph === fieldBegin.fieldEnd.line.paragraph && !this.selection.hasValidInline(inline.line.paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
            // tslint:disable-next-line:max-line-length
            this.getNextWordOffset(inline, 0, type, !(endPosition.paragraph === fieldBegin.line.paragraph && endPosition.offset === startOffset), endSelection, endPosition, excludeSpace);
            // tslint:disable-next-line:max-line-length
            if (endSelection && !isNullOrUndefined(fieldBegin.fieldSeparator) && (endPosition.paragraph === fieldBegin.line.paragraph) && (endPosition.offset === fieldBegin.fieldSeparator.line.getOffset(fieldBegin.fieldSeparator, fieldBegin.fieldSeparator.length))) {
                endPosition.setPositionParagraph(fieldBegin.line, startOffset);
                return;
            }
            if (!endSelection) {
                // tslint:disable-next-line:max-line-length
                endPosition.setPositionParagraph(fieldBegin.fieldEnd.line, fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, fieldBegin.fieldEnd.length));
            }
        }
    }
    /**
     * get next word offset from image
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetImage(image, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (isInField) {
            endPosition.setPositionParagraph(image.line, image.line.getOffset(image, indexInInline));
            endSelection = false;
            return;
        }
        if (indexInInline === 0) {
            let startOffset = image.line.getOffset(image, 0);
            endSelection = true;
            if (endPosition.offset === startOffset) {
                if (isNullOrUndefined(image.nextNode)) {
                    endPosition.setPositionParagraph(image.line, startOffset + image.length);
                }
                else {
                    this.getNextWordOffset(image.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                }
            }
            else {
                endPosition.setPositionParagraph(image.line, startOffset);
            }
        }
        else if (!isNullOrUndefined(image.nextNode)) {
            this.getNextWordOffset(image.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
    }
    /**
     * get next word offset from span
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetSpan(span, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (span.text === '\t' || span.text === '\v') {
            if (isInField) {
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                endSelection = false;
                return;
            }
            if (indexInInline === 0) {
                endSelection = true;
                let startOffset = span.line.getOffset(span, 0);
                if (endPosition.offset === startOffset) {
                    endPosition.setPositionParagraph(span.line, startOffset + span.length);
                }
                else {
                    endPosition.setPositionParagraph(span.line, startOffset);
                }
            }
            else if (!isNullOrUndefined(span.nextNode)) {
                this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
            }
        }
        else {
            let wordEndIndex = 0;
            if (indexInInline === 0 && endSelection && (HelperMethods.wordSplitCharacters.indexOf(span.text[0]) === -1)) {
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                if (isInField) {
                    return;
                }
            }
            else if (indexInInline < span.length) {
                // tslint:disable-next-line:max-line-length
                let txt = indexInInline > 0 && span.text.length - 1 >= indexInInline ? span.text.slice(indexInInline, span.length) : span.text;
                wordEndIndex = HelperMethods.indexOfAny(txt, HelperMethods.wordSplitCharacters);
                if (wordEndIndex !== -1) {
                    if (isInField) {
                        endSelection = false;
                        return;
                    }
                    let offset = span.line.getOffset(span, wordEndIndex + indexInInline);
                    // tslint:disable-next-line:max-line-length
                    if ((excludeSpace || txt[wordEndIndex] !== ' ') && !endSelection && span.line.paragraph === endPosition.paragraph && offset !== endPosition.offset) {
                        endSelection = true;
                        endPosition.setPositionParagraph(span.line, offset);
                        return;
                    }
                    wordEndIndex++;
                    while (wordEndIndex < txt.length && HelperMethods.wordSplitCharacters.indexOf(txt[wordEndIndex]) !== -1) {
                        if (txt[wordEndIndex] !== ' ' && txt[wordEndIndex] !== '　') {
                            break;
                        }
                        wordEndIndex++;
                    }
                    endSelection = true;
                    if (wordEndIndex < txt.length) {
                        // tslint:disable-next-line:max-line-length
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, wordEndIndex + indexInInline));
                    }
                    else if (!isNullOrUndefined(span.nextNode)) {
                        // tslint:disable-next-line:max-line-length
                        this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                    }
                    else {
                        // tslint:disable-next-line:max-line-length
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, wordEndIndex + indexInInline));
                    }
                }
                else if (!isNullOrUndefined(span.nextNode)) {
                    this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
                }
                else {
                    endPosition.setPositionParagraph(span.line, span.line.getEndOffset());
                }
            }
            else if (!isNullOrUndefined(span.nextNode)) {
                this.getNextWordOffset(span.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
            }
        }
    }
    /**
     * get next word offset from field separator
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetFieldSeperator(fieldSeparator, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        if (!isNullOrUndefined(fieldSeparator.nextNode)) {
            this.getNextWordOffset(fieldSeparator.nextNode, 0, type, isInField, endSelection, endPosition, excludeSpace);
        }
    }
    /**
     * get next word offset from field end
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getNextWordOffsetFieldEnd(fieldEnd, indexInInline, type, isInField, endSelection, endPosition, excludeSpace) {
        let startOffset = fieldEnd.line.getOffset(fieldEnd, 0);
        let endOffset = startOffset + fieldEnd.length;
        if (endPosition.offset === startOffset) {
            endPosition.setPositionParagraph(fieldEnd.line, endOffset);
            if (isNullOrUndefined(fieldEnd.nextNode)) {
                return;
            }
        }
        if (!isNullOrUndefined(fieldEnd.nextNode)) {
            this.getNextWordOffset(fieldEnd.nextNode, 0, type, false, endSelection, endPosition, excludeSpace);
            if (endPosition.offset === endOffset) {
                endPosition.setPositionParagraph(fieldEnd.line, startOffset);
            }
        }
        else {
            endPosition.setPositionParagraph(fieldEnd.line, startOffset);
        }
        endSelection = true;
    }
    /**
     * Get previous word offset
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffset(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (inline instanceof TextElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetSpan(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof ImageElementBox) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetImage(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldBegin(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldSeparator(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetFieldEnd(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof BookmarkElementBox) {
            this.getPreviousWordOffsetBookMark(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (inline instanceof ListTextElementBox && inline.previousNode) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffsetSpan(inline.previousNode, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
        }
    }
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetBookMark(bookmark, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (bookmark.previousNode) {
            if (bookmark.previousNode instanceof TextElementBox) {
                let inline = bookmark.previousNode;
                if (HelperMethods.lastIndexOfAny(inline.text, HelperMethods.wordSplitCharacters) !== inline.text.length - 1) {
                    this.getPreviousWordOffset(inline, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                }
                else {
                    endPosition.setPositionParagraph(bookmark.line, bookmark.line.getOffset(bookmark, 0));
                }
            }
        }
        else {
            endPosition.setPositionParagraph(bookmark.line, selection.getStartLineOffset(bookmark.line));
        }
    }
    /**
     * get previous word offset from field end
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetFieldEnd(fieldEnd, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        let startOffset = fieldEnd.line.getOffset(fieldEnd, 0);
        let endOffset = startOffset + fieldEnd.length;
        if (isNullOrUndefined(fieldEnd.fieldSeparator)) {
            this.getPreviousWordOffsetFieldBegin(fieldEnd.fieldBegin, selection, 0, type, isInField, isStarted, endSelection, endPosition);
        }
        else if (type === 0 && !isNullOrUndefined(fieldEnd.previousNode)) {
            let inline = fieldEnd.previousNode;
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(inline, selection, inline.length, type, (inline instanceof FieldElementBox && inline.fieldType === 1), isStarted, endSelection, endPosition);
        }
        else if (!isNullOrUndefined(fieldEnd.fieldBegin) && type !== 0) {
            let inline = fieldEnd.previousNode;
            // tslint:disable-next-line:max-line-length
            if (isNullOrUndefined(inline) || (inline.line.paragraph === fieldEnd.fieldBegin.line.paragraph && !selection.hasValidInline(inline.line.paragraph, inline, fieldEnd.fieldBegin))) {
                inline = fieldEnd.fieldBegin;
            }
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(inline, selection, inline.length, type, !(endPosition.paragraph === fieldEnd.line.paragraph && endPosition.offset === endOffset), isStarted, endSelection, endPosition);
            if (endSelection && endPosition.paragraph === fieldEnd.line.paragraph
                && endPosition.offset === startOffset) {
                endPosition.setPositionParagraph(fieldEnd.line, endOffset);
                return;
            }
            if (!endSelection) {
                // tslint:disable-next-line:max-line-length
                endPosition.setPositionParagraph(fieldEnd.fieldBegin.line, fieldEnd.fieldBegin.line.getOffset(fieldEnd.fieldBegin, 0));
            }
        }
    }
    /**
     * get previous word offset from field separator
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetFieldSeparator(fieldSeparator, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        this.getPreviousWordOffsetFieldBegin(fieldSeparator.fieldBegin, selection, fieldSeparator.fieldBegin.length, type, isInField, isStarted, endSelection, endPosition);
    }
    /**
     * get previous word offset from field begin
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetFieldBegin(fieldBegin, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        let startOffset = fieldBegin.line.getOffset(fieldBegin, 0);
        let endOffset = startOffset + fieldBegin.length;
        if (endPosition.offset === endOffset) {
            endPosition.setPositionParagraph(fieldBegin.line, startOffset);
        }
        if (!isNullOrUndefined(fieldBegin.previousNode)) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(fieldBegin.previousNode, selection, fieldBegin.previousNode.length, type, false, isStarted, endSelection, endPosition);
            if (endPosition.offset === startOffset) {
                if (type !== 0 && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    // tslint:disable-next-line:max-line-length
                    endPosition.setPositionParagraph(fieldBegin.line, fieldBegin.fieldSeparator.line.getOffset(fieldBegin.fieldSeparator, fieldBegin.fieldSeparator.length));
                }
            }
        }
        else {
            endPosition.setPositionParagraph(fieldBegin.line, selection.getStartLineOffset(fieldBegin.line));
        }
    }
    /**
     * get previous word offset from image
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getPreviousWordOffsetImage(image, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (isInField) {
            endPosition.setPositionParagraph(image.line, image.line.getOffset(image, indexInInline));
            endSelection = false;
            return;
        }
        if (indexInInline === image.length) {
            let endOffset = image.line.getOffset(image, image.length);
            if (endOffset === endPosition.offset) {
                endPosition.setPositionParagraph(image.line, endOffset - image.length);
            }
            else {
                endPosition.setPositionParagraph(image.line, endOffset);
            }
        }
        else if (!isNullOrUndefined(image.previousNode)) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(image.previousNode, selection, image.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
        }
    }
    /**
     * Get previous word offset from span
     * @private
     */
    // tslint:disable-next-line:max-line-length   
    getPreviousWordOffsetSpan(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (span.text === '\t' || span.text === '\v') {
            if (isInField) {
                endSelection = false;
                return;
            }
            if (indexInInline === span.length) {
                endSelection = true;
                let endOffset = span.line.getOffset(span, span.length);
                if (endOffset === endPosition.offset) {
                    endPosition.setPositionParagraph(span.line, endOffset - span.length);
                }
                else {
                    endPosition.setPositionParagraph(span.line, endOffset);
                }
            }
            else if (!isNullOrUndefined(span.previousNode)) {
                // tslint:disable-next-line:max-line-length
                this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
            }
        }
        else {
            let wordStartIndex = 0;
            if (!isStarted) {
                while (indexInInline > 0 && span.text[indexInInline - 1] === ' ') {
                    indexInInline--;
                }
                endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
            }
            if (indexInInline > 0) {
                isStarted = true;
                if (indexInInline === 0 && endSelection && (HelperMethods.wordSplitCharacters.indexOf(span.text[0])) === -1) {
                    endPosition.setPositionParagraph(span.line, span.line.getOffset(span, indexInInline));
                    endSelection = true;
                    return;
                }
                let txt = span.text.length > indexInInline ? span.text.slice(0, indexInInline) : span.text;
                wordStartIndex = HelperMethods.lastIndexOfAny(txt, HelperMethods.wordSplitCharacters);
                if (wordStartIndex !== -1) {
                    if (isInField) {
                        endSelection = false;
                        return;
                    }
                    while (wordStartIndex > 0 && endSelection && txt[wordStartIndex] !== ' '
                        && (HelperMethods.wordSplitCharacters.indexOf(txt[wordStartIndex - 1])) !== -1) {
                        wordStartIndex--;
                    }
                    if (txt[wordStartIndex] === ' ' || txt[wordStartIndex] === '　' || !endSelection) {
                        wordStartIndex++;
                    }
                    endSelection = true;
                    if (wordStartIndex > 0) {
                        let offset = span.line.getOffset(span, wordStartIndex);
                        if (span.line.paragraph === endPosition.paragraph && offset === endPosition.offset) {
                            // tslint:disable-next-line:max-line-length
                            this.getPreviousWordOffsetSpan(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                        }
                        else {
                            endPosition.setPositionParagraph(span.line, offset);
                        }
                    }
                    else if (span.previousNode instanceof TextElementBox) {
                        // tslint:disable-next-line:max-line-length
                        this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
                    }
                    else {
                        endPosition.setPositionParagraph(span.line, span.line.getOffset(span, 0));
                    }
                }
                else {
                    this.setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
                }
            }
            else {
                this.setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition);
            }
        }
    }
    /**
     * set previous word offset in span
     * @private
     */
    // tslint:disable-next-line:max-line-length
    setPreviousWordOffset(span, selection, indexInInline, type, isInField, isStarted, endSelection, endPosition) {
        if (span.previousNode instanceof ElementBox && span.line === span.previousNode.line) {
            // tslint:disable-next-line:max-line-length
            this.getPreviousWordOffset(span.previousNode, selection, span.previousNode.length, type, isInField, isStarted, endSelection, endPosition);
        }
        else {
            endPosition.setPositionParagraph(span.line, selection.getStartLineOffset(span.line));
        }
    }
    /**
     * Validate if text position is in field forward
     * @private
     */
    validateForwardFieldSelection(currentIndex, selectionEndIndex) {
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(currentIndex);
        textPosition.isUpdateLocation = false;
        let isPositionMoved = false;
        while (currentIndex !== selectionEndIndex && TextPosition.isForwardSelection(currentIndex, selectionEndIndex)) {
            if (!isPositionMoved) {
                textPosition.moveNextPosition(false);
                let nextIndex = textPosition.getHierarchicalIndexInternal();
                //Handled specifically to break infinite looping, if selection ends at last paragraph mark.
                if (currentIndex === nextIndex) {
                    break;
                }
            }
            let indexInInline = 0;
            let inlineObj = textPosition.currentWidget.getInline(textPosition.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                let selectionStartIndex = this.selection.start.getHierarchicalIndexInternal();
                if (indexInInline === inline.length && inline instanceof FieldElementBox && inline.fieldType === 1) {
                    if (inline.line.getOffset(inline, 0) === this.offset) {
                        return;
                    }
                    let lineWidget = inline.fieldBegin.line;
                    let fieldBeginOffset = lineWidget.getOffset(inline.fieldBegin, 0);
                    let fieldBeginIndex = this.getHierarchicalIndex(lineWidget, fieldBeginOffset.toString());
                    if (!TextPosition.isForwardSelection(selectionStartIndex, fieldBeginIndex)) {
                        this.selection.start.setPositionParagraph(lineWidget, fieldBeginOffset);
                    }
                }
                let nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
                if (!isNullOrUndefined(nextInline) && nextInline instanceof ElementBox) {
                    inline = nextInline;
                }
            }
            isPositionMoved = (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd));
            if (isPositionMoved) {
                if (inline.line.getOffset(inline, 0) === this.offset) {
                    return;
                }
                let fieldEnd = inline.fieldEnd;
                let paragraph = fieldEnd.line.paragraph;
                let fieldEndOffset = fieldEnd.line.getOffset(fieldEnd, 1);
                let fieldEndIndex = this.getHierarchicalIndex(fieldEnd.line, fieldEndOffset.toString());
                if (!TextPosition.isForwardSelection(fieldEndIndex, selectionEndIndex)) {
                    //If selection end is after field begin, extend selection end to field end.
                    this.moveToInline(inline.fieldEnd, 1);
                    return;
                }
                textPosition.moveToInline(inline.fieldEnd, 1);
            }
            currentIndex = textPosition.getHierarchicalIndexInternal();
        }
    }
    /**
     * Validate if text position is in field backward
     * @private
     */
    validateBackwardFieldSelection(currentIndex, selectionEndIndex) {
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(currentIndex);
        textPosition.isUpdateLocation = false;
        let selectionStartIndex = this.selection.start.getHierarchicalIndexInternal();
        while (currentIndex !== selectionEndIndex && TextPosition.isForwardSelection(selectionEndIndex, currentIndex)) {
            let indexInInline = 0;
            let inlineObj = textPosition.currentWidget.getInline(textPosition.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                let nextInline = this.selection.getNextRenderedElementBox(inline, indexInInline);
                if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
                    let paragraph = nextInline.fieldEnd.line;
                    let fieldEndOffset = paragraph.getOffset(nextInline.fieldEnd, 1);
                    let fieldEndIndex = this.getHierarchicalIndex(paragraph, fieldEndOffset.toString());
                    if (!TextPosition.isForwardSelection(fieldEndIndex, selectionStartIndex)) {
                        this.selection.start.setPositionParagraph(paragraph, fieldEndOffset);
                        selectionStartIndex = fieldEndIndex;
                    }
                }
            }
            if (inline instanceof FieldElementBox && inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
                let line = inline.fieldBegin.line;
                let fieldBegin = inline.fieldBegin;
                let fieldBeginOffset = line.getOffset(fieldBegin, 0);
                let fieldBeginIndex = this.getHierarchicalIndex(line, fieldBeginOffset.toString());
                if (!TextPosition.isForwardSelection(selectionEndIndex, fieldBeginIndex)) {
                    //If field begin is before selection end, extend selection end to field begin.
                    this.moveToInline(inline.fieldBegin, 0);
                    return;
                }
                textPosition.moveToInline(inline.fieldBegin, 0);
            }
            else {
                textPosition.movePreviousPosition();
            }
            currentIndex = textPosition.getHierarchicalIndexInternal();
        }
    }
    /**
     * @private
     */
    paragraphStartInternal(selection, moveToPreviousParagraph) {
        let offset = selection.getStartLineOffset(this.currentWidget);
        if (this.offset === offset && moveToPreviousParagraph) {
            let startParagraph = this.moveToNextParagraphInTableCheck();
            if (startParagraph) {
                this.moveToPreviousParagraphInTable(selection);
            }
            else if (!isNullOrUndefined(selection.getPreviousParagraphBlock(this.currentWidget.paragraph))) {
                let paragraphValue = selection.getPreviousParagraphBlock(this.currentWidget.paragraph);
                this.currentWidget = paragraphValue.childWidgets[0];
                this.offset = selection.getStartLineOffset(this.currentWidget);
            }
        }
        else {
            this.currentWidget = this.currentWidget.paragraph.getSplitWidgets()[0].childWidgets[0];
            this.offset = offset;
        }
        this.calculateOffset();
    }
    /**
     * @private
     */
    calculateOffset() {
        let selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            this.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Moves the text position to start of the paragraph.
     * @private
     */
    moveToParagraphStartInternal(selection, moveToPreviousParagraph) {
        let startOffset = selection.getStartOffset(this.paragraph);
        if (this.offset === startOffset && moveToPreviousParagraph) {
            let paragraphstart = this.moveToNextParagraphInTableCheck();
            if (paragraphstart) {
                this.moveToPreviousParagraphInTable(selection);
            }
            else if (!isNullOrUndefined(selection.getPreviousParagraphBlock(this.paragraph))) {
                this.currentWidget = selection.getPreviousParagraphBlock(this.paragraph).firstChild;
                this.offset = selection.getStartOffset(this.paragraph);
            }
        }
        else {
            this.currentWidget = this.paragraph.firstChild;
            this.offset = selection.getStartLineOffset(this.currentWidget);
        }
        let selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            this.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
        }
        this.updatePhysicalPosition(false);
    }
    /**
     * Moves the text position to end of the paragraph.
     * @private
     */
    moveToParagraphEndInternal(selection, moveToNextParagraph) {
        // tslint:disable-next-line:max-line-length
        let splittedParagraph = this.currentWidget.paragraph;
        while (splittedParagraph.nextSplitWidget) {
            splittedParagraph = splittedParagraph.nextSplitWidget;
        }
        this.currentWidget = splittedParagraph.childWidgets[splittedParagraph.childWidgets.length - 1];
        let endOffset = this.currentWidget.getEndOffset() + 1;
        if (this.offset === endOffset && moveToNextParagraph) {
            let paragraphEnd = this.moveToNextParagraphInTableCheck();
            if (paragraphEnd) {
                this.moveToNextParagraphInTable();
            }
            else if (!isNullOrUndefined(selection.getNextParagraphBlock(this.currentWidget.paragraph))) {
                let endParagraph = selection.getNextParagraphBlock(this.currentWidget.paragraph);
                this.currentWidget = endParagraph.childWidgets[endParagraph.childWidgets.length - 1];
                this.offset = this.currentWidget.getEndOffset() + 1;
            }
        }
        else {
            this.offset = endOffset;
        }
        this.calculateOffset();
    }
    /**
     * @private
     */
    moveUp(selection, left) {
        let paragraph = this.currentWidget.paragraph;
        //Moves text position to start of line.
        this.moveToLineStartInternal(selection, true);
        //Moves previous line starting.
        this.movePreviousPosition();
        let prevLine = undefined;
        let currentParagraph = this.currentWidget.paragraph;
        if (paragraph.isInsideTable && paragraph !== currentParagraph && paragraph.associatedCell !== currentParagraph.associatedCell
            // tslint:disable-next-line:max-line-length
            && (!isNullOrUndefined(currentParagraph.associatedCell) && (paragraph.associatedCell.ownerRow === currentParagraph.associatedCell.ownerRow))) {
            let ownerRow = currentParagraph.associatedCell.ownerRow;
            if (ownerRow.previousRenderedWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getFirstCellInRegion(ownerRow.previousRenderedWidget, currentParagraph.associatedCell, left, true);
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            else {
                let prevBlock = ownerRow.ownerTable.previousRenderedWidget;
                do {
                    if (prevBlock instanceof TableWidget) {
                        prevBlock = selection.getLastBlockInLastCell(prevBlock);
                    }
                } while (prevBlock instanceof TableWidget);
                if (prevBlock instanceof ParagraphWidget) {
                    this.setPosition(prevBlock.childWidgets[prevBlock.childWidgets.length - 1], false);
                }
            }
            prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        else {
            if (!paragraph.isInsideTable && this.currentWidget.paragraph.isInsideTable) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getFirstCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                // tslint:disable-next-line:max-line-length
            }
            else if (paragraph.isInsideTable && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && paragraph.associatedCell.ownerRow.previousRenderedWidget !== paragraph.associatedCell.ownerRow.previousSplitWidget &&
                paragraph.associatedCell.ownerRow.previousRenderedWidget === this.currentWidget.paragraph.associatedCell.ownerRow)) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        //Moves till the Up/Down selection width.
        let top = selection.getTop(prevLine);
        selection.updateTextPositionWidget(prevLine, new Point(left, top), this, false);
    }
    /**
     * @private
     */
    moveDown(selection, left) {
        //Moves text position to end of line.
        let prevParagraph = this.currentWidget.paragraph;
        let currentLine = this.currentWidget;
        this.moveToLineEndInternal(selection, true);
        let length = this.selection.getParagraphLength(this.currentWidget.paragraph);
        if (this.offset > length) {
            this.offset = length;
        }
        //Moves next line starting.
        this.moveNextPosition();
        let nextLine = undefined;
        // tslint:disable-next-line:max-line-length
        if (prevParagraph.isInsideTable && prevParagraph !== this.currentWidget.paragraph && prevParagraph.associatedCell !== this.currentWidget.paragraph.associatedCell && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && prevParagraph.associatedCell.ownerRow === this.currentWidget.paragraph.associatedCell.ownerRow)) {
            let ownerRow = this.currentWidget.paragraph.associatedCell.ownerRow;
            // tslint:disable-next-line:max-line-length
            if (prevParagraph.isInsideTable && this.currentWidget.paragraph.isInsideTable && prevParagraph.associatedCell.cellFormat.rowSpan > 1 && prevParagraph.associatedCell.cellFormat.rowSpan + prevParagraph.associatedCell.ownerRow.rowIndex === prevParagraph.associatedCell.ownerTable.childWidgets.length) {
                //If the prevParagraph  owner cell is Verically merged upto the last row, then theposition moved to next column. the position moved to out of the current tabel so owner row is assigned to last row.
                // tslint:disable-next-line:max-line-length
                ownerRow = this.currentWidget.paragraph.associatedCell.ownerTable.childWidgets[this.currentWidget.paragraph.associatedCell.ownerTable.childWidgets.length - 1];
            }
            if (ownerRow.nextRenderedWidget instanceof TableRowWidget) {
                // tslint:disable-next-line:max-line-length
                let cell = this.selection.getLastCellInRegion(ownerRow.nextRenderedWidget, this.currentWidget.paragraph.associatedCell, left, false);
                this.setPosition(this.selection.getFirstParagraph(cell).childWidgets[0], true);
            }
            else {
                let nextBlock = this.selection.getNextRenderedBlock(ownerRow.ownerTable);
                do {
                    if (nextBlock instanceof TableWidget) {
                        nextBlock = this.selection.getFirstBlockInFirstCell(nextBlock);
                    }
                } while (nextBlock instanceof TableWidget);
                if (nextBlock instanceof ParagraphWidget) {
                    this.setPosition(nextBlock.childWidgets[0], true);
                }
            }
            nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        else {
            if (!prevParagraph.isInsideTable && this.currentWidget.paragraph.isInsideTable) {
                // tslint:disable-next-line:max-line-length
                let cell = this.selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, false);
                this.setPosition(this.selection.getFirstParagraph(cell).childWidgets[0], true);
                // tslint:disable-next-line:max-line-length
            }
            else if (prevParagraph.isInsideTable && (!isNullOrUndefined(this.currentWidget.paragraph.associatedCell) && prevParagraph.associatedCell.ownerRow.nextRenderedWidget !== prevParagraph.associatedCell.ownerRow.nextSplitWidget
                && prevParagraph.associatedCell.ownerRow.nextRenderedWidget === this.currentWidget.paragraph.associatedCell.ownerRow)) {
                // tslint:disable-next-line:max-line-length
                let cell = selection.getLastCellInRegion(this.currentWidget.paragraph.associatedCell.ownerRow, this.currentWidget.paragraph.associatedCell, this.owner.selection.upDownSelectionLength, true);
                this.setPosition(selection.getFirstParagraph(cell).childWidgets[0], false);
            }
            nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        }
        //Moves till the Up/Down selection width.
        let top = this.selection.getTop(nextLine);
        if (nextLine !== currentLine) {
            this.selection.updateTextPositionWidget(nextLine, new Point(left, top), this, false);
        }
    }
    /**
     * Moves the text position to start of the line.
     * @private
     */
    moveToLineStartInternal(selection, moveToPreviousLine) {
        if (this.location.x > this.viewer.clientActiveArea.right) {
            this.offset = this.offset - 1;
        }
        let currentLine = selection.getLineWidgetInternal(this.currentWidget, this.offset, moveToPreviousLine);
        let firstElement;
        let isParaBidi = this.currentWidget.paragraph.paragraphFormat.bidi;
        if (isParaBidi && currentLine.children.length > 0 && this.containsRtlText(currentLine)) {
            firstElement = currentLine.children[currentLine.children.length - 1];
            if (firstElement instanceof ListTextElementBox) {
                firstElement = undefined;
            }
        }
        else {
            firstElement = selection.getFirstElementInternal(currentLine);
        }
        this.viewer.moveCaretPosition = 1;
        let startOffset = selection.getStartOffset(this.currentWidget.paragraph);
        if (isNullOrUndefined(firstElement) && this.offset > startOffset) {
            let index = 0;
            let inlineObj = this.currentWidget.getInline(this.offset, index);
            let inline = inlineObj.element;
            index = inlineObj.index;
            if (inline instanceof TextElementBox && inline.text !== '\v') {
                this.offset = startOffset;
            }
        }
        else if (!isNullOrUndefined(firstElement)) {
            let indexInInline = 0;
            this.currentWidget = firstElement.line;
            this.offset = this.currentWidget.getOffset(firstElement, indexInInline);
            indexInInline = 0;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (inline instanceof FieldElementBox) {
                //Checks if field character is part of rendered field, otherwise moves to previous rendered content.
                let prevInline = selection.getPreviousValidElement(inline);
                if (!isNullOrUndefined(prevInline)) {
                    inline = prevInline;
                    this.currentWidget = inline.line;
                    this.offset = this.currentWidget.getOffset(inline, inline.length);
                    if (inline instanceof FieldElementBox) {
                        this.offset--;
                    }
                }
            }
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Check paragraph is inside table
     * @private
     */
    moveToNextParagraphInTableCheck() {
        if ((this.selection.start.paragraph.isInsideTable || this.paragraph.isInsideTable)
            && (this.selection.start.paragraph.associatedCell !== this.paragraph.associatedCell
                || this.selection.isCellSelected(this.selection.start.paragraph.associatedCell, this.selection.start, this))) {
            return true;
        }
        return false;
    }
    /**
     * Moves the text position to end of the word.
     * @private
     */
    moveToWordEndInternal(type, excludeSpace) {
        // type === 0 -------->CTRL+ARROW Navigation
        // type === 1 -------->CTRL+SHIFT+ARROW Selection
        // type === 2 -------->Double-tap Word Selection
        let incrementValue = 0;
        let endOffset = this.currentWidget.getEndOffset();
        if (this.selection.isParagraphFirstLine(this.currentWidget)) {
            if (this.currentWidget.children[0] instanceof ListTextElementBox) {
                incrementValue = 1;
            }
            if (this.currentWidget.children[1] instanceof ListTextElementBox) {
                incrementValue = 2;
            }
        }
        if (this.offset + incrementValue === endOffset || this.offset === endOffset + 1) {
            if (this.offset === endOffset && type !== 0) {
                this.setPositionParagraph(this.currentWidget, endOffset + 1);
            }
            else {
                let nextParagraph = this.selection.getNextParagraphBlock(this.currentWidget.paragraph);
                if (isNullOrUndefined(nextParagraph)) {
                    return;
                }
                this.currentWidget = nextParagraph.childWidgets[0];
                this.offset = this.selection.getStartLineOffset(this.currentWidget);
                if (type === 1) {
                    // tslint:disable-next-line:max-line-length
                    let nextWord = this.moveToNextParagraphInTableCheck();
                    if (nextWord) {
                        this.moveToNextParagraphInTable();
                    }
                    else {
                        this.moveToWordEndInternal(type, excludeSpace);
                    }
                }
            }
        }
        else {
            let indexInInline = 0;
            let endSelection = false;
            let inlineObj = this.currentWidget.getInline(this.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            this.getNextWordOffset(inline, indexInInline, type, false, endSelection, this, excludeSpace);
        }
        if (type !== 0) {
            let selectionStartIndex = this.owner.selection.start.getHierarchicalIndexInternal();
            let selectionEndIndex = this.getHierarchicalIndexInternal();
            if (selectionStartIndex !== selectionEndIndex) {
                this.validateForwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * move text position to next paragraph inside table
     * @private
     */
    moveToNextParagraphInTable() {
        let paragraph = this.currentWidget.paragraph;
        let nextParagraph = (paragraph.isInsideTable) ? this.selection.getNextSelectionCell(paragraph.associatedCell) :
            this.selection.getNextParagraphBlock(paragraph);
        if (isNullOrUndefined(nextParagraph)) {
            return;
        }
        this.currentWidget = nextParagraph.childWidgets[nextParagraph.childWidgets.length - 1];
        this.offset = this.currentWidget.getEndOffset() + 1;
    }
    /**
     * Moves the text position to start of the previous paragraph.
     */
    moveToPreviousParagraph(selection) {
        let startOffset = selection.getStartOffset(this.currentWidget.paragraph);
        // tslint:disable-next-line:max-line-length
        if (this.offset === startOffset && !isNullOrUndefined(selection.getPreviousParagraphBlock(this.currentWidget.paragraph))) {
            let previousParagraph = selection.getPreviousParagraphBlock(this.currentWidget.paragraph);
            this.currentWidget = previousParagraph.childWidgets[0];
            this.offset = selection.getStartOffset(this.currentWidget.paragraph);
        }
        else {
            this.offset = selection.getStartOffset(this.currentWidget.paragraph);
        }
        this.updatePhysicalPosition(true);
    }
    /**
     * Move to previous line from current position
     * @private
     */
    moveToPreviousLine(selection, left) {
        let currentIndex = this.getHierarchicalIndexInternal();
        let currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        //Moves text position to start of line.
        this.moveToLineStartInternal(selection, true);
        if (this.currentWidget.paragraph.isInsideTable) {
            this.moveUpInTable(selection);
        }
        else {
            this.moveBackward();
        }
        let prevLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let lineStart = selection.getLeft(prevLine);
        let lineWidth = selection.getWidth(prevLine, true);
        //Moves till the Up/Down selection width.
        if (lineWidth + lineStart >= left && currentLine !== prevLine) {
            let top = selection.getTop(prevLine);
            let point = new Point(left, top);
            selection.updateTextPositionWidget(prevLine, point, this, true);
        }
        //Checks if the current position is between field result, then move to field begin.
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        this.validateBackwardFieldSelection(currentIndex, selectionEndIndex);
    }
    /**
     * @private
     */
    moveToLineEndInternal(selection, moveToNextLine) {
        if (this.location.x > this.viewer.clientActiveArea.right) {
            this.offset = this.offset - 1;
        }
        let currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let firstElement = selection.getFirstElementInternal(currentLine);
        let isParaBidi = this.currentWidget.paragraph.paragraphFormat.bidi;
        this.viewer.moveCaretPosition = 2;
        if (isNullOrUndefined(firstElement) && this.offset === selection.getStartLineOffset(this.currentWidget)) {
            this.offset = selection.getParagraphLength(this.paragraph) + 1;
            this.updatePhysicalPosition(true);
        }
        else if (!isNullOrUndefined(firstElement)) {
            let lastElement;
            // As per Microsoft Behavior, when current para is RTL and if line widget contains rtl text or mixed inlines(rtl, normal),
            // then need to consider the last element and to update offset to last element
            if (isParaBidi && this.containsRtlText(currentLine)) {
                let endOffset = currentLine.getEndOffset();
                lastElement = currentLine.getInline(endOffset, 0).element;
            }
            else {
                lastElement = currentLine.children[currentLine.children.length - 1];
                if (lastElement instanceof ListTextElementBox && currentLine.children.length > 2) {
                    lastElement = currentLine.children[currentLine.children.length - 3];
                }
            }
            let index = 0;
            index += lastElement instanceof TextElementBox ? lastElement.length : 1;
            this.currentWidget = lastElement.line;
            if (index === lastElement.length
                && isNullOrUndefined(lastElement.nextNode) && selection.isParagraphLastLine(this.currentWidget)) {
                let length = selection.getLineLength(this.currentWidget);
                this.offset = moveToNextLine ? length + 1 : length;
            }
            else {
                let inline = lastElement;
                while (!isNullOrUndefined(inline) && inline.length === index && inline.nextNode instanceof FieldElementBox) {
                    let nextInline = selection.getNextValidElement(inline.nextNode);
                    if (inline !== nextInline) {
                        inline = nextInline;
                        index = 0;
                    }
                    if (inline instanceof FieldElementBox && inline.fieldType === 0
                        && !isNullOrUndefined(inline.fieldEnd)) {
                        let fieldBegin = inline;
                        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                            inline = fieldBegin.fieldEnd;
                        }
                        else {
                            inline = fieldBegin.fieldSeparator;
                            this.currentWidget = inline.line;
                            if (this.currentWidget === fieldBegin.fieldEnd.line
                                && !selection.hasValidInline(this.currentWidget.paragraph, inline, fieldBegin.fieldEnd)) {
                                inline = fieldBegin.fieldEnd;
                            }
                        }
                        this.currentWidget = inline.line;
                    }
                    if (inline instanceof FieldElementBox) {
                        index = 1;
                    }
                }
                if (index === inline.length && isNullOrUndefined(inline.nextNode)) {
                    index++;
                }
                if (!moveToNextLine && inline instanceof ElementBox && inline.text === '\v') {
                    index--;
                }
                this.offset = this.currentWidget.getOffset(inline, index);
            }
            this.updatePhysicalPosition(moveToNextLine);
        }
    }
    /**
     * Move to next line
     * @private
     */
    moveToNextLine(left) {
        let selection = this.selection;
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionInternal(this);
        let currentIndex = this.getHierarchicalIndexInternal();
        let currentLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let isAtLineStart = this.offset === 0 ? true : false;
        //Moves text position to end of line.
        this.moveToLineEndInternal(selection, true);
        let isMoveToLineEnd = !textPosition.isAtSamePosition(this);
        textPosition.setPositionInternal(this);
        if (this.currentWidget.paragraph.isInsideTable) {
            this.moveDownInTable(selection);
        }
        else {
            this.moveNextPosition();
            this.moveForward();
        }
        let nextLine = selection.getLineWidgetParagraph(this.offset, this.currentWidget);
        let lineStart = selection.getLeft(nextLine);
        let firstElement = selection.getFirstElementInternal(nextLine);
        // tslint:disable-next-line:max-line-length
        let firstItemWidth = isNullOrUndefined(firstElement) ? selection.getWidth(nextLine, true) : selection.getLeftInternal(nextLine, firstElement, 1) - lineStart;
        //Moves till the Up/Down selection width.
        if (lineStart < left && (firstItemWidth / 2 < left - lineStart)) {
            let top = selection.getTop(nextLine);
            let point = new Point(left, top);
            selection.updateTextPositionWidget(nextLine, point, this, true);
            let width = selection.getWidth(nextLine, true);
            if (width < left - lineStart) {
                this.moveToLineEndInternal(selection, true);
            }
        }
        else if (isMoveToLineEnd && this.currentWidget.paragraph.isInsideTable
            && this.currentWidget === this.owner.selection.start.currentWidget) {
            this.setPositionInternal(textPosition);
        }
        else if (!isMoveToLineEnd) {
            this.moveToLineEndInternal(selection, true);
        }
        //Checks if the current position is between field result, then move to field end.
        let selectionEndIndex = this.getHierarchicalIndexInternal();
        this.validateForwardFieldSelection(currentIndex, selectionEndIndex);
    }
    /**
     * Move upward in table
     * @private
     */
    moveUpInTable(selection) {
        let isPositionUpdated = false;
        let end = this.owner.selection.end;
        let isBackwardSelection = !this.owner.selection.isEmpty;
        isPositionUpdated = end.paragraph.isInsideTable;
        if (isPositionUpdated) {
            let startCell = this.currentWidget.paragraph.associatedCell;
            let endCell = end.paragraph.associatedCell;
            let containerCell = selection.getContainerCellOf(endCell, startCell);
            isPositionUpdated = containerCell.ownerTable.contains(startCell);
            if (isPositionUpdated) {
                endCell = selection.getSelectedCell(endCell, containerCell);
                startCell = selection.getSelectedCell(startCell, containerCell);
                // tslint:disable-next-line:max-line-length
                let isInContainerCell = selection.containsCell(containerCell, this.currentWidget.paragraph.associatedCell);
                let isContainerCellSelected = selection.isCellSelected(containerCell, this, end);
                if (!isContainerCellSelected) {
                    // tslint:disable-next-line:max-line-length
                    isContainerCellSelected = this.currentWidget.paragraph === selection.getFirstParagraph(containerCell) && this.isAtParagraphStart;
                }
                if ((isInContainerCell && isContainerCellSelected
                    || !isInContainerCell) && !isNullOrUndefined(startCell.ownerRow.previousRenderedWidget)) {
                    //Moves to cell in previous row.
                    let row = startCell.ownerRow.previousRenderedWidget;
                    // tslint:disable-next-line:max-line-length
                    let cell = selection.getFirstCellInRegion(row, containerCell, this.owner.selection.upDownSelectionLength, true);
                    let previousParagraph = selection.getLastParagraph(cell);
                    this.setPosition(previousParagraph.childWidgets[0], true);
                    return;
                }
                else if (isInContainerCell && isContainerCellSelected
                    && isNullOrUndefined(startCell.ownerRow.previousRenderedWidget) || !isInContainerCell) {
                    if (isBackwardSelection) {
                        //Moves to first cell of row.
                        startCell = startCell.ownerRow.childWidgets[0];
                        let previousParagraph = selection.getFirstParagraph(startCell);
                        this.setPosition(previousParagraph.childWidgets[0], true);
                    }
                    else {
                        //Moves to last cell of row.
                        startCell = startCell.ownerRow.childWidgets[startCell.ownerRow.childWidgets.length - 1];
                        let previousParagraph = selection.getLastParagraph(startCell);
                        this.setPosition(previousParagraph.childWidgets[0], false);
                    }
                }
            }
        }
        if (!isPositionUpdated) {
            //Moves to previous row / previous block.
            let cell = selection.getContainerCell(this.currentWidget.paragraph.associatedCell);
            if (isBackwardSelection) {
                //Moves to first cell of row.
                cell = cell.ownerRow.childWidgets[0];
                let previousParagraph = selection.getFirstParagraph(cell);
                this.setPosition(previousParagraph.childWidgets[0], true);
            }
            else {
                //Moves to end of row.
                cell = cell.ownerRow.childWidgets[cell.ownerRow.childWidgets.length - 1];
                let previousParagraph = selection.getLastParagraph(cell);
                this.setPosition(previousParagraph.childWidgets[0], false);
            }
        }
        //Moves to previous row / previous block.
        this.moveBackward();
    }
    /**
     * Move down inside table
     * @private
     */
    moveDownInTable(selection) {
        let isPositionUpdated = false;
        let isForwardSelection = this.owner.selection.isEmpty || this.owner.selection.isForward;
        isPositionUpdated = this.owner.selection.start.paragraph.isInsideTable;
        if (isPositionUpdated) {
            let startCell = this.owner.selection.start.paragraph.associatedCell;
            let endCell = this.currentWidget.paragraph.associatedCell;
            let containerCell = selection.getContainerCellOf(startCell, endCell);
            isPositionUpdated = containerCell.ownerTable.contains(endCell);
            if (isPositionUpdated) {
                startCell = selection.getSelectedCell(startCell, containerCell);
                endCell = selection.getSelectedCell(endCell, containerCell);
                // tslint:disable-next-line:max-line-length
                let isInContainerCell = selection.containsCell(containerCell, this.currentWidget.paragraph.associatedCell);
                let isContainerCellSelected = selection.isCellSelected(containerCell, this.owner.selection.start, this);
                if ((isInContainerCell && isContainerCellSelected
                    || !isInContainerCell) && !isNullOrUndefined(endCell.ownerRow.nextRenderedWidget)) {
                    //Moves to cell in next row.
                    let row = endCell.ownerRow.nextRenderedWidget;
                    // tslint:disable-next-line:max-line-length
                    let cell = selection.getLastCellInRegion(row, containerCell, this.owner.selection.upDownSelectionLength, false);
                    let lastParagraph = selection.getLastParagraph(cell);
                    this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                    return;
                }
                else if (isInContainerCell && isContainerCellSelected
                    && isNullOrUndefined(endCell.ownerRow.nextRenderedWidget) || !isInContainerCell) {
                    if (isForwardSelection) {
                        //Moves to last cell of row.
                        endCell = endCell.ownerRow.childWidgets[endCell.ownerRow.childWidgets.length - 1];
                        let lastParagraph = selection.getLastParagraph(endCell);
                        this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
                    }
                    else {
                        //Moves to first cell of row.
                        endCell = endCell.ownerRow.childWidgets[0];
                        let lastParagraph = selection.getFirstParagraph(endCell);
                        this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], true);
                    }
                }
            }
        }
        if (!isPositionUpdated) {
            //Moves to next row / next block.
            let cell = selection.getContainerCell(this.currentWidget.paragraph.associatedCell);
            if (isForwardSelection) {
                //Moves to end of row.
                cell = cell.ownerRow.childWidgets[cell.ownerRow.childWidgets.length - 1];
                let lastParagraph = selection.getLastParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], false);
            }
            else if (cell.ownerRow.nextRenderedWidget) {
                //Moves to first cell of row.
                cell = cell.ownerRow.nextRenderedWidget.childWidgets[0];
                let lastParagraph = selection.getFirstParagraph(cell);
                this.setPosition(lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1], true);
            }
        }
        //Moves to next row / next block.
        this.moveForward();
    }
    /**
     * @private
     */
    destroy() {
        this.offset = undefined;
        this.isUpdateLocation = undefined;
        if (!isNullOrUndefined(this.location)) {
            this.location.destroy();
        }
        this.location = undefined;
        this.currentWidget = undefined;
        this.owner = undefined;
        this.viewer = undefined;
    }
}
/**
 * @private
 */
class SelectionWidgetInfo {
    constructor(left, width) {
        this.leftIn = 0;
        this.widthIn = 0;
        this.color = '';
        this.leftIn = left;
        this.widthIn = width;
    }
    /**
     * @private
     */
    get left() {
        return this.leftIn;
    }
    /**
     * @private
     */
    set left(value) {
        this.leftIn = value;
    }
    /**
     * @private
     */
    get width() {
        return this.widthIn;
    }
    /**
     * @private
     */
    set width(value) {
        this.widthIn = value;
    }
    /**
     * @private
     */
    destroy() {
        this.widthIn = undefined;
        this.leftIn = undefined;
    }
}
/**
 * @private
 */
class Hyperlink {
    constructor(fieldBeginAdv, selection) {
        this.linkInternal = '';
        this.localRef = '';
        this.opensNewWindow = false;
        let fieldCode = selection.getFieldCode(fieldBeginAdv);
        let lowercase = fieldCode.toLowerCase();
        if (lowercase.substring(0, 9) === 'hyperlink') {
            this.parseFieldValues(fieldCode.substring(9).trim(), selection);
        }
    }
    /**
     * Gets navigation link.
     * @returns string
     * @private
     */
    get navigationLink() {
        return this.linkInternal;
    }
    /**
     * Gets the local reference if any.
     * @returns string
     * @private
     */
    get localReference() {
        return this.localRef;
    }
    /**
     * Gets hyper link type.
     * @returns HyperLinkType
     * @private
     */
    get linkType() {
        return this.typeInternal;
    }
    /**
     * Parse field values
     * @param  {string} value
     * @returns Void
     */
    parseFieldValues(value, selection) {
        let codes = value.split(' ');
        let isLocalRef = false;
        for (let i = 0; i < codes.length; i++) {
            let code = codes[i];
            if (code.length < 1) {
                continue;
            }
            if (code === '\\t' || code === '\\l') {
                isLocalRef = true;
            }
            else if (code === '\\n') {
                this.opensNewWindow = true;
            }
            else {
                code = this.parseFieldValue(code, code[0] === '\"' ? '\"' : undefined);
                if (isLocalRef) {
                    this.localRef = code;
                    isLocalRef = false;
                }
                else {
                    this.linkInternal = code;
                }
            }
        }
        this.setLinkType();
    }
    parseFieldValue(value, endChar) {
        value = value.substring(1);
        let endIndex = endChar ? value.indexOf(endChar) : -1;
        if (endIndex < 0) {
            endIndex = value.length;
        }
        return value.substring(0, endIndex).trim();
    }
    setLinkType() {
        // If only local reference.
        if (isNullOrUndefined(this.linkInternal) || this.linkInternal.length < 1) {
            this.typeInternal = 'Bookmark';
            return;
        }
        // Validates link.
        if (this.linkInternal.substring(0, 4) === ('www.')) {
            this.linkInternal = 'http://' + this.navigationLink;
        }
        else if (this.linkInternal[0] === '@') {
            this.linkInternal = 'mailto:' + this.navigationLink;
        }
        // Finds proper link type.
        if (this.linkInternal.substring(0, 7) === 'http://'
            || this.linkInternal.substring(0, 8) === 'https://') {
            this.typeInternal = 'WebPage';
        }
        else if (this.linkInternal.substring(0, 7) === 'mailto:') {
            this.typeInternal = 'Email';
        }
        else {
            this.typeInternal = 'File';
        }
    }
    /**
     * @private
     */
    destroy() {
        this.linkInternal = undefined;
        this.localRef = undefined;
        this.typeInternal = undefined;
        this.opensNewWindow = undefined;
    }
}
/**
 * @private
 */
class ImageFormat {
    /**
     * Constructor for image format class
     * @param imageContainer - Specifies for image width and height values.
     */
    constructor(imageContainer) {
        /**
         * @private
         */
        this.width = 0;
        /**
         * @private
         */
        this.height = 0;
        this.width = imageContainer.width;
        this.height = imageContainer.height;
    }
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    destroy() {
        this.width = undefined;
        this.height = undefined;
    }
}

/**
 * Selection
 */
class Selection {
    /**
     * @private
     */
    constructor(documentEditor) {
        /**
         * @private
         */
        this.upDownSelectionLength = 0;
        /**
         * @private
         */
        this.isSkipLayouting = false;
        /**
         * @private
         */
        this.isImageSelected = false;
        this.contextTypeInternal = undefined;
        /**
         * @private
         */
        this.caret = undefined;
        //Format Retrieval Field
        /**
         * @private
         */
        this.isRetrieveFormatting = false;
        /**
         * @private
         */
        this.skipFormatRetrieval = false;
        this.isMoveDownOrMoveUp = false;
        /**
         * @private
         */
        this.isViewPasteOptions = false;
        /**
         * @private
         */
        this.skipEditRangeRetrieval = false;
        /**
         * @private
         */
        this.selectedWidgets = undefined;
        /**
         * @private
         */
        this.isHighlightEditRegionIn = false;
        /**
         * @private
         */
        this.isHightlightEditRegionInternal = false;
        /**
         * @private
         */
        this.isCurrentUser = false;
        /**
         * @private
         */
        this.isHighlightNext = false;
        /**
         * @private
         */
        this.editRegionHighlighters = undefined;
        /**
         * @private
         */
        this.pasteOptions = (event) => {
            if (event.item.text === 'Keep source formatting') {
                this.owner.editor.applyPasteOptions('KeepSourceFormatting');
            }
            else if (event.item.text === 'Match destination formatting') {
                this.owner.editor.applyPasteOptions('MergeWithExistingFormatting');
            }
            else {
                this.owner.editor.applyPasteOptions('KeepTextOnly');
            }
        };
        /**
         * Hides caret.
         * @private
         */
        this.hideCaret = () => {
            if (!isNullOrUndefined(this.caret)) {
                this.caret.style.display = 'none';
            }
        };
        this.owner = documentEditor;
        this.viewer = this.owner.viewer;
        this.start = new TextPosition(this.owner);
        this.end = new TextPosition(this.owner);
        this.selectedWidgets = new Dictionary();
        this.characterFormatIn = new SelectionCharacterFormat(this);
        this.paragraphFormatIn = new SelectionParagraphFormat(this, this.viewer);
        this.sectionFormatIn = new SelectionSectionFormat(this);
        this.rowFormatIn = new SelectionRowFormat(this);
        this.cellFormatIn = new SelectionCellFormat(this);
        this.tableFormatIn = new SelectionTableFormat(this);
        this.imageFormatInternal = new SelectionImageFormat(this);
        this.editRangeCollection = [];
        this.editRegionHighlighters = new Dictionary();
    }
    /**
     * @private
     */
    get isHighlightEditRegion() {
        return this.isHighlightEditRegionIn;
    }
    /**
     * @private
     */
    set isHighlightEditRegion(value) {
        this.isHighlightEditRegionIn = value;
        this.onHighlight();
    }
    /**
     * @private
     */
    get htmlWriter() {
        if (isNullOrUndefined(this.htmlWriterIn)) {
            this.htmlWriterIn = new HtmlExport();
        }
        return this.htmlWriterIn;
    }
    /**
     * Gets the start text position of last range in the selection
     * @returns {TextPosition}
     * @private
     */
    get start() {
        if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.viewer)) {
            if (isNullOrUndefined(this.startInternal)) {
                this.startInternal = this.owner.documentStart;
            }
            return this.startInternal;
        }
        return undefined;
    }
    /**
     * @private
     */
    set start(value) {
        this.startInternal = value;
    }
    //Format retrieval properties
    /**
     * Gets the instance of selection character format.
     * @default undefined
     * @aspType SelectionCharacterFormat
     * @blazorType SelectionCharacterFormat
     * @return {SelectionCharacterFormat}
     */
    get characterFormat() {
        return this.characterFormatIn;
    }
    /**
     * Gets the instance of selection paragraph format.
     * @default undefined
     * @aspType SelectionParagraphFormat
     * @blazorType SelectionParagraphFormat
     * @return {SelectionParagraphFormat}
     */
    get paragraphFormat() {
        return this.paragraphFormatIn;
    }
    /**
     * Gets the instance of selection section format.
     * @default undefined
     * @aspType SelectionSectionFormat
     * @blazorType SelectionSectionFormat
     * @return {SelectionSectionFormat}
     */
    get sectionFormat() {
        return this.sectionFormatIn;
    }
    /**
     * Gets the instance of selection table format.
     * @default undefined
     * @aspType SelectionTableFormat
     * @blazorType SelectionTableFormat
     * @return {SelectionTableFormat}
     */
    get tableFormat() {
        return this.tableFormatIn;
    }
    /**
     * Gets the instance of selection cell format.
     * @default undefined
     * @aspType SelectionCellFormat
     * @blazorType SelectionCellFormat
     * @return {SelectionCellFormat}
     */
    get cellFormat() {
        return this.cellFormatIn;
    }
    /**
     * Gets the instance of selection row format.
     * @default undefined
     * @aspType SelectionRowFormat
     * @blazorType SelectionRowFormat
     * @returns {SelectionRowFormat}
     */
    get rowFormat() {
        return this.rowFormatIn;
    }
    /**
     * Gets the instance of selection image format.
     * @default undefined
     * @aspType SelectionImageFormat
     * @blazorType SelectionImageFormat
     * @returns {SelectionImageFormat}
     */
    get imageFormat() {
        return this.imageFormatInternal;
    }
    /**
     * Gets the start text position of selection range.
     * @private
     */
    get end() {
        return this.endInternal;
    }
    /**
     * Gets the page number where the selection ends.
     */
    get startPage() {
        if (!this.owner.isDocumentLoaded || isNullOrUndefined(this.viewer)
            || isNullOrUndefined(this.viewer.selectionStartPage)) {
            return 1;
        }
        return this.viewer.pages.indexOf(this.viewer.selectionStartPage) + 1;
    }
    /**
     * Gets the page number where the selection ends.
     */
    get endPage() {
        if (!this.owner.isDocumentLoaded || isNullOrUndefined(this.viewer)
            || isNullOrUndefined(this.viewer.selectionEndPage)) {
            return 1;
        }
        return this.viewer.pages.indexOf(this.viewer.selectionEndPage) + 1;
    }
    /**
     * For internal use
     * @private
     */
    set end(value) {
        this.endInternal = value;
    }
    /**
     * Determines whether the selection direction is forward or not.
     * @default false
     * @returns {boolean}
     * @private
     */
    get isForward() {
        return this.start.isExistBefore(this.end);
    }
    /**
     * Determines whether the start and end positions are same or not.
     * @default false
     * @returns {boolean}
     * @private
     */
    get isEmpty() {
        if (isNullOrUndefined(this.start)) {
            return true;
        }
        return this.start.isAtSamePosition(this.end);
    }
    /**
     * Returns start hierarchical index.
     */
    get startOffset() {
        return this.getHierarchicalIndexByPosition(this.start);
    }
    /**
     * Returns end hierarchical index.
     */
    get endOffset() {
        return this.getHierarchicalIndexByPosition(this.end);
    }
    /**
     * Gets the text within selection.
     * @default ''
     * @aspType string
     * @blazorType string
     * @returns {string}
     */
    get text() {
        return this.getText(false);
    }
    /**
     * Gets the context type of the selection.
     */
    get contextType() {
        return this.contextTypeInternal;
    }
    /**
     * Gets bookmark name collection.
     */
    get bookmarks() {
        return this.getSelBookmarks();
    }
    /**
     * @private
     */
    get isCleared() {
        return isNullOrUndefined(this.end);
    }
    /**
     * Returns true if selection is in field
     */
    get isInField() {
        if (!isNullOrUndefined(this.getHyperlinkField(true))) {
            return true;
        }
        return false;
    }
    getSelBookmarks() {
        let bookmarkCln = [];
        let bookmarks = this.viewer.bookmarks;
        let start = this.start;
        let end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        let bookmrkStart;
        let bookmrkEnd;
        let isCellSelected = false;
        let selectedCells = this.getSelectedCells();
        for (let i = 0; i < bookmarks.length; i++) {
            if (bookmarks.keys[i].indexOf('_') !== 0) {
                bookmrkStart = bookmarks.get(bookmarks.keys[i]);
                bookmrkEnd = bookmrkStart.reference;
                let bmStartPos = this.getElementPosition(bookmrkStart).startPosition;
                let bmEndPos = this.getElementPosition(bookmrkEnd).startPosition;
                if (bmStartPos.paragraph.isInsideTable || bmEndPos.paragraph.isInsideTable) {
                    if (selectedCells.length > 0) {
                        if (selectedCells.indexOf(bmStartPos.paragraph.associatedCell) >= 0
                            || selectedCells.indexOf(bmEndPos.paragraph.associatedCell) >= 0) {
                            isCellSelected = true;
                        }
                        else {
                            isCellSelected = false;
                            if (selectedCells.indexOf(bmStartPos.paragraph.associatedCell) < 0
                                || selectedCells.indexOf(bmEndPos.paragraph.associatedCell) < 0) {
                                let endCell = end.paragraph.isInsideTable && end.paragraph.associatedCell;
                                let bmEndPosCell = bmEndPos.paragraph.associatedCell;
                                if (endCell && endCell.ownerTable.equals(bmEndPos.paragraph.associatedCell.ownerTable) &&
                                    endCell.ownerTable.equals(bmEndPosCell.ownerTable) &&
                                    !(endCell.ownerTable
                                        && selectedCells.indexOf(this.getCellInTable(endCell.ownerTable, bmEndPosCell)) >= 0)) {
                                    continue;
                                }
                            }
                        }
                    }
                    else {
                        isCellSelected = false;
                    }
                }
                else {
                    isCellSelected = false;
                }
                if ((start.isExistAfter(bmStartPos) || start.isAtSamePosition(bmStartPos))
                    && (end.isExistBefore(bmEndPos) || end.isAtSamePosition(bmEndPos)) ||
                    ((bmStartPos.isExistAfter(start) || bmStartPos.isAtSamePosition(start))
                        && (bmEndPos.isExistBefore(end) || bmEndPos.isAtSamePosition(end))) ||
                    (bmStartPos.isExistAfter(start) && bmStartPos.isExistBefore(end)
                        && (end.isExistAfter(bmEndPos) || end.isExistBefore(bmEndPos))) ||
                    (bmEndPos.isExistBefore(end) && bmEndPos.isExistAfter(start)
                        && (start.isExistBefore(bmStartPos) || start.isExistAfter(bmStartPos))) || isCellSelected) {
                    bookmarkCln.push(bookmrkStart.name);
                }
            }
        }
        return bookmarkCln;
    }
    getModuleName() {
        return 'Selection';
    }
    //Public API
    /**
     * Moves the selection to the header of current page.
     */
    goToHeader() {
        this.owner.enableHeaderAndFooter = true;
        this.enableHeadersFootersRegion(this.start.paragraph.bodyWidget.page.headerWidget);
    }
    /**
     * Moves the selection to the footer of current page.
     */
    goToFooter() {
        this.owner.enableHeaderAndFooter = true;
        this.enableHeadersFootersRegion(this.start.paragraph.bodyWidget.page.footerWidget);
    }
    /**
     * Closes the header and footer region.
     */
    closeHeaderFooter() {
        this.disableHeaderFooter();
    }
    /**
     * Moves the selection to the start of specified page number.
     */
    goToPage(pageNumber) {
        if (pageNumber >= 1 && pageNumber <= this.viewer.pages.length) {
            let page = this.viewer.pages[pageNumber - 1];
            this.updateTextPositionForBlockContainer(page.bodyWidgets[0]);
        }
    }
    /**
     * Selects the entire table if the context is within table.
     */
    selectTable() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableInternal();
    }
    /**
     * Selects the entire row if the context is within table.
     */
    selectRow() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableRow();
    }
    /**
     * Selects the entire column if the context is within table.
     */
    selectColumn() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectColumnInternal();
    }
    /**
     * Selects the entire cell if the context is within table.
     */
    selectCell() {
        if (!this.owner.enableSelection) {
            return;
        }
        this.selectTableCell();
    }
    select(selectionSettings, startOrEnd) {
        if (typeof (selectionSettings) === 'string') {
            let startPosition = this.getTextPosBasedOnLogicalIndex(selectionSettings);
            let endPosition = this.getTextPosBasedOnLogicalIndex(startOrEnd);
            this.selectPosition(startPosition, endPosition);
        }
        else {
            let point = new Point(selectionSettings.x, selectionSettings.y);
            let pageCoordinates = this.viewer.findFocusedPage(point, true);
            if (selectionSettings.extend) {
                this.moveTextPosition(pageCoordinates, this.end);
            }
            else {
                this.viewer.updateTextPositionForSelection(pageCoordinates, 1);
            }
        }
    }
    /**
     * Selects based on start and end hierarchical index.
     */
    selectByHierarchicalIndex(start, end) {
        let startPosition = this.getTextPosBasedOnLogicalIndex(start);
        let endPosition = this.getTextPosBasedOnLogicalIndex(end);
        this.selectPosition(startPosition, endPosition);
    }
    /**
     * Select the current field if selection is in field
     */
    selectField() {
        if (this.isInField) {
            let fieldStart = this.getHyperlinkField(true);
            let fieldEnd = fieldStart.fieldEnd;
            let offset = fieldStart.line.getOffset(fieldStart, 0);
            let startPosition = new TextPosition(this.viewer.owner);
            startPosition.setPositionParagraph(fieldStart.line, offset);
            let endoffset = fieldEnd.line.getOffset(fieldEnd, 1);
            let endPosition = new TextPosition(this.viewer.owner);
            endPosition.setPositionParagraph(fieldEnd.line, endoffset);
            //selects the field range
            this.viewer.selection.selectRange(startPosition, endPosition);
        }
    }
    /**
     * Toggles the bold property of selected contents.
     * @private
     */
    toggleBold() {
        if (this.owner.editorModule) {
            this.owner.editorModule.toggleBold();
        }
    }
    /**
     * Toggles the italic property of selected contents.
     * @private
     */
    toggleItalic() {
        if (this.owner.editorModule) {
            this.owner.editorModule.toggleItalic();
        }
    }
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of ‘underline’ parameter is Single.
     * @private
     */
    toggleUnderline(underline) {
        if (this.owner.editor) {
            this.owner.editor.toggleUnderline(underline);
        }
    }
    /**
     * Toggles the strike through property of selected contents.
     * @param {Strikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     * @private
     */
    toggleStrikethrough(strikethrough) {
        if (this.owner.editor) {
            this.owner.editor.toggleStrikethrough(strikethrough);
        }
    }
    /**
     * Toggles the highlight color property of selected contents.
     * @param {HighlightColor} highlightColor Default value of ‘underline’ parameter is Yellow.
     * @private
     */
    toggleHighlightColor(highlightColor) {
        if (this.owner.editor) {
            this.owner.editor.toggleHighlightColor(highlightColor);
        }
    }
    /**
     * Toggles the subscript formatting of selected contents.
     * @private
     */
    toggleSubscript() {
        if (this.owner.editor) {
            this.owner.editor.toggleSubscript();
        }
    }
    /**
     * Toggles the superscript formatting of selected contents.
     * @private
     */
    toggleSuperscript() {
        if (this.owner.editor) {
            this.owner.editor.toggleSuperscript();
        }
    }
    /**
     * Toggles the text alignment property of selected contents.
     * @param {TextAlignment} textAlignment Default value of ‘textAlignment parameter is TextAlignment.Left.
     * @private
     */
    toggleTextAlignment(textAlignment) {
        if (this.owner.editor) {
            this.owner.editor.toggleTextAlignment(textAlignment);
        }
    }
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     * @private
     */
    increaseIndent() {
        if (this.owner.editor) {
            this.owner.editor.increaseIndent();
        }
    }
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     * @private
     */
    decreaseIndent() {
        if (this.owner.editor) {
            this.owner.editor.decreaseIndent();
        }
    }
    /**
     * Fires the `requestNavigate` event if current selection context is in hyperlink.
     */
    navigateHyperlink() {
        let fieldBegin = this.getHyperlinkField();
        if (fieldBegin) {
            this.fireRequestNavigate(fieldBegin);
        }
    }
    /**
     * Navigate Hyperlink
     * @param fieldBegin
     * @private
     */
    fireRequestNavigate(fieldBegin) {
        let hyperlink = new Hyperlink(fieldBegin, this);
        let eventArgs = {
            isHandled: false,
            navigationLink: hyperlink.navigationLink,
            linkType: hyperlink.linkType,
            localReference: hyperlink.localReference,
            source: this.owner
        };
        this.owner.trigger('requestNavigate', eventArgs);
        if (!eventArgs.isHandled) {
            this.viewer.selection.navigateBookmark(hyperlink.localReference, true);
        }
    }
    /**
     * Copies the hyperlink URL if the context is within hyperlink.
     */
    copyHyperlink() {
        let hyperLinkField = this.getHyperlinkField();
        let linkText = this.getLinkText(hyperLinkField);
        this.copyToClipboard(linkText);
    }
    isHideSelection(paragraph) {
        let bodyWgt = paragraph.bodyWidget;
        let sectionFormat = bodyWgt.sectionFormat;
        let pageHt = sectionFormat.pageHeight - sectionFormat.footerDistance;
        let headerFooterHt = bodyWgt.page.boundingRectangle.height / 100 * 40;
        return this.contextType.indexOf('Footer') >= 0
            && (paragraph.y + paragraph.height > HelperMethods.convertPointToPixel(pageHt))
            || this.contextType.indexOf('Header') >= 0 && paragraph.y + paragraph.height > headerFooterHt;
    }
    //Selection add, Highlight, remove API starts
    /**
     * @private
     */
    highlightSelection(isSelectionChanged) {
        if (this.owner.enableImageResizerMode) {
            this.owner.imageResizerModule.hideImageResizer();
        }
        if (this.isEmpty) {
            if (this.isHideSelection(this.start.paragraph)) {
                this.hideCaret();
                return;
            }
            this.updateCaretPosition();
        }
        else {
            if (this.isForward) {
                this.highlightSelectedContent(this.start, this.end);
            }
            else {
                this.highlightSelectedContent(this.end, this.start);
            }
            if (this.viewer.isComposingIME) {
                this.updateCaretPosition();
            }
        }
        this.viewer.updateTouchMarkPosition();
        if (isSelectionChanged) {
            this.viewer.scrollToPosition(this.start, this.end);
        }
    }
    /**
     * @private
     */
    createHighlightBorder(lineWidget, width, left, top, isElementBoxHighlight) {
        if (width < 0) {
            width = 0;
        }
        let page = this.getPage(lineWidget.paragraph);
        let height = lineWidget.height;
        let widgets = this.selectedWidgets;
        let selectionWidget = undefined;
        let selectionWidgetCollection = undefined;
        if (this.isHightlightEditRegionInternal) {
            this.addEditRegionHighlight(lineWidget, left, width);
            return;
        }
        else {
            if (widgets.containsKey(lineWidget)) {
                if (widgets.get(lineWidget) instanceof SelectionWidgetInfo) {
                    selectionWidget = widgets.get(lineWidget);
                    // if the line element has already added with SelectionWidgetInfo
                    // now its need to be added as ElementBox highlighting them remove it from dictionary and add it collection.
                    if (isElementBoxHighlight) {
                        widgets.remove(lineWidget);
                        selectionWidgetCollection = [];
                        widgets.add(lineWidget, selectionWidgetCollection);
                    }
                }
                else {
                    selectionWidgetCollection = widgets.get(lineWidget);
                }
            }
            else {
                if (isElementBoxHighlight) {
                    selectionWidgetCollection = [];
                    widgets.add(lineWidget, selectionWidgetCollection);
                }
                else {
                    selectionWidget = new SelectionWidgetInfo(left, width);
                    widgets.add(lineWidget, selectionWidget);
                }
            }
            if (selectionWidget === undefined) {
                selectionWidget = new SelectionWidgetInfo(left, width);
                widgets.add(lineWidget, selectionWidget);
            }
        }
        let viewer = this.viewer;
        let pageTop = this.getPageTop(page);
        let pageLeft = page.boundingRectangle.x;
        if (viewer.containerTop <= pageTop
            || pageTop < viewer.containerTop + viewer.selectionCanvas.height) {
            let zoomFactor = viewer.zoomFactor;
            this.clipSelection(page, pageTop);
            if (this.viewer.isComposingIME) {
                // tslint:disable-next-line:max-line-length
                this.renderDashLine(viewer.selectionContext, page, lineWidget, (pageLeft + (left * zoomFactor)) - viewer.containerLeft, top, width * zoomFactor, height);
            }
            else {
                this.viewer.selectionContext.fillStyle = 'gray';
                viewer.selectionContext.globalAlpha = 0.4;
                // tslint:disable-next-line:max-line-length
                viewer.selectionContext.fillRect((pageLeft + (left * zoomFactor)) - viewer.containerLeft, (pageTop + (top * zoomFactor)) - viewer.containerTop, width * zoomFactor, height * zoomFactor);
            }
            viewer.selectionContext.restore();
        }
        if (isElementBoxHighlight) {
            selectionWidgetCollection.push(selectionWidget);
        }
    }
    /**
     * @private
     */
    addEditRegionHighlight(lineWidget, left, width) {
        let highlighters = undefined;
        let collection = this.editRegionHighlighters;
        if (collection.containsKey(lineWidget)) {
            highlighters = collection.get(lineWidget);
        }
        else {
            highlighters = [];
            collection.add(lineWidget, highlighters);
        }
        let editRegionHighlight = new SelectionWidgetInfo(left, width);
        if (this.isCurrentUser) {
            editRegionHighlight.color = this.owner.userColor !== '' ? this.owner.userColor : '#FFFF00';
        }
        highlighters.push(editRegionHighlight);
        return editRegionHighlight;
    }
    /**
     * Create selection highlight inside table
     * @private
     */
    createHighlightBorderInsideTable(cellWidget) {
        let page = this.getPage(cellWidget);
        let selectionWidget = undefined;
        let left = cellWidget.x - cellWidget.margin.left + cellWidget.leftBorderWidth;
        let width = cellWidget.width + cellWidget.margin.left
            + cellWidget.margin.right - cellWidget.leftBorderWidth - cellWidget.rightBorderWidth;
        let top = cellWidget.y;
        let height = cellWidget.height;
        let pageTop = this.getPageTop(page);
        let pageLeft = page.boundingRectangle.x;
        let isVisiblePage = this.viewer.containerTop <= pageTop
            || pageTop < this.viewer.containerTop + this.viewer.selectionCanvas.height;
        let widgets = this.selectedWidgets;
        if (!this.isHightlightEditRegionInternal) {
            if (widgets.containsKey(cellWidget) && widgets.get(cellWidget) instanceof SelectionWidgetInfo) {
                selectionWidget = widgets.get(cellWidget);
                if (isVisiblePage) {
                    // tslint:disable-next-line:max-line-length
                    this.viewer.selectionContext.clearRect((pageLeft + (selectionWidget.left * this.viewer.zoomFactor) - this.viewer.containerLeft), (pageTop + (top * this.viewer.zoomFactor)) - this.viewer.containerTop, selectionWidget.width * this.viewer.zoomFactor, height * this.viewer.zoomFactor);
                }
            }
            else {
                selectionWidget = new SelectionWidgetInfo(left, width);
                if (widgets.containsKey(cellWidget)) {
                    widgets.remove(widgets.get(cellWidget));
                }
                widgets.add(cellWidget, selectionWidget);
            }
        }
        if (isVisiblePage) {
            this.viewer.selectionContext.fillStyle = 'gray';
            this.viewer.selectionContext.globalAlpha = 0.4;
            let zoomFactor = this.viewer.zoomFactor;
            this.clipSelection(page, pageTop);
            // tslint:disable-next-line:max-line-length
            this.viewer.selectionContext.fillRect((pageLeft + (left * zoomFactor)) - this.viewer.containerLeft, (pageTop + (top * zoomFactor)) - this.viewer.containerTop, width * zoomFactor, height * zoomFactor);
            this.viewer.selectionContext.restore();
        }
    }
    /**
     * @private
     */
    clipSelection(page, pageTop) {
        let viewer = this.viewer;
        let width = page.boundingRectangle.width * viewer.zoomFactor;
        let height = page.boundingRectangle.height * viewer.zoomFactor;
        let left = page.boundingRectangle.x;
        viewer.selectionContext.beginPath();
        viewer.selectionContext.save();
        viewer.selectionContext.rect(left - viewer.containerLeft, pageTop - viewer.containerTop, width, height);
        viewer.selectionContext.clip();
    }
    /**
     * Add selection highlight
     * @private
     */
    addSelectionHighlight(canvasContext, widget, top) {
        if (this.selectedWidgets.containsKey(widget)) {
            let height = widget.height;
            let widgetInfo = this.selectedWidgets.get(widget);
            let widgetInfoCollection = undefined;
            if (widgetInfo instanceof SelectionWidgetInfo) {
                widgetInfoCollection = [];
                widgetInfoCollection.push(widgetInfo);
            }
            else {
                widgetInfoCollection = widgetInfo;
            }
            if (!isNullOrUndefined(widgetInfoCollection)) {
                for (let i = 0; i < widgetInfoCollection.length; i++) {
                    let width = this.viewer.render.getScaledValue(widgetInfoCollection[i].width);
                    let left = this.viewer.render.getScaledValue(widgetInfoCollection[i].left, 1);
                    let page = this.owner.selection.getPage(widget.paragraph);
                    this.owner.selection.clipSelection(page, this.owner.selection.getPageTop(page));
                    if (this.viewer.isComposingIME) {
                        this.renderDashLine(canvasContext, page, widget, left, top, width, height);
                    }
                    else {
                        height = this.viewer.render.getScaledValue(height);
                        canvasContext.globalAlpha = 0.4;
                        canvasContext.fillStyle = 'gray';
                        canvasContext.fillRect(left, this.viewer.render.getScaledValue(top, 2), width, height);
                    }
                    canvasContext.restore();
                }
            }
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    renderDashLine(ctx, page, widget, left, top, width, height) {
        let fontColor = this.characterFormat.fontColor;
        let fillColor = fontColor ? this.viewer.render.getColor(fontColor) : '#000000';
        ctx.globalAlpha = 1;
        // Get character format copied from selection format
        let format = this.owner.editor.copyInsertFormat(new WCharacterFormat(), false);
        let heightInfo = this.viewer.textHelper.getHeight(format);
        let pageTop = this.getPageTop(page);
        let descent = heightInfo.Height - heightInfo.BaselineOffset;
        top = this.viewer.render.getUnderlineYPosition(widget) + top + 4 - descent;
        // tslint:disable-next-line:max-line-length
        this.viewer.render.renderDashLine(ctx, left, (pageTop - this.viewer.containerTop) + (top * this.viewer.zoomFactor), width, fillColor, true);
    }
    /**
     * Add Selection highlight inside table
     * @private
     */
    addSelectionHighlightTable(canvasContext, tableCellWidget) {
        if (this.selectedWidgets.containsKey(tableCellWidget)) {
            let selectedWidgetInfo = this.selectedWidgets.get(tableCellWidget);
            let selectedWidgetInfoCollection = undefined;
            if (selectedWidgetInfo instanceof SelectionWidgetInfo) {
                selectedWidgetInfoCollection = [];
                selectedWidgetInfoCollection.push(selectedWidgetInfo);
            }
            else {
                selectedWidgetInfoCollection = selectedWidgetInfo;
            }
            if (!isNullOrUndefined(selectedWidgetInfoCollection)) {
                for (let i = 0; i < selectedWidgetInfoCollection.length; i++) {
                    let left = this.viewer.render.getScaledValue(selectedWidgetInfoCollection[i].left, 1);
                    let top = this.viewer.render.getScaledValue(tableCellWidget.y, 2);
                    let width = this.viewer.render.getScaledValue(selectedWidgetInfoCollection[i].width);
                    let height = this.viewer.render.getScaledValue(tableCellWidget.height);
                    canvasContext.fillStyle = 'gray';
                    let page = this.owner.selection.getPage(tableCellWidget);
                    this.owner.selection.clipSelection(page, this.owner.selection.getPageTop(page));
                    canvasContext.fillRect(left, top, width, height);
                    canvasContext.restore();
                }
            }
        }
    }
    /**
     * Remove Selection highlight
     * @private
     */
    removeSelectionHighlight(widget) {
        let left = 0;
        let top = 0;
        let width = 0;
        let height = 0;
        let page = undefined;
        if (widget instanceof LineWidget) {
            let lineWidget = widget;
            let currentParaWidget = lineWidget.paragraph;
            page = !isNullOrUndefined(currentParaWidget) ?
                this.getPage((lineWidget.paragraph)) : undefined;
            if (isNullOrUndefined(page)) {
                return;
            }
            top = this.getTop(lineWidget);
            height = lineWidget.height;
        }
        else if (widget instanceof TableCellWidget) {
            page = !isNullOrUndefined(widget) ?
                this.getPage(widget) : undefined;
            if (isNullOrUndefined(page)) {
                return;
            }
            top = widget.y;
            height = widget.height;
        }
        if (isNullOrUndefined(page)) {
            return;
        }
        let selectedWidget = this.selectedWidgets.get(widget);
        let selectedWidgetCollection = undefined;
        if (selectedWidget instanceof SelectionWidgetInfo) {
            selectedWidgetCollection = [];
            selectedWidgetCollection.push(selectedWidget);
        }
        else {
            selectedWidgetCollection = selectedWidget;
        }
        if (!isNullOrUndefined(selectedWidgetCollection)) {
            for (let i = 0; i < selectedWidgetCollection.length; i++) {
                width = selectedWidgetCollection[i].width;
                left = selectedWidgetCollection[i].left;
                let pageRect = page.boundingRectangle;
                let pageIndex = this.viewer.pages.indexOf(page);
                let pageGap = this.viewer.pageGap;
                let pageTop = (pageRect.y - pageGap * (pageIndex + 1)) * this.viewer.zoomFactor + pageGap * (pageIndex + 1);
                let pageLeft = pageRect.x;
                let zoomFactor = this.viewer.zoomFactor;
                if (this.viewer.containerTop <= pageTop
                    || pageTop < this.viewer.containerTop + this.viewer.selectionCanvas.height) {
                    // tslint:disable-next-line:max-line-length
                    this.viewer.selectionContext.clearRect((pageLeft + (left * zoomFactor) - this.viewer.containerLeft) - 0.5, (pageTop + (top * zoomFactor)) - this.viewer.containerTop - 0.5, width * zoomFactor + 0.5, height * zoomFactor + 0.5);
                }
            }
        }
    }
    /**
     * Selects Current word
     */
    selectCurrentWord(excludeSpace) {
        let startPosition = this.start.clone();
        let endPosition = this.end.clone();
        this.selectCurrentWordRange(startPosition, endPosition, excludeSpace ? excludeSpace : false);
        this.selectRange(startPosition, endPosition);
    }
    /**
     * Selects current paragraph
     */
    selectParagraph() {
        if (!isNullOrUndefined(this.start)) {
            this.start.paragraphStartInternal(this, false);
            this.end.moveToParagraphEndInternal(this, false);
            this.upDownSelectionLength = this.end.location.x;
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Selects current line.
     */
    selectLine() {
        if (!isNullOrUndefined(this.start)) {
            this.moveToLineStart();
            this.handleShiftEndKey();
        }
    }
    /**
     * Moves selection to start of the document.
     */
    moveToDocumentStart() {
        this.handleControlHomeKey();
    }
    /**
     * Moves selection to end of the document.
     */
    moveToDocumentEnd() {
        this.handleControlEndKey();
    }
    /**
     * Moves selection to current paragraph start.
     */
    moveToParagraphStart() {
        if (this.isForward) {
            this.start.paragraphStartInternal(this, false);
            this.end.setPositionInternal(this.start);
            this.upDownSelectionLength = this.end.location.x;
        }
        else {
            this.end.paragraphStartInternal(this, false);
            this.start.setPositionInternal(this.end);
            this.upDownSelectionLength = this.start.location.x;
        }
        this.fireSelectionChanged(true);
    }
    /**
     * Moves selection to current paragraph end.
     */
    moveToParagraphEnd() {
        if (this.isForward) {
            this.start.moveToParagraphEndInternal(this, false);
            this.end.setPositionInternal(this.start);
            this.upDownSelectionLength = this.end.location.x;
        }
        else {
            this.end.moveToParagraphEndInternal(this, false);
            this.start.setPositionInternal(this.end);
            this.upDownSelectionLength = this.start.location.x;
        }
        this.fireSelectionChanged(true);
    }
    /**
     * Moves selection to next line.
     */
    moveToNextLine() {
        this.moveDown();
    }
    /**
     * Moves selection to previous line.
     */
    moveToPreviousLine() {
        this.moveUp();
    }
    /**
     * Moves selection to next character.
     */
    moveToNextCharacter() {
        this.handleRightKey();
    }
    /**
     * Moves selection to previous character.
     */
    moveToPreviousCharacter() {
        this.handleLeftKey();
    }
    /**
     * Select current word range
     * @private
     */
    selectCurrentWordRange(startPosition, endPosition, excludeSpace) {
        if (!isNullOrUndefined(startPosition)) {
            if (startPosition.offset > 0) {
                let wordStart = startPosition.clone();
                let indexInInline = 0;
                let inlineObj = startPosition.currentWidget.getInline(startPosition.offset, indexInInline);
                let inline = inlineObj.element;
                indexInInline = inlineObj.index;
                if (!isNullOrUndefined(inline) && inline instanceof FieldElementBox && inline.fieldType === 1) {
                    // tslint:disable-next-line:max-line-length
                    if (startPosition.offset > 2 && (!isNullOrUndefined(inline.fieldSeparator) || isNullOrUndefined(inline.fieldBegin))) {
                        wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 2);
                        wordStart.moveToWordEndInternal(0, false);
                        if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset - 1)) {
                            startPosition.moveToWordStartInternal(2);
                        }
                    }
                    else if (startPosition.offset > 3 && isNullOrUndefined(inline.fieldSeparator)) {
                        wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 3);
                        wordStart.moveToWordEndInternal(0, false);
                        if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset)) {
                            startPosition.moveToWordStartInternal(2);
                        }
                    }
                }
                else {
                    wordStart.setPositionParagraph(wordStart.currentWidget, startPosition.offset - 1);
                    wordStart.moveToWordEndInternal(0, false);
                    if (!(wordStart.paragraph === startPosition.paragraph && wordStart.offset === startPosition.offset)) {
                        startPosition.moveToWordStartInternal(2);
                    }
                }
            }
            endPosition.moveToWordEndInternal(2, excludeSpace);
        }
    }
    /**
     * Extends selection to paragraph start.
     */
    extendToParagraphStart() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.paragraphStartInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to paragraph end.
     */
    extendToParagraphEnd() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToParagraphEndInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to next text position
     * @private
     */
    moveNextPosition() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (this.isEmpty) {
            this.start.moveNextPosition();
            this.end.setPositionInternal(this.start);
        }
        this.updateForwardSelection();
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to next paragraph
     * @private
     */
    moveToNextParagraph() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToNextParagraphStartInternal();
        this.start.setPositionInternal(this.end);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to previous text position
     * @private
     */
    movePreviousPosition() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (this.isEmpty) {
            this.start.movePreviousPosition();
            this.end.setPositionInternal(this.start);
        }
        this.updateBackwardSelection();
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Move to previous paragraph
     * @private
     */
    moveToPreviousParagraph() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToPreviousParagraph(this);
        this.start.setPositionInternal(this.end);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extends selection to previous line.
     */
    extendToPreviousLine() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToPreviousLine(this, this.upDownSelectionLength);
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to line end
     */
    extendToLineEnd() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToLineEndInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extends selection to line start.
     */
    extendToLineStart() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToLineStartInternal(this, true);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    moveUp() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (!this.isEmpty) {
            if (this.isForward) {
                this.end.setPositionInternal(this.start);
            }
            else {
                this.start.setPositionInternal(this.end);
            }
            this.upDownSelectionLength = this.start.location.x;
        }
        this.upDownSelectionLength = this.start.location.x;
        this.start.moveUp(this, this.upDownSelectionLength);
        this.end.setPositionInternal(this.start);
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    moveDown() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.setPositionInternal(this.end);
            }
            else {
                this.end.setPositionInternal(this.start);
            }
            this.upDownSelectionLength = this.start.location.x;
        }
        this.start.moveDown(this, this.upDownSelectionLength);
        this.end.setPositionInternal(this.start);
        this.fireSelectionChanged(true);
    }
    updateForwardSelection() {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.setPositionInternal(this.end);
            }
            else {
                this.end.setPositionInternal(this.start);
            }
        }
    }
    updateBackwardSelection() {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.end.setPositionInternal(this.start);
            }
            else {
                this.start.setPositionInternal(this.end);
            }
        }
    }
    /**
     * @private
     */
    getFirstBlockInFirstCell(table) {
        if (table.childWidgets.length > 0) {
            let firstrow = table.childWidgets[0];
            if (firstrow.childWidgets.length > 0) {
                let firstcell = firstrow.childWidgets[0];
                if (firstcell.childWidgets.length === 0) {
                    return undefined;
                }
                return firstcell.childWidgets[0];
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getFirstCellInRegion(row, startCell, selectionLength, isMovePrevious) {
        let cellStart = this.getCellLeft(row, startCell);
        let cellEnd = cellStart + startCell.cellFormat.cellWidth;
        let flag = true;
        if (cellStart <= selectionLength && selectionLength < cellEnd) {
            for (let k = 0; k < row.childWidgets.length; k++) {
                let left = this.getCellLeft(row, row.childWidgets[k]);
                if (HelperMethods.round(cellStart, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(cellEnd, 2)) {
                    flag = false;
                    return row.childWidgets[k];
                }
            }
        }
        else {
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cellLeft = this.getCellLeft(row, row.childWidgets[j]);
                if (cellLeft <= selectionLength && cellLeft +
                    row.childWidgets[j].cellFormat.cellWidth > selectionLength) {
                    flag = false;
                    return row.childWidgets[j];
                }
            }
        }
        if (flag) {
            if (!isNullOrUndefined(row.previousRenderedWidget) && isMovePrevious) {
                let previousWidget = row.previousRenderedWidget;
                return this.getFirstCellInRegion(previousWidget, startCell, selectionLength, isMovePrevious);
            }
            else if (!isNullOrUndefined(row.nextRenderedWidget) && !isMovePrevious) {
                return this.getFirstCellInRegion(row.nextRenderedWidget, startCell, selectionLength, isMovePrevious);
            }
        }
        return row.childWidgets[0];
    }
    /**
     * @private
     */
    getFirstParagraph(tableCell) {
        while (tableCell.previousSplitWidget) {
            tableCell = tableCell.previousSplitWidget;
        }
        let firstBlock = tableCell.firstChild;
        return this.getFirstParagraphBlock(firstBlock);
    }
    /**
     * Get last block in last cell
     * @private
     */
    //Table
    getLastBlockInLastCell(table) {
        if (table.childWidgets.length > 0) {
            let lastRow = table.childWidgets[table.childWidgets.length - 1];
            let lastCell = lastRow.childWidgets[lastRow.childWidgets.length - 1];
            while (lastCell.childWidgets.length === 0 && !isNullOrUndefined(lastCell.previousSplitWidget)) {
                lastCell = lastCell.previousSplitWidget;
            }
            return lastCell.childWidgets[lastCell.childWidgets.length - 1];
        }
        return undefined;
    }
    /**
     * Moves selection to start of the current line.
     */
    moveToLineStart() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.updateBackwardSelection();
        this.start.moveToLineStartInternal(this, false);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Moves selection to end of the current line.
     */
    moveToLineEnd() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.updateForwardSelection();
        this.start.moveToLineEndInternal(this, false);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Get Page top
     * @private
     */
    getPageTop(page) {
        // tslint:disable-next-line:max-line-length
        return (page.boundingRectangle.y - this.viewer.pageGap * (this.viewer.pages.indexOf(page) + 1)) * this.viewer.zoomFactor + this.viewer.pageGap * (this.viewer.pages.indexOf(page) + 1);
    }
    /**
     * Move text position to cursor point
     * @private
     */
    moveTextPosition(cursorPoint, textPosition) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        //Updates the text position based on the cursor position.
        let widget = this.viewer.getLineWidgetInternal(cursorPoint, true);
        if (!isNullOrUndefined(widget)) {
            this.updateTextPositionWidget(widget, cursorPoint, textPosition, true);
        }
        this.upDownSelectionLength = textPosition.location.x;
        let selectionStartIndex = this.start.getHierarchicalIndexInternal();
        let selectionEndIndex = this.end.getHierarchicalIndexInternal();
        if (selectionStartIndex !== selectionEndIndex) {
            // Extends selection end to field begin or field end.
            if (TextPosition.isForwardSelection(selectionStartIndex, selectionEndIndex)) {
                textPosition.validateForwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
            else {
                textPosition.validateBackwardFieldSelection(selectionStartIndex, selectionEndIndex);
            }
        }
        this.fireSelectionChanged(true);
    }
    //Helper Method Implementation 
    //Document
    /**
     * Get document start position
     * @private
     */
    getDocumentStart() {
        let block = this.viewer.pages[0].bodyWidgets[0].childWidgets[0];
        return this.setPositionForBlock(block, true);
    }
    /**
     * Get document end position
     * @private
     */
    getDocumentEnd() {
        let textPosition = undefined;
        let documentStart = this.owner.documentStart;
        let lastPage = this.viewer.pages[this.viewer.pages.length - 1];
        if (!isNullOrUndefined(documentStart) && lastPage.bodyWidgets[0].childWidgets.length > 0) {
            let block = undefined;
            let section = lastPage.bodyWidgets[0];
            let blocks = section.childWidgets;
            let lastBlkItem = blocks.length - 1;
            let lastBlock = blocks[lastBlkItem];
            if (lastBlock instanceof BlockWidget) {
                block = lastBlock;
            }
            textPosition = this.setPositionForBlock(block, false);
        }
        return textPosition;
    }
    //Keyboard shortcut internal API
    /**
     * @private
     * Handles control end key.
     */
    handleControlEndKey() {
        let documentEnd = undefined;
        if (!isNullOrUndefined(this.owner.documentEnd)) {
            documentEnd = this.owner.documentEnd;
        }
        if (!isNullOrUndefined(documentEnd)) {
            this.owner.selection.selectContent(documentEnd, true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control home key.
     */
    handleControlHomeKey() {
        let documentStart = undefined;
        if (!isNullOrUndefined(this.owner.documentStart)) {
            documentStart = this.owner.documentStart;
        }
        if (!isNullOrUndefined(documentStart)) {
            this.owner.selection.selectContent(documentStart, true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control left key.
     */
    handleControlLeftKey() {
        this.extendToWordStartInternal(true);
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control right key.
     */
    handleControlRightKey() {
        this.extendToWordEndInternal(true);
        this.checkForCursorVisibility();
    }
    /**
     * Handles control down key.
     * @private
     */
    handleControlDownKey() {
        this.moveToNextParagraph();
        this.checkForCursorVisibility();
    }
    /**
     * Handles control up key.
     * @private
     */
    handleControlUpKey() {
        this.moveToPreviousParagraph();
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles shift left key.
     */
    handleShiftLeftKey() {
        this.extendBackward();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift up key.
     * @private
     */
    handleShiftUpKey() {
        this.extendToPreviousLine();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift right key.
     * @private
     */
    handleShiftRightKey() {
        this.extendForward();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift down key.
     * @private
     */
    handleShiftDownKey() {
        this.extendToNextLine();
        this.checkForCursorVisibility();
    }
    /**
     * @private
     * Handles control shift left key.
     */
    handleControlShiftLeftKey() {
        let isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.extendToWordEndInternal(false);
        }
        else {
            this.extendToWordStartInternal(false);
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift up key.
     * @private
     */
    handleControlShiftUpKey() {
        this.extendToParagraphStart();
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift right key
     * @private
     */
    handleControlShiftRightKey() {
        let isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.extendToWordStartInternal(false);
        }
        else {
            this.extendToWordEndInternal(false);
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift down key.
     * @private
     */
    handleControlShiftDownKey() {
        this.extendToParagraphEnd();
        this.checkForCursorVisibility();
    }
    /**
     * Handles left key.
     * @private
     */
    handleLeftKey() {
        if (this.end.isCurrentParaBidi) {
            this.moveNextPosition();
        }
        else {
            this.movePreviousPosition();
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles up key.
     * @private
     */
    handleUpKey() {
        this.isMoveDownOrMoveUp = true;
        this.moveUp();
        this.isMoveDownOrMoveUp = false;
        this.checkForCursorVisibility();
    }
    /**
     * Handles right key.
     * @private
     */
    handleRightKey() {
        if (this.end.isCurrentParaBidi) {
            this.movePreviousPosition();
        }
        else {
            this.moveNextPosition();
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles end key.
     * @private
     */
    handleEndKey() {
        this.moveToLineEnd();
        this.checkForCursorVisibility();
    }
    /**
     * Handles home key.
     * @private
     */
    handleHomeKey() {
        this.moveToLineStart();
        this.checkForCursorVisibility();
    }
    /**
     * Handles down key.
     * @private
     */
    handleDownKey() {
        this.isMoveDownOrMoveUp = true;
        this.moveDown();
        this.isMoveDownOrMoveUp = false;
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift end key.
     * @private
     */
    handleShiftEndKey() {
        this.extendToLineEnd();
        this.checkForCursorVisibility();
    }
    /**
     * Handles shift home key.
     * @private
     */
    handleShiftHomeKey() {
        this.extendToLineStart();
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift end key.
     * @private
     */
    handleControlShiftEndKey() {
        let documentEnd = undefined;
        if (!isNullOrUndefined(this.owner.documentEnd)) {
            documentEnd = this.owner.documentEnd;
        }
        if (!isNullOrUndefined(documentEnd)) {
            this.end.setPosition(documentEnd.currentWidget, false);
            this.fireSelectionChanged(true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles control shift home key.
     * @private
     */
    handleControlShiftHomeKey() {
        let documentStart = undefined;
        if (!isNullOrUndefined(this.owner.documentStart)) {
            documentStart = this.owner.documentStart;
        }
        if (!isNullOrUndefined(documentStart)) {
            this.end.setPositionInternal(documentStart);
            this.fireSelectionChanged(true);
        }
        this.checkForCursorVisibility();
    }
    /**
     * Handles tab key.
     * @param isNavigateInCell
     * @param isShiftTab
     * @private
     */
    handleTabKey(isNavigateInCell, isShiftTab) {
        let start = this.start;
        if (isNullOrUndefined(start)) {
            return;
        }
        if (start.paragraph.isInsideTable && this.end.paragraph.isInsideTable && (isNavigateInCell || isShiftTab)) {
            //Perform tab navigation
            if (isShiftTab) {
                this.selectPreviousCell();
            }
            else {
                this.selectNextCell();
            }
        }
        else if ((isNavigateInCell || isShiftTab) && !isNullOrUndefined(start) && start.offset === this.getStartOffset(start.paragraph)
            && !isNullOrUndefined(start.paragraph.paragraphFormat) && !isNullOrUndefined(start.paragraph.paragraphFormat.listFormat)
            && start.paragraph.paragraphFormat.listFormat.listId !== -1 && !this.owner.isReadOnlyMode) {
            this.owner.editorModule.updateListLevel(isShiftTab ? false : true);
        }
        else if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.handleTextInput('\t');
        }
        this.checkForCursorVisibility();
    }
    selectPreviousCell() {
        let tableCell = this.start.paragraph.associatedCell;
        let tableRow = tableCell.ownerRow;
        let tableAdv = tableRow.ownerTable;
        if (isNullOrUndefined(tableCell.previousWidget)) {
            if (!isNullOrUndefined(tableRow.previousRenderedWidget)) {
                //Move text selection or cursor to previous row's last cell
                let prevRow = undefined;
                if (tableRow.previousRenderedWidget instanceof TableRowWidget) {
                    prevRow = tableRow.previousRenderedWidget;
                }
                this.selectTableCellInternal(prevRow.childWidgets[prevRow.childWidgets.length - 1], true);
            }
        }
        else {
            //Move text selection or cursor to next cell in current row
            let prevCell = undefined;
            if (tableCell.previousWidget instanceof TableCellWidget) {
                prevCell = tableCell.previousWidget;
            }
            this.selectTableCellInternal(prevCell, true);
        }
    }
    selectNextCell() {
        let tableCell = this.start.paragraph.associatedCell;
        let tableRow = tableCell.ownerRow;
        let tableAdv = tableRow.ownerTable;
        if (isNullOrUndefined(tableCell.nextWidget)) {
            if (isNullOrUndefined(tableRow.nextRenderedWidget) && !this.owner.isReadOnlyMode) {
                //Insert new row below                  
                this.owner.editorModule.insertRow(false);
            }
            else {
                //Move text selection or cursor to next row's first cell
                let nextRow = undefined;
                if (tableRow.nextRenderedWidget instanceof TableRowWidget) {
                    nextRow = tableRow.nextRenderedWidget;
                }
                this.selectTableCellInternal(nextRow.childWidgets[0], true);
            }
            // }
        }
        else {
            //Move text selection or cursor to next cell in current row
            let nextCell = undefined;
            if (tableCell.nextRenderedWidget instanceof TableCellWidget) {
                nextCell = tableCell.nextRenderedWidget;
            }
            this.selectTableCellInternal(nextCell, true);
        }
    }
    /**
     * Select given table cell
     * @private
     */
    selectTableCellInternal(tableCell, clearMultiSelection) {
        let firstParagraph = this.getFirstParagraph(tableCell);
        let lastParagraph = this.getLastParagraph(tableCell);
        if (firstParagraph === lastParagraph && lastParagraph.isEmpty()) {
            this.selectParagraphInternal(lastParagraph, true);
        }
        else {
            let firstLineWidget = lastParagraph.childWidgets[0];
            this.start.setPosition(firstParagraph.childWidgets[0], true);
            this.end.setPositionParagraph(firstLineWidget, firstLineWidget.getEndOffset());
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Select while table
     * @private
     */
    selectTableInternal() {
        let start = this.start;
        let end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(this.getTable(start, end))) {
            let containerCell = this.getContainerCellOf(start.paragraph.associatedCell, end.paragraph.associatedCell);
            let table = containerCell.ownerTable;
            let firstPara = this.getFirstParagraphBlock(table);
            let lastPara = this.getLastParagraphBlock(table);
            let offset = lastPara.lastChild.getEndOffset();
            this.start.setPosition(firstPara.childWidgets[0], true);
            this.end.setPositionParagraph(lastPara.lastChild, offset + 1);
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * Select single column
     * @private
     */
    selectColumnInternal() {
        let startTextPos = this.start;
        let endTextPos = this.end;
        if (!this.isForward) {
            startTextPos = this.end;
            endTextPos = this.start;
        }
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(startTextPos) && !isNullOrUndefined(endTextPos) && !isNullOrUndefined(this.getTable(startTextPos, endTextPos))) {
            let containerCell = this.getContainerCellOf(startTextPos.paragraph.associatedCell, endTextPos.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(endTextPos.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(startTextPos.paragraph.associatedCell, containerCell);
                let endCell = this.getSelectedCell(endTextPos.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, endTextPos.paragraph.associatedCell)) {
                    let row = startCell.ownerRow;
                    let columnCells = containerCell.ownerTable.getColumnCellsForSelection(containerCell, containerCell);
                    if (columnCells.length > 0) {
                        let firstPara = this.getFirstParagraph(columnCells[0]);
                        let lastPara = this.getLastParagraph(columnCells[columnCells.length - 1]);
                        this.start.setPosition(firstPara.firstChild, true);
                        let lastLine = lastPara.lastChild;
                        this.end.setPositionParagraph(lastLine, lastLine.getEndOffset() + 1);
                    }
                }
                else {
                    let startCellColumnCells = containerCell.ownerTable.getColumnCellsForSelection(startCell, startCell);
                    let endCellColumnCells = containerCell.ownerTable.getColumnCellsForSelection(endCell, endCell);
                    if (startCellColumnCells.length > 0 && endCellColumnCells.length > 0) {
                        let firstPara = this.getFirstParagraph(startCellColumnCells[0]);
                        // tslint:disable-next-line:max-line-length
                        let lastPara = this.getLastParagraph(endCellColumnCells[endCellColumnCells.length - 1]);
                        this.start.setPosition(firstPara.firstChild, true);
                        let lastLine = lastPara.lastChild;
                        this.end.setPositionParagraph(lastLine, lastLine.getEndOffset() + 1);
                    }
                }
            }
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * Select single row
     * @private
     */
    selectTableRow() {
        let startPos = this.start;
        let endPos = this.end;
        if (!this.isForward) {
            startPos = this.end;
            endPos = this.start;
        }
        if (!isNullOrUndefined(startPos) && !isNullOrUndefined(endPos) && !isNullOrUndefined(this.getTable(startPos, endPos))) {
            let containerCell;
            containerCell = this.getContainerCellOf(startPos.paragraph.associatedCell, endPos.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(endPos.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(startPos.paragraph.associatedCell, containerCell);
                let endCell = this.getSelectedCell(endPos.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, endPos.paragraph.associatedCell)) {
                    let row = startCell.ownerRow;
                    let firstPara = this.getFirstParagraph(row.childWidgets[0]);
                    let lastPara = this.getLastParagraph(row.childWidgets[row.childWidgets.length - 1]);
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
                else {
                    let firstPara = this.getFirstParagraph(startCell.ownerRow.childWidgets[0]);
                    let lastPara;
                    // tslint:disable-next-line:max-line-length
                    lastPara = this.getLastParagraph(endCell.ownerRow.childWidgets[endCell.ownerRow.childWidgets.length - 1]);
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * Select single cell
     * @private
     */
    selectTableCell() {
        let start = this.start;
        let end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (isNullOrUndefined(this.getTable(start, end))) {
            return;
        }
        if (this.isEmpty) {
            if (start.paragraph.isInsideTable && !isNullOrUndefined(start.paragraph.associatedCell)) {
                let firstPara = this.getFirstParagraph(start.paragraph.associatedCell);
                let lastPara = this.getLastParagraph(end.paragraph.associatedCell);
                if (firstPara === lastPara) {
                    this.start.setPosition(lastPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
                else {
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        else {
            let containerCell = this.getContainerCell(start.paragraph.associatedCell);
            // tslint:disable-next-line:max-line-length
            if (this.containsCell(containerCell, start.paragraph.associatedCell) && this.containsCell(containerCell, end.paragraph.associatedCell)) {
                let firstPara = this.getFirstParagraph(containerCell);
                let lastPara = this.getLastParagraph(containerCell);
                if (!isNullOrUndefined(firstPara) && !isNullOrUndefined(lastPara)) {
                    this.start.setPosition(firstPara.firstChild, true);
                    this.end.setPositionParagraph(lastPara.lastChild, lastPara.lastChild.getEndOffset() + 1);
                }
            }
        }
        this.selectPosition(this.start, this.end);
    }
    /**
     * Selects the entire document.
     */
    selectAll() {
        let documentStart;
        let documentEnd;
        if (this.owner.enableHeaderAndFooter) {
            let headerFooter = this.getContainerWidget(this.start.paragraph);
            documentStart = this.setPositionForBlock(headerFooter.firstChild, true);
            documentEnd = this.setPositionForBlock(headerFooter.lastChild, false);
        }
        else {
            documentStart = this.owner.documentStart;
            documentEnd = this.owner.documentEnd;
        }
        //Selects the entire document.        
        if (!isNullOrUndefined(documentStart)) {
            this.start.setPositionInternal(documentStart);
            this.end.setPositionParagraph(documentEnd.currentWidget, documentEnd.offset + 1);
            this.upDownSelectionLength = this.end.location.x;
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Extends selection backward.
     */
    extendBackward() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        let isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.end.moveForward();
        }
        else {
            this.end.moveBackward();
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extends selection forward.
     */
    extendForward() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        let isForward = this.isForward ? this.start.isCurrentParaBidi : this.end.isCurrentParaBidi;
        if (isForward) {
            this.end.moveBackward();
        }
        else {
            this.end.moveForward();
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to word start and end
     * @private
     */
    extendToWordStartEnd() {
        if ((this.start.paragraph.isInsideTable || this.end.paragraph.isInsideTable)
            && (this.start.paragraph.associatedCell !== this.end.paragraph.associatedCell
                || this.isCellSelected(this.start.paragraph.associatedCell, this.start, this.end))) {
            return true;
        }
        return false;
    }
    /**
     * Extends selection to word start.
     */
    extendToWordStart() {
        this.extendToWordStartInternal(false);
    }
    /**
     * Extends selection to word end.
     */
    extendToWordEnd() {
        this.extendToWordEndInternal(false);
    }
    /**
     * Extends selection to word start
     * @private
     */
    extendToWordStartInternal(isNavigation) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        let isCellSelected = this.extendToWordStartEnd();
        if (isCellSelected) {
            this.end.moveToPreviousParagraphInTable(this);
        }
        else {
            if (isNavigation && this.end.isCurrentParaBidi) {
                this.end.moveToWordEndInternal(isNavigation ? 0 : 1, false);
            }
            else {
                this.end.moveToWordStartInternal(isNavigation ? 0 : 1);
            }
        }
        if (isNavigation) {
            this.start.setPositionInternal(this.end);
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extends selection to word end.
     */
    extendToWordEndInternal(isNavigation) {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        let isCellSelect = this.extendToWordStartEnd();
        if (isCellSelect) {
            this.end.moveToNextParagraphInTable();
        }
        else {
            if (isNavigation && this.end.isCurrentParaBidi) {
                this.end.moveToWordStartInternal(isNavigation ? 0 : 1);
            }
            else {
                this.end.moveToWordEndInternal(isNavigation ? 0 : 1, false);
            }
        }
        if (isNavigation) {
            this.start.setPositionInternal(this.end);
        }
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Extend selection to next line.
     */
    extendToNextLine() {
        if (isNullOrUndefined(this.start)) {
            return;
        }
        this.end.moveToNextLine(this.upDownSelectionLength);
        this.fireSelectionChanged(true);
    }
    //Selection Text get API
    //Selection add, Highlight, remove API enda
    getTextPosition(hierarchicalIndex) {
        let textPosition = new TextPosition(this.owner);
        textPosition.setPositionForCurrentIndex(hierarchicalIndex);
        return textPosition;
    }
    /**
     * Get Selected text
     * @private
     */
    getText(includeObject) {
        if (isNullOrUndefined(this.start) || isNullOrUndefined(this.end)
            || isNullOrUndefined(this.start.paragraph) || isNullOrUndefined(this.end.paragraph)) {
            return undefined;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (startPosition.isAtSamePosition(endPosition)) {
            return '';
        }
        return this.getTextInternal(startPosition, endPosition, includeObject);
    }
    /**
     * Get selected text
     * @private
     */
    getTextInternal(start, end, includeObject) {
        if (start.isExistAfter(end)) {
            let temp = end;
            end = start;
            start = temp;
        }
        let startPosition = start;
        let endPosition = end;
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(start.paragraph) && !isNullOrUndefined(end.paragraph)) {
            let startIndex = 0;
            let endIndex = 0;
            let startOffset = start.offset;
            let endOffset = end.offset;
            let startInlineObj = start.currentWidget.getInline(startOffset, startIndex);
            startIndex = startInlineObj.index;
            let inline = startInlineObj.element;
            // If the start position is at the beginning of field begin that has field end, then field code should be skipped.
            if (inline instanceof FieldElementBox && !isNullOrUndefined(inline.fieldEnd)) {
                let elementInfo = this.getRenderedInline(inline, startIndex);
                inline = elementInfo.element;
                startIndex = elementInfo.index;
            }
            let endInlineObj = end.currentWidget.getInline(endOffset, endIndex);
            let endInline = endInlineObj.element;
            endIndex = endInlineObj.index;
            let text = '';
            // Retrieves the text from start inline.
            if (inline instanceof ImageElementBox && includeObject && startIndex === 0) {
                text = ElementBox.objectCharacter;
            }
            else if (inline instanceof TextElementBox) {
                // tslint:disable-next-line:max-line-length
                text = ((isNullOrUndefined(inline.text)) || (inline.text) === '') || inline.text.length < startIndex ? text : inline.text.substring(startIndex);
            }
            if (startPosition.paragraph === endPosition.paragraph) {
                if (inline instanceof ElementBox) {
                    if (inline === endInline && inline instanceof TextElementBox) {
                        text = text.length < endIndex - startIndex ? text : text.substring(0, endIndex - startIndex);
                    }
                    else if (inline.nextNode instanceof ElementBox) {
                        // tslint:disable-next-line:max-line-length
                        text = text + this.getTextInline(inline.nextNode, endPosition.paragraph, endInline, endIndex, includeObject);
                    }
                }
            }
            else {
                if (inline instanceof ElementBox && inline.nextNode instanceof ElementBox) {
                    text = text + this.getTextInline(inline.nextNode, endPosition.paragraph, undefined, 0, includeObject);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    let nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(startPosition.paragraph);
                    text = text + '\r';
                    while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.isEmpty()) {
                        text = text + '\r';
                        if (nextParagraphWidget === endPosition.paragraph) {
                            return text;
                        }
                        nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(nextParagraphWidget);
                    }
                    if (!isNullOrUndefined(nextParagraphWidget) && !nextParagraphWidget.isEmpty()) {
                        // tslint:disable-next-line:max-line-length
                        text = text + this.getTextInline(nextParagraphWidget.childWidgets[0].children[0], endPosition.paragraph, endInline, endIndex, includeObject);
                    }
                }
            }
            // If the selection includes end paragraph mark.
            if (endOffset === (endPosition.currentWidget).getEndOffset() + 1) {
                text = text + '\r';
            }
            return text;
        }
        return undefined;
    }
    /**
     * @private
     * @param block
     * @param offset
     */
    getHierarchicalIndex(block, offset) {
        let index;
        if (block) {
            if (block instanceof HeaderFooterWidget) {
                let hfString = block.headerFooterType.indexOf('Header') !== -1 ? 'H' : 'F';
                let pageIndex = block.page.index.toString();
                let headerFooterIndex = this.viewer.getHeaderFooter(block.headerFooterType).toString();
                let sectionIndex = block.page.sectionIndex;
                index = sectionIndex + ';' + hfString + ';' + pageIndex + ';' + offset;
            }
            else {
                index = block.index + ';' + offset;
            }
            if (block.containerWidget) {
                if (block instanceof TableCellWidget && block.rowIndex !== block.containerWidget.index) {
                    index = block.rowIndex + ';' + index;
                    block = block.containerWidget;
                }
                return this.getHierarchicalIndex(block.containerWidget, index);
            }
        }
        return index;
    }
    getHierarchicalIndexByPosition(position) {
        let info = this.getParagraphInfo(position);
        return this.getHierarchicalIndex(info.paragraph, info.offset.toString());
    }
    /**
     * @private
     * Gets logical position.
     */
    getTextPosBasedOnLogicalIndex(hierarchicalIndex) {
        let textPosition = new TextPosition(this.owner);
        let blockInfo = this.getParagraph({ index: hierarchicalIndex });
        let lineInfo = this.getLineInfoBasedOnParagraph(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
        return textPosition;
    }
    /**
     * Get offset value to update in selection
     * @private
     */
    getLineInfoBasedOnParagraph(paragraph, offset) {
        let length = this.getParagraphLength(paragraph);
        let next = paragraph.nextSplitWidget;
        if (offset > length + 1 && isNullOrUndefined(next)) {
            offset = length;
        }
        while (offset > length && next instanceof ParagraphWidget) {
            offset -= length;
            paragraph = next;
            length = this.getParagraphLength(paragraph);
            next = paragraph.nextSplitWidget;
        }
        return this.getLineInfo(paragraph, offset);
    }
    /**
     * @private
     */
    getParagraph(position) {
        let paragraph = this.getParagraphInternal(this.getBodyWidget(position), position);
        return { paragraph: paragraph, offset: parseInt(position.index, 10) };
    }
    /**
     * Gets body widget based on position.
     * @private
     */
    getBodyWidget(position) {
        let index = position.index.indexOf(';');
        let value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        let sectionIndex = parseInt(value, 10);
        index = parseInt(value, 10);
        index = position.index.indexOf(';');
        value = position.index.substring(0, index);
        // position = position.substring(index).replace(';', '');
        if (value === 'H' || value === 'F') {
            return this.getHeaderFooterWidget(position);
        }
        index = parseInt(value, 10);
        return this.getBodyWidgetInternal(sectionIndex, index);
    }
    getHeaderFooterWidget(position) {
        //HEADER OR FOOTER WIDGET
        let index = position.index.indexOf(';');
        let value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        let isHeader = value === 'H';
        index = position.index.indexOf(';');
        value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        index = parseInt(value, 10);
        let page = this.viewer.pages[index];
        if (isHeader) {
            return page.headerWidget;
        }
        else {
            return page.footerWidget;
        }
    }
    /**
     * @private
     */
    getBodyWidgetInternal(sectionIndex, blockIndex) {
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let bodyWidget = this.viewer.pages[i].bodyWidgets[0];
            if (bodyWidget.index === sectionIndex) {
                if (bodyWidget.childWidgets.length > 0 && bodyWidget.firstChild.index <= blockIndex &&
                    bodyWidget.lastChild.index >= blockIndex) {
                    return bodyWidget;
                }
            }
            if (bodyWidget.index > sectionIndex) {
                break;
            }
        }
        return undefined;
    }
    /**
     * Get paragraph relative to position
     * @private
     */
    getParagraphInternal(container, position) {
        if (isNullOrUndefined(position.index)) {
            return undefined;
        }
        // let ins: Widget = container;
        let index = position.index.indexOf(';');
        let value = '0';
        if (index >= 0) {
            value = position.index.substring(0, index);
            position.index = position.index.substring(index).replace(';', '');
        }
        // if (container instanceof BodyWidget && value === 'HF') {
        //     return this.getParagraph(container.headerFooters, position);
        // }
        index = parseInt(value, 10);
        if (container instanceof TableRowWidget && index >= container.childWidgets.length) {
            position.index = '0;0';
            index = container.childWidgets.length - 1;
        }
        let childWidget = this.getBlockByIndex(container, index);
        if (childWidget) {
            let child = childWidget;
            if (child instanceof ParagraphWidget) {
                if (position.index.indexOf(';') > 0) {
                    position.index = '0';
                }
                return child;
            }
            if (child instanceof Widget) {
                if (position.index.indexOf(';') > 0) {
                    return this.getParagraphInternal(child, position);
                }
                else {
                    //If table is shifted to previous text position then return the first paragraph within table.
                    if (child instanceof TableWidget) {
                        return this.viewer.selection.getFirstParagraphInFirstCell(child);
                    }
                    return undefined;
                }
            }
        }
        else if (container) {
            let nextWidget = container.getSplitWidgets().pop().nextRenderedWidget;
            if (nextWidget instanceof Widget) {
                position.index = '0';
                if (nextWidget instanceof TableWidget) {
                    return this.viewer.selection.getFirstParagraphInFirstCell(nextWidget);
                }
                return nextWidget;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getBlockByIndex(container, blockIndex) {
        let childWidget;
        if (container) {
            for (let j = 0; j < container.childWidgets.length; j++) {
                if (container.childWidgets[j].index === blockIndex) {
                    childWidget = container.childWidgets[j];
                    break;
                }
            }
            if (!childWidget && !(container instanceof HeaderFooterWidget)) {
                return this.getBlockByIndex(container.nextSplitWidget, blockIndex);
            }
        }
        return childWidget;
    }
    /**
     * Get logical offset of paragraph.
     * @private
     */
    getParagraphInfo(position) {
        return this.getParagraphInfoInternal(position.currentWidget, position.offset);
    }
    /**
     * @private
     */
    getParagraphInfoInternal(line, lineOffset) {
        let paragraph = line.paragraph;
        let offset = this.getParagraphLength(paragraph, line) + lineOffset;
        let previous = paragraph.previousSplitWidget;
        while (previous instanceof ParagraphWidget) {
            paragraph = previous;
            offset += this.viewer.selection.getParagraphLength(paragraph);
            previous = paragraph.previousSplitWidget;
        }
        return { 'paragraph': paragraph, 'offset': offset };
    }
    /**
     * @private
     */
    getListTextElementBox(paragarph) {
        if (isNullOrUndefined(paragarph)) {
            return undefined;
        }
        let listTextElement;
        if (!paragarph.isEmpty()) {
            let lineWidget = paragarph.childWidgets[0];
            if (lineWidget.children.length > 1) {
                if (lineWidget.children[0] instanceof ListTextElementBox) {
                    listTextElement = lineWidget.children[0];
                }
            }
        }
        return listTextElement;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getTextInline(inlineElement, endParagraphWidget, endInline, endIndex, includeObject) {
        let text = '';
        do {
            if (inlineElement === endInline) {
                if (inlineElement instanceof TextElementBox) {
                    let span = inlineElement;
                    if (!(isNullOrUndefined(span.text) || span.text === '')) {
                        if (span.text.length < endIndex) {
                            text = text + span.text;
                        }
                        else {
                            text = text + span.text.substring(0, endIndex);
                        }
                    }
                    // tslint:disable-next-line:max-line-length
                }
                else if (inlineElement instanceof ImageElementBox && includeObject && endIndex === inlineElement.length) {
                    text = text + ElementBox.objectCharacter;
                }
                return text;
            }
            if (inlineElement instanceof TextElementBox) {
                text = text + inlineElement.text;
            }
            else if (inlineElement instanceof ImageElementBox && includeObject) {
                text = text + ElementBox.objectCharacter;
            }
            else if (inlineElement instanceof FieldElementBox && !isNullOrUndefined(inlineElement.fieldEnd)) {
                if (!isNullOrUndefined(inlineElement.fieldSeparator)) {
                    inlineElement = inlineElement.fieldSeparator;
                }
                else {
                    inlineElement = inlineElement.fieldEnd;
                }
            }
            if (isNullOrUndefined(inlineElement.nextNode)) {
                break;
            }
            inlineElement = inlineElement.nextNode;
        } while (!isNullOrUndefined(inlineElement));
        if (endParagraphWidget === inlineElement.line.paragraph) {
            return text;
        }
        // tslint:disable-next-line:max-line-length
        let nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(inlineElement.line.paragraph);
        while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.isEmpty()) {
            text = text + '\r';
            if (nextParagraphWidget === endParagraphWidget) {
                return text;
            }
            nextParagraphWidget = this.viewer.selection.getNextParagraphBlock(nextParagraphWidget);
        }
        if (!isNullOrUndefined(nextParagraphWidget) && !nextParagraphWidget.isEmpty()) {
            let lineWidget = nextParagraphWidget.childWidgets[0];
            // tslint:disable-next-line:max-line-length
            text = text + '\r' + this.getTextInline(lineWidget.children[0], endParagraphWidget, endInline, endIndex, includeObject);
        }
        return text;
    }
    /**
     * Returns field code.
     * @private
     * @param fieldBegin
     */
    getFieldCode(fieldBegin) {
        let fieldCode = '';
        if (!(fieldBegin.fieldEnd instanceof FieldElementBox)) {
            return fieldCode;
        }
        let paragraph = fieldBegin.paragraph;
        let endParagraph = fieldBegin.fieldEnd.paragraph;
        if (fieldBegin.fieldSeparator instanceof FieldElementBox) {
            endParagraph = fieldBegin.fieldSeparator.paragraph;
        }
        let startLineIndex = fieldBegin.line.indexInOwner;
        let startIndex = fieldBegin.indexInOwner;
        do {
            fieldCode += this.getFieldCodeInternal(paragraph, startLineIndex, startIndex);
            if (paragraph === endParagraph) {
                break;
            }
            paragraph = this.getNextParagraphBlock(paragraph);
            startLineIndex = 0;
            startIndex = 0;
        } while (paragraph instanceof ParagraphWidget);
        return fieldCode.trim();
    }
    getFieldCodeInternal(paragraph, startLineIndex, inlineIndex) {
        let fieldCode = '';
        for (let i = startLineIndex; i < paragraph.childWidgets.length; i++) {
            let line = paragraph.childWidgets[i];
            for (let i = inlineIndex; i < line.children.length; i++) {
                let element = line.children[i];
                if (element instanceof TextElementBox) {
                    fieldCode += element.text;
                }
                if (element instanceof FieldElementBox
                    && (element.fieldType === 2 || element.fieldType === 1)) {
                    return fieldCode;
                }
            }
            inlineIndex = 0;
        }
        return fieldCode;
    }
    /**
     * @private
     */
    getTocFieldInternal() {
        let paragraph = this.start.paragraph;
        if (!this.isEmpty && !this.isForward) {
            paragraph = this.end.paragraph;
        }
        while (paragraph instanceof ParagraphWidget && paragraph.childWidgets.length > 0) {
            let line = paragraph.firstChild;
            if (line.children.length > 0) {
                let element = line.children[0];
                let nextElement = element.nextNode;
                if (element instanceof FieldElementBox && element.fieldType === 0 && nextElement instanceof TextElementBox
                    && nextElement.text.trim().toLowerCase().indexOf('toc') === 0) {
                    return element;
                }
            }
            paragraph = paragraph.previousRenderedWidget;
        }
        return undefined;
    }
    /**
     * Get next paragraph in bodyWidget
     * @private
     */
    getNextParagraph(section) {
        if (section.nextRenderedWidget instanceof BodyWidget) {
            let block = section.nextRenderedWidget.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return undefined;
    }
    /**
     * @private
     */
    getPreviousParagraph(section) {
        if (section.previousRenderedWidget instanceof BodyWidget) {
            let bodyWidget = section.previousRenderedWidget;
            let block = bodyWidget.childWidgets[bodyWidget.childWidgets.length - 1];
            return this.getLastParagraphBlock(block);
        }
        return undefined;
    }
    /**
     * Get first paragraph in cell
     * @private
     */
    getFirstParagraphInCell(cell) {
        let firstBlock = cell.childWidgets[0];
        if (firstBlock instanceof ParagraphWidget) {
            return firstBlock;
        }
        else {
            return this.getFirstParagraphInFirstCell(firstBlock);
        }
    }
    /**
     * Get first paragraph in first cell
     * @private
     */
    getFirstParagraphInFirstCell(table) {
        if (table.childWidgets.length > 0) {
            let firstRow = table.childWidgets[0];
            let cell = firstRow.childWidgets[0];
            let block = cell.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return undefined;
    }
    /**
     * Get last paragraph in last cell
     * @private
     */
    getLastParagraphInLastCell(table) {
        if (table.childWidgets.length > 0) {
            let lastrow = table.lastChild;
            let lastcell = lastrow.lastChild;
            let lastBlock = lastcell.lastChild;
            return this.getLastParagraphBlock(lastBlock);
        }
        return undefined;
    }
    /**
     * Get last paragraph in first row
     * @private
     */
    getLastParagraphInFirstRow(table) {
        if (table.childWidgets.length > 0) {
            let row = table.firstChild;
            let lastcell = row.lastChild;
            let lastBlock = lastcell.lastChild;
            return this.getLastParagraphBlock(lastBlock);
        }
        return undefined;
    }
    /**
     * Get Next start inline
     * @private
     */
    getNextStartInline(line, offset) {
        let indexInInline = 0;
        let inlineObj = line.getInline(offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
            let nextValidInline = this.getNextValidElement(inline.nextNode);
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                inline = nextValidInline;
            }
        }
        return inline;
    }
    /**
     * Get previous text inline
     * @private
     */
    getPreviousTextInline(inline) {
        if (inline.previousNode instanceof TextElementBox) {
            return inline.previousNode;
        }
        if (inline.previousNode instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline.previousNode)) {
            if (inline.previousNode.fieldType === 0 || inline.previousNode.fieldType === 1) {
                return inline.previousNode;
            }
            return inline.previousNode.fieldBegin;
        }
        if (!isNullOrUndefined(inline.previousNode)) {
            return this.getPreviousTextInline((inline.previousNode));
        }
        return undefined;
    }
    /**
     * Get next text inline
     * @private
     */
    getNextTextInline(inline) {
        if (inline.nextNode instanceof TextElementBox) {
            return inline.nextNode;
        }
        if (inline.nextNode instanceof FieldElementBox && (HelperMethods.isLinkedFieldCharacter(inline.nextNode))) {
            if (inline.nextNode.fieldType === 1 || inline.nextNode.fieldType === 0) {
                return inline.nextNode;
            }
            return inline.nextNode.fieldEnd;
        }
        if (!isNullOrUndefined(inline.nextNode)) {
            return this.getNextTextInline((inline.nextNode));
        }
        return undefined;
    }
    /**
     * Get container table
     * @private
     */
    getContainerTable(block) {
        if (block.isInsideTable) {
            if (block.associatedCell.ownerTable.isInsideTable) {
                block = this.getContainerTable(block.associatedCell.ownerTable);
            }
            else {
                block = block.associatedCell.ownerTable;
            }
        }
        if (block instanceof TableWidget) {
            return block;
        }
        return undefined;
    }
    /**
     * @private
     */
    isExistBefore(start, block) {
        if (start.isInsideTable) {
            let cell1 = start.associatedCell;
            if (block.isInsideTable) {
                let cell2 = block.associatedCell;
                if (cell1 === cell2) {
                    return cell1.childWidgets.indexOf(start) < cell1.childWidgets.indexOf(block);
                }
                if (cell1.ownerRow === cell2.ownerRow) {
                    return cell1.cellIndex < cell2.cellIndex;
                }
                if (cell1.ownerTable === cell2.ownerTable) {
                    return cell1.ownerRow.rowIndex < cell2.ownerRow.rowIndex;
                }
                //Checks if current block exists before the block.
                let containerCell = this.getContainerCellOf(cell1, cell2);
                if (containerCell.ownerTable.contains(cell2)) {
                    cell1 = this.getSelectedCell(cell1, containerCell);
                    cell2 = this.getSelectedCell(cell2, containerCell);
                    if (cell1 === containerCell) {
                        return this.isExistBefore(start, cell2.ownerTable);
                    }
                    if (cell2 === containerCell) {
                        return this.isExistBefore(cell1.ownerTable, block);
                    }
                    if (containerCell.ownerRow === cell2.ownerRow) {
                        return containerCell.cellIndex < cell2.cellIndex;
                    }
                    if (containerCell.ownerTable === cell2.ownerTable) {
                        return containerCell.ownerRow.rowIndex < cell2.ownerRow.rowIndex;
                    }
                    return this.isExistBefore(cell1.ownerTable, cell2.ownerTable);
                }
                return this.isExistBefore(containerCell.ownerTable, this.getContainerTable(cell2.ownerTable));
            }
            else {
                let ownerTable = this.getContainerTable(start);
                return this.isExistBefore(ownerTable, block);
            }
        }
        else if (block.isInsideTable) {
            let ownerTable = this.getContainerTable(block);
            return this.isExistBefore(start, ownerTable);
        }
        else {
            {
                if (start.containerWidget === block.containerWidget) {
                    return start.index <
                        block.index;
                }
                if (start.containerWidget instanceof BodyWidget && block.containerWidget instanceof BodyWidget) {
                    //Splitted blocks                     
                    let startPage = this.viewer.pages.indexOf(start.containerWidget.page);
                    let endPage = this.viewer.pages.indexOf(block.containerWidget.page);
                    return startPage < endPage;
                }
            }
        }
        return false;
    }
    /**
     * @private
     */
    isExistAfter(start, block) {
        if (start.isInsideTable) {
            let cell1 = start.associatedCell;
            //Current paragraph in cell, paragraph in cell
            if (block.isInsideTable) {
                let cell2 = block.associatedCell;
                if (cell1 === cell2) {
                    return cell1.childWidgets.indexOf(start) > cell1.childWidgets.indexOf(block);
                }
                if (cell1.ownerRow === cell2.ownerRow) {
                    return cell1.cellIndex > cell2.cellIndex;
                }
                if (cell1.ownerTable === cell2.ownerTable) {
                    return cell1.ownerRow.rowIndex > cell2.ownerRow.rowIndex;
                }
                //Checks if this block exists before block.
                let containerCell = this.getContainerCellOf(cell1, cell2);
                if (containerCell.ownerTable.contains(cell2)) {
                    cell1 = this.getSelectedCell(cell1, containerCell);
                    cell2 = this.getSelectedCell(cell2, containerCell);
                    if (cell1 === containerCell) {
                        return this.isExistAfter(start, cell2.ownerTable);
                    }
                    if (cell2 === containerCell) {
                        return this.isExistAfter(cell1.ownerTable, block);
                    }
                    if (containerCell.ownerRow === cell2.ownerRow) {
                        return containerCell.cellIndex > cell2.cellIndex;
                    }
                    if (containerCell.ownerTable === cell2.ownerTable) {
                        return containerCell.ownerRow.rowIndex > cell2.ownerRow.rowIndex;
                    }
                    return this.isExistAfter(cell1.ownerTable, cell2.ownerTable);
                }
                return this.isExistAfter(containerCell.ownerTable, this.getContainerTable(cell2.ownerTable));
            }
            else {
                let ownerTable = this.getContainerTable(start);
                return this.isExistAfter(ownerTable, block);
            }
        }
        else if (block.isInsideTable) {
            let ownerTable = this.getContainerTable(block);
            return this.isExistAfter(start, ownerTable);
        }
        else {
            if (start.containerWidget === block.containerWidget) {
                return start.index >
                    block.index;
            }
            if (start.containerWidget instanceof BodyWidget && block.containerWidget instanceof BodyWidget) {
                //Splitted blocks                     
                let startPage = this.viewer.pages.indexOf(start.containerWidget.page);
                let endPage = this.viewer.pages.indexOf(block.containerWidget.page);
                return startPage > endPage;
            }
            //     if (start.owner instanceof WHeaderFooter) {
            //         return (start.owner as WHeaderFooter).childWidgets.indexOf(start) 
            // > (block.owner as WHeaderFooter).childWidgets.indexOf(block);
            //     } else if (start.section === block.section && start.section instanceof WSection) {
            //         return (start.section as WSection).childWidgets.indexOf(start)
            //  > (start.section as WSection).childWidgets.indexOf(block);
            //     } else if (start.wordDocument instanceof WordDocument) {
            // tslint:disable-next-line:max-line-length
            //         return (start.wordDocument as WordDocument).sections.indexOf(start.section as WSection) > (start.wordDocument as WordDocument).sections.indexOf(block.section as WSection);
        }
        return false;
    }
    /**
     * Return true if current inline in exist before inline
     * @private
     */
    isExistBeforeInline(currentInline, inline) {
        if (currentInline.line === inline.line) {
            return currentInline.line.children.indexOf(currentInline) <
                inline.line.children.indexOf(inline);
        }
        if (currentInline.line.paragraph === inline.line.paragraph) {
            return currentInline.line.paragraph.childWidgets.indexOf(currentInline.line)
                < inline.line.paragraph.childWidgets.indexOf(inline.line);
        }
        let startParagraph = currentInline.line.paragraph;
        let endParagraph = inline.line.paragraph;
        if (startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) <
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
            }
            else if (startParagraph.containerWidget instanceof HeaderFooterWidget) {
                // return ((currentInline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(currentInline.owner as WParagraph) <
                //     ((inline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(inline.owner as WParagraph);
            }
            else {
                return startParagraph.containerWidget.childWidgets.indexOf(startParagraph) <
                    endParagraph.containerWidget.childWidgets.indexOf(endParagraph);
            }
        }
        return this.isExistBefore(startParagraph, endParagraph);
    }
    /**
     * Return true id current inline is exist after inline
     * @private
     */
    isExistAfterInline(currentInline, inline) {
        if (currentInline.line === inline.line) {
            return currentInline.line.children.indexOf(currentInline) >
                inline.line.children.indexOf(inline);
        }
        if (currentInline.line.paragraph === inline.line.paragraph) {
            return currentInline.line.paragraph.childWidgets.indexOf(currentInline.line)
                > inline.line.paragraph.childWidgets.indexOf(inline.line);
        }
        let startParagraph = currentInline.line.paragraph;
        let endParagraph = inline.line.paragraph;
        if (startParagraph.containerWidget === endParagraph.containerWidget) {
            if (startParagraph.isInsideTable) {
                return startParagraph.associatedCell.childWidgets.indexOf(startParagraph) >
                    endParagraph.associatedCell.childWidgets.indexOf(endParagraph);
            }
            else if (startParagraph.containerWidget instanceof HeaderFooterWidget) {
                // return ((currentInline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(currentInline.owner as WParagraph) <
                //     ((inline.owner as WParagraph).owner as WHeaderFooter).blocks.indexOf(inline.owner as WParagraph);
            }
            else {
                return startParagraph.containerWidget.childWidgets.indexOf(startParagraph) >
                    endParagraph.containerWidget.childWidgets.indexOf(endParagraph);
            }
        }
        return this.isExistAfter(startParagraph, endParagraph);
    }
    /**
     * Get next rendered block
     * @private
     */
    getNextRenderedBlock(block) {
        if (isNullOrUndefined(block.nextWidget)) {
            return block.nextRenderedWidget;
        }
        return block.nextWidget;
    }
    /**
     * Get next rendered block
     * @private
     */
    getPreviousRenderedBlock(block) {
        if (isNullOrUndefined(block.previousWidget)) {
            return block.previousRenderedWidget;
        }
        return block.previousWidget;
    }
    /**
     * Get Next paragraph in block
     * @private
     */
    getNextParagraphBlock(block) {
        if (block.nextRenderedWidget instanceof ParagraphWidget) {
            return block.nextRenderedWidget;
        }
        else if (block.nextRenderedWidget instanceof TableWidget) {
            return this.getFirstParagraphInFirstCell(block.nextRenderedWidget);
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getNextParagraphCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            let bodyWidget = block.containerWidget;
            return this.getNextParagraph(block.containerWidget);
        }
        else if (block.containerWidget instanceof HeaderFooterWidget && this.isMoveDownOrMoveUp) {
            return this.getFirstBlockInNextHeaderFooter(block);
        }
        return undefined;
    }
    /**
     * @private
     */
    getFirstBlockInNextHeaderFooter(block) {
        let headerFooter = block.containerWidget;
        let nextBlock;
        if (headerFooter.headerFooterType.indexOf('Header') !== -1) {
            nextBlock = headerFooter.page.footerWidget.firstChild;
        }
        else if (headerFooter.page.nextPage) {
            nextBlock = headerFooter.page.nextPage.headerWidget.firstChild;
        }
        else {
            return undefined;
        }
        if (nextBlock instanceof ParagraphWidget) {
            return nextBlock;
        }
        else {
            return this.getFirstBlockInFirstCell(nextBlock);
        }
    }
    /**
     * @private
     */
    getLastBlockInPreviousHeaderFooter(block) {
        let headerFooter = block.containerWidget;
        let previousBlock;
        if (headerFooter.headerFooterType.indexOf('Footer') !== -1) {
            previousBlock = headerFooter.page.headerWidget.lastChild;
        }
        else if (headerFooter.page.previousPage) {
            previousBlock = headerFooter.page.previousPage.footerWidget.lastChild;
        }
        else {
            return undefined;
        }
        if (previousBlock instanceof ParagraphWidget) {
            return previousBlock;
        }
        else {
            return this.getFirstBlockInFirstCell(previousBlock);
        }
    }
    /**
     * Get previous paragraph in block
     * @private
     */
    getPreviousParagraphBlock(block) {
        if (block.previousRenderedWidget instanceof ParagraphWidget) {
            return block.previousRenderedWidget;
        }
        else if (block.previousRenderedWidget instanceof TableWidget) {
            return this.getLastParagraphInLastCell((block.previousRenderedWidget));
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getPreviousParagraphCell((block.containerWidget));
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getPreviousParagraph(block.containerWidget);
        }
        else if (block.containerWidget instanceof HeaderFooterWidget && this.isMoveDownOrMoveUp) {
            return this.getLastBlockInPreviousHeaderFooter(block);
        }
        return undefined;
    }
    /**
     * Get first paragraph in block
     * @private
     */
    getFirstParagraphBlock(block) {
        if (block instanceof ParagraphWidget) {
            return block;
        }
        else if (block instanceof TableWidget) {
            return this.getFirstParagraphInFirstCell(block);
        }
        return undefined;
    }
    /**
     * Get last paragraph in block
     * @private
     */
    getLastParagraphBlock(block) {
        if (block instanceof ParagraphWidget) {
            return block;
        }
        else if (block instanceof TableWidget) {
            return this.getLastParagraphInLastCell(block);
        }
        return undefined;
    }
    /**
     * Return true if paragraph has valid inline
     * @private
     */
    hasValidInline(paragraph, start, end) {
        let index = paragraph.childWidgets.indexOf(start.line);
        for (let i = index; i < paragraph.childWidgets.length; i++) {
            for (let j = 0; j < paragraph.childWidgets[i].children.length; j++) {
                let inline = paragraph.childWidgets[i].children[j];
                if (inline.length === 0) {
                    continue;
                }
                if (inline === end) {
                    return false;
                }
                if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                    || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Get paragraph length
     * @private
     */
    getParagraphLength(paragraph, endLine, elementInfo) {
        let length = 0;
        for (let j = 0; j < paragraph.childWidgets.length; j++) {
            let line = paragraph.childWidgets[j];
            if (endLine instanceof LineWidget && endLine === line) {
                if (elementInfo) {
                    length += this.getLineLength(line, elementInfo);
                }
                break;
            }
            length += this.getLineLength(line);
        }
        return length;
    }
    /**
     * Get Line length
     * @private
     */
    getLineLength(line, elementInfo) {
        let length = 0;
        let bidi = line.paragraph.bidi;
        for (let i = !bidi ? 0 : line.children.length - 1; bidi ? i > -1 : i < line.children.length; bidi ? i-- : i++) {
            let element = line.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            if (elementInfo && elementInfo.element instanceof ElementBox && elementInfo.element === element) {
                length += elementInfo.index;
                break;
            }
            length += element.length;
        }
        return length;
    }
    /**
     * Get line information
     * @private
     */
    getLineInfo(paragraph, offset) {
        let line = undefined;
        let length = 0;
        let childLength = paragraph.childWidgets.length;
        for (let j = 0; j < childLength; j++) {
            line = paragraph.childWidgets[j];
            length = this.getLineLength(line);
            if (offset <= length || j === childLength - 1) {
                break;
            }
            else {
                offset = offset - length;
            }
        }
        return { 'line': line, 'offset': offset };
    }
    /**
     * @private
     */
    getElementInfo(line, offset) {
        let element = undefined;
        for (let i = 0; i < line.children.length; i++) {
            element = line.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            if (offset > element.length
                && (!(offset === element.length + 1 && isNullOrUndefined(element.nextNode)))) {
                offset = offset - element.length;
            }
            else {
                break;
            }
        }
        return { 'element': element, 'index': offset };
    }
    /**
     * Get paragraph start offset
     * @private
     */
    getStartOffset(paragraph) {
        let startOffset = 0;
        if (paragraph.childWidgets.length > 0) {
            let childWidgets = paragraph.childWidgets[0];
            return this.getStartLineOffset(childWidgets);
        }
        return startOffset;
    }
    /**
     * @private
     */
    getStartLineOffset(line) {
        let startOffset = 0;
        for (let i = 0; i < line.children.length; i++) {
            let inline = line.children[i];
            if (inline.length === 0) {
                continue;
            }
            // tslint:disable-next-line:max-line-length
            if (inline instanceof TextElementBox || inline instanceof ImageElementBox || inline instanceof BookmarkElementBox
                || inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox || inline instanceof CommentCharacterElementBox
                || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                return startOffset;
            }
            if (inline instanceof ListTextElementBox) {
                continue;
            }
            startOffset += inline.length;
        }
        return startOffset;
    }
    /**
     * Get previous paragraph from selection
     * @private
     */
    getPreviousSelectionCell(cell) {
        if (!isNullOrUndefined(cell.previousRenderedWidget)) {
            if (!this.isForward) {
                let block = cell.previousRenderedWidget.childWidgets[0];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    return this.getFirstParagraphInLastRow(block);
                }
            }
            else {
                let widgets = cell.previousRenderedWidget.childWidgets;
                let block = widgets[widgets.length - 1];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    return this.getPreviousParagraphSelection(block.childWidgets[block.childWidgets.length - 1]);
                }
            }
        }
        return this.getPreviousSelectionRow(cell.ownerRow);
    }
    /**
     * Get previous paragraph selection in selection
     * @private
     */
    getPreviousSelectionRow(row) {
        if (!isNullOrUndefined(row.previousRenderedWidget)) {
            if (!this.isForward) {
                let cell = row.previousRenderedWidget.childWidgets[0];
                let block = cell.childWidgets[0];
                return this.getFirstParagraphBlock(block);
            }
            else {
                return this.getPreviousParagraphSelection(row.previousRenderedWidget);
            }
        }
        return this.getPreviousSelectionBlock(row.ownerTable);
    }
    /**
     * @private
     */
    getNextSelectionBlock(block) {
        if (block.nextRenderedWidget instanceof ParagraphWidget) {
            return block.nextRenderedWidget;
        }
        else if (block.nextRenderedWidget instanceof TableWidget) {
            if (this.isEmpty || this.isForward) {
                return this.getLastParagraphInFirstRow(block.nextRenderedWidget);
            }
            else {
                return this.getNextParagraphSelection(block.nextRenderedWidget.childWidgets[0]);
            }
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getNextSelectionCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getNextSelection(block.containerWidget);
        }
        return undefined;
    }
    /**
     * Get next paragraph from selected cell
     * @private
     */
    getNextSelectionCell(cell) {
        if (!isNullOrUndefined(cell.nextRenderedWidget)) {
            if (this.isEmpty || this.isForward) {
                // tslint:disable-next-line:max-line-length
                let block = cell.nextRenderedWidget.childWidgets[cell.nextRenderedWidget.childWidgets.length - 1];
                return this.getLastParagraphBlock(block);
            }
            else {
                //Return first paragraph in cell. 
                let block = cell.nextRenderedWidget.childWidgets[0];
                if (block instanceof ParagraphWidget) {
                    return block;
                }
                else {
                    return this.getNextParagraphSelection(block.childWidgets[0]);
                }
            }
        }
        return this.getNextSelectionRow(cell.ownerRow);
    }
    /**
     * Get next paragraph in selection
     * @private
     */
    getNextSelectionRow(row) {
        if (!isNullOrUndefined(row.nextRenderedWidget)) {
            let isForwardSelection = this.isEmpty || this.isForward;
            if (isForwardSelection) {
                // tslint:disable-next-line:max-line-length
                let cell = row.nextRenderedWidget.childWidgets[row.nextRenderedWidget.childWidgets.length - 1];
                let block = cell.childWidgets[cell.childWidgets.length - 1];
                return this.getLastParagraphBlock(block);
            }
            else {
                return this.getNextParagraphSelection(row.nextRenderedWidget);
            }
        }
        return this.getNextSelectionBlock(row.ownerTable);
    }
    /**
     * Get next block with selection
     * @private
     */
    getNextSelection(section) {
        if (section.nextRenderedWidget instanceof BodyWidget) {
            let block = section.nextRenderedWidget.childWidgets[0];
            if (block instanceof ParagraphWidget) {
                return block;
            }
            else {
                if (this.isEmpty || this.isForward) {
                    return this.getLastParagraphInFirstRow(block);
                }
                else {
                    return this.getNextParagraphSelection(block.childWidgets[0]);
                }
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getNextParagraphSelection(row) {
        //Iterate the exact cell based on UP/Down selection length.
        let cell = row.childWidgets[0];
        if (this.start.paragraph.isInsideTable
            && row.ownerTable.contains(this.start.paragraph.associatedCell)) {
            let startCell = this.getCellInTable(row.ownerTable, this.start.paragraph.associatedCell);
            cell = this.getFirstCellInRegion(row, startCell, this.upDownSelectionLength, false);
        }
        let block = cell.childWidgets[0];
        return this.getFirstParagraphBlock(block);
    }
    /**
     * @private
     */
    getPreviousSelectionBlock(block) {
        if (block.previousRenderedWidget instanceof ParagraphWidget) {
            return block.previousRenderedWidget;
        }
        else if (block.previousRenderedWidget instanceof TableWidget) {
            if (!this.isForward) {
                return this.getFirstParagraphInLastRow(block.previousRenderedWidget);
            }
            else {
                // tslint:disable-next-line:max-line-length
                return this.getPreviousParagraphSelection(block.previousRenderedWidget.childWidgets[block.previousRenderedWidget.childWidgets.length - 1]);
            }
        }
        if (block.containerWidget instanceof TableCellWidget) {
            return this.getPreviousSelectionCell(block.containerWidget);
        }
        else if (block.containerWidget instanceof BodyWidget) {
            return this.getPreviousSelection(block.containerWidget);
        }
        return undefined;
    }
    /**
     * Get previous paragraph in selection
     * @private
     */
    getPreviousSelection(section) {
        if (section.previousRenderedWidget instanceof BodyWidget) {
            let prevBodyWidget = section.previousRenderedWidget;
            let block = prevBodyWidget.childWidgets[prevBodyWidget.childWidgets.length - 1];
            if (block instanceof ParagraphWidget) {
                return block;
            }
            else {
                if (!this.isForward) {
                    return this.getFirstParagraphInLastRow(block);
                }
                else {
                    let tableWidget = block;
                    // tslint:disable-next-line:max-line-length
                    return this.getPreviousParagraphSelection(tableWidget.childWidgets[tableWidget.childWidgets.length - 1]);
                }
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    getPreviousParagraphSelection(row) {
        //Iterate the exact cell based on UP/Down selection length.
        let cell = row.childWidgets[row.childWidgets.length - 1];
        if (this.start.paragraph.isInsideTable
            && row.ownerTable.contains(this.start.paragraph.associatedCell)) {
            let startCell = this.getCellInTable(row.ownerTable, this.start.paragraph.associatedCell);
            cell = this.getLastCellInRegion(row, startCell, this.upDownSelectionLength, true);
        }
        let block = cell.childWidgets[cell.childWidgets.length - 1];
        return this.getLastParagraphBlock(block);
    }
    /**
     * Get last cell in the selected region
     * @private
     */
    getLastCellInRegion(row, startCell, selLength, isMovePrev) {
        let start = this.getCellLeft(row, startCell);
        let end = start + startCell.cellFormat.cellWidth;
        let flag = true;
        if (start <= selLength && selLength < end) {
            for (let i = row.childWidgets.length - 1; i >= 0; i--) {
                let left = this.getCellLeft(row, row.childWidgets[i]);
                if (HelperMethods.round(start, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(end, 2)) {
                    flag = false;
                    return row.childWidgets[i];
                }
            }
        }
        else {
            for (let i = row.childWidgets.length - 1; i >= 0; i--) {
                let left = this.getCellLeft(row, row.childWidgets[i]);
                if (left <= selLength && left + row.childWidgets[i].cellFormat.cellWidth > selLength) {
                    flag = false;
                    return row.childWidgets[i];
                }
            }
        }
        if (flag) {
            if (!isNullOrUndefined(row.previousRenderedWidget) && isMovePrev) {
                return this.getLastCellInRegion(row.previousRenderedWidget, startCell, selLength, isMovePrev);
            }
            else if (!isNullOrUndefined(row.nextRenderedWidget) && !isMovePrev) {
                return this.getLastCellInRegion(row.nextRenderedWidget, startCell, selLength, isMovePrev);
            }
        }
        return row.childWidgets[row.childWidgets.length - 1];
    }
    /**
     * Get Container table
     * @private
     */
    getCellInTable(table, tableCell) {
        while (tableCell.ownerTable.isInsideTable) {
            if (table.equals(tableCell.ownerTable)) {
                return tableCell;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return tableCell;
    }
    /**
     * Get first paragraph in last row
     * @private
     */
    getFirstParagraphInLastRow(table) {
        if (table.childWidgets.length > 0) {
            let lastRow = table.childWidgets[table.childWidgets.length - 1];
            let lastCell = lastRow.childWidgets[0];
            let lastBlock = lastCell.childWidgets[0];
            return this.getFirstParagraphBlock(lastBlock);
        }
        return undefined;
    }
    /**
     * Get previous valid offset
     * @private
     */
    getPreviousValidOffset(paragraph, offset) {
        if (offset === 0) {
            return 0;
        }
        let validOffset = 0;
        let count = 0;
        let value = 0;
        let bidi = paragraph.paragraphFormat.bidi;
        for (let i = 0; i < paragraph.childWidgets.length; i++) {
            let lineWidget = paragraph.childWidgets[i];
            if (!bidi) {
                for (let j = 0; j < lineWidget.children.length; j++) {
                    let inline = lineWidget.children[j];
                    if (inline.length === 0) {
                        continue;
                    }
                    if (offset <= count + inline.length) {
                        return offset - 1 === count ? validOffset : offset - 1;
                    }
                    if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                        validOffset = count + inline.length;
                    }
                    count += inline.length;
                }
            }
            else {
                value = lineWidget.getInlineForOffset(offset, false, undefined, false, true, false).index;
                if (value >= 0) {
                    return value;
                }
            }
        }
        return offset - 1 === count ? validOffset : offset - 1;
    }
    /**
     * Get next valid offset
     * @private
     */
    getNextValidOffset(line, offset) {
        let count = 0;
        if (!line.paragraph.paragraphFormat.bidi) {
            for (let i = 0; i < line.children.length; i++) {
                let inline = line.children[i];
                if (inline.length === 0 || inline instanceof ListTextElementBox) {
                    continue;
                }
                if (offset < count + inline.length) {
                    if (inline instanceof TextElementBox || inline instanceof ImageElementBox
                        || (inline instanceof FieldElementBox && HelperMethods.isLinkedFieldCharacter(inline))) {
                        return (offset > count ? offset : count) + 1;
                    }
                }
                count += inline.length;
            }
        }
        else {
            if (offset !== this.getLineLength(line)) {
                offset = line.getInlineForOffset(offset, false, undefined, false, false, true).index;
            }
        }
        return offset;
    }
    /**
     * Get paragraph mark size info
     * @private
     */
    getParagraphMarkSize(paragraph, topMargin, bottomMargin) {
        let size = this.viewer.textHelper.getParagraphMarkSize(paragraph.characterFormat);
        let baselineOffset = size.BaselineOffset;
        let maxHeight = size.Height;
        let maxBaselineOffset = baselineOffset;
        if (paragraph instanceof ParagraphWidget) {
            // let paragraphWidget: ParagraphWidget[] = paragraph.renderedElement() as ParagraphWidget[];
            if (paragraph.childWidgets.length > 0) {
                let lineWidget = paragraph.childWidgets[0];
            }
            //Gets line spacing.
            let lineSpacing = this.viewer.layout.getLineSpacing(paragraph, maxHeight);
            let beforeSpacing = this.viewer.layout.getBeforeSpacing(paragraph);
            topMargin = maxBaselineOffset - baselineOffset;
            bottomMargin = maxHeight - maxBaselineOffset - (size.Height - baselineOffset);
            //Updates line spacing, paragraph after/ before spacing and aligns the text to base line offset.
            let lineSpacingType = paragraph.paragraphFormat.lineSpacingType;
            if (lineSpacingType === 'Multiple') {
                if (lineSpacing > maxHeight) {
                    bottomMargin += lineSpacing - maxHeight;
                }
                else {
                    topMargin += lineSpacing - maxHeight;
                }
            }
            else if (lineSpacingType === 'Exactly') {
                topMargin += lineSpacing - (topMargin + size.Height + bottomMargin);
            }
            else if (lineSpacing > topMargin + size.Height + bottomMargin) {
                topMargin += lineSpacing - (topMargin + size.Height + bottomMargin);
            }
            topMargin += beforeSpacing;
            bottomMargin += this.viewer.layout.getAfterSpacing(paragraph);
        }
        return { 'width': size.Width, 'height': size.Height, 'topMargin': topMargin, 'bottomMargin': bottomMargin };
    }
    /**
     * @private
     */
    getPhysicalPositionInternal(line, offset, moveNextLine) {
        if (line.paragraph.isEmpty()) {
            let paragraphWidget = line.paragraph;
            let left = paragraphWidget.x;
            if (paragraphWidget.childWidgets.length > 0) {
                let lineWidget = paragraphWidget.childWidgets[0];
                left = this.getLeft(lineWidget);
            }
            let topMargin = 0;
            let bottomMargin = 0;
            let size = this.getParagraphMarkSize(line.paragraph, topMargin, bottomMargin);
            if (offset > 0) {
                left += size.width;
            }
            return new Point(left, paragraphWidget.y + topMargin);
        }
        else {
            let indexInInline = 0;
            let inlineObj = line.getInline(offset, indexInInline, line.paragraph.bidi);
            let inline = inlineObj.element; //return indexInInline must
            indexInInline = inlineObj.index;
            // tslint:disable-next-line:max-line-length
            // if (inline.length === indexInInline && !isNullOrUndefined(inline.nextNode) && this.viewer.renderedElements.containsKey(inline) &&
            //     this.viewer.renderedElements.get(inline).length > 0 && this.viewer.renderedElements.containsKey(inline.nextNode as WInline)
            //     && this.viewer.renderedElements.get(inline.nextNode as WInline).length > 0 &&
            // tslint:disable-next-line:max-line-length
            //     (this.viewer.renderedElements.get(inline)[this.viewer.renderedElements.get(inline).length - 1] as ElementBox).line !== (this.viewer.renderedElements.get(inline.nextNode as WInline)[0] as ElementBox).line) {
            //     //Handled specifically to move the cursor at start of next line.
            //     inline = inline.nextNode as WInline;
            //     indexInInline = 0;
            // }
            return this.getPhysicalPositionInline(inline, indexInInline, moveNextLine);
        }
    }
    /**
     * Highlight selected content
     * @private
     */
    highlightSelectedContent(start, end) {
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || (!start.paragraph.associatedCell.equals(end.paragraph.associatedCell))
            || this.isCellSelected(start.paragraph.associatedCell, start, end))) {
            this.highlightCell(start.paragraph.associatedCell, this, start, end);
        }
        else {
            let inline = undefined;
            let index = 0;
            if (!this.owner.isReadOnlyMode && start.paragraph === end.paragraph) {
                if (start.offset + 1 === end.offset) {
                    let inlineObj = end.currentWidget.getInline(end.offset, index);
                    inline = inlineObj.element; // return index value
                    index = inlineObj.index;
                    if (inline instanceof ImageElementBox) {
                        let startOffset = start.currentWidget.getOffset(inline, 0);
                        if (startOffset !== start.offset) {
                            inline = undefined;
                        }
                    }
                }
                else {
                    let indexInInline = 0;
                    let startInlineObj = start.currentWidget.getInline(start.offset, indexInInline);
                    let startInline = startInlineObj.element; //return indexInInline
                    indexInInline = startInlineObj.index;
                    if (indexInInline === startInline.length) {
                        startInline = this.getNextRenderedElementBox(startInline, indexInInline);
                    }
                    let endInlineObj = end.currentWidget.getInline(end.offset, indexInInline);
                    let endInline = endInlineObj.element; //return indexInInline
                    indexInInline = endInlineObj.index;
                    // tslint:disable-next-line:max-line-length
                    if (startInline instanceof FieldElementBox && endInline instanceof FieldElementBox && !isNullOrUndefined(startInline.fieldSeparator)) {
                        let fieldValue = startInline.fieldSeparator.nextNode;
                        if (fieldValue instanceof ImageElementBox && fieldValue.nextNode === endInline) {
                            inline = fieldValue;
                        }
                    }
                }
            }
            if (!this.owner.isReadOnlyMode && inline instanceof ImageElementBox && this.owner.isDocumentLoaded) {
                let elementBoxObj = this.getElementBoxInternal(inline, index);
                let elementBox = elementBoxObj.element; //return index 
                index = elementBoxObj.index;
                if (this.owner.enableImageResizerMode) {
                    this.owner.imageResizerModule.positionImageResizer(elementBox);
                    this.owner.imageResizerModule.showImageResizer();
                }
                if (this.viewer.isTouchInput) {
                    this.viewer.touchStart.style.display = 'none';
                    this.viewer.touchEnd.style.display = 'none';
                }
            }
            else {
                this.highlight(start.paragraph, start, end);
                if (this.isHighlightNext) {
                    this.highlightNextBlock(this.hightLightNextParagraph, start, end);
                    this.isHighlightNext = false;
                    this.hightLightNextParagraph = undefined;
                }
            }
        }
    }
    /**
     * @private
     */
    // tslint:disable:max-func-body-length
    highlight(paragraph, start, end) {
        let selectionStartIndex = 0;
        let selectionEndIndex = 0;
        let startElement = undefined;
        let endElement = undefined;
        let startLineWidget = undefined;
        let endLineWidget = undefined;
        //return start Element and selection start index
        let startLineObj = this.getStartLineWidget(paragraph, start, startElement, selectionStartIndex);
        startElement = startLineObj.element;
        if (isNullOrUndefined(startElement)) {
            startLineWidget = paragraph.childWidgets[0];
        }
        else {
            startLineWidget = startElement.line;
        }
        selectionStartIndex = startLineObj.index;
        let endLineObj = this.getEndLineWidget(end, endElement, selectionEndIndex);
        endElement = endLineObj.element;
        if (endElement) {
            endLineWidget = endElement.line;
        }
        else {
            endLineWidget = end.paragraph.childWidgets[end.paragraph.childWidgets.length - 1];
        }
        selectionEndIndex = endLineObj.index;
        let top = 0;
        let left = 0;
        if (!isNullOrUndefined(startLineWidget)) {
            top = this.getTop(startLineWidget);
            left = this.getLeftInternal(startLineWidget, startElement, selectionStartIndex);
        }
        if (!isNullOrUndefined(startLineWidget) && startLineWidget === endLineWidget) {
            //Selection ends in current line.
            let right = this.getLeftInternal(endLineWidget, endElement, selectionEndIndex);
            let width = 0;
            let isRtlText = false;
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            if (!isRtlText && startElement instanceof TextElementBox) {
                isRtlText = startElement.isRightToLeft;
            }
            width = Math.abs(right - left);
            // Handled the highlighting approach as genric for normal and rtl text.
            if (isRtlText || paragraph.bidi) {
                let elementBoxCollection = this.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                if (elementBoxCollection && elementBoxCollection.length > 1) {
                    for (let i = 0; i < elementBoxCollection.length; i++) {
                        let element = elementBoxCollection[i];
                        let elementIsRTL = false;
                        let index = element instanceof TextElementBox ? element.length : 1;
                        if (element === startElement) {
                            left = this.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            right = this.getLeftInternal(startLineWidget, element, index);
                        }
                        else if (element === endElement) {
                            left = this.getLeftInternal(startLineWidget, element, 0);
                            right = this.getLeftInternal(startLineWidget, element, selectionEndIndex);
                        }
                        else {
                            left = this.getLeftInternal(startLineWidget, element, 0);
                            right = this.getLeftInternal(startLineWidget, element, index);
                        }
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        // Handled the paragraph mark highliting as special case.
                        if (element === endElement && element instanceof TextElementBox
                            && selectionEndIndex > element.length) {
                            let charFormat = element.line.paragraph.characterFormat;
                            let paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(charFormat).Width;
                            if (paragraph.bidi && !elementIsRTL) {
                                width -= paragraphMarkWidth;
                                // Highlight the element.
                                this.createHighlightBorder(startLineWidget, width, left, top, true);
                                // Highlight the paragraph mark of Bidi paragrph. 
                                left = this.getLineStartLeft(startLineWidget) - paragraphMarkWidth;
                                this.createHighlightBorder(startLineWidget, paragraphMarkWidth, left, top, true);
                                // continue to next element.
                                continue;
                            }
                        }
                        this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top, true);
                    }
                }
                else { // Need to handle the Paragraph mark highlighting.
                    if (endElement instanceof TextElementBox && selectionEndIndex > endElement.length) {
                        let charFormat = endElement.line.paragraph.characterFormat;
                        let paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(charFormat).Width;
                        // Since isRTLText is truo, so the right is considered as left
                        if (!paragraph.bidi && isRtlText) {
                            right += paragraphMarkWidth;
                            width -= paragraphMarkWidth;
                            // Highlight the element.
                            this.createHighlightBorder(startLineWidget, width, right, top, true);
                            // Highlight the paragraph mark. 
                            right += endElement.width;
                            this.createHighlightBorder(startLineWidget, paragraphMarkWidth, right, top, true);
                        }
                        else if (paragraph.bidi && !isRtlText) {
                            width -= paragraphMarkWidth;
                            // Highlight the element.
                            this.createHighlightBorder(startLineWidget, width, left, top, true);
                            // Highlight the paragraph mark of Bidi paragrph. 
                            left = this.getLineStartLeft(startLineWidget) - paragraphMarkWidth;
                            this.createHighlightBorder(startLineWidget, paragraphMarkWidth, left, top, true);
                        }
                        else {
                            this.createHighlightBorder(startLineWidget, width, isRtlText ? right : left, top, false);
                        }
                    }
                    else {
                        this.createHighlightBorder(startLineWidget, width, isRtlText ? right : left, top, false);
                    }
                }
            }
            else {
                // Start element and end element will be in reverese for Bidi paragraph highlighting. 
                // So, the right is considered based on Bidi property. 
                this.createHighlightBorder(startLineWidget, width, paragraph.bidi ? right : left, top, false);
            }
        }
        else {
            if (!isNullOrUndefined(startLineWidget)) {
                let x = startLineWidget.paragraph.x;
                if (paragraph !== startLineWidget.paragraph) {
                    paragraph = startLineWidget.paragraph;
                }
                let width = this.getWidth(startLineWidget, true) - (left - startLineWidget.paragraph.x);
                // Handled the  highlighting approach as genric for normal and rtl text.
                if (paragraph.bidi || (startElement instanceof TextElementBox && startElement.isRightToLeft)) {
                    let right = 0;
                    // tslint:disable-next-line:max-line-length
                    let elementCollection = this.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                    if (elementCollection) {
                        let elementIsRTL = false;
                        for (let i = 0; i < elementCollection.length; i++) {
                            let element = elementCollection[i];
                            elementIsRTL = false;
                            if (element === startElement) {
                                left = this.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            }
                            else {
                                left = this.getLeftInternal(startLineWidget, element, 0);
                            }
                            let index = element instanceof TextElementBox ? element.length : 1;
                            right = this.getLeftInternal(startLineWidget, element, index);
                            if (element instanceof TextElementBox) {
                                elementIsRTL = element.isRightToLeft;
                            }
                            width = Math.abs(right - left);
                            this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top, true);
                        }
                        // Highlight the Paragrph mark for last line.
                        if (startLineWidget.isLastLine()) {
                            // tslint:disable-next-line:max-line-length
                            let charFormat = elementCollection[elementCollection.length - 1].line.paragraph.characterFormat;
                            let paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(charFormat).Width;
                            if (paragraph.bidi) {
                                // The paragraph mark will be at the left most end.
                                left = this.getLineStartLeft(startLineWidget) - paragraphMarkWidth;
                            }
                            else { // The paragraph mark will at right most end.
                                left = elementIsRTL ? startLineWidget.paragraph.x + this.getWidth(startLineWidget, false) : right;
                            }
                            this.createHighlightBorder(startLineWidget, paragraphMarkWidth, left, top, true);
                        }
                    }
                    else {
                        this.createHighlightBorder(startLineWidget, width, left, top, false);
                    }
                }
                else {
                    this.createHighlightBorder(startLineWidget, width, left, top, false);
                }
                let lineIndex = startLineWidget.paragraph.childWidgets.indexOf(startLineWidget);
                //Iterates to last item of paragraph or selection end.                                             
                this.highlightParagraph(paragraph, lineIndex + 1, endLineWidget, endElement, selectionEndIndex);
                if (paragraph.childWidgets.indexOf(end.currentWidget) !== -1) {
                    return;
                }
            }
            if (this.isHideSelection(paragraph)) {
                this.isHighlightNext = false;
                return;
            }
            this.isHighlightNext = true;
            this.hightLightNextParagraph = paragraph;
        }
    }
    highlightNextBlock(paragraph, start, end) {
        let block = paragraph.nextRenderedWidget;
        if (!isNullOrUndefined(block)) {
            if (block instanceof ParagraphWidget) {
                this.isHighlightNext = false;
                this.highlight(block, start, end);
                if (this.isHighlightNext) {
                    this.highlightNextBlock(this.hightLightNextParagraph, start, end);
                    this.isHighlightNext = false;
                    this.hightLightNextParagraph = undefined;
                }
            }
            else {
                this.highlightTable(block, start, end);
            }
        }
    }
    /**
     * Get start line widget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getStartLineWidget(paragraph, start, startElement, selectionStartIndex) {
        let offset = paragraph === start.paragraph ? start.offset : this.getStartOffset(paragraph);
        let startInlineObj = undefined;
        if (paragraph === start.paragraph) {
            startInlineObj = start.currentWidget.getInline(offset, selectionStartIndex);
        }
        else {
            startInlineObj = paragraph.firstChild.getInline(offset, selectionStartIndex);
        }
        startElement = startInlineObj.element; //return selectionStartIndex
        selectionStartIndex = startInlineObj.index;
        if (startElement instanceof FieldElementBox) {
            let inlineInfo = this.getRenderedInline(startElement, selectionStartIndex);
            startElement = inlineInfo.element;
            selectionStartIndex = inlineInfo.index;
        }
        if (offset === this.getParagraphLength(start.paragraph) + 1) {
            selectionStartIndex++;
        }
        return {
            'index': selectionStartIndex, 'element': startElement
        };
    }
    /**
     * Get end line widget
     * @private
     */
    getEndLineWidget(end, endElement, selectionEndIndex) {
        let endInlineObj = end.currentWidget.getInline(end.offset, selectionEndIndex);
        endElement = endInlineObj.element; //return selection end index
        selectionEndIndex = endInlineObj.index;
        if (endElement instanceof FieldElementBox) {
            let inlineInfo = this.getRenderedInline(endElement, selectionEndIndex);
            endElement = inlineInfo.element;
            selectionEndIndex = inlineInfo.index;
        }
        let lineIndex = end.paragraph.childWidgets.indexOf(end.currentWidget);
        if (lineIndex === end.paragraph.childWidgets.length - 1 && end.offset === this.getLineLength(end.currentWidget) + 1) {
            selectionEndIndex = endElement ? endElement.length + 1 : 1;
        }
        return { 'index': selectionEndIndex, 'element': endElement };
    }
    /**
     * Get line widget
     * @private
     */
    getLineWidgetInternal(line, offset, moveToNextLine) {
        let lineWidget = undefined;
        if (line.children.length === 0 && line instanceof LineWidget) {
            lineWidget = line;
        }
        else {
            let indexInInline = 0;
            let inlineInfo = line.getInline(offset, indexInInline);
            let inline = inlineInfo.element;
            indexInInline = inlineInfo.index;
            lineWidget = inline instanceof ElementBox ? inline.line
                : this.getLineWidgetInternalInline(inline, indexInInline, moveToNextLine);
        }
        return lineWidget;
    }
    /**
     * Get last line widget
     * @private
     */
    getLineWidgetParagraph(offset, line) {
        let linewidget = undefined;
        if (line.children.length === 0) {
            linewidget = line;
        }
        else {
            let indexInInline = 0;
            let inlineInfo = line.getInline(offset, indexInInline);
            let inline = inlineInfo.element;
            indexInInline = inlineInfo.index;
            linewidget = this.getLineWidget(inline, indexInInline);
        }
        return linewidget;
    }
    /**
     * Highlight selected cell
     * @private
     */
    /* tslint:disable */
    // tslint:disable-next-line:max-line-length    
    highlightCells(table, startCell, endCell) {
        let start = this.getCellLeft(startCell.ownerRow, startCell);
        let end = start + startCell.cellFormat.cellWidth;
        let endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (start > endCellLeft) {
            start = endCellLeft;
        }
        if (end < endCellRight) {
            end = endCellRight;
        }
        if (start > this.upDownSelectionLength) {
            start = this.upDownSelectionLength;
        }
        if (end < this.upDownSelectionLength) {
            end = this.upDownSelectionLength;
        }
        let tableWidgetCollection = table.getSplitWidgets();
        let startTableIndex = tableWidgetCollection.indexOf(startCell.ownerRow.ownerTable);
        let endTableIndex = tableWidgetCollection.indexOf(endCell.ownerRow.ownerTable);
        if (startTableIndex === endTableIndex) {
            let count = table.childWidgets.indexOf(endCell.ownerRow);
            for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
                this.highlightRow(table.childWidgets[i], start, end);
            }
        }
        else {
            let startRowIndex = 0;
            let endRowIndex = 0;
            for (let i = startTableIndex; i <= endTableIndex; i++) {
                table = tableWidgetCollection[i];
                if (i === startTableIndex) {
                    startRowIndex = table.childWidgets.indexOf(startCell.ownerRow);
                }
                else {
                    startRowIndex = 0;
                }
                if (i === endTableIndex) {
                    endRowIndex = table.childWidgets.indexOf(endCell.ownerRow);
                }
                else {
                    endRowIndex = table.childWidgets.length - 1;
                }
                for (let j = startRowIndex; j <= endRowIndex; j++) {
                    this.highlightRow(table.childWidgets[j], start, end);
                }
            }
        }
    }
    /* tslint:enable */
    /**
     * highlight selected table
     * @private
     */
    highlightTable(table, start, end) {
        this.highlightInternal(table.childWidgets[0], start, end);
        if (!end.paragraph.isInsideTable //Selection end is outside the table cell.
            || !table.contains(end.paragraph.associatedCell)) { //Selection end is not inside the current table.
            this.highlightNextBlock(table, start, end);
        }
    }
    /**
     * Get cell left
     * @private
     */
    getCellLeft(row, cell) {
        let left = 0;
        left += cell.x - cell.margin.left;
        return left;
    }
    /**
     * Get next paragraph for row
     * @private
     */
    getNextParagraphRow(row) {
        if (!isNullOrUndefined(row.nextRenderedWidget)) {
            let cell = row.nextRenderedWidget.childWidgets[0];
            let block = cell.childWidgets[0];
            return this.getFirstParagraphBlock(block);
        }
        return this.getNextParagraphBlock(row.ownerTable);
    }
    /**
     * Get previous paragraph from row
     * @private
     */
    getPreviousParagraphRow(row) {
        if (!isNullOrUndefined(row.previousRenderedWidget)) {
            // tslint:disable-next-line:max-line-length
            let cell = row.previousRenderedWidget.lastChild;
            let block = cell.lastChild ? cell.lastChild : (cell.previousSplitWidget).lastChild;
            return this.getLastParagraphBlock(block);
        }
        return this.getPreviousParagraphBlock(row.ownerTable);
    }
    /**
     * Return true if row contain cell
     * @private
     */
    containsRow(row, tableCell) {
        if (row.childWidgets.indexOf(tableCell) !== -1) {
            return true;
        }
        while (tableCell.ownerTable.isInsideTable) {
            if (row.childWidgets.indexOf(tableCell) !== -1) {
                return true;
            }
            tableCell = tableCell.ownerTable.associatedCell;
        }
        return row.childWidgets.indexOf(tableCell) !== -1;
    }
    /**
     * Highlight selected row
     * @private
     */
    highlightRow(row, start, end) {
        for (let i = 0; i < row.childWidgets.length; i++) {
            let left = this.getCellLeft(row, row.childWidgets[i]);
            if (HelperMethods.round(start, 2) <= HelperMethods.round(left, 2) &&
                HelperMethods.round(left, 2) < HelperMethods.round(end, 2)) {
                this.highlightCellWidget(row.childWidgets[i]);
            }
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    highlightInternal(row, start, end) {
        for (let i = 0; i < row.childWidgets.length; i++) {
            this.highlightCellWidget(row.childWidgets[i]);
        }
        if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
            return;
        }
        else if (row.nextRenderedWidget instanceof TableRowWidget) {
            this.highlightInternal(row.nextRenderedWidget, start, end);
        }
    }
    /**
     * Get last paragraph in cell
     * @private
     */
    getLastParagraph(cell) {
        while (cell.nextSplitWidget) {
            if (cell.nextSplitWidget.childWidgets.length > 0) {
                cell = cell.nextSplitWidget;
            }
            else {
                break;
            }
        }
        let lastBlock;
        if (cell.childWidgets.length > 0) {
            lastBlock = cell.lastChild;
        }
        else {
            lastBlock = cell.previousSplitWidget.lastChild;
        }
        return this.getLastParagraphBlock(lastBlock);
    }
    /**
     * Return true is source cell contain cell
     * @private
     */
    containsCell(sourceCell, cell) {
        if (sourceCell.equals(cell)) {
            return true;
        }
        while (cell.ownerTable.isInsideTable) {
            if (sourceCell.equals(cell.ownerTable.associatedCell)) {
                return true;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return false;
    }
    /**
     * Return true if cell is selected
     * @private
     */
    isCellSelected(cell, startPosition, endPosition) {
        let lastParagraph = this.getLastParagraph(cell);
        // tslint:disable-next-line:max-line-length
        let isAtCellEnd = lastParagraph === endPosition.paragraph && endPosition.offset === this.getParagraphLength(lastParagraph) + 1;
        return isAtCellEnd || (!this.containsCell(cell, startPosition.paragraph.associatedCell) ||
            !this.containsCell(cell, endPosition.paragraph.associatedCell));
    }
    /**
     * Return Container cell
     * @private
     */
    getContainerCellOf(cell, tableCell) {
        while (cell.ownerTable.isInsideTable) {
            if (cell.ownerTable.contains(tableCell)) {
                return cell;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    }
    /**
     * Get Selected cell
     * @private
     */
    getSelectedCell(cell, containerCell) {
        if (cell.ownerTable.equals(containerCell.ownerTable)) {
            return cell;
        }
        while (cell.ownerTable.isInsideTable) {
            if (cell.ownerTable.associatedCell.equals(containerCell)) {
                return cell;
            }
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    }
    /**
     * @private
     */
    getSelectedCells() {
        let cells = [];
        for (let i = 0; i < this.selectedWidgets.keys.length; i++) {
            let widget = this.selectedWidgets.keys[i];
            if (widget instanceof TableCellWidget) {
                cells.push(widget);
            }
        }
        return cells;
    }
    /**
     * Get Next paragraph from cell
     * @private
     */
    getNextParagraphCell(cell) {
        if (cell.nextRenderedWidget && cell.nextRenderedWidget instanceof TableCellWidget) {
            //Return first paragraph in cell.            
            cell = cell.nextRenderedWidget;
            let block = cell.firstChild;
            if (block) {
                return this.getFirstParagraphBlock(block);
            }
            else {
                return this.getNextParagraphCell(cell);
            }
        }
        return this.getNextParagraphRow(cell.containerWidget);
    }
    /**
     * Get previous paragraph from cell
     * @private
     */
    getPreviousParagraphCell(cell) {
        if (!isNullOrUndefined(cell.previousRenderedWidget) && cell.previousRenderedWidget instanceof TableCellWidget) {
            cell = cell.previousRenderedWidget;
            let block = cell.lastChild;
            return this.getLastParagraphBlock(block);
        }
        return this.getPreviousParagraphRow(cell.ownerRow);
    }
    /**
     * Get cell's container cell
     * @private
     */
    getContainerCell(cell) {
        while (!isNullOrUndefined(cell.ownerTable) && cell.ownerTable.isInsideTable) {
            cell = cell.ownerTable.associatedCell;
        }
        return cell;
    }
    /**
     * Highlight selected cell
     * @private
     */
    /* tslint:disable */
    highlightCell(cell, selection, start, end) {
        if (end.paragraph.isInsideTable) {
            let containerCell = this.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(cell, containerCell);
                let endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    /* tslint:enable */
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.highlightCellWidget(containerCell);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.highlight(start.paragraph, start, end);
                            if (this.isHighlightNext) {
                                this.highlightNextBlock(this.hightLightNextParagraph, start, end);
                                this.isHighlightNext = false;
                                this.hightLightNextParagraph = undefined;
                            }
                        }
                        else {
                            this.highlightContainer(startCell, start, end);
                        }
                    }
                }
                else {
                    //Selection end is not in container cell.
                    this.highlightCellWidget(containerCell);
                    if (containerCell.ownerRow.equals(endCell.ownerRow)) {
                        //Highlight other selected cells in current row.
                        startCell = containerCell;
                        while (!isNullOrUndefined(startCell.nextRenderedWidget)) {
                            startCell = startCell.nextRenderedWidget;
                            this.highlightCellWidget(startCell);
                            if (startCell === endCell) {
                                break;
                            }
                        }
                    }
                    else {
                        this.highlightCells(containerCell.ownerTable, containerCell, endCell);
                    }
                }
            }
            else {
                this.highlightContainer(containerCell, start, end);
            }
        }
        else {
            let cell1 = this.getContainerCell(cell);
            this.highlightContainer(cell1, start, end);
        }
    }
    /**
     * @private
     */
    highlightContainer(cell, start, end) {
        this.highlightInternal(cell.containerWidget, start, end);
        this.highlightNextBlock(cell.ownerTable, start, end);
    }
    /**
     * Get previous valid element
     * @private
     */
    getPreviousValidElement(inline) {
        let previousValidInline = undefined;
        while (inline instanceof FieldElementBox) {
            if (HelperMethods.isLinkedFieldCharacter(inline)) {
                if (inline instanceof FieldElementBox && inline.fieldType === 0) {
                    previousValidInline = inline;
                }
                else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    previousValidInline = inline;
                    if (isNullOrUndefined(inline.fieldSeparator)) {
                        inline = inline.fieldBegin;
                        previousValidInline = inline;
                    }
                }
                else {
                    inline = inline.fieldBegin;
                    previousValidInline = inline;
                }
            }
            inline = inline.previousNode;
        }
        return isNullOrUndefined(previousValidInline) ? inline : previousValidInline;
    }
    /**
     * Get next valid element
     * @private
     */
    getNextValidElement(inline) {
        let nextValidInline = undefined;
        while (inline instanceof FieldElementBox) {
            if (inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
                return isNullOrUndefined(nextValidInline) ? inline : nextValidInline;
            }
            else if (inline.fieldType === 1 && !isNullOrUndefined(inline.fieldBegin)) {
                nextValidInline = inline;
            }
            inline = inline.nextNode;
        }
        return (isNullOrUndefined(nextValidInline) ? inline : nextValidInline);
    }
    /**
     * Return next valid inline with index
     * @private
     */
    validateTextPosition(inline, index) {
        if (inline.length === index && inline.nextNode instanceof FieldElementBox) {
            //If inline is last item within field, then set field end as text position.
            let nextInline = this.getNextValidElement(inline.nextNode);
            if (nextInline instanceof FieldElementBox && nextInline.fieldType === 1) {
                inline = nextInline;
                index = 1;
            }
        }
        else if (index === 0 && inline.previousNode instanceof FieldElementBox) {
            let prevInline = this.getPreviousValidElement(inline.previousNode);
            inline = prevInline;
            index = inline instanceof FieldElementBox ? 0 : inline.length;
            if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                index++;
            }
        }
        return { 'element': inline, 'index': index };
    }
    /**
     * Get inline physical location
     * @private
     */
    getPhysicalPositionInline(inline, index, moveNextLine) {
        let element = undefined;
        element = this.getElementBox(inline, index, moveNextLine).element;
        let lineWidget = undefined;
        if (isNullOrUndefined(element) || isNullOrUndefined(element.line)) {
            if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                element = inline;
            }
            else {
                if (inline instanceof FieldElementBox || inline instanceof BookmarkElementBox) {
                    return this.getFieldCharacterPosition(inline);
                }
                return new Point(0, 0);
            }
        }
        let margin = element.margin;
        let top = 0;
        let left = 0;
        if (element instanceof TextElementBox && element.text === '\v' && isNullOrUndefined(inline.nextNode)) {
            lineWidget = this.getNextLineWidget(element.line.paragraph, element);
            index = 0;
        }
        else {
            lineWidget = element.line;
        }
        top = this.getTop(lineWidget);
        if (element instanceof ImageElementBox) {
            let format = element.line.paragraph.characterFormat;
            let previousInline = this.getPreviousTextElement(inline);
            if (!isNullOrUndefined(previousInline)) {
                format = previousInline.characterFormat;
            }
            else {
                let nextInline = this.getNextTextElement(inline);
                if (!isNullOrUndefined(nextInline)) {
                    format = nextInline.characterFormat;
                }
            }
            let measureObj = this.viewer.textHelper.getHeight(format);
            if (element.margin.top + element.height - measureObj.BaselineOffset > 0) {
                top += element.margin.top + element.height - measureObj.BaselineOffset;
            }
        }
        else if (!(element instanceof FieldElementBox)) {
            top += margin.top > 0 ? margin.top : 0;
        }
        left = (isNullOrUndefined(element) || isNullOrUndefined(lineWidget)) ? 0 : this.getLeftInternal(lineWidget, element, index);
        return new Point(left, top);
    }
    /**
     * Get field character position
     * @private
     */
    getFieldCharacterPosition(firstInline) {
        let nextValidInline = this.getNextValidElementForField(firstInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            let nextParagraph = firstInline.line.paragraph;
            return this.getEndPosition(nextParagraph);
        }
        else {
            return this.getPhysicalPositionInline(nextValidInline, 0, true);
        }
    }
    /**
     * @private
     */
    getNextValidElementForField(firstInline) {
        if (firstInline instanceof FieldElementBox && firstInline.fieldType === 0
            && HelperMethods.isLinkedFieldCharacter(firstInline)) {
            let fieldBegin = firstInline;
            if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                firstInline = fieldBegin.fieldEnd;
            }
            else {
                firstInline = fieldBegin.fieldSeparator;
            }
        }
        let nextValidInline = undefined;
        if (!isNullOrUndefined(firstInline.nextNode)) {
            nextValidInline = this.getNextValidElement(firstInline.nextNode);
        }
        return nextValidInline;
    }
    /**
     * Get paragraph end position
     * @private
     */
    getEndPosition(widget) {
        let left = widget.x;
        let top = widget.y;
        let lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            lineWidget = widget.childWidgets[widget.childWidgets.length - 1];
            left += this.getWidth(lineWidget, false);
        }
        if (!isNullOrUndefined(lineWidget)) {
            top = this.getTop(lineWidget);
        }
        let topMargin = 0;
        let bottomMargin = 0;
        let size = this.getParagraphMarkSize(widget, topMargin, bottomMargin);
        return new Point(left, top + size.topMargin);
    }
    /**
     * Get element box
     * @private
     */
    getElementBox(currentInline, index, moveToNextLine) {
        let elementBox = undefined;
        if (!(currentInline instanceof FieldElementBox || currentInline instanceof BookmarkElementBox)) {
            elementBox = currentInline;
        }
        return { 'element': elementBox, 'index': index };
    }
    /**
     * @private
     */
    getPreviousTextElement(inline) {
        if (inline.previousNode instanceof TextElementBox) {
            return inline.previousNode;
        }
        if (!isNullOrUndefined(inline.previousNode)) {
            return this.getPreviousTextElement(inline.previousNode);
        }
        return undefined;
    }
    /**
     * Get next text inline
     * @private
     */
    getNextTextElement(inline) {
        if (inline.nextNode instanceof TextElementBox) {
            return inline.nextNode;
        }
        if (!isNullOrUndefined(inline.nextNode)) {
            return this.getNextTextElement(inline.nextNode);
        }
        return undefined;
    }
    /**
     * @private
     */
    getNextRenderedElementBox(inline, indexInInline) {
        if (inline instanceof FieldElementBox) {
            let fieldBegin = inline;
            if (fieldBegin.fieldType === 0) {
                inline = this.getRenderedField(fieldBegin);
                if (fieldBegin === inline) {
                    return fieldBegin;
                }
            }
            indexInInline = 1;
        }
        while (!isNullOrUndefined(inline) && indexInInline === inline.length && inline.nextNode instanceof FieldElementBox) {
            let nextValidInline = this.getNextValidElement((inline.nextNode));
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                let fieldBegin = nextValidInline;
                inline = this.getRenderedField(fieldBegin);
                if (!isNullOrUndefined(inline) && fieldBegin === inline) {
                    return fieldBegin;
                }
                indexInInline = 1;
            }
            else {
                inline = nextValidInline;
            }
        }
        return inline;
    }
    /**
     * @private
     */
    getElementBoxInternal(inline, index) {
        let element = undefined;
        element = inline;
        return {
            'element': element, 'index': index
        };
    }
    /**
     * Get Line widget
     * @private
     */
    getLineWidget(inline, index) {
        return this.getLineWidgetInternalInline(inline, index, true);
    }
    /**
     * @private
     */
    getLineWidgetInternalInline(inline, index, moveToNextLine) {
        let elementObj = this.getElementBox(inline, index, moveToNextLine);
        let element = elementObj.element; //return index
        index = elementObj.index;
        if (!isNullOrUndefined(element)) {
            if (moveToNextLine && element instanceof TextElementBox && element.text === '\v' && index === 1) {
                return this.getNextLineWidget(element.line.paragraph, element);
            }
            else {
                return element.line;
            }
        }
        let startInline = inline;
        //ToDo: Check previous inline here.
        let nextValidInline = this.getNextValidElementForField(startInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            let lineWidget = undefined;
            let widget = startInline.line.paragraph;
            if (widget.childWidgets.length > 0) {
                lineWidget = widget.childWidgets[widget.childWidgets.length - 1];
            }
            return lineWidget;
        }
        else {
            return this.getLineWidget(nextValidInline, 0);
        }
    }
    /**
     * Get next line widget
     * @private
     */
    getNextLineWidget(paragraph, element) {
        let lineWidget = undefined;
        let widget = paragraph;
        if (widget.childWidgets.length > 0) {
            let widgetIndex = widget.childWidgets.indexOf(element.line);
            if (widgetIndex === widget.childWidgets.length - 1) {
                widget = paragraph;
                // widget = paragraph.leafWidgets[paragraph.leafWidgets.length - 1];
                widgetIndex = -1;
            }
            else if (widgetIndex > widget.childWidgets.length - 1) {
                widget = this.getNextParagraphBlock(paragraph);
                widgetIndex = -1;
            }
            else if (widgetIndex < 0) {
                // widget = paragraph.leafWidgets[paragraph.leafWidgets.length - 1];
                widget = paragraph;
                widgetIndex = widget.childWidgets.indexOf(element.line);
            }
            lineWidget = widget.childWidgets[widgetIndex + 1];
        }
        return lineWidget;
    }
    /**
     * Get Caret height
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getCaretHeight(inline, index, format, isEmptySelection, topMargin, isItalic) {
        let elementBoxInfo = this.getElementBox(inline, index, false);
        let element = elementBoxInfo.element;
        let currentInline = inline;
        if (isNullOrUndefined(element)) {
            if (currentInline instanceof FieldElementBox) {
                return this.getFieldCharacterHeight(currentInline, format, isEmptySelection, topMargin, isItalic);
            }
            return { 'height': this.viewer.textHelper.getHeight(format).Height, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        let margin = element.margin;
        let heightElement = element.height;
        let maxLineHeight = 0;
        if (element instanceof ImageElementBox) {
            let previousInline = this.getPreviousTextElement(inline);
            let nextInline = this.getNextTextElement(inline);
            if (isNullOrUndefined(previousInline) && isNullOrUndefined(nextInline)) {
                let top = 0;
                let bottom = 0;
                let paragarph = inline.line.paragraph;
                let sizeInfo = this.getParagraphMarkSize(paragarph, top, bottom);
                top = sizeInfo.topMargin;
                bottom = sizeInfo.bottomMargin;
                maxLineHeight = sizeInfo.height;
                isItalic = paragarph.characterFormat.italic;
                if (!isEmptySelection) {
                    maxLineHeight += this.viewer.layout.getAfterSpacing(paragarph);
                }
            }
            else if (isNullOrUndefined(previousInline)) {
                isItalic = nextInline.characterFormat.italic;
                return this.getCaretHeight(nextInline, 0, nextInline.characterFormat, isEmptySelection, topMargin, isItalic);
            }
            else {
                if (!isNullOrUndefined(nextInline) && element instanceof ImageElementBox) {
                    //Calculates the caret size using image character format.
                    let textSizeInfo = this.viewer.textHelper.getHeight(element.characterFormat);
                    let charHeight = textSizeInfo.Height;
                    let baselineOffset = textSizeInfo.BaselineOffset;
                    // tslint:disable-next-line:max-line-length
                    maxLineHeight = (element.margin.top < 0 && baselineOffset > element.margin.top + element.height) ? element.margin.top + element.height + charHeight - baselineOffset : charHeight;
                    if (!isEmptySelection) {
                        maxLineHeight += element.margin.bottom;
                    }
                }
                else {
                    isItalic = previousInline.characterFormat.italic;
                    // tslint:disable-next-line:max-line-length
                    return this.getCaretHeight(previousInline, previousInline.length, previousInline.characterFormat, isEmptySelection, topMargin, isItalic);
                }
            }
        }
        else {
            let baselineAlignment = format.baselineAlignment;
            let elementHeight = heightElement;
            if (baselineAlignment !== 'Normal' && isEmptySelection) {
                //Set the caret height as sub/super script text height and updates the top margin for sub script text.
                elementHeight = elementHeight / 1.5;
                if (baselineAlignment === 'Subscript') {
                    topMargin = heightElement - elementHeight;
                }
            }
            maxLineHeight = (margin.top < 0 ? margin.top : 0) + elementHeight;
            if (!isEmptySelection) {
                maxLineHeight += margin.bottom;
            }
        }
        if (!isEmptySelection) {
            return { 'height': maxLineHeight, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        let height = this.viewer.textHelper.getHeight(format).Height;
        if (height > maxLineHeight) {
            height = maxLineHeight;
        }
        return { 'height': height, 'topMargin': topMargin, 'isItalic': isItalic };
    }
    /**
     * Get field characters height
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getFieldCharacterHeight(startInline, format, isEmptySelection, topMargin, isItalic) {
        let nextValidInline = this.getNextValidElementForField(startInline);
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            let nextParagraph = startInline.line.paragraph;
            let height = this.viewer.textHelper.getParagraphMarkSize(format).Height;
            let top = 0;
            let bottom = 0;
            let sizeInfo = this.getParagraphMarkSize(nextParagraph, top, bottom);
            let maxLineHeight = sizeInfo.height;
            top = sizeInfo.topMargin;
            bottom = sizeInfo.bottomMargin;
            if (!isEmptySelection) {
                maxLineHeight += bottom;
                return { 'height': maxLineHeight, 'topMargin': topMargin, 'isItalic': isItalic };
            }
            if (height > maxLineHeight) {
                height = maxLineHeight;
            }
            return { 'height': height, 'topMargin': topMargin, 'isItalic': isItalic };
        }
        else {
            return this.getCaretHeight(nextValidInline, 0, format, isEmptySelection, topMargin, isItalic);
        }
    }
    /**
     * Get rendered inline
     * @private
     */
    //FieldCharacter
    getRenderedInline(inline, inlineIndex) {
        let prevInline = this.getPreviousValidElement(inline);
        while (prevInline instanceof FieldElementBox) {
            prevInline = this.getPreviousTextElement(prevInline);
            if (prevInline instanceof FieldElementBox) {
                prevInline = prevInline.previousNode;
            }
        }
        if (!isNullOrUndefined(prevInline)) {
            inlineIndex = prevInline.length;
            return { 'element': prevInline, 'index': inlineIndex };
        }
        inlineIndex = 0;
        let nextInline = this.getNextRenderedElementBox(inline, 0);
        if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0) {
            nextInline = nextInline.fieldSeparator;
            nextInline = nextInline.nextNode;
            while (nextInline instanceof FieldElementBox) {
                if (nextInline instanceof FieldElementBox && nextInline.fieldType === 0
                    && HelperMethods.isLinkedFieldCharacter(nextInline)) {
                    if (isNullOrUndefined(nextInline.fieldSeparator)) {
                        nextInline = nextInline.fieldEnd;
                    }
                    else {
                        nextInline = nextInline.fieldSeparator;
                    }
                }
                nextInline = nextInline.nextNode;
            }
        }
        return { 'element': nextInline, 'index': inlineIndex };
    }
    //Field Begin
    /**
     * Get rendered field
     * @private
     */
    getRenderedField(fieldBegin) {
        let inline = fieldBegin;
        if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
            inline = fieldBegin.fieldEnd;
        }
        else {
            inline = fieldBegin.fieldSeparator;
            let paragraph = inline.line.paragraph;
            if (paragraph === fieldBegin.fieldEnd.line.paragraph
                && !this.hasValidInline(paragraph, inline, fieldBegin.fieldEnd)) {
                inline = fieldBegin.fieldEnd;
            }
            else {
                return inline;
            }
        }
        return inline;
    }
    /**
     * Return true is inline is tha last inline
     * @private
     */
    isLastRenderedInline(inline, index) {
        while (index === inline.length && inline.nextNode instanceof FieldElementBox) {
            let nextValidInline = this.getNextValidElement(inline.nextNode);
            index = 0;
            if (nextValidInline instanceof FieldElementBox && nextValidInline.fieldType === 0) {
                inline = nextValidInline;
            }
            if (inline instanceof FieldElementBox && inline.fieldType === 0 && !isNullOrUndefined(inline.fieldEnd)) {
                let fieldBegin = inline;
                if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    inline = fieldBegin.fieldEnd;
                    index = 1;
                }
                else {
                    inline = fieldBegin.fieldSeparator;
                    let paragraph = inline.line.paragraph;
                    index = 1;
                    if (paragraph === fieldBegin.fieldEnd.line.paragraph
                        && !this.hasValidInline(paragraph, inline, fieldBegin.fieldEnd)) {
                        inline = fieldBegin.fieldEnd;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        return index === inline.length && isNullOrUndefined(inline.nextNode);
    }
    /**
     * Get page
     * @private
     */
    getPage(widget) {
        let page = undefined;
        if (widget.containerWidget instanceof BlockContainer) {
            let bodyWidget = widget.containerWidget;
            page = widget.containerWidget.page;
        }
        else if (!isNullOrUndefined(widget.containerWidget)) {
            page = this.getPage(widget.containerWidget);
        }
        return page;
    }
    /**
     * Clear Selection highlight
     * @private
     */
    clearSelectionHighlightInSelectedWidgets() {
        let isNonEmptySelection = false;
        let widgets = this.selectedWidgets.keys;
        for (let i = 0; i < widgets.length; i++) {
            this.removeSelectionHighlight(widgets[i]);
            isNonEmptySelection = true;
        }
        this.selectedWidgets.clear();
        return isNonEmptySelection;
    }
    /**
     * Clear selection highlight
     * @private
     */
    clearChildSelectionHighlight(widget) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            if (widget.childWidgets[i] instanceof LineWidget) {
                this.clearSelectionHighlightLineWidget(widget.childWidgets[i]);
            }
            else if (widget.childWidgets[i] instanceof TableCellWidget) {
                this.clearSelectionHighlight(widget.childWidgets[i]);
            }
            else if (widget.childWidgets[i] instanceof Widget) {
                this.clearChildSelectionHighlight(widget.childWidgets[i]);
            }
        }
    }
    /**
     * Get line widget from paragraph widget
     * @private
     */
    //Body Widget
    getLineWidgetBodyWidget(widget, point) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let childWidget = widget.childWidgets[i];
            if (childWidget instanceof Widget && childWidget.y <= point.y
                && (childWidget.y + childWidget.height) >= point.y) {
                if (childWidget instanceof ParagraphWidget) {
                    return this.getLineWidgetParaWidget(childWidget, point);
                }
                else {
                    return this.getLineWidgetTableWidget(childWidget, point);
                }
            }
        }
        let line = undefined;
        if (widget.childWidgets.length > 0) {
            let firstChild = widget.childWidgets[0];
            if (firstChild instanceof Widget && firstChild.y <= point.y) {
                if (widget.childWidgets[widget.childWidgets.length - 1] instanceof ParagraphWidget) {
                    // tslint:disable-next-line:max-line-length
                    line = this.getLineWidgetParaWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    line = this.getLineWidgetTableWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
            }
            else {
                let childWidget = undefined;
                if (firstChild instanceof Widget) {
                    childWidget = firstChild;
                }
                if (!isNullOrUndefined(childWidget)) {
                    if (childWidget instanceof ParagraphWidget) {
                        line = this.getLineWidgetParaWidget(firstChild, point);
                    }
                    else {
                        line = this.getLineWidgetTableWidget(firstChild, point);
                    }
                }
            }
        }
        return line;
    }
    //ParagraphWidget
    /**
     * Get line widget from paragraph widget
     * @private
     */
    getLineWidgetParaWidget(widget, point) {
        let childWidgets = widget.childWidgets;
        let top = widget.y;
        for (let i = 0; i < childWidgets.length; i++) {
            if (top <= point.y
                && (top + childWidgets[i].height) >= point.y) {
                return childWidgets[i];
            }
            top += childWidgets[i].height;
        }
        let lineWidget = undefined;
        if (childWidgets.length > 0) {
            if (widget.y <= point.y) {
                lineWidget = childWidgets[childWidgets.length - 1];
            }
            else {
                lineWidget = childWidgets[0];
            }
        }
        return lineWidget;
    }
    /**
     * highlight paragraph widget
     * @private
     */
    // tslint:disable-next-line:max-line-length
    highlightParagraph(widget, startIndex, endLine, endElement, endIndex) {
        let top = 0;
        let width = 0;
        let isRtlText = false;
        if (widget.paragraphFormat.bidi && endLine.children.indexOf(endElement) > 0) {
            endElement = endLine.children[0];
        }
        for (let i = startIndex; i < widget.childWidgets.length; i++) {
            let line = widget.childWidgets[i];
            if (i === startIndex) {
                top = this.getTop(line);
            }
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            let left = this.getLeft(line);
            if (line === endLine) {
                //Selection ends in current line.
                let right = 0;
                // highlighting approach for normal and rtl text.
                if (isRtlText || widget.bidi) {
                    let elementBoxCollection = this.getElementsBackward(line, endElement, endElement, widget.bidi);
                    for (let i = 0; i < elementBoxCollection.length; i++) {
                        let element = elementBoxCollection[i];
                        let elementIsRTL = false;
                        if (element === endElement) {
                            right = this.getLeftInternal(line, element, endIndex);
                        }
                        else {
                            let index = element instanceof TextElementBox ? element.length : 1;
                            right = this.getLeftInternal(line, element, index);
                        }
                        left = this.getLeftInternal(line, element, 0);
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        // Handled the paragraph mark highliting as special case.
                        if (element === endElement && element instanceof TextElementBox && endIndex > element.length) {
                            // tslint:disable-next-line:max-line-length
                            let paragraphMarkWidth = this.viewer.textHelper.getParagraphMarkSize(element.line.paragraph.characterFormat).Width;
                            if (!widget.bidi && elementIsRTL) {
                                right += paragraphMarkWidth;
                            }
                            else if (widget.bidi && !elementIsRTL) { // Paragrph and Selection ends in normal text
                                width -= paragraphMarkWidth;
                                // Highlight the element.
                                this.createHighlightBorder(line, width, left, top, true);
                                // Highlight the paragraph mark of Bidi paragrph. 
                                left = this.getLineStartLeft(line) - paragraphMarkWidth;
                                this.createHighlightBorder(line, paragraphMarkWidth, left, top, true);
                                // continue to next element.
                                continue;
                            }
                        }
                        this.createHighlightBorder(line, width, elementIsRTL ? right : left, top, true);
                    }
                    return;
                }
                else {
                    right = this.getLeftInternal(endLine, endElement, endIndex);
                    width = Math.abs(right - left);
                    this.createHighlightBorder(line, width, isRtlText ? right : left, top, false);
                    return;
                }
            }
            else {
                width = this.getWidth(line, true) - (left - widget.x);
                // Highlight the paragrph mark for Bidi paragrph.
                if (widget.bidi && line.isLastLine()) {
                    left -= this.viewer.textHelper.getParagraphMarkSize(widget.characterFormat).Width;
                }
                this.createHighlightBorder(line, width, left, top, false);
                top += line.height;
            }
        }
    }
    //Table Widget
    /**
     * Get line widget form table widget
     * @private
     */
    getLineWidgetTableWidget(widget, point) {
        let lineWidget = undefined;
        for (let i = 0; i < widget.childWidgets.length; i++) {
            //Removed the height condition check to handle the vertically merged cells.
            let childWidget = widget.childWidgets[i];
            if (childWidget instanceof TableRowWidget && childWidget.y <= point.y) {
                lineWidget = this.getLineWidgetRowWidget(childWidget, point);
                let cellWidget = undefined;
                if (!isNullOrUndefined(lineWidget) && lineWidget.paragraph.containerWidget instanceof TableCellWidget) {
                    cellWidget = lineWidget.paragraph.containerWidget;
                }
                let cellSpacing = 0;
                let rowSpan = 0;
                if (!isNullOrUndefined(cellWidget)) {
                    let tableWidget = cellWidget.ownerRow.containerWidget;
                    cellSpacing = HelperMethods.convertPointToPixel(tableWidget.tableFormat.cellSpacing);
                    rowSpan = cellWidget.cellFormat.rowSpan;
                }
                let leftCellSpacing = 0;
                let rightCellSpacing = 0;
                let topCellSpacing = 0;
                let bottomCellSpacing = 0;
                if (cellSpacing > 0) {
                    leftCellSpacing = cellWidget.cellIndex === 0 ? cellSpacing : cellSpacing / 2;
                    // tslint:disable-next-line:max-line-length
                    rightCellSpacing = cellWidget.cellIndex === cellWidget.ownerRow.childWidgets.length - 1 ? cellSpacing : cellSpacing / 2;
                    let rowWidget = undefined;
                    if (cellWidget.containerWidget instanceof TableRowWidget) {
                        rowWidget = cellWidget.containerWidget;
                    }
                    let tableWidget = undefined;
                    if (cellWidget.containerWidget.containerWidget instanceof TableWidget) {
                        tableWidget = cellWidget.containerWidget.containerWidget;
                    }
                    if (!isNullOrUndefined(rowWidget) && !isNullOrUndefined(tableWidget)) {
                        topCellSpacing = cellWidget.ownerRow.rowIndex === 0 ? cellSpacing : cellSpacing / 2;
                        if (cellWidget.ownerRow.rowIndex + rowSpan === cellWidget.ownerTable.childWidgets.length) {
                            bottomCellSpacing = cellSpacing;
                        }
                        else {
                            bottomCellSpacing = cellSpacing / 2;
                        }
                    }
                }
                if ((!isNullOrUndefined(lineWidget) && lineWidget.paragraph.x <= point.x
                    && lineWidget.paragraph.x + lineWidget.width >= point.x
                    && lineWidget.paragraph.y <= point.y && this.getTop(lineWidget) + lineWidget.height >= point.y)
                    || (!isNullOrUndefined(cellWidget) && cellWidget.x - cellWidget.margin.left - leftCellSpacing <= point.x
                        && cellWidget.x + cellWidget.width + cellWidget.margin.right + rightCellSpacing >= point.x
                        && cellWidget.y - cellWidget.margin.top - topCellSpacing <= point.y
                        && cellWidget.y + cellWidget.height + cellWidget.margin.bottom + bottomCellSpacing >= point.y)) {
                    break;
                }
            }
        }
        return lineWidget;
    }
    //TableRowWidget
    /**
     * Get line widget fom row
     * @private
     */
    getLineWidgetRowWidget(widget, point) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            let cellSpacing = 0;
            cellSpacing = HelperMethods.convertPointToPixel(widget.ownerTable.tableFormat.cellSpacing);
            let leftCellSpacing = 0;
            let rightCellSpacing = 0;
            if (cellSpacing > 0) {
                leftCellSpacing = widget.childWidgets[i].columnIndex === 0 ? cellSpacing : cellSpacing / 2;
                // tslint:disable-next-line:max-line-length
                rightCellSpacing = widget.childWidgets[i].cellIndex === widget.childWidgets[i].ownerRow.childWidgets.length - 1 ? cellSpacing : cellSpacing / 2;
            }
            if (widget.childWidgets[i].x -
                // tslint:disable-next-line:max-line-length
                widget.childWidgets[i].margin.left - leftCellSpacing <= point.x && (widget.childWidgets[i].x +
                // tslint:disable-next-line:max-line-length
                widget.childWidgets[i].width) + widget.childWidgets[i].margin.right + rightCellSpacing >= point.x) {
                return this.getLineWidgetCellWidget(widget.childWidgets[i], point);
            }
        }
        let lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            if (widget.childWidgets[0].x <= point.x) {
                lineWidget = this.getLineWidgetCellWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
            }
            else {
                lineWidget = this.getLineWidgetCellWidget(widget.childWidgets[0], point);
            }
        }
        return lineWidget;
    }
    /**
     * @private
     */
    getFirstBlock(cell) {
        if (cell.childWidgets.length > 0) {
            return cell.childWidgets[0];
        }
        return undefined;
    }
    //Table Cell Widget
    /**
     * Highlight selected cell widget
     * @private
     */
    highlightCellWidget(widget) {
        let widgets = [];
        if (widget.previousSplitWidget || widget.nextSplitWidget) {
            widgets = widget.getSplitWidgets();
        }
        else {
            widgets.push(widget);
        }
        for (let i = 0; i < widgets.length; i++) {
            widget = widgets[i];
            //Clears Selection highlight of the child widgets.
            this.clearChildSelectionHighlight(widget);
            //Highlights the entire cell.
            this.createHighlightBorderInsideTable(widget);
        }
    }
    /**
     * Clear selection highlight
     * @private
     */
    clearSelectionHighlight(widget) {
        if (this.selectedWidgets.containsKey(widget)) {
            this.removeSelectionHighlight(widget);
            this.selectedWidgets.remove(widget);
        }
    }
    /**
     * Get line widget from cell widget
     * @private
     */
    getLineWidgetCellWidget(widget, point) {
        for (let i = 0; i < widget.childWidgets.length; i++) {
            if (widget.childWidgets[i].y <= point.y
                && (widget.childWidgets[i].y + widget.childWidgets[i].height) >= point.y) {
                if (widget.childWidgets[i] instanceof ParagraphWidget) {
                    return this.getLineWidgetParaWidget(widget.childWidgets[i], point);
                }
                else {
                    return this.getLineWidgetTableWidget(widget.childWidgets[i], point);
                }
            }
        }
        let lineWidget = undefined;
        if (widget.childWidgets.length > 0) {
            if (widget.childWidgets[0].y <= point.y) {
                if (widget.childWidgets[widget.childWidgets.length - 1] instanceof ParagraphWidget) {
                    // tslint:disable-next-line:max-line-length
                    lineWidget = this.getLineWidgetParaWidget(widget.childWidgets[widget.childWidgets.length - 1], point);
                }
                else {
                    lineWidget = this.getLineWidgetTableWidget(widget.childWidgets[0], point);
                }
            }
        }
        return lineWidget;
    }
    //LineWidget
    /**
     * update text position
     * @private
     */
    updateTextPosition(widget, point) {
        let caretPosition = point;
        let element = undefined;
        let index = 0;
        let isImageSelected = false;
        let isImageSelectedObj = this.updateTextPositionIn(widget, element, index, point, false);
        if (!isNullOrUndefined(isImageSelectedObj)) {
            element = isImageSelectedObj.element;
            index = isImageSelectedObj.index;
            caretPosition = isImageSelectedObj.caretPosition;
            isImageSelected = isImageSelectedObj.isImageSelected;
            this.isImageSelected = isImageSelected;
        }
        if (isImageSelected) {
            this.selectInternal(widget, element, index, caretPosition);
            if (index === 0) {
                this.extendForward();
            }
            else {
                this.extendBackward();
            }
        }
        else {
            this.selectInternal(widget, element, index, caretPosition);
        }
    }
    /**
     * @private
     */
    /* tslint:disable */
    updateTextPositionIn(widget, inline, index, caretPosition, includeParagraphMark) {
        let isImageSelected = false;
        let top = this.getTop(widget);
        let left = widget.paragraph.x;
        let elementValues = this.getFirstElement(widget, left);
        let element = elementValues.element;
        let isRtlText = false;
        let isParaBidi = false;
        left = elementValues.left;
        if (isNullOrUndefined(element)) {
            let topMargin = 0;
            let bottomMargin = 0;
            let size = this.getParagraphMarkSize(widget.paragraph, topMargin, bottomMargin);
            topMargin = size.topMargin;
            bottomMargin = size.bottomMargin;
            let selectParaMark = this.viewer.mouseDownOffset.y >= top && this.viewer.mouseDownOffset.y < top + widget.height ? (this.viewer.mouseDownOffset.x < left + size.width) : true;
            if (selectParaMark && includeParagraphMark && caretPosition.x > left + size.width / 2) {
                left += size.width;
                if (widget.children.length > 0) {
                    inline = widget.children[widget.children.length - 1];
                    index = inline.length;
                }
                index++;
            }
            caretPosition = new Point(left, topMargin > 0 ? top + topMargin : top);
        }
        else {
            if (!isNullOrUndefined(element)) {
                if (caretPosition.x > left + element.margin.left) {
                    for (let i = widget.children.indexOf(element); i < widget.children.length; i++) {
                        element = widget.children[i];
                        let isCurrentParaBidi = false;
                        if (element instanceof ListTextElementBox || element instanceof TextElementBox) {
                            isCurrentParaBidi = element.line.paragraph.paragraphFormat.bidi;
                        }
                        if (caretPosition.x < left + element.margin.left + element.width || i === widget.children.length - 1
                            || ((widget.children[i + 1] instanceof ListTextElementBox) && isCurrentParaBidi)) {
                            break;
                        }
                        left += element.margin.left + element.width;
                    }
                    if (element instanceof TextElementBox) {
                        isRtlText = element.isRightToLeft;
                        isParaBidi = element.line.paragraph.paragraphFormat.bidi;
                    }
                    if (caretPosition.x > left + element.margin.left + element.width) {
                        //Line End
                        index = element instanceof TextElementBox ? element.length : 1;
                        if (isRtlText && isParaBidi) {
                            index = 0;
                        }
                        if ((element instanceof TextElementBox && element.text !== "\v") || includeParagraphMark) {
                            left += element.margin.left + element.width;
                        }
                    }
                    else if (element instanceof TextElementBox) {
                        if (element instanceof TextElementBox && isRtlText) {
                            left += element.width;
                        }
                        let x = 0;
                        if (isRtlText) {
                            x = (left + element.margin.left) - caretPosition.x;
                        }
                        else {
                            x = caretPosition.x - left - element.margin.left;
                        }
                        left += element.margin.left;
                        let prevWidth = 0;
                        let charIndex = 0;
                        for (let i = 1; i <= element.length; i++) {
                            let width = 0;
                            if (i === element.length) {
                                width = element.width;
                            }
                            else {
                                width = this.viewer.textHelper.getWidth(element.text.substr(0, i), element.characterFormat);
                            }
                            if (x < width || i === element.length) {
                                //Updates exact left position of the caret.
                                let charWidth = width - prevWidth;
                                if (x - prevWidth > charWidth / 2) {
                                    if (isRtlText) {
                                        left -= width;
                                    }
                                    else {
                                        left += width;
                                    }
                                    charIndex = i;
                                }
                                else {
                                    if (isRtlText) {
                                        left -= prevWidth;
                                    }
                                    else {
                                        left += prevWidth;
                                    }
                                    charIndex = i - 1;
                                    if (i === 1 && element !== widget.children[0]) {
                                        let curIndex = widget.children.indexOf(element);
                                        if (!(widget.children[curIndex - 1] instanceof ListTextElementBox) && !isRtlText) {
                                            element = widget.children[curIndex - 1];
                                            charIndex = element instanceof TextElementBox ? element.length : 1;
                                        }
                                    }
                                }
                                break;
                            }
                            prevWidth = width;
                        }
                        index = charIndex;
                    }
                    else {
                        isImageSelected = element instanceof ImageElementBox;
                        if (caretPosition.x - left - element.margin.left > element.width / 2) {
                            index = 1;
                            left += element.margin.left + element.width;
                        }
                        else if (element !== widget.children[0] && !isImageSelected) {
                            let curIndex = widget.children.indexOf(element);
                            if (!(widget.children[curIndex - 1] instanceof ListTextElementBox)) {
                                element = widget.children[curIndex - 1];
                                index = element instanceof TextElementBox ? element.length : 1;
                            }
                        }
                    }
                    if (element instanceof TextElementBox && element.text === '\v') {
                        index = 0;
                    }
                }
                else {
                    isRtlText = element.isRightToLeft;
                    isParaBidi = element.line.paragraph.paragraphFormat.bidi;
                    if (element instanceof TextElementBox && (isParaBidi || isRtlText) && caretPosition.x < left + element.margin.left + element.width) {
                        index = this.getTextLength(element.line, element) + element.length;
                    }
                    else {
                        index = this.getTextLength(element.line, element);
                    }
                    left += element.margin.left;
                }
                if (element instanceof TextElementBox) {
                    top += element.margin.top > 0 ? element.margin.top : 0;
                }
                else {
                    let textMetrics = this.viewer.textHelper.getHeight(element.characterFormat); //for ascent and descent
                    let height = element.height;
                    if (element instanceof BookmarkElementBox && !this.viewer.layout.hasValidElement(element.line.paragraph)) {
                        height = textMetrics.Height; //after text helper class
                    }
                    top += element.margin.top + height - textMetrics.BaselineOffset;
                }
                inline = element;
                let inlineObj = this.validateTextPosition(inline, index);
                inline = inlineObj.element;
                index = inlineObj.index;
                let isParagraphEnd = isNullOrUndefined(inline.nextNode) && index === inline.length;
                let isLineEnd = isNullOrUndefined(inline.nextNode)
                    && inline instanceof TextElementBox && inline.text === '\v';
                if (includeParagraphMark && inline.nextNode instanceof FieldElementBox && index === inline.length) {
                    isParagraphEnd = this.isLastRenderedInline(inline, index);
                }
                if (includeParagraphMark && isParagraphEnd || isLineEnd) {
                    let width = 0;
                    //Include width of Paragraph mark.
                    if (isParagraphEnd) {
                        width = this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
                        let selectParaMark = this.viewer.mouseDownOffset.y >= top && this.viewer.mouseDownOffset.y < top + widget.height ? (this.viewer.mouseDownOffset.x < left + width) : true;
                        if (selectParaMark && caretPosition.x > left + width / 2) {
                            left += width;
                            index = inline.length + 1;
                        }
                        //Include width of line break mark.
                    }
                    else if (isLineEnd) {
                        width = element.width;
                        left += width;
                        index = inline.length;
                    }
                }
                caretPosition = new Point(left, top);
            }
        }
        return {
            'element': inline,
            'index': index,
            'caretPosition': caretPosition,
            'isImageSelected': isImageSelected
        };
    }
    /* tslint:enable */
    /**
     * Get text length if the line widget
     * @private
     */
    getTextLength(widget, element) {
        let length = 0;
        let count = widget.children.indexOf(element);
        if (widget.children.length > 0 && widget.children[0] instanceof ListTextElementBox) {
            if (widget.children[1] instanceof ListTextElementBox) {
                count -= 2;
            }
            else {
                count -= 1;
            }
        }
        for (let i = 1; i < count; i++) {
            length += widget.children[i].length;
        }
        return length;
    }
    /**
     * Get Line widget left
     * @private
     */
    getLeft(widget) {
        let left = widget.paragraph.x;
        let paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paragraphFormat.bidi && !(paragraphFormat.textAlignment === 'Right')) {
            left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
        }
        for (let i = 0; i < widget.children.length; i++) {
            let element = widget.children[i];
            if (element instanceof ListTextElementBox && !paragraphFormat.bidi) { //after list implementation
                if (i === 0) {
                    left += element.margin.left + element.width;
                }
                else {
                    left += element.width;
                }
            }
            else {
                left += element.margin.left;
                break;
            }
        }
        return left;
    }
    /**
     * Get line widget top
     * @private
     */
    getTop(widget) {
        let top = widget.paragraph.y;
        let count = widget.paragraph.childWidgets.indexOf(widget);
        for (let i = 0; i < count; i++) {
            top += widget.paragraph.childWidgets[i].height;
        }
        return top;
    }
    /**
     * Get first element the widget
     * @private
     */
    getFirstElement(widget, left) {
        let firstLineIndent = 0;
        if (this.isParagraphFirstLine(widget) && !widget.paragraph.paragraphFormat.bidi) {
            firstLineIndent = HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        left += firstLineIndent;
        let element = undefined;
        for (let i = 0; i < widget.children.length; i++) {
            element = widget.children[i];
            if (element instanceof ListTextElementBox || element instanceof CommentCharacterElementBox) {
                if (widget.paragraph.paragraphFormat.bidi) {
                    left += element.margin.left;
                    element = undefined;
                    break;
                }
                left += element.margin.left + element.width;
                element = undefined;
                // }
                //  else if (element instanceof FieldElementBox || element instanceof BookmarkElementBox
                //     || (element.nextNode instanceof FieldElementBox && ((element.nextNode as FieldElementBox).fieldType === 2))) {
                //     element = undefined;
            }
            else {
                break;
            }
        }
        return { 'element': element, 'left': left };
    }
    /**
     * Return inline index
     * @private
     */
    //ElementBox
    getIndexInInline(elementBox) {
        let indexInInline = 0;
        if (elementBox instanceof TextElementBox) {
            let count = elementBox.line.children.indexOf(elementBox);
            for (let i = 0; i < count; i++) {
                let element = elementBox.line.children[i];
                if (element instanceof FieldElementBox || element instanceof ListTextElementBox) {
                    continue;
                }
                indexInInline += element.length;
            }
        }
        return indexInInline;
    }
    /**
     * Return true if widget is first inline of paragraph
     * @private
     */
    isParagraphFirstLine(widget) {
        if (isNullOrUndefined(widget.paragraph.previousSplitWidget) &&
            widget === widget.paragraph.firstChild) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isParagraphLastLine(widget) {
        if (isNullOrUndefined(widget.paragraph.nextSplitWidget)
            && widget === widget.paragraph.lastChild) {
            return true;
        }
        return false;
    }
    /**
     * Return line widget width
     * @private
     */
    getWidth(widget, includeParagraphMark) {
        let width = 0;
        let paraFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paraFormat.bidi) {
            width += HelperMethods.convertPointToPixel(paraFormat.firstLineIndent);
        }
        for (let i = 0; i < widget.children.length; i++) {
            width += widget.children[i].margin.left + widget.children[i].width;
        }
        if (includeParagraphMark && widget.paragraph.childWidgets.indexOf(widget) === widget.paragraph.childWidgets.length - 1
            && isNullOrUndefined(widget.paragraph.nextSplitWidget)) {
            width += this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
        }
        return width;
    }
    /**
     * Return line widget left
     * @private
     */
    getLeftInternal(widget, elementBox, index) {
        let left = widget.paragraph.x;
        let paraFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paraFormat.bidi) {
            // tslint:disable-next-line:max-line-length
            left += HelperMethods.convertPointToPixel(widget.paragraph.paragraphFormat.firstLineIndent);
        }
        let isRtlText = false;
        let isParaBidi = false;
        if (elementBox instanceof TextElementBox) {
            isRtlText = elementBox.isRightToLeft;
            isParaBidi = elementBox.line.paragraph.paragraphFormat.bidi;
        }
        //when line contains normal text and para is RTL para.
        //if home key is pressed, update caret position after the last element in a line.
        //if end key pressed, update caret position before the first element in a line. 
        if (isParaBidi) {
            if (!isRtlText) {
                if (this.viewer.moveCaretPosition === 1 && widget.children.length > 0) {
                    elementBox = widget.children[widget.children.length - 1];
                }
                else if (this.viewer.moveCaretPosition === 2) {
                    elementBox = widget.children[0];
                }
                if (elementBox instanceof ListTextElementBox && widget.children.length > 2) {
                    elementBox = widget.children[widget.children.length - 3];
                }
            }
        }
        let count = widget.children.indexOf(elementBox);
        if ((widget.children.length === 1 && widget.children[0] instanceof ListTextElementBox) || (widget.children.length === 2
            && widget.children[0] instanceof ListTextElementBox && widget.children[1] instanceof ListTextElementBox)) {
            count = widget.children.length;
        }
        for (let i = 0; i < count; i++) {
            let widgetInternal = widget.children[i];
            // if (widgetInternal instanceof FieldElementBox) {
            //     continue;
            // }
            if (i === 1 && widget.children[i] instanceof ListTextElementBox) {
                left += widget.children[i].width;
            }
            else if (widget.children[i] instanceof TabElementBox && elementBox === widgetInternal) {
                left += widget.children[i].margin.left;
            }
            else {
                left += widget.children[i].margin.left + widget.children[i].width;
            }
        }
        if (!isNullOrUndefined(elementBox)) {
            left += elementBox.margin.left;
            if (isRtlText || (this.viewer.moveCaretPosition === 1 && !isRtlText && isParaBidi)) {
                left += elementBox.width;
            }
        }
        let width = 0;
        if (elementBox instanceof TextElementBox) {
            if ((this.viewer.moveCaretPosition !== 0) && (isParaBidi || isRtlText)) {
                if ((isRtlText && isParaBidi && this.viewer.moveCaretPosition === 2)
                    || (isRtlText && !isParaBidi && this.viewer.moveCaretPosition === 1)) {
                    left -= elementBox.width;
                }
                this.viewer.moveCaretPosition = 0;
                return left;
            }
            if (index === elementBox.length && !isRtlText) {
                left += elementBox.width;
            }
            else if (index > elementBox.length) {
                width = this.viewer.textHelper.getParagraphMarkWidth(elementBox.line.paragraph.characterFormat);
                if (isRtlText) {
                    left -= elementBox.width + width;
                }
                else {
                    left += elementBox.width + width;
                }
            }
            else {
                // tslint:disable-next-line:max-line-length
                width = this.viewer.textHelper.getWidth(elementBox.text.substr(0, index), elementBox.characterFormat);
                if (isRtlText) {
                    left -= width;
                }
                else {
                    left += width;
                }
            }
            this.viewer.moveCaretPosition = 0;
        }
        else if (index > 0) {
            if (!isNullOrUndefined(elementBox) && !(elementBox instanceof ListTextElementBox)) {
                left += elementBox.width;
                if (index === 2) {
                    let paragraph = elementBox.line.paragraph;
                    left += this.viewer.textHelper.getParagraphMarkWidth(paragraph.characterFormat);
                }
            }
            else {
                left += this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
            }
        }
        return left;
    }
    /**
     * Return line widget start offset
     * @private
     */
    getLineStartLeft(widget) {
        let left = widget.paragraph.x;
        let paragraphFormat = widget.paragraph.paragraphFormat;
        if (this.isParagraphFirstLine(widget) && !paragraphFormat.bidi) {
            left += HelperMethods.convertPointToPixel(paragraphFormat.firstLineIndent);
        }
        if (widget.children.length > 0) {
            left += widget.children[0].margin.left;
        }
        return left;
    }
    /**
     * Update text position
     * @private
     */
    updateTextPositionWidget(widget, point, textPosition, includeParagraphMark) {
        let caretPosition = point;
        let inline = undefined;
        let index = 0;
        let updatePositionObj;
        updatePositionObj = this.updateTextPositionIn(widget, inline, index, caretPosition, includeParagraphMark);
        inline = updatePositionObj.element;
        index = updatePositionObj.index;
        caretPosition = updatePositionObj.caretPosition;
        textPosition.setPositionForSelection(widget, inline, index, caretPosition);
    }
    /**
     * Clear selection highlight
     * @private
     */
    clearSelectionHighlightLineWidget(widget) {
        if (!isNullOrUndefined(this.owner) && this.selectedWidgets.length > 0) {
            this.clearSelectionHighlight(this);
        }
    }
    /**
     * Return first element from line widget
     * @private
     */
    getFirstElementInternal(widget) {
        let element = undefined;
        let isBidi = widget.paragraph.paragraphFormat.bidi;
        let childLen = widget.children.length;
        for (let i = isBidi ? childLen - 1 : 0; isBidi ? i >= 0 : i < childLen; isBidi ? i-- : i++) {
            element = widget.children[i];
            if (element instanceof ListTextElementBox) {
                element = undefined;
            }
            else {
                break;
            }
        }
        return element;
    }
    //Selection API    
    /**
     * Select content between given range
     * @private
     */
    selectRange(startPosition, endPosition) {
        this.start.setPositionInternal(startPosition);
        this.end.setPositionInternal(endPosition);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Selects current paragraph
     * @private
     */
    selectParagraphInternal(paragraph, positionAtStart) {
        let line;
        if (!isNullOrUndefined(paragraph) && !isNullOrUndefined(paragraph.firstChild)) {
            line = paragraph.firstChild;
            if (positionAtStart) {
                this.start.setPosition(line, positionAtStart);
            }
            else {
                let endOffset = line.getEndOffset();
                this.start.setPositionParagraph(line, endOffset);
            }
        }
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = this.start.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    setPositionForBlock(block, selectFirstBlock) {
        let position;
        if (block instanceof TableWidget) {
            if (selectFirstBlock) {
                block = this.getFirstParagraphInFirstCell(block);
            }
            else {
                block = this.getLastParagraphInLastCell(block);
            }
        }
        if (block instanceof ParagraphWidget) {
            position = new TextPosition(this.owner);
            if (selectFirstBlock) {
                position.setPosition(block.firstChild, true);
            }
            else {
                let line = block.lastChild;
                position.setPositionParagraph(line, line.getEndOffset());
            }
        }
        return position;
    }
    /**
     * Select content in given text position
     * @private
     */
    selectContent(textPosition, clearMultiSelection) {
        if (isNullOrUndefined(textPosition)) {
            throw new Error('textPosition is undefined.');
        }
        this.start.setPositionInternal(textPosition);
        this.end.setPositionInternal(textPosition);
        this.upDownSelectionLength = this.end.location.x;
        this.fireSelectionChanged(true);
    }
    /**
     * Select paragraph
     * @private
     */
    selectInternal(lineWidget, element, index, physicalLocation) {
        this.start.setPositionForSelection(lineWidget, element, index, physicalLocation);
        this.end.setPositionInternal(this.start);
        this.upDownSelectionLength = physicalLocation.x;
        this.fireSelectionChanged(true);
    }
    /**
     * @private
     */
    selects(lineWidget, offset, skipSelectionChange) {
        this.viewer.clearSelectionHighlight();
        this.start.setPositionForLineWidget(lineWidget, offset);
        this.end.setPositionInternal(this.start);
        if (!skipSelectionChange) {
            this.fireSelectionChanged(true);
        }
    }
    /**
     * Select content between start and end position
     * @private
     */
    selectPosition(startPosition, endPosition) {
        if (isNullOrUndefined(startPosition) || isNullOrUndefined(endPosition)) {
            throw new Error('TextPosition cannot be undefined');
        }
        if (isNullOrUndefined(startPosition.paragraph)
            || startPosition.offset > this.getParagraphLength(startPosition.paragraph) + 1) {
            throw new Error('Start TextPosition is not valid.');
        }
        if (isNullOrUndefined(endPosition.paragraph)
            || endPosition.offset > this.getParagraphLength(endPosition.paragraph) + 1) {
            throw new Error('End TextPosition is not valid.');
        }
        if (startPosition.isAtSamePosition(endPosition)) {
            // Select start position.
            this.selectRange(startPosition, startPosition);
        }
        else {
            // If both text position exists within same comment or outside comment, and not at same position.
            if (startPosition.isExistBefore(endPosition)) {
                // tslint:disable-next-line:max-line-length
                endPosition.validateForwardFieldSelection(startPosition.getHierarchicalIndexInternal(), endPosition.getHierarchicalIndexInternal());
            }
            else {
                // tslint:disable-next-line:max-line-length
                startPosition.validateForwardFieldSelection(endPosition.getHierarchicalIndexInternal(), startPosition.getHierarchicalIndexInternal());
            }
            this.selectRange(startPosition, endPosition);
        }
    }
    /**
     * Notify selection change event
     * @private
     */
    fireSelectionChanged(isSelectionChanged) {
        if (!this.isEmpty) {
            if (this.isForward) {
                this.start.updatePhysicalPosition(true);
                this.end.updatePhysicalPosition(false);
            }
            else {
                this.start.updatePhysicalPosition(false);
                this.end.updatePhysicalPosition(true);
            }
        }
        if (!this.skipFormatRetrieval) {
            this.retrieveCurrentFormatProperties();
        }
        this.viewer.clearSelectionHighlight();
        this.hideToolTip();
        if (this.owner.isLayoutEnabled && !this.owner.isShiftingEnabled) {
            this.highlightSelection(true);
        }
        if (this.viewer.restrictEditingPane.isShowRestrictPane && !this.skipEditRangeRetrieval) {
            this.viewer.restrictEditingPane.updateUserInformation();
        }
        if (isSelectionChanged) {
            if (this.start.paragraph.isInHeaderFooter && !this.owner.enableHeaderAndFooter) {
                this.owner.enableHeaderAndFooter = true;
            }
            else if (!this.start.paragraph.isInHeaderFooter && this.owner.enableHeaderAndFooter) {
                this.owner.enableHeaderAndFooter = false;
            }
            this.owner.fireSelectionChange();
        }
        this.viewer.updateFocus();
    }
    //Formats Retrieval
    /**
     * Retrieve all current selection format
     * @private
     */
    retrieveCurrentFormatProperties() {
        this.isRetrieveFormatting = true;
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        this.retrieveImageFormat(startPosition, endPosition);
        this.retrieveCharacterFormat(startPosition, endPosition);
        this.retrieveParagraphFormat(startPosition, endPosition);
        this.retrieveSectionFormat(startPosition, endPosition);
        this.retrieveTableFormat(startPosition, endPosition);
        if (!this.isImageSelected) {
            this.imageFormat.clearImageFormat();
        }
        this.isRetrieveFormatting = false;
        this.setCurrentContextType();
    }
    /**
     * @private
     */
    retrieveImageFormat(start, end) {
        let image;
        if (start.currentWidget === end.currentWidget && start.offset + 1 === end.offset) {
            let elementInfo = end.currentWidget.getInline(end.offset, 0);
            image = elementInfo.element;
            let index = elementInfo.index;
            if (image instanceof ImageElementBox) {
                let startOffset = start.currentWidget.getOffset(image, 0);
                if (startOffset !== start.offset) {
                    image = undefined;
                }
            }
        }
        if (image instanceof ImageElementBox) {
            this.imageFormat.copyImageFormat(image);
        }
        else {
            this.imageFormat.clearImageFormat();
        }
    }
    setCurrentContextType() {
        let contextIsinImage = this.imageFormat.image ? true : false;
        let contextIsinTable = (isNullOrUndefined(this.tableFormat) || isNullOrUndefined(this.tableFormat.table)) ? false : true;
        let style = this.start.paragraph.paragraphFormat.baseStyle;
        if (style instanceof WParagraphStyle && style.name.toLowerCase().indexOf('toc') === 0) {
            let tocField = this.getTocFieldInternal();
            if (!isNullOrUndefined(tocField)) {
                this.contextTypeInternal = 'TableOfContents';
                return;
            }
        }
        if (this.start.paragraph.isInHeaderFooter) {
            let isInHeader = this.start.paragraph.bodyWidget.headerFooterType.indexOf('Header') !== -1;
            if (contextIsinTable) {
                if (contextIsinImage) {
                    this.contextTypeInternal = isInHeader ? 'HeaderTableImage' : 'FooterTableImage';
                }
                else {
                    this.contextTypeInternal = isInHeader ? 'HeaderTableText' : 'FooterTableText';
                }
            }
            else {
                if (contextIsinImage) {
                    this.contextTypeInternal = isInHeader ? 'HeaderImage' : 'FooterImage';
                }
                else {
                    this.contextTypeInternal = isInHeader ? 'HeaderText' : 'FooterText';
                }
            }
        }
        else {
            if (contextIsinTable) {
                this.contextTypeInternal = contextIsinImage ? 'TableImage' : 'TableText';
            }
            else {
                this.contextTypeInternal = contextIsinImage ? 'Image' : 'Text';
            }
        }
    }
    //Table Format retrieval starts
    /**
     * Retrieve selection table format
     * @private
     */
    retrieveTableFormat(start, end) {
        let tableAdv = this.getTable(start, end);
        if (!isNullOrUndefined(tableAdv)) {
            this.tableFormat.copyFormat(tableAdv.tableFormat);
            this.tableFormat.table = tableAdv;
            this.retrieveCellFormat(start, end);
            this.retrieveRowFormat(start, end);
        }
        else {
            //When the selection is out of table
            this.tableFormat.clearFormat();
        }
    }
    /**
     * Retrieve selection cell format
     * @private
     */
    retrieveCellFormat(start, end) {
        if (start.paragraph.isInsideTable && end.paragraph.isInsideTable) {
            this.cellFormat.copyFormat(start.paragraph.associatedCell.cellFormat);
            this.getCellFormat(start.paragraph.associatedCell.ownerTable, start, end);
        }
        else {
            //When the selection is out of table
            this.cellFormat.clearCellFormat();
        }
    }
    /**
     * Retrieve selection row format
     * @private
     */
    retrieveRowFormat(start, end) {
        if (start.paragraph.isInsideTable && end.paragraph.isInsideTable) {
            this.rowFormat.copyFormat(start.paragraph.associatedCell.ownerRow.rowFormat);
            this.getRowFormat(start.paragraph.associatedCell.ownerTable, start, end);
        }
        else {
            //When the selection is out of table
            this.rowFormat.clearRowFormat();
        }
    }
    /**
     * Get selected cell format
     * @private
     */
    getCellFormat(table, start, end) {
        if (start.paragraph.associatedCell.equals(end.paragraph.associatedCell)) {
            return;
        }
        let isStarted = false;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row === start.paragraph.associatedCell.ownerRow) {
                isStarted = true;
            }
            if (isStarted) {
                for (let j = 0; j < row.childWidgets.length; j++) {
                    let cell = row.childWidgets[j];
                    if (this.isCellSelected(cell, start, end)) {
                        this.cellFormat.combineFormat(cell.cellFormat);
                    }
                    if (cell === end.paragraph.associatedCell) {
                        this.cellFormat.combineFormat(cell.cellFormat);
                        return;
                    }
                }
            }
        }
    }
    /**
     * Get selected row format
     * @private
     */
    getRowFormat(table, start, end) {
        let tableRow = start.paragraph.associatedCell.ownerRow;
        if (tableRow === end.paragraph.associatedCell.ownerRow) {
            return;
        }
        for (let i = table.childWidgets.indexOf(tableRow) + 1; i < table.childWidgets.length; i++) {
            let tempTableRow = table.childWidgets[i];
            this.rowFormat.combineFormat(tempTableRow.rowFormat);
            if (tempTableRow === end.paragraph.associatedCell.ownerRow) {
                return;
            }
        }
    }
    /**
     * Return table with given text position
     * @private
     */
    getTable(startPosition, endPosition) {
        if (!isNullOrUndefined(startPosition.paragraph.associatedCell) && !isNullOrUndefined(endPosition.paragraph.associatedCell)) {
            let startTable = startPosition.paragraph.associatedCell.ownerTable;
            let endTable = startPosition.paragraph.associatedCell.ownerTable;
            if (startTable === endTable) {
                return startTable;
            }
            else {
                if (startTable.contains(startPosition.paragraph.associatedCell)) {
                    return startTable;
                }
                else if (endTable.contains(startPosition.paragraph.associatedCell)) {
                    return endTable;
                }
                else if (!startTable.isInsideTable || !endTable.isInsideTable) {
                    return undefined;
                }
                else {
                    do {
                        startTable = startTable.associatedCell.ownerTable;
                        if (startTable === endTable || startTable.contains(endTable.associatedCell)) {
                            return startTable;
                        }
                        else if (endTable.contains(startTable.associatedCell)) {
                            return endTable;
                        }
                    } while (!isNullOrUndefined(startTable.associatedCell));
                }
            }
        }
        return undefined;
    }
    getContainerWidget(block) {
        let bodyWidget;
        if (block.containerWidget instanceof BlockContainer) {
            bodyWidget = block.containerWidget;
        }
        else {
            bodyWidget = block.containerWidget;
            while (!(bodyWidget instanceof BlockContainer)) {
                bodyWidget = bodyWidget.containerWidget;
            }
        }
        return bodyWidget;
    }
    //Table format retrieval ends
    //Section format retrieval starts
    /**
     * Retrieve selection section format
     * @private
     */
    retrieveSectionFormat(start, end) {
        let startParaSection = this.getContainerWidget(start.paragraph);
        let endParaSection = this.getContainerWidget(end.paragraph);
        if (!isNullOrUndefined(startParaSection)) {
            this.sectionFormat.copyFormat(startParaSection.sectionFormat);
            let startPageIndex = this.viewer.pages.indexOf(startParaSection.page);
            let endPageIndex = this.viewer.pages.indexOf(endParaSection.page);
            for (let i = startPageIndex + 1; i <= endPageIndex; i++) {
                this.sectionFormat.combineFormat(this.viewer.pages[i].bodyWidgets[0].sectionFormat);
            }
        }
    }
    //section format retrieval ends.
    //Paragraph format retrieval implementation starts.
    /**
     * Retrieve selection paragraph format
     * @private
     */
    retrieveParagraphFormat(start, end) {
        this.getParagraphFormatForSelection(start.paragraph, this, start, end);
    }
    /**
     * @private
     */
    getParagraphFormatForSelection(paragraph, selection, start, end) {
        //Selection start in cell.
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || this.isCellSelected(start.paragraph.associatedCell, start, end))) {
            this.getParagraphFormatInternalInCell(start.paragraph.associatedCell, start, end);
        }
        else {
            this.getParagraphFormatInternalInParagraph(paragraph, start, end);
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getParagraphFormatInternalInParagraph(paragraph, start, end) {
        if (start.paragraph === paragraph) {
            this.paragraphFormat.copyFormat(paragraph.paragraphFormat);
        }
        else {
            this.paragraphFormat.combineFormat(paragraph.paragraphFormat);
        }
        if (end.paragraph === paragraph) {
            return;
        }
        let block = this.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            this.getParagraphFormatInternalInBlock(block, start, end);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInternalInBlock(block, start, end) {
        if (block instanceof ParagraphWidget) {
            this.getParagraphFormatInternalInParagraph(block, start, end);
        }
        else {
            this.getParagraphFormatInternalInTable(block, start, end);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInternalInTable(table, start, end) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let tableRow = table.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                this.getParagraphFormatInCell(tableRow.childWidgets[j]);
            }
            if (end.paragraph.isInsideTable && this.containsRow(tableRow, end.paragraph.associatedCell)) {
                return;
            }
        }
        let block = this.getNextRenderedBlock(table);
        //Goto the next block.
        this.getParagraphFormatInternalInBlock(block, start, end);
    }
    /**
     * Get paragraph format in cell
     * @private
     */
    getParagraphFormatInCell(cell) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            this.getParagraphFormatInBlock(cell.childWidgets[i]);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInBlock(block) {
        if (block instanceof ParagraphWidget) {
            this.getParagraphFormatInParagraph(block);
        }
        else {
            this.getParagraphFormatInTable(block);
        }
    }
    /**
     * @private
     */
    getParagraphFormatInTable(tableAdv) {
        for (let i = 0; i < tableAdv.childWidgets.length; i++) {
            let tableRow = tableAdv.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                this.getParagraphFormatInCell(tableRow.childWidgets[j]);
            }
        }
    }
    /**
     * @private
     */
    getParagraphFormatInParagraph(paragraph) {
        this.paragraphFormat.combineFormat(paragraph.paragraphFormat);
    }
    /**
     * Get paragraph format in cell
     * @private
     */
    getParagraphFormatInternalInCell(cellAdv, start, end) {
        if (end.paragraph.isInsideTable) {
            let containerCell = this.getContainerCellOf(cellAdv, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(cellAdv, containerCell);
                let endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.getParagraphFormatInCell(containerCell);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.getParagraphFormatInternalInParagraph(start.paragraph, start, end);
                        }
                        else {
                            this.getParagraphFormatInRow(startCell.ownerRow, start, end);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.getParaFormatForCell(containerCell.ownerTable, containerCell, endCell);
                }
            }
            else {
                this.getParagraphFormatInRow(containerCell.ownerRow, start, end);
            }
        }
        else {
            let cell = this.getContainerCell(cellAdv);
            this.getParagraphFormatInRow(cell.ownerRow, start, end);
        }
    }
    /**
     * @private
     */
    getParaFormatForCell(table, startCell, endCell) {
        let startCellIn = this.getCellLeft(startCell.ownerRow, startCell);
        let endCellIn = startCellIn + startCell.cellFormat.cellWidth;
        let endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (startCellIn > endCellLeft) {
            startCellIn = endCellLeft;
        }
        if (endCellIn < endCellRight) {
            endCellIn = endCellRight;
        }
        if (startCellIn > this.upDownSelectionLength) {
            startCellIn = this.upDownSelectionLength;
        }
        if (startCellIn < this.upDownSelectionLength) {
            startCellIn = this.upDownSelectionLength;
        }
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            let tableRow = table.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                let cell = tableRow.childWidgets[j];
                let left = this.getCellLeft(tableRow, cell);
                if (HelperMethods.round(startCellIn, 2) <= HelperMethods.round(left, 2)
                    && HelperMethods.round(left, 2) < HelperMethods.round(endCellIn, 2)) {
                    this.getParagraphFormatInCell(cell);
                }
            }
        }
    }
    /**
     * Get paragraph format ins row
     * @private
     */
    getParagraphFormatInRow(tableRow, start, end) {
        for (let i = tableRow.rowIndex; i < tableRow.ownerTable.childWidgets.length; i++) {
            let row = tableRow.ownerTable.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.getParagraphFormatInCell(row.childWidgets[j]);
            }
            if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        let block = this.getNextRenderedBlock(tableRow.ownerTable);
        //Goto the next block.
        this.getParagraphFormatInternalInBlock(block, start, end);
    }
    // paragraph format retrieval implementation ends
    // Character format retrieval implementation starts.
    /**
     * Retrieve Selection character format
     * @private
     */
    retrieveCharacterFormat(start, end) {
        this.characterFormat.copyFormat(start.paragraph.characterFormat);
        if (start.paragraph === end.paragraph && start.currentWidget.isLastLine()
            && start.offset === this.getLineLength(start.currentWidget) && start.offset + 1 === end.offset) {
            return;
        }
        let para = start.paragraph;
        if (start.offset === this.getParagraphLength(para) && !this.isEmpty) {
            para = this.getNextParagraphBlock(para);
        }
        while (!isNullOrUndefined(para) && para !== end.paragraph && para.isEmpty()) {
            para = this.getNextParagraphBlock(para);
        }
        let offset = para === start.paragraph ? start.offset : 0;
        let indexInInline = 0;
        if (!isNullOrUndefined(para) && !para.isEmpty()) {
            let position = new TextPosition(this.owner);
            let elemInfo = start.currentWidget.getInline(offset, indexInInline);
            let physicalLocation = this.getPhysicalPositionInternal(start.currentWidget, offset, true);
            position.setPositionForSelection(start.currentWidget, elemInfo.element, elemInfo.index, physicalLocation);
            this.getCharacterFormatForSelection(para, this, position, end);
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getCharacterFormatForSelection(paragraph, selection, startPosition, endPosition) {
        //Selection start in cell.
        if (startPosition.paragraph instanceof ParagraphWidget && startPosition.paragraph.isInsideTable
            && (!endPosition.paragraph.isInsideTable
                || startPosition.paragraph.associatedCell !== endPosition.paragraph.associatedCell
                || this.isCellSelected(startPosition.paragraph.associatedCell, startPosition, endPosition))) {
            this.getCharacterFormatInTableCell(startPosition.paragraph.associatedCell, selection, startPosition, endPosition);
        }
        else {
            this.getCharacterFormat(paragraph, startPosition, endPosition);
        }
    }
    /**
     * Get Character format
     * @private
     */
    //Format Retrieval
    getCharacterFormatForTableRow(tableRowAdv, start, end) {
        for (let i = tableRowAdv.rowIndex; i < tableRowAdv.ownerTable.childWidgets.length; i++) {
            let tableRow = tableRowAdv.ownerTable.childWidgets[i];
            for (let j = 0; j < tableRow.childWidgets.length; j++) {
                this.getCharacterFormatForSelectionCell(tableRow.childWidgets[j], start, end);
            }
            if (end.paragraph.isInsideTable && this.containsRow(tableRow, end.paragraph.associatedCell)) {
                return;
            }
        }
        let block = this.getNextRenderedBlock(tableRowAdv.ownerTable);
        // //Goto the next block.
        this.getCharacterFormatForBlock(block, start, end);
    }
    /**
     * Get Character format in table
     * @private
     */
    getCharacterFormatInTableCell(tableCell, selection, start, end) {
        if (end.paragraph.isInsideTable) {
            let containerCell = this.getContainerCellOf(tableCell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = this.getSelectedCell(tableCell, containerCell);
                let endCell = this.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (this.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (this.isCellSelected(containerCell, start, end)) {
                        this.getCharacterFormatForSelectionCell(containerCell, start, end);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.getCharacterFormat(start.paragraph, start, end);
                        }
                        else {
                            this.getCharacterFormatForTableRow(startCell.ownerRow, start, end);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.getCharacterFormatInternalInTable(containerCell.ownerTable, containerCell, endCell, start, end);
                }
            }
            else {
                this.getCharacterFormatForTableRow(containerCell.ownerRow, start, end);
            }
        }
        else {
            let cell = this.getContainerCell(tableCell);
            this.getCharacterFormatForTableRow(cell.ownerRow, start, end);
        }
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getCharacterFormatInternalInTable(table, startCell, endCell, startPosition, endPosition) {
        let startIn = this.getCellLeft(startCell.ownerRow, startCell);
        let endIn = startIn + startCell.cellFormat.cellWidth;
        let endCellLeft = this.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        if (startIn > endCellLeft) {
            startIn = endCellLeft;
        }
        if (endIn < endCellRight) {
            endIn = endCellRight;
        }
        if (startIn > this.upDownSelectionLength) {
            startIn = this.upDownSelectionLength;
        }
        if (endIn < this.upDownSelectionLength) {
            endIn = this.upDownSelectionLength;
        }
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let left = this.getCellLeft(row, cell);
                if (HelperMethods.round(startIn, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(endIn, 2)) {
                    this.getCharacterFormatForSelectionCell(cell, startPosition, endPosition);
                }
            }
        }
    }
    /**
     * Get character format with in selection
     * @private
     */
    getCharacterFormat(paragraph, start, end) {
        if (paragraph !== start.paragraph && paragraph !== end.paragraph) {
            this.getCharacterFormatInternal(paragraph, this);
            return;
        }
        if (end.paragraph === paragraph && start.paragraph !== paragraph && end.offset === 0) {
            return;
        }
        let startOffset = 0;
        let length = this.getParagraphLength(paragraph);
        if (paragraph === start.paragraph) {
            startOffset = start.offset;
            //Sets selection character format.            
            let isUpdated = this.setCharacterFormat(paragraph, start, end, length);
            if (isUpdated) {
                return;
            }
        }
        let startLineWidget = paragraph.childWidgets.indexOf(start.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(start.currentWidget) : 0;
        let endLineWidget = paragraph.childWidgets.indexOf(end.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(end.currentWidget) : paragraph.childWidgets.length - 1;
        let endOffset = end.offset;
        if (paragraph !== end.paragraph) {
            endOffset = length;
        }
        let isFieldStartSelected = false;
        for (let i = startLineWidget; i <= endLineWidget; i++) {
            let lineWidget = paragraph.childWidgets[i];
            if (i !== startLineWidget) {
                startOffset = this.getStartLineOffset(lineWidget);
            }
            if (lineWidget === end.currentWidget) {
                endOffset = end.offset;
            }
            else {
                endOffset = this.getLineLength(lineWidget);
            }
            let count = 0;
            for (let j = 0; j < lineWidget.children.length; j++) {
                let inline = lineWidget.children[j];
                if (startOffset >= count + inline.length) {
                    count += inline.length;
                    continue;
                }
                if (inline instanceof FieldElementBox && inline.fieldType === 0
                    && HelperMethods.isLinkedFieldCharacter(inline)) {
                    let nextInline = isNullOrUndefined(inline.fieldSeparator) ?
                        inline.fieldEnd : inline.fieldSeparator;
                    do {
                        count += inline.length;
                        inline = inline.nextNode;
                        i++;
                    } while (!isNullOrUndefined(inline) && inline !== nextInline);
                    isFieldStartSelected = true;
                }
                if (inline instanceof FieldElementBox && inline.fieldType === 1
                    && HelperMethods.isLinkedFieldCharacter(inline) && isFieldStartSelected) {
                    let fieldInline = inline.fieldBegin;
                    do {
                        this.characterFormat.combineFormat(fieldInline.characterFormat);
                        fieldInline = fieldInline.nextNode;
                    } while (!(fieldInline instanceof FieldElementBox));
                }
                if (inline instanceof TextElementBox) {
                    this.characterFormat.combineFormat(inline.characterFormat);
                }
                if (isNullOrUndefined(inline) || endOffset <= count + inline.length) {
                    break;
                }
                count += inline.length;
            }
        }
        if (end.paragraph === paragraph) {
            return;
        }
        let block = this.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            this.getCharacterFormatForBlock(block, start, end);
        }
    }
    setCharacterFormat(para, startPos, endPos, length) {
        let index = 0;
        let startOffset = startPos.offset;
        let inlineAndIndex = startPos.currentWidget.getInline(startOffset, index);
        index = inlineAndIndex.index;
        let inline = inlineAndIndex.element;
        if (isNullOrUndefined(inline)) {
            let currentLineIndex = startPos.paragraph.childWidgets.indexOf(startPos.currentWidget);
            if (startPos.currentWidget.previousLine) {
                inline = startPos.currentWidget.previousLine.children[startPos.currentWidget.previousLine.children.length - 1];
                this.characterFormat.copyFormat(inline.characterFormat);
                return true;
            }
        }
        if (startOffset < length) {
            if (this.isEmpty) {
                if (inline instanceof TextElementBox || (inline instanceof FieldElementBox
                    && (inline.fieldType === 0 || inline.fieldType === 1))) {
                    let previousNode = this.getPreviousTextElement(inline);
                    if (startOffset === 0 && previousNode) {
                        inline = previousNode;
                    }
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else {
                    if (!isNullOrUndefined(this.getPreviousTextElement(inline))) {
                        this.characterFormat.copyFormat(this.getPreviousTextElement(inline).characterFormat);
                    }
                    else if (!isNullOrUndefined(this.getNextTextElement(inline))) {
                        this.characterFormat.copyFormat(this.getNextTextElement(inline).characterFormat);
                    }
                    else {
                        this.characterFormat.copyFormat(para.characterFormat);
                    }
                }
                return true;
            }
            else {
                if (index === inline.length && !isNullOrUndefined(inline.nextNode)) {
                    this.characterFormat.copyFormat(this.getNextValidCharacterFormat(inline));
                }
                else if (inline instanceof TextElementBox) {
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else if (inline instanceof FieldElementBox) {
                    this.characterFormat.copyFormat(this.getNextValidCharacterFormatOfField(inline));
                }
            }
        }
        else {
            if (length === endPos.offset) {
                if (inline instanceof TextElementBox || inline instanceof FieldElementBox) {
                    this.characterFormat.copyFormat(inline.characterFormat);
                }
                else if (!isNullOrUndefined(inline)) {
                    inline = this.getPreviousTextElement(inline);
                    if (!isNullOrUndefined(inline)) {
                        this.characterFormat.copyFormat(inline.characterFormat);
                    }
                }
                else {
                    this.characterFormat.copyFormat(para.characterFormat);
                }
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     */
    getCharacterFormatForBlock(block, start, end) {
        if (block instanceof ParagraphWidget) {
            this.getCharacterFormat(block, start, end);
        }
        else {
            this.getCharacterFormatInTable(block, start, end);
        }
    }
    /**
     * @private
     */
    getCharacterFormatInTable(table, start, end) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.getCharacterFormatForSelectionCell(row.childWidgets[j], start, end);
            }
            if (end.paragraph.isInsideTable && this.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        let blockAdv = this.getNextRenderedBlock(table);
        // //Goto the next block.
        this.getCharacterFormatForBlock(blockAdv, start, end);
    }
    /**
     * Get character format in selection
     * @private
     */
    getCharacterFormatForSelectionCell(cell, start, end) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            this.getCharacterFormatForBlock(cell.childWidgets[i], start, end);
        }
    }
    /**
     * @private
     */
    getCharacterFormatInternal(paragraph, selection) {
        for (let i = 0; i < paragraph.childWidgets.length; i++) {
            let linewidget = paragraph.childWidgets[i];
            for (let j = 0; j < linewidget.children.length; j++) {
                let element = linewidget.children[j];
                if (!(element instanceof ImageElementBox || element instanceof FieldElementBox)) {
                    selection.characterFormat.combineFormat(element.characterFormat);
                }
            }
        }
    }
    /**
     * Get next valid character format from inline
     * @private
     */
    getNextValidCharacterFormat(inline) {
        let startInline = this.getNextTextElement(inline);
        if (isNullOrUndefined(startInline)) {
            return inline.characterFormat;
        }
        let fieldBegin = undefined;
        if (startInline instanceof FieldElementBox) {
            if (fieldBegin.fieldType === 0) {
                fieldBegin = startInline;
            }
        }
        if (isNullOrUndefined(fieldBegin)) {
            return startInline.characterFormat;
        }
        else {
            return this.getNextValidCharacterFormatOfField(fieldBegin);
        }
    }
    /**
     * Get next valid paragraph format from field
     * @private
     */
    getNextValidCharacterFormatOfField(fieldBegin) {
        let startInline = fieldBegin;
        if (HelperMethods.isLinkedFieldCharacter(fieldBegin)) {
            if (isNullOrUndefined(fieldBegin.fieldSeparator)) {
                startInline = fieldBegin.fieldEnd;
            }
            else {
                startInline = fieldBegin.fieldSeparator;
            }
        }
        let nextValidInline = undefined;
        if (!isNullOrUndefined(startInline.nextNode)) {
            //Check the next node is a valid and returns inline.
            nextValidInline = this.getNextValidElement(startInline.nextNode);
        }
        //If field separator/end exists at end of paragraph, then move to next paragraph.
        if (isNullOrUndefined(nextValidInline)) {
            return startInline.characterFormat;
        }
        return nextValidInline.characterFormat;
    }
    /**
     * Return true if cursor point with in selection range
     * @private
     */
    checkCursorIsInSelection(widget, point) {
        if (isNullOrUndefined(this.start) || this.isEmpty || isNullOrUndefined(widget)) {
            return false;
        }
        let isSelected = false;
        do {
            if (this.selectedWidgets.containsKey(widget)) {
                let top;
                let left;
                if (widget instanceof LineWidget) {
                    top = this.owner.selection.getTop(widget);
                    left = this.owner.selection.getLeft(widget);
                }
                else {
                    top = widget.y;
                    left = widget.x;
                }
                let widgetInfo = this.selectedWidgets.get(widget);
                isSelected = widgetInfo.left <= point.x && top <= point.y &&
                    top + widget.height >= point.y && widgetInfo.left + widgetInfo.width >= point.x;
            }
            widget = (widget instanceof LineWidget) ? widget.paragraph : widget.containerWidget;
        } while (!isNullOrUndefined(widget) && !isSelected);
        return isSelected;
    }
    /**
     * Copy paragraph for to selection paragraph format
     * @private
     */
    copySelectionParagraphFormat() {
        let format = new WParagraphFormat();
        this.paragraphFormat.copyToFormat(format);
        return format;
    }
    /**
     * Get hyperlink display text
     * @private
     */
    // tslint:disable-next-line
    getHyperlinkDisplayText(paragraph, fieldSeparator, fieldEnd, isNestedField, format) {
        let para = paragraph;
        if (para !== fieldEnd.line.paragraph) {
            isNestedField = true;
            return { displayText: '<<Selection in Document>>', 'isNestedField': isNestedField, 'format': format };
        }
        let displayText = '';
        let lineIndex = para.childWidgets.indexOf(fieldSeparator.line);
        let index = para.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (let j = lineIndex; j < para.childWidgets.length; j++) {
            let lineWidget = para.childWidgets[j];
            if (j !== lineIndex) {
                index = -1;
            }
            for (let i = index + 1; i < lineWidget.children.length; i++) {
                let inline = lineWidget.children[i];
                if (inline === fieldEnd) {
                    return { 'displayText': displayText, 'isNestedField': isNestedField, 'format': format };
                }
                if (inline instanceof TextElementBox) {
                    displayText += inline.text;
                    format = inline.characterFormat;
                }
                else if (inline instanceof FieldElementBox) {
                    if (inline instanceof FieldElementBox && inline.fieldType === 0
                        && !isNullOrUndefined(inline.fieldEnd)) {
                        if (isNullOrUndefined(inline.fieldSeparator)) {
                            index = lineWidget.children.indexOf(inline.fieldEnd);
                        }
                        else {
                            index = lineWidget.children.indexOf(inline.fieldSeparator);
                        }
                    }
                }
                else {
                    isNestedField = true;
                    return { 'displayText': '<<Selection in Document>>', 'isNestedField': isNestedField, 'format': format };
                }
            }
        }
        return { 'displayText': displayText, 'isNestedField': isNestedField, 'format': format };
    }
    /**
     * Navigates hyperlink on mouse Event.
     * @private
     */
    navigateHyperLinkOnEvent(cursorPoint, isTouchInput) {
        let widget = this.viewer.getLineWidget(cursorPoint);
        if (!isNullOrUndefined(widget)) {
            let hyperLinkField = this.getHyperLinkFieldInCurrentSelection(widget, cursorPoint);
            //Invokes Hyperlink navigation events.
            if (!isNullOrUndefined(hyperLinkField)) {
                this.viewer.updateTextPositionForSelection(cursorPoint, 1);
                this.fireRequestNavigate(hyperLinkField);
                setTimeout(() => {
                    if (this.viewer) {
                        this.viewer.isTouchInput = isTouchInput;
                        this.viewer.updateFocus();
                        this.viewer.isTouchInput = false;
                    }
                });
            }
        }
    }
    /**
     * @private
     */
    getLinkText(fieldBegin) {
        let hyperlink = new Hyperlink(fieldBegin, this);
        let link = hyperlink.navigationLink;
        if (hyperlink.localReference.length > 0) {
            if (hyperlink.localReference[0] === '_' && (isNullOrUndefined(link) || link.length === 0)) {
                link = 'Current Document';
            }
            else {
                link += '#' + hyperlink.localReference;
            }
        }
        hyperlink.destroy();
        return link;
    }
    /**
     * Set Hyperlink content to tool tip element
     * @private
     */
    setHyperlinkContentToToolTip(fieldBegin, widget, xPos) {
        if (fieldBegin) {
            if (this.owner.contextMenuModule &&
                this.owner.contextMenuModule.contextMenuInstance.element.style.display === 'block') {
                return;
            }
            if (!this.toolTipElement) {
                this.toolTipElement = createElement('div', { className: 'e-de-tooltip' });
                this.viewer.viewerContainer.appendChild(this.toolTipElement);
            }
            this.toolTipElement.style.display = 'block';
            let l10n = new L10n('documenteditor', this.owner.defaultLocale);
            l10n.setLocale(this.owner.locale);
            let toolTipText = l10n.getConstant('Click to follow link');
            if (this.owner.useCtrlClickToFollowHyperlink) {
                toolTipText = 'Ctrl+' + toolTipText;
            }
            let linkText = this.getLinkText(fieldBegin);
            this.toolTipElement.innerHTML = linkText + '</br><b>' + toolTipText + '</b>';
            let widgetTop = this.getTop(widget) * this.viewer.zoomFactor;
            let page = this.getPage(widget.paragraph);
            let containerWidth = this.viewer.viewerContainer.getBoundingClientRect().width + this.viewer.viewerContainer.scrollLeft;
            let left = page.boundingRectangle.x + xPos * this.viewer.zoomFactor;
            if ((left + this.toolTipElement.clientWidth + 10) > containerWidth) {
                left = left - ((this.toolTipElement.clientWidth - (containerWidth - left)) + 15);
            }
            let top = this.getPageTop(page) + (widgetTop - this.toolTipElement.offsetHeight);
            top = top > this.viewer.viewerContainer.scrollTop ? top : top + widget.height + this.toolTipElement.offsetHeight;
            this.showToolTip(left, top);
            if (!isNullOrUndefined(this.toolTipField) && fieldBegin !== this.toolTipField) {
                this.toolTipObject.position = { X: left, Y: top };
            }
            this.toolTipObject.show();
            this.toolTipField = fieldBegin;
        }
        else {
            this.hideToolTip();
        }
    }
    /**
     * @private
     */
    createPasteElement(top, left) {
        let locale = new L10n('documenteditor', this.owner.defaultLocale);
        locale.setLocale(this.owner.locale);
        let items = [
            {
                text: locale.getConstant('Keep source formatting'),
                iconCss: 'e-icons e-de-paste-source'
            },
            {
                text: locale.getConstant('Match destination formatting'),
                iconCss: 'e-icons e-de-paste-merge'
            },
            {
                text: locale.getConstant('Text only'),
                iconCss: 'e-icons e-de-paste-text'
            }
        ];
        if (!this.pasteElement) {
            this.pasteElement = createElement('div', { className: 'e-de-tooltip' });
            this.viewer.viewerContainer.appendChild(this.pasteElement);
            let splitButtonEle = createElement('button', { id: 'iconsplitbtn' });
            this.pasteElement.appendChild(splitButtonEle);
            this.pasteDropDwn = new DropDownButton({
                items: items, iconCss: 'e-icons e-de-paste', select: this.pasteOptions
            });
            this.pasteDropDwn.appendTo('#iconsplitbtn');
        }
        this.pasteElement.style.display = 'block';
        this.pasteElement.style.position = 'absolute';
        this.pasteElement.style.left = left;
        this.pasteElement.style.top = top;
    }
    /**
     * Show hyperlink tooltip
     * @private
     */
    showToolTip(x, y) {
        if (!this.toolTipObject) {
            this.toolTipObject = new Popup(this.toolTipElement, {
                height: 'auto',
                width: 'auto',
                relateTo: this.viewer.viewerContainer.parentElement,
                position: { X: x, Y: y }
            });
        }
    }
    /**
     * Hide tooltip object
     * @private
     */
    hideToolTip() {
        this.toolTipField = undefined;
        if (this.toolTipObject) {
            this.toolTipElement.style.display = 'none';
            this.toolTipObject.hide();
            this.toolTipObject.destroy();
            this.toolTipObject = undefined;
        }
    }
    /**
     * Return hyperlink field
     * @private
     */
    getHyperLinkFieldInCurrentSelection(widget, cursorPosition) {
        let inline = undefined;
        let top = this.getTop(widget);
        let lineStartLeft = this.getLineStartLeft(widget);
        if (cursorPosition.y < top || cursorPosition.y > top + widget.height
            || cursorPosition.x < lineStartLeft || cursorPosition.x > lineStartLeft + widget.paragraph.width) {
            return undefined;
        }
        let left = widget.paragraph.x;
        let elementValues = this.getFirstElement(widget, left);
        left = elementValues.left;
        let element = elementValues.element;
        if (isNullOrUndefined(element)) {
            let width = this.viewer.textHelper.getParagraphMarkWidth(widget.paragraph.characterFormat);
            if (cursorPosition.x <= lineStartLeft + width || cursorPosition.x >= lineStartLeft + width) {
                //Check if paragraph is within a field result.
                let checkedFields = [];
                let field = this.getHyperLinkFields(widget.paragraph, checkedFields);
                checkedFields = [];
                checkedFields = undefined;
                return field;
            }
        }
        else {
            if (cursorPosition.x > left + element.margin.left) {
                for (let i = widget.children.indexOf(element); i < widget.children.length; i++) {
                    element = widget.children[i];
                    if (cursorPosition.x < left + element.margin.left + element.width || i === widget.children.length - 1) {
                        break;
                    }
                    left += element.margin.left + element.width;
                }
            }
            inline = element;
            let width = element.margin.left + element.width;
            if (isNullOrUndefined(inline.nextNode)) {
                //Include width of Paragraph mark.
                width += this.viewer.textHelper.getParagraphMarkWidth(inline.line.paragraph.characterFormat);
            }
            if (cursorPosition.x <= left + width) {
                //Check if inline is within a field result.
                let checkedFields = [];
                let field = this.getHyperLinkFieldInternal(inline.line.paragraph, inline, checkedFields);
                checkedFields = [];
                checkedFields = undefined;
                return field;
            }
        }
        return undefined;
    }
    /**
     * Return field if paragraph contain hyperlink field
     * @private
     */
    getHyperlinkField(isRetrieve) {
        if (isNullOrUndefined(this.end)) {
            return undefined;
        }
        let index = 0;
        let currentInline = this.end.currentWidget.getInline(this.end.offset, index);
        index = currentInline.index;
        let inline = currentInline.element;
        let checkedFields = [];
        let field = undefined;
        if (isNullOrUndefined(inline)) {
            field = this.getHyperLinkFields(this.end.paragraph, checkedFields, isRetrieve);
        }
        else {
            let paragraph = inline.line.paragraph;
            field = this.getHyperLinkFieldInternal(paragraph, inline, checkedFields, isRetrieve);
        }
        checkedFields = [];
        return field;
    }
    /**
     * @private
     */
    getHyperLinkFields(paragraph, checkedFields, isRetrieve) {
        for (let i = 0; i < this.viewer.fields.length; i++) {
            if (checkedFields.indexOf(this.viewer.fields[i]) !== -1 || isNullOrUndefined(this.viewer.fields[i].fieldSeparator)) {
                continue;
            }
            else {
                checkedFields.push(this.viewer.fields[i]);
            }
            let field = this.getFieldCode(this.viewer.fields[i]);
            field = field.trim().toLowerCase();
            let isParagraph = this.paragraphIsInFieldResult(this.viewer.fields[i], paragraph);
            if ((isRetrieve || (!isRetrieve && field.match('hyperlink '))) && isParagraph) {
                return this.viewer.fields[i];
            }
        }
        // if (paragraph.containerWidget instanceof BodyWidget && !(paragraph instanceof WHeaderFooter)) {
        //     return this.getHyperLinkFields((paragraph.con as WCompositeNode), checkedFields);
        // }
        return undefined;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    getHyperLinkFieldInternal(paragraph, inline, fields, isRetrieve) {
        for (let i = 0; i < this.viewer.fields.length; i++) {
            if (fields.indexOf(this.viewer.fields[i]) !== -1 || isNullOrUndefined(this.viewer.fields[i].fieldSeparator)) {
                continue;
            }
            else {
                fields.push(this.viewer.fields[i]);
            }
            let fieldCode = this.getFieldCode(this.viewer.fields[i]);
            fieldCode = fieldCode.trim().toLowerCase();
            let isInline = (this.inlineIsInFieldResult(this.viewer.fields[i], inline) || this.isImageField());
            if ((isRetrieve || (!isRetrieve && fieldCode.match('hyperlink '))) && isInline) {
                return this.viewer.fields[i];
            }
        }
        if (paragraph.containerWidget instanceof BodyWidget && !(paragraph instanceof HeaderFooterWidget)) {
            return this.getHyperLinkFieldInternal(paragraph.containerWidget, inline, fields, isRetrieve);
        }
        return undefined;
    }
    /**
     * @private
     */
    getBlock(currentIndex) {
        if (currentIndex === '' || isNullOrUndefined(currentIndex)) {
            return undefined;
        }
        let index = { index: currentIndex };
        let page = this.start.getPage(index);
        let bodyIndex = index.index.indexOf(';');
        let value = index.index.substring(0, bodyIndex);
        index.index = index.index.substring(bodyIndex).replace(';', '');
        let bodyWidget = page.bodyWidgets[parseInt(value, 10)];
        return this.getBlockInternal(bodyWidget, index.index);
    }
    /**
     * Return Block relative to position
     * @private
     */
    getBlockInternal(widget, position) {
        if (position === '' || isNullOrUndefined(position)) {
            return undefined;
        }
        let index = position.indexOf(';');
        let value = position.substring(0, index);
        position = position.substring(index).replace(';', '');
        let node = widget;
        // if (node instanceof Widget && value === 'HF') {
        //     //Gets the block in Header footers.
        //     let blockObj: BlockInfo = this.getBlock((node as WSection).headersFooters, position);
        // tslint:disable-next-line:max-line-length
        //     return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
        // }
        index = parseInt(value, 10);
        if (index >= 0 && index < widget.childWidgets.length) {
            let child = widget.childWidgets[(index)];
            if (position.indexOf(';') >= 0) {
                if (child instanceof ParagraphWidget) {
                    if (position.indexOf(';') >= 0) {
                        position = '0';
                    }
                    return child;
                }
                if (child instanceof BlockWidget) {
                    let blockObj = this.getBlockInternal(child, position);
                    return blockObj;
                }
            }
            else {
                return child;
            }
        }
        else {
            return node;
        }
        return node;
    }
    /**
     * Return true if inline is in field result
     * @private
     */
    inlineIsInFieldResult(fieldBegin, inline) {
        if (!isNullOrUndefined(fieldBegin.fieldEnd) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
            if (this.isExistBeforeInline(fieldBegin.fieldSeparator, inline)) {
                return this.isExistAfterInline(fieldBegin.fieldEnd, inline);
            }
        }
        return false;
    }
    /**
     * Retrieve true if paragraph is in field result
     * @private
     */
    paragraphIsInFieldResult(fieldBegin, paragraph) {
        if (!isNullOrUndefined(fieldBegin.fieldEnd) && !isNullOrUndefined(fieldBegin.fieldSeparator)) {
            let fieldParagraph = fieldBegin.fieldSeparator.line.paragraph;
            if (fieldBegin.fieldSeparator.line.paragraph === paragraph
                || this.isExistBefore(fieldParagraph, paragraph)) {
                let currentParagraph = fieldBegin.fieldEnd.line.paragraph;
                return (currentParagraph !== paragraph && this.isExistAfter(fieldParagraph, paragraph));
            }
        }
        return false;
    }
    /**
     * Return true if image is In field
     * @private
     */
    isImageField() {
        if (this.start.paragraph.isEmpty() || this.end.paragraph.isEmpty()) {
            return false;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        let indexInInline = 0;
        let inlineInfo = startPosition.paragraph.getInline(startPosition.offset, indexInInline);
        let inline = inlineInfo.element;
        indexInInline = inlineInfo.index;
        if (indexInInline === inline.length) {
            inline = this.getNextRenderedElementBox(inline, indexInInline);
        }
        inlineInfo = endPosition.paragraph.getInline(endPosition.offset, indexInInline);
        let endInline = inlineInfo.element;
        indexInInline = inlineInfo.index;
        if (inline instanceof FieldElementBox && inline.fieldType === 0
            && endInline instanceof FieldElementBox && endInline.fieldType === 1 && inline.fieldSeparator) {
            let fieldValue = inline.fieldSeparator.nextNode;
            if (fieldValue instanceof ImageElementBox && fieldValue.nextNode === endInline) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     */
    isTableSelected() {
        let start = this.start;
        let end = this.end;
        if (!this.isForward) {
            start = this.end;
            end = this.start;
        }
        if (isNullOrUndefined(start.paragraph.associatedCell) ||
            isNullOrUndefined(end.paragraph.associatedCell)) {
            return false;
        }
        let table = start.paragraph.associatedCell.ownerTable.getSplitWidgets();
        let firstParagraph = this.getFirstBlockInFirstCell(table[0]);
        let lastParagraph = this.getLastBlockInLastCell(table[table.length - 1]);
        return start.paragraph.associatedCell.equals(firstParagraph.associatedCell) &&
            end.paragraph.associatedCell.equals(lastParagraph.associatedCell)
            && (!firstParagraph.associatedCell.equals(lastParagraph.associatedCell) || (start.offset === 0
                && end.offset === this.getLineLength(lastParagraph.lastChild) + 1));
    }
    /**
     * Select List Text
     * @private
     */
    selectListText() {
        let lineWidget = this.viewer.selectionLineWidget;
        let endOffset = '0';
        let selectionIndex = lineWidget.getHierarchicalIndex(endOffset);
        let startPosition = this.getTextPosition(selectionIndex);
        let endPosition = this.getTextPosition(selectionIndex);
        this.selectRange(startPosition, endPosition);
        this.highlightListText(this.viewer.selectionLineWidget);
        this.contextTypeInternal = 'List';
    }
    /**
     * Manually select the list text
     * @private
     */
    highlightListText(linewidget) {
        let width = linewidget.children[0].width;
        let left = this.viewer.getLeftValue(linewidget);
        let top = linewidget.paragraph.y;
        this.createHighlightBorder(linewidget, width, left, top, false);
        this.viewer.isListTextSelected = true;
    }
    /**
     * @private
     */
    updateImageSize(imageFormat) {
        this.owner.isShiftingEnabled = true;
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        let inline = null;
        let index = 0;
        let paragraph = startPosition.paragraph;
        if (paragraph === endPosition.paragraph
            && startPosition.offset + 1 === endPosition.offset) {
            let inlineObj = paragraph.getInline(endPosition.offset, index);
            inline = inlineObj.element;
            index = inlineObj.index;
        }
        if (inline instanceof ImageElementBox) {
            let width = inline.width;
            let height = inline.height;
            inline.width = imageFormat.width;
            inline.height = imageFormat.height;
            imageFormat.width = width;
            imageFormat.height = height;
            if (paragraph !== null && paragraph.containerWidget !== null && this.owner.editorModule) {
                let lineIndex = paragraph.childWidgets.indexOf(inline.line);
                let elementIndex = inline.line.children.indexOf(inline);
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
                this.highlightSelection(false);
            }
        }
    }
    /**
     * Gets selected table content
     * @private
     */
    getSelectedCellsInTable(table, startCell, endCell) {
        let startColumnIndex = startCell.columnIndex;
        let endColumnIndex = endCell.columnIndex + endCell.cellFormat.columnSpan - 1;
        let startRowindex = startCell.ownerRow.index;
        let endRowIndex = endCell.ownerRow.index;
        let cells = [];
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.index >= startRowindex && row.index <= endRowIndex) {
                for (let j = 0; j < row.childWidgets.length; j++) {
                    let cell = row.childWidgets[j];
                    if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                        cells.push(cell);
                    }
                }
            }
            if (row.index > endRowIndex) {
                break;
            }
        }
        return cells;
        // return html;
    }
    /**
     * Copies the selected content to clipboard.
     */
    copy() {
        if (this.isEmpty) {
            return;
        }
        this.copySelectedContent(false);
    }
    /**
     * @private
     */
    copySelectedContent(isCut) {
        if (isNullOrUndefined(this.owner.sfdtExportModule)) {
            return;
        }
        let startPosition = this.start;
        let endPosition = this.end;
        if (!this.isForward) {
            startPosition = this.end;
            endPosition = this.start;
        }
        /* tslint:disable:no-any */
        // tslint:disable-next-line:max-line-length
        let documentContent = this.owner.sfdtExportModule.write(startPosition.currentWidget, startPosition.offset, endPosition.currentWidget, endPosition.offset, true);
        /* tslint:enable:no-any */
        if (this.owner.editorModule) {
            this.owner.editorModule.copiedData = JSON.stringify(documentContent);
        }
        let html = this.htmlWriter.writeHtml(documentContent);
        this.copyToClipboard(html);
        if (isCut && this.owner.editorModule) {
            this.owner.editorModule.handleCut(this);
        }
        this.viewer.updateFocus();
    }
    /**
     * Copy content to clipboard
     * @private
     */
    copyToClipboard(htmlContent) {
        window.getSelection().removeAllRanges();
        let div = document.createElement('div');
        div.style.left = '-10000px';
        div.style.top = '-10000px';
        div.innerHTML = htmlContent;
        document.body.appendChild(div);
        let range = document.createRange();
        range.selectNodeContents(div);
        window.getSelection().addRange(range);
        let copySuccess = false;
        try {
            copySuccess = document.execCommand('copy');
        }
        catch (e) {
            // Copying data to Clipboard can potentially fail - for example, if another application is holding Clipboard open.
        }
        finally {
            window.getSelection().removeAllRanges();
            div.parentNode.removeChild(div);
            this.viewer.viewerContainer.focus();
        }
        return copySuccess;
    }
    // Caret implementation starts
    /**
     * Shows caret in current selection position.
     * @private
     */
    showCaret() {
        // tslint:disable-next-line:max-line-length
        let page = !isNullOrUndefined(this.viewer.currentPage) ? this.viewer.currentPage : this.viewer.currentRenderingPage;
        if (isNullOrUndefined(page) || this.viewer.isRowOrCellResizing || this.owner.enableImageResizerMode && this.owner.imageResizerModule.isImageResizerVisible) {
            return;
        }
        let left = page.boundingRectangle.x;
        let right = page.boundingRectangle.width * this.viewer.zoomFactor + left;
        if (!this.owner.enableImageResizerMode || !this.owner.imageResizerModule.isImageResizerVisible) {
            if (this.isHideSelection(this.start.paragraph)) {
                this.caret.style.display = 'none';
            }
            else if (this.isEmpty && (!this.owner.isReadOnlyMode || this.owner.enableCursorOnReadOnly)) {
                let caretLeft = parseInt(this.caret.style.left.replace('px', ''), 10);
                if (caretLeft < left || caretLeft > right) {
                    this.caret.style.display = 'none';
                }
                else {
                    this.caret.style.display = 'block';
                }
            }
            else if (this.isImageSelected && !this.owner.enableImageResizerMode) {
                this.caret.style.display = 'block';
            }
            else {
                if (this.caret.style.display === 'block' || isNullOrUndefined(this)) {
                    if (!this.viewer.isComposingIME) {
                        this.caret.style.display = 'none';
                    }
                }
            }
        }
        if (!isNullOrUndefined(this) && this.viewer.isTouchInput && !this.owner.isReadOnlyMode) {
            let caretStartLeft = parseInt(this.viewer.touchStart.style.left.replace('px', ''), 10) + 14;
            let caretEndLeft = parseInt(this.viewer.touchEnd.style.left.replace('px', ''), 10) + 14;
            let page = this.getSelectionPage(this.start);
            if (page) {
                if (caretEndLeft < left || caretEndLeft > right) {
                    this.viewer.touchEnd.style.display = 'none';
                }
                else {
                    this.viewer.touchEnd.style.display = 'block';
                }
                if (!this.isEmpty) {
                    left = page.boundingRectangle.x;
                    right = page.boundingRectangle.width * this.viewer.zoomFactor + left;
                }
                if (caretStartLeft < left || caretStartLeft > right) {
                    this.viewer.touchStart.style.display = 'none';
                }
                else {
                    this.viewer.touchStart.style.display = 'block';
                }
            }
        }
        else {
            this.viewer.touchStart.style.display = 'none';
            this.viewer.touchEnd.style.display = 'none';
        }
    }
    /**
     * To set the editable div caret position
     * @private
     */
    setEditableDivCaretPosition(index) {
        this.viewer.editableDiv.focus();
        let child = this.viewer.editableDiv.childNodes[this.viewer.editableDiv.childNodes.length - 1];
        if (child) {
            let range = document.createRange();
            range.setStart(child, index);
            range.collapse(true);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
        }
    }
    /**
     * Initializes caret.
     * @private
     */
    initCaret() {
        this.caret = createElement('div', {
            styles: 'position:absolute',
            className: 'e-de-blink-cursor e-de-cursor-animation'
        });
        this.viewer.viewerContainer.appendChild(this.caret);
    }
    /**
     * Updates caret position.
     * @private
     */
    updateCaretPosition() {
        let caretPosition = this.end.location;
        let page = this.getSelectionPage(this.end);
        if (page && !isNullOrUndefined(this.caret)) {
            this.caret.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor) + 'px';
            let caretInfo = this.updateCaretSize(this.owner.selection.end);
            let topMargin = caretInfo.topMargin;
            let caretHeight = caretInfo.height;
            let viewer = this.viewer;
            // tslint:disable-next-line:max-line-length
            let pageTop = (page.boundingRectangle.y - viewer.pageGap * (this.viewer.pages.indexOf(page) + 1)) * this.viewer.zoomFactor + viewer.pageGap * (this.viewer.pages.indexOf(page) + 1);
            this.caret.style.top = pageTop + (Math.round(caretPosition.y + topMargin) * this.viewer.zoomFactor) + 'px';
            if (this.owner.selection.characterFormat.baselineAlignment === 'Subscript') {
                this.caret.style.top = parseFloat(this.caret.style.top) + (parseFloat(this.caret.style.height) / 2) + 'px';
            }
            if (this.viewer.isTouchInput || this.viewer.touchStart.style.display !== 'none') {
                // tslint:disable-next-line:max-line-length
                this.viewer.touchStart.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor - 14) + 'px';
                this.viewer.touchStart.style.top = pageTop + ((caretPosition.y + caretInfo.height) * this.viewer.zoomFactor) + 'px';
                // tslint:disable-next-line:max-line-length
                this.viewer.touchEnd.style.left = page.boundingRectangle.x + (Math.round(caretPosition.x) * this.viewer.zoomFactor - 14) + 'px';
                this.viewer.touchEnd.style.top = pageTop + ((caretPosition.y + caretInfo.height) * this.viewer.zoomFactor) + 'px';
            }
        }
        this.showHidePasteOptions(this.caret.style.top, this.caret.style.left);
    }
    /**
     * @private
     */
    showHidePasteOptions(top, left) {
        if (this.isViewPasteOptions) {
            if (this.pasteElement && this.pasteElement.style.display === 'block') {
                return;
            }
            this.createPasteElement(top, left);
        }
        else if (this.pasteElement) {
            this.pasteElement.style.display = 'none';
        }
    }
    /**
     * @private
     */
    getRect(position) {
        let caretPosition = position.location;
        let page = this.getSelectionPage(position);
        if (page) {
            let viewer = this.viewer;
            let left = page.boundingRectangle.x + (Math.round(caretPosition.x) * viewer.zoomFactor);
            let pageGap = viewer.pageGap;
            // tslint:disable-next-line:max-line-length
            let pageTop = (page.boundingRectangle.y - pageGap * (page.index + 1)) * viewer.zoomFactor + pageGap * (page.index + 1);
            let top = pageTop + (Math.round(caretPosition.y) * viewer.zoomFactor);
            return new Point(left, top);
        }
        return new Point(0, 0);
    }
    /**
     * Gets current selected page
     * @private
     */
    getSelectionPage(position) {
        let lineWidget = this.getLineWidgetInternal(position.currentWidget, position.offset, true);
        if (lineWidget) {
            return this.getPage(lineWidget.paragraph);
        }
        return undefined;
    }
    /**
     * Updates caret size.
     * @private
     */
    updateCaretSize(textPosition, skipUpdate) {
        let topMargin = 0;
        let isItalic = false;
        let caret;
        let index = 0;
        let caretHeight = 0;
        if (this.characterFormat.italic) {
            isItalic = this.characterFormat.italic;
        }
        if (textPosition.paragraph.isEmpty()) {
            let paragraph = textPosition.paragraph;
            let bottomMargin = 0;
            let paragraphInfo = this.getParagraphMarkSize(paragraph, topMargin, bottomMargin);
            topMargin = paragraphInfo.topMargin;
            bottomMargin = paragraphInfo.bottomMargin;
            let height = paragraphInfo.height;
            caretHeight = topMargin < 0 ? topMargin + height : height;
            if (!skipUpdate) {
                this.caret.style.height = caretHeight * this.viewer.zoomFactor + 'px';
            }
            topMargin = 0;
        }
        else {
            let inlineInfo = textPosition.currentWidget.getInline(textPosition.offset, index);
            index = inlineInfo.index;
            let inline = inlineInfo.element;
            if (!isNullOrUndefined(inline)) {
                caret = this.getCaretHeight(inline, index, inline.characterFormat, true, topMargin, isItalic);
                caretHeight = caret.height;
                if (!skipUpdate) {
                    this.caret.style.height = caret.height * this.viewer.zoomFactor + 'px';
                }
            }
        }
        if (!skipUpdate) {
            if (isItalic) {
                this.caret.style.transform = 'rotate(13deg)';
            }
            else {
                this.caret.style.transform = '';
            }
        }
        return {
            'topMargin': topMargin,
            'height': caretHeight
        };
    }
    /**
     * Updates caret to page.
     * @private
     */
    updateCaretToPage(startPosition, endPage) {
        if (!isNullOrUndefined(endPage)) {
            this.viewer.selectionEndPage = endPage;
            if (this.owner.selection.isEmpty) {
                this.viewer.selectionStartPage = endPage;
            }
            else {
                // tslint:disable-next-line:max-line-length
                let startLineWidget = this.getLineWidgetParagraph(startPosition.offset, startPosition.paragraph.childWidgets[0]);
                //Gets start page.
                let startPage = this.getPage(startLineWidget.paragraph);
                if (!isNullOrUndefined(startPage)) {
                    this.viewer.selectionStartPage = startPage;
                }
            }
        }
        this.checkForCursorVisibility();
    }
    /**
     * Gets caret bottom position.
     * @private
     */
    getCaretBottom(textPosition, isEmptySelection) {
        let bottom = textPosition.location.y;
        if (textPosition.paragraph.isEmpty()) {
            let paragraph = textPosition.paragraph;
            let topMargin = 0;
            let bottomMargin = 0;
            let sizeInfo = this.getParagraphMarkSize(paragraph, topMargin, bottomMargin);
            topMargin = sizeInfo.topMargin;
            bottomMargin = sizeInfo.bottomMargin;
            bottom += sizeInfo.height;
            bottom += topMargin;
            if (!isEmptySelection) {
                bottom += bottomMargin;
            }
        }
        else {
            let index = 0;
            let inlineInfo = textPosition.paragraph.getInline(textPosition.offset, index);
            let inline = inlineInfo.element;
            index = inlineInfo.index;
            let topMargin = 0;
            let isItalic = false;
            // tslint:disable-next-line:max-line-length
            let caretHeightInfo = this.getCaretHeight(inline, index, inline.characterFormat, false, topMargin, isItalic);
            topMargin = caretHeightInfo.topMargin;
            isItalic = caretHeightInfo.isItalic;
            bottom += caretHeightInfo.height;
            if (isEmptySelection) {
                bottom -= HelperMethods.convertPointToPixel(this.viewer.layout.getAfterSpacing(textPosition.paragraph));
            }
        }
        return bottom;
    }
    /**
     * Checks for cursor visibility.
     * @param isTouch
     * @private
     */
    checkForCursorVisibility() {
        this.showCaret();
    }
    // caret implementation ends
    /**
     * Keyboard shortcuts
     * @private
     */
    // tslint:disable:max-func-body-length
    onKeyDownInternal(event, ctrl, shift, alt) {
        let key = event.which || event.keyCode;
        if (ctrl && !shift && !alt) {
            this.viewer.isControlPressed = true;
            switch (key) {
                // case 9:
                //     event.preventDefault();
                //     if (this.owner.acceptTab) {
                //         this.selection.handleTabKey(false, false);
                //     }
                //     break;
                case 35:
                    this.handleControlEndKey();
                    break;
                case 36:
                    this.handleControlHomeKey();
                    break;
                case 37:
                    this.handleControlLeftKey();
                    break;
                case 38:
                    this.handleControlUpKey();
                    break;
                case 39:
                    this.handleControlRightKey();
                    break;
                case 40:
                    this.handleControlDownKey();
                    break;
                case 65:
                    this.owner.selection.selectAll();
                    break;
                case 67:
                    event.preventDefault();
                    this.copy();
                    break;
                case 70:
                    event.preventDefault();
                    if (!isNullOrUndefined(this.owner.optionsPaneModule)) {
                        this.owner.optionsPaneModule.showHideOptionsPane(true);
                    }
                    break;
            }
        }
        else if (shift && !ctrl && !alt) {
            switch (key) {
                case 35:
                    this.handleShiftEndKey();
                    event.preventDefault();
                    break;
                case 36:
                    this.handleShiftHomeKey();
                    event.preventDefault();
                    break;
                case 37:
                    this.handleShiftLeftKey();
                    event.preventDefault();
                    break;
                case 38:
                    this.handleShiftUpKey();
                    event.preventDefault();
                    break;
                case 39:
                    this.handleShiftRightKey();
                    event.preventDefault();
                    break;
                case 40:
                    this.handleShiftDownKey();
                    event.preventDefault();
                    break;
            }
        }
        else if (shift && ctrl && !alt) {
            switch (key) {
                case 35:
                    this.handleControlShiftEndKey();
                    break;
                case 36:
                    this.handleControlShiftHomeKey();
                    break;
                case 37:
                    this.handleControlShiftLeftKey();
                    break;
                case 38:
                    this.handleControlShiftUpKey();
                    break;
                case 39:
                    this.handleControlShiftRightKey();
                    break;
                case 40:
                    this.handleControlShiftDownKey();
                    break;
            }
        }
        else {
            switch (key) {
                // case 9:
                //     event.preventDefault();
                //     if (this.owner.acceptTab) {
                //         this.handleTabKey(true, false);
                //     }
                //     break;             
                case 33:
                    event.preventDefault();
                    this.viewer.viewerContainer.scrollTop -= this.viewer.visibleBounds.height;
                    break;
                case 34:
                    event.preventDefault();
                    this.viewer.viewerContainer.scrollTop += this.viewer.visibleBounds.height;
                    break;
                case 35:
                    this.handleEndKey();
                    event.preventDefault();
                    break;
                case 36:
                    this.handleHomeKey();
                    event.preventDefault();
                    break;
                case 37:
                    this.handleLeftKey();
                    event.preventDefault();
                    break;
                case 38:
                    this.handleUpKey();
                    event.preventDefault();
                    break;
                case 39:
                    this.handleRightKey();
                    event.preventDefault();
                    break;
                case 40:
                    this.handleDownKey();
                    event.preventDefault();
                    break;
            }
        }
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.onKeyDownInternal(event, ctrl, shift, alt);
        }
        if (this.owner.searchModule) {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(this.owner.searchModule.searchHighlighters) && this.owner.searchModule.searchHighlighters.length > 0) {
                this.owner.searchModule.searchResults.clear();
            }
        }
        if (event.keyCode === 27 || event.which === 27) {
            if (!isNullOrUndefined(this.owner.optionsPaneModule)) {
                this.owner.optionsPaneModule.showHideOptionsPane(false);
            }
            if (this.owner.enableHeaderAndFooter) {
                this.disableHeaderFooter();
            }
        }
    }
    //#region Enable or disable Header Footer
    /**
     * @private
     */
    checkAndEnableHeaderFooter(point, pagePoint) {
        let page = this.viewer.currentPage;
        if (this.isCursorInsidePageRect(point, page)) {
            if (this.isCursorInHeaderRegion(point, page)) {
                if (this.owner.enableHeaderAndFooter) {
                    return false;
                }
                return this.enableHeadersFootersRegion(page.headerWidget);
            }
            if (this.isCursorInFooterRegion(point, page)) {
                if (this.owner.enableHeaderAndFooter) {
                    return false;
                }
                return this.enableHeadersFootersRegion(page.footerWidget);
            }
        }
        if (this.owner.enableHeaderAndFooter) {
            this.owner.enableHeaderAndFooter = false;
            this.viewer.updateTextPositionForSelection(pagePoint, 1);
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isCursorInsidePageRect(point, page) {
        if ((this.viewer.containerLeft + point.x) >= page.boundingRectangle.x &&
            (this.viewer.containerLeft + point.x) <= (page.boundingRectangle.x + (page.boundingRectangle.width * this.viewer.zoomFactor))) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isCursorInHeaderRegion(point, page) {
        let pageTop = this.getPageTop(page);
        let headerHeight = 0;
        let header = page.headerWidget;
        if (header) {
            headerHeight = (header.y + header.height);
        }
        let isEmpty = header.isEmpty && !this.owner.enableHeaderAndFooter;
        let topMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.topMargin);
        let pageHeight = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.pageHeight);
        let height = isEmpty ? topMargin : Math.min(Math.max(headerHeight, topMargin), pageHeight / 100 * 40);
        height = height * this.viewer.zoomFactor;
        if ((this.viewer.containerTop + point.y) >= pageTop && (this.viewer.containerTop + point.y) <= pageTop + height) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    isCursorInFooterRegion(point, page) {
        let pageRect = page.boundingRectangle;
        let pageTop = this.getPageTop(page);
        let pageBottom = pageTop + (pageRect.height * this.viewer.zoomFactor);
        let footerDistance = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.footerDistance);
        let footerHeight = 0;
        if (page.footerWidget) {
            footerHeight = page.footerWidget.height;
        }
        let bottomMargin = HelperMethods.convertPointToPixel(page.bodyWidgets[0].sectionFormat.bottomMargin);
        let isEmpty = page.footerWidget.isEmpty && !this.owner.enableHeaderAndFooter;
        let height = pageRect.height;
        if (isEmpty) {
            height = (height - bottomMargin) * this.viewer.zoomFactor;
        }
        else {
            // tslint:disable-next-line:max-line-length
            height = (height - Math.min(pageRect.height / 100 * 40, Math.max(footerHeight + footerDistance, bottomMargin))) * this.viewer.zoomFactor;
        }
        if ((this.viewer.containerTop + point.y) <= pageBottom && (this.viewer.containerTop + point.y) >= pageTop + height) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    enableHeadersFootersRegion(widget) {
        this.owner.enableHeaderAndFooter = true;
        this.updateTextPositionForBlockContainer(widget);
        this.shiftBlockOnHeaderFooterEnableDisable();
        return true;
    }
    /**
     * @private
     */
    shiftBlockOnHeaderFooterEnableDisable() {
        for (let i = 0; i < this.viewer.headersFooters.length; i++) {
            let headerFooter = this.viewer.headersFooters[i];
            let sectionFormat = this.getBodyWidgetInternal(i, 0).sectionFormat;
            for (let key of Object.keys(headerFooter)) {
                let widget = headerFooter[key];
                if (widget.isEmpty) {
                    this.owner.editor.shiftPageContent(widget.headerFooterType, sectionFormat);
                }
            }
        }
    }
    /**
     * @private
     */
    updateTextPositionForBlockContainer(widget) {
        let block = widget.firstChild;
        if (block instanceof TableWidget) {
            block = this.getFirstBlockInFirstCell(block);
        }
        this.selectParagraphInternal(block, true);
    }
    /**
     * Disable Header footer
     * @private
     */
    disableHeaderFooter() {
        let page = this.getPage(this.start.paragraph);
        this.updateTextPositionForBlockContainer(page.bodyWidgets[0]);
        this.owner.enableHeaderAndFooter = false;
        this.shiftBlockOnHeaderFooterEnableDisable();
    }
    //#endregion
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.contextTypeInternal)) {
            this.contextTypeInternal = undefined;
        }
        if (this.pasteDropDwn) {
            this.pasteDropDwn.destroy();
            this.pasteDropDwn = undefined;
        }
        this.caret = undefined;
        this.contextTypeInternal = undefined;
        this.upDownSelectionLength = undefined;
        this.viewer = undefined;
        this.owner = undefined;
    }
    /**
     * Navigates to the specified bookmark.
     * @param name
     * @param moveToStart
     * @private
     */
    navigateBookmark(name, moveToStart) {
        let bookmarks = this.viewer.bookmarks;
        if (bookmarks.containsKey(name)) {
            //bookmark start element
            let bookmrkElmnt = bookmarks.get(name);
            let offset = bookmrkElmnt.line.getOffset(bookmrkElmnt, 1);
            let startPosition = new TextPosition(this.viewer.owner);
            startPosition.setPositionParagraph(bookmrkElmnt.line, offset);
            if (moveToStart) {
                this.viewer.selection.selectRange(startPosition, startPosition);
            }
            else {
                //bookmark end element
                let bookmrkEnd = bookmrkElmnt.reference;
                let endoffset = bookmrkEnd.line.getOffset(bookmrkEnd, 0);
                let endPosition = new TextPosition(this.viewer.owner);
                endPosition.setPositionParagraph(bookmrkEnd.line, endoffset);
                //selects the bookmark range
                this.viewer.selection.selectRange(startPosition, endPosition);
            }
        }
    }
    /**
     * Selects the specified bookmark.
     * @param name
     */
    selectBookmark(name) {
        this.navigateBookmark(name);
    }
    /**
     * Returns the toc field from the selection.
     * @private
     */
    getTocField() {
        let paragraph = this.start.paragraph;
        let tocPara = undefined;
        while ((paragraph !== undefined && this.isTocStyle(paragraph))) {
            tocPara = paragraph;
            paragraph = paragraph.previousRenderedWidget;
        }
        if (tocPara !== undefined) {
            let lineWidget = tocPara.childWidgets[0];
            if (lineWidget !== undefined) {
                return lineWidget.children[0];
            }
        }
        return undefined;
    }
    /**
     * Returns true if the paragraph has toc style.
     */
    isTocStyle(paragraph) {
        let style = paragraph.paragraphFormat.baseStyle;
        return (style !== undefined && (style.name.toLowerCase().indexOf('toc') !== -1));
    }
    /**
     * @private
     */
    getElementsForward(lineWidget, startElement, endElement, bidi) {
        if (isNullOrUndefined(startElement)) {
            return undefined;
        }
        let elements = [];
        while (bidi && startElement && startElement !== endElement && startElement.nextElement && !startElement.isRightToLeft) {
            startElement = startElement.nextElement;
        }
        while (bidi && endElement && startElement !== endElement && endElement.previousElement && !endElement.isRightToLeft) {
            endElement = endElement.previousElement;
        }
        let elementIndex = lineWidget.children.indexOf(startElement);
        while (elementIndex >= 0) {
            for (let i = elementIndex; i > -1 && i < lineWidget.children.length; bidi ? i-- : i++) {
                let inlineElement = lineWidget.children[i];
                if (inlineElement.line === lineWidget) {
                    if (inlineElement === endElement) {
                        elements.push(inlineElement);
                        elementIndex = -1;
                        break;
                    }
                    else {
                        elements.push(inlineElement);
                    }
                }
                else {
                    elementIndex = -1;
                    break;
                }
            }
            // inline = inline !== null && inline.NextNode !== null ? (inline.NextNode as Inline).GetNextRenderedInline() : null;
            elementIndex = -1;
        }
        return elements.length === 0 ? undefined : elements;
    }
    // Gets the current line elements in inline reverse order from the end element.
    /**
     * @private
     */
    getElementsBackward(lineWidget, startElement, endElement, bidi) {
        let elements = [];
        while (bidi && startElement && startElement.previousElement && (!startElement.isRightToLeft
            || startElement instanceof TextElementBox && this.viewer.textHelper.isRTLText(startElement.text))) {
            startElement = startElement.previousElement;
        }
        let elementIndex = lineWidget.children.indexOf(startElement);
        while (elementIndex >= 0) {
            for (let i = elementIndex; i > -1 && i < lineWidget.children.length; bidi ? i++ : i--) {
                let inlineElement = lineWidget.children[i];
                if (inlineElement.line === lineWidget) {
                    elements.push(inlineElement);
                }
                else {
                    elementIndex = -1;
                    break;
                }
            }
            // inline = inline !== null && inline.NextNode !== null ? (inline.NextNode as Inline).GetNextRenderedInline() : null;
            elementIndex = -1;
        }
        return elements;
    }
    /**
     * Navigate to previous comment in the document.
     */
    navigatePreviousComment() {
        this.commentNavigateInternal(false);
    }
    /**
     * Navigate to next comment in the document.
     */
    navigateNextComment() {
        this.commentNavigateInternal(true);
    }
    commentNavigateInternal(next) {
        if (!this.viewer.currentSelectedComment) {
            if (this.viewer.comments.length === 0) {
                return;
            }
            this.viewer.currentSelectedComment = this.viewer.comments[0];
        }
        if (this.viewer.currentSelectedComment) {
            let comments = this.viewer.comments;
            let comment = this.viewer.currentSelectedComment;
            let index = comments.indexOf(comment);
            if (next) {
                comment = (index === (comments.length - 1)) ? comments[0] : comments[index + 1];
            }
            else {
                comment = index === 0 ? comments[comments.length - 1] : comments[index - 1];
            }
            this.viewer.currentSelectedComment = comment;
            this.selectComment(comment);
        }
    }
    /**
     * @private
     */
    selectComment(comment) {
        if (!isNullOrUndefined(comment)) {
            let startPosition = this.getElementPosition(comment.commentStart).startPosition;
            let endPosition = this.getElementPosition(comment.commentEnd).startPosition;
            this.selectPosition(startPosition, endPosition);
            if (this.owner.commentReviewPane) {
                this.owner.commentReviewPane.selectComment(comment);
            }
        }
    }
    /**
     * @private
     */
    updateEditRangeCollection() {
        if (this.editRangeCollection.length > 0) {
            this.editRangeCollection = [];
        }
        let editRangeStart;
        let everyOneArea;
        if (!this.viewer.isDocumentProtected) {
            for (let i = 0; i < this.viewer.editRanges.length; i++) {
                let user = this.viewer.editRanges.keys[i];
                editRangeStart = this.viewer.editRanges.get(user);
                for (let j = 0; j < editRangeStart.length; j++) {
                    this.editRangeCollection.push(editRangeStart[j]);
                }
            }
        }
        else {
            if (this.viewer.editRanges.containsKey(this.owner.currentUser)) {
                editRangeStart = this.viewer.editRanges.get(this.owner.currentUser);
                for (let j = 0; j < editRangeStart.length; j++) {
                    this.editRangeCollection.push(editRangeStart[j]);
                }
            }
            if (this.viewer.editRanges.containsKey('Everyone')) {
                let user = 'Everyone';
                everyOneArea = this.viewer.editRanges.get(user);
                for (let j = 0; j < everyOneArea.length; j++) {
                    this.editRangeCollection.push(everyOneArea[j]);
                }
            }
        }
    }
    //Restrict editing implementation starts
    /**
     * @private
     */
    onHighlight() {
        if (this.isHighlightEditRegion) {
            this.highlightEditRegion();
        }
        else {
            this.unHighlightEditRegion();
        }
        this.viewer.renderVisiblePages();
    }
    /**
     * @private
     */
    highlightEditRegion() {
        this.updateEditRangeCollection();
        if (!this.isHighlightEditRegion) {
            this.unHighlightEditRegion();
            return;
        }
        this.isHightlightEditRegionInternal = true;
        if (isNullOrUndefined(this.editRegionHighlighters)) {
            this.editRegionHighlighters = new Dictionary();
        }
        this.editRegionHighlighters.clear();
        for (let j = 0; j < this.editRangeCollection.length; j++) {
            this.highlightEditRegionInternal(this.editRangeCollection[j]);
        }
        this.isHightlightEditRegionInternal = false;
        this.viewer.updateScrollBars();
    }
    /**
     * @private
     */
    unHighlightEditRegion() {
        if (!isNullOrUndefined(this.editRegionHighlighters)) {
            this.editRegionHighlighters.clear();
            this.editRegionHighlighters = undefined;
        }
        this.isHightlightEditRegionInternal = false;
    }
    /**
     * @private
     */
    highlightEditRegionInternal(editRangeStart) {
        let positionInfo = this.getPosition(editRangeStart);
        let startPosition = positionInfo.startPosition;
        let endPosition = positionInfo.endPosition;
        // if (editRangeStart.user === this.owner.currentUser && editRangeStart.group === '') {
        this.isCurrentUser = true;
        // }
        this.highlightEditRegions(editRangeStart, startPosition, endPosition);
        this.isCurrentUser = false;
    }
    /**
     * Shows all the editing region, where current user can edit.
     */
    showAllEditingRegion() {
        if (this.editRangeCollection.length === 0) {
            this.updateEditRangeCollection();
        }
        this.viewer.clearSelectionHighlight();
        for (let j = 0; j < this.editRangeCollection.length; j++) {
            let editRangeStart = this.editRangeCollection[j];
            let positionInfo = this.getPosition(editRangeStart);
            let startPosition = positionInfo.startPosition;
            let endPosition = positionInfo.endPosition;
            this.highlightEditRegions(editRangeStart, startPosition, endPosition);
        }
    }
    highlightEditRegions(editRangeStart, startPosition, endPosition) {
        if (!editRangeStart.line.paragraph.isInsideTable) {
            this.highlight(editRangeStart.line.paragraph, startPosition, endPosition);
            if (this.isHighlightNext) {
                this.highlightNextBlock(this.hightLightNextParagraph, startPosition, endPosition);
                this.isHighlightNext = false;
                this.hightLightNextParagraph = undefined;
            }
        }
        else {
            let row = editRangeStart.line.paragraph.associatedCell.ownerRow;
            let cell = row.childWidgets[editRangeStart.columnFirst];
            for (let i = 0; i < cell.childWidgets.length; i++) {
                if (cell.childWidgets[i] instanceof ParagraphWidget) {
                    this.highlight(cell.childWidgets[i], startPosition, endPosition);
                    if (this.isHighlightNext) {
                        this.highlightNextBlock(this.hightLightNextParagraph, startPosition, endPosition);
                        this.isHighlightNext = false;
                        this.hightLightNextParagraph = undefined;
                    }
                }
            }
        }
    }
    /**
     * Navigate to next editing region, where current user can edit.
     */
    navigateToNextEditingRegion() {
        let editRange = this.getEditRangeStartElement();
        //Sort based on position
        for (let i = this.editRangeCollection.length - 1; i >= 0; i--) {
            for (let j = 1; j <= i; j++) {
                let nextPosition = this.getPosition(this.editRangeCollection[j - 1]).startPosition;
                let firstPosition = this.getPosition(this.editRangeCollection[j]).startPosition;
                if (nextPosition.isExistAfter(firstPosition)) {
                    let temp = this.editRangeCollection[j - 1];
                    this.editRangeCollection[j - 1] = this.editRangeCollection[j];
                    this.editRangeCollection[j] = temp;
                }
            }
        }
        let index = this.editRangeCollection.indexOf(editRange);
        let editRangeStart = index < this.editRangeCollection.length - 1 ?
            this.editRangeCollection[index + 1] : this.editRangeCollection[0];
        let positionInfo = this.getPosition(editRangeStart);
        let startPosition = positionInfo.startPosition;
        let endPosition = positionInfo.endPosition;
        this.selectRange(startPosition, endPosition);
    }
    /**
     * Highlight all the editing region, where current user can edit.
     */
    toggleEditingRegionHighlight() {
        this.isHighlightEditRegion = !this.isHighlightEditRegion;
    }
    /**
     * @private
     */
    getEditRangeStartElement() {
        for (let i = 0; i < this.editRangeCollection.length; i++) {
            let editStart = this.editRangeCollection[i];
            let position = this.getPosition(editStart);
            let start = position.startPosition;
            let end = position.endPosition;
            if ((this.start.isExistAfter(start) || this.start.isAtSamePosition(start))
                && (this.end.isExistBefore(end) || this.end.isAtSamePosition(end))) {
                return editStart;
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    isSelectionIsAtEditRegion(update) {
        if (!this.viewer.isDocumentProtected) {
            return false;
        }
        return this.checkSelectionIsAtEditRegion();
    }
    checkSelectionIsAtEditRegion() {
        for (let i = 0; i < this.editRangeCollection.length; i++) {
            let editRangeStart = this.editRangeCollection[i];
            let positionInfo = this.getPosition(editRangeStart);
            let startPosition = positionInfo.startPosition;
            let endPosition = positionInfo.endPosition;
            let start = this.start;
            let end = this.end;
            if (!this.isForward) {
                start = this.end;
                end = this.start;
            }
            if ((start.isExistAfter(startPosition) || start.isAtSamePosition(startPosition))
                && (end.isExistBefore(endPosition) || end.isAtSamePosition(endPosition))) {
                return true;
            }
        }
        return false;
    }
    getPosition(element) {
        let offset = element.line.getOffset(element, 1);
        let startPosition = new TextPosition(this.viewer.owner);
        startPosition.setPositionParagraph(element.line, offset);
        let endElement = element.editRangeEnd;
        offset = endElement.line.getOffset(endElement, 1);
        let endPosition = new TextPosition(this.viewer.owner);
        endPosition.setPositionParagraph(endElement.line, offset);
        return { 'startPosition': startPosition, 'endPosition': endPosition };
    }
    /**
     * @private
     */
    getElementPosition(element) {
        let offset = element.line.getOffset(element, 1);
        let startPosition = new TextPosition(this.viewer.owner);
        startPosition.setPositionParagraph(element.line, offset);
        return { 'startPosition': startPosition, 'endPosition': undefined };
    }
}

/**
 * Selection Export
 */

/**
 * @private
 */
class TextSearch {
    constructor(owner) {
        this.wordBefore = '\\b';
        this.wordAfter = '\\b';
        this.isHeader = false;
        this.isFooter = false;
        this.owner = owner;
    }
    get viewer() {
        return this.owner.viewer;
    }
    find(pattern, findOption) {
        return this.findNext(pattern, findOption, '0;0;0');
    }
    // tslint:disable-next-line:max-line-length   
    findNext(pattern, findOption, hierarchicalPosition) {
        if (typeof pattern === 'string') {
            pattern = this.stringToRegex(pattern, findOption);
        }
        if (hierarchicalPosition === undefined) {
            hierarchicalPosition = '0;0;0';
        }
        this.owner.searchModule.textSearchResults.clearResults();
        let results = this.owner.searchModule.textSearchResults;
        this.findDocument(results, pattern, true, findOption, hierarchicalPosition);
        return results.length > 0, results.currentSearchResult;
    }
    stringToRegex(textToFind, option) {
        if (textToFind.indexOf('\\') > -1) {
            textToFind = textToFind.split('\\').join('\\\\');
        }
        // tslint:disable-next-line:max-line-length
        if (textToFind.indexOf('(') > -1 || textToFind.indexOf(')') > -1 || textToFind.indexOf('.') > -1 || textToFind.indexOf('[') > -1 || textToFind.indexOf(']') > -1) {
            let text = '';
            for (let i = 0; i < textToFind.length; i++) {
                // tslint:disable-next-line:max-line-length
                if (textToFind[i] === '(' || textToFind[i] === ')' || textToFind[i] === '.' || textToFind[i] === '[' || textToFind[i] === ']') {
                    text += '\\' + textToFind[i];
                }
                else {
                    text += textToFind[i];
                }
            }
            textToFind = text;
        }
        if (option === 'WholeWord' || option === 'CaseSensitiveWholeWord') {
            textToFind = this.wordBefore + textToFind + this.wordAfter;
        }
        return new RegExp(textToFind, (option === 'CaseSensitive' || option === 'CaseSensitiveWholeWord') ? 'g' : 'ig');
    }
    isPatternEmpty(pattern) {
        let wordEmpty = this.wordBefore + this.wordAfter;
        let patternRegExp = pattern.toString();
        return (patternRegExp.length === 0 || patternRegExp === wordEmpty);
    }
    // tslint:disable-next-line:max-line-length     
    findAll(pattern, findOption, hierarchicalPosition) {
        if (typeof pattern === 'string') {
            pattern = this.stringToRegex(pattern, findOption);
        }
        if (hierarchicalPosition === undefined) {
            hierarchicalPosition = '0;0;0';
        }
        this.owner.searchModule.textSearchResults.clearResults();
        let results = this.owner.searchModule.textSearchResults;
        this.findDocument(results, pattern, false, findOption, hierarchicalPosition);
        if (results.length > 0 && results.currentIndex < 0) {
            results.currentIndex = 0;
        }
        if (!isNullOrUndefined(results.currentSearchResult)) {
            let eventArgs = { source: this.viewer.owner };
            this.viewer.owner.trigger('searchResultsChange', eventArgs);
            return results;
        }
        return undefined;
    }
    /**
     * Method to retrieve text from a line widget
     * @param  {ElementBox} inlineElement
     * @param {number} indexInInline
     * @param {boolean} includeNextLine
     * @private
     */
    getElementInfo(inlineElement, indexInInline, includeNextLine) {
        let inlines = inlineElement;
        let stringBuilder = '';
        let spans = new Dictionary();
        //tslint:disable no-constant-condition
        do {
            // tslint:disable-next-line:max-line-length 
            if (inlineElement instanceof TextElementBox && (!isNullOrUndefined(inlineElement.text) && inlineElement.text !== '')) {
                spans.add(inlineElement, stringBuilder.length);
                // IndexInInline Handled specifically for simple find operation to start from starting point
                if (inlineElement === inlines) {
                    stringBuilder = stringBuilder + (inlineElement.text.substring(indexInInline));
                }
                else {
                    stringBuilder = stringBuilder + (inlineElement.text);
                }
            }
            else if (inlineElement instanceof FieldElementBox) {
                let fieldBegin = inlineElement;
                if (!isNullOrUndefined(fieldBegin.fieldEnd)) {
                    // tslint:disable-next-line:max-line-length 
                    inlineElement = isNullOrUndefined(fieldBegin.fieldSeparator) ? fieldBegin.fieldEnd : fieldBegin.fieldSeparator;
                }
            }
            if (!isNullOrUndefined(inlineElement) && isNullOrUndefined(inlineElement.nextNode)) {
                break;
            }
            if (!isNullOrUndefined(inlineElement)) {
                if ((!isNullOrUndefined(includeNextLine) && !includeNextLine)) {
                    let elementBoxes = inlineElement.line.children;
                    let length = inlineElement.line.children.length;
                    if (elementBoxes.indexOf(inlineElement) < length - 1) {
                        inlineElement = inlineElement.nextNode;
                    }
                    else {
                        inlineElement = undefined;
                        break;
                    }
                }
                else {
                    inlineElement = inlineElement.nextNode;
                }
            }
        } while (true);
        let text = stringBuilder.toString();
        return { elementsWithOffset: spans, fullText: text };
    }
    /**
     * Method to update location for matched text
     * @param {RegExpExecArray} matches
     * @param {TextSearchResults} results
     * @param {Dictionary<TextElementBox, number>} textInfo
     * @param {number}indexInInline
     * @param {boolean} isInline
     * @param {boolean}isFirstMatch
     * @param {TextPosition}selectionEnd
     */
    // tslint:disable-next-line:max-line-length
    updateMatchedTextLocation(matches, results, textInfo, indexInInline, inlines, isFirstMatch, selectionEnd, startPosition) {
        for (let i = 0; i < matches.length; i++) {
            let match = matches[i];
            let isMatched;
            if (!(isNullOrUndefined(startPosition)) && match.index < startPosition) {
                continue;
            }
            let result = results.addResult();
            let spanKeys = textInfo.keys;
            for (let i = 0; i < spanKeys.length; i++) {
                let span = spanKeys[i];
                let startIndex = textInfo.get(span);
                let spanLength = span.length;
                // IndexInInline Handled specifically for simple find operation to start from starting point
                if (span === inlines) {
                    spanLength -= indexInInline;
                }
                if (isNullOrUndefined(result.start) && match.index < startIndex + spanLength) {
                    let index = match.index - startIndex;
                    // IndexInInline Handled specifically for simple find operation to start from starting point
                    if (span === inlines) {
                        index += indexInInline;
                    }
                    let offset = (span.line).getOffset(span, index);
                    result.start = this.getTextPosition(span.line, offset.toString());
                    result.start.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
                    result.start.setPositionParagraph(span.line, offset);
                }
                if (match.index + match[0].length <= startIndex + spanLength) {
                    let index = (match.index + match[0].length) - startIndex;
                    // IndexInInline Handled specifically for simple find operation to start from starting point
                    if (span === inlines) {
                        index += indexInInline;
                    }
                    let offset = (span.line).getOffset(span, index);
                    result.end = this.getTextPosition(span.line, offset.toString());
                    result.end.location = this.owner.selection.getPhysicalPositionInternal(span.line, offset, true);
                    result.end.setPositionParagraph(span.line, offset);
                    isMatched = true;
                    break;
                }
            }
            result.isHeader = this.isHeader;
            result.isFooter = this.isFooter;
            if (isFirstMatch) {
                results.currentIndex = 0;
                break;
                // tslint:disable-next-line:max-line-length   
            }
            else if (results.currentIndex < 0 && !isNullOrUndefined(selectionEnd) && (selectionEnd.isExistBefore(result.start) ||
                selectionEnd.isAtSamePosition(result.start))) {
                results.currentIndex = results.indexOf(result);
            }
            if (!isNullOrUndefined(startPosition) && isMatched) {
                break;
            }
        }
    }
    // tslint:disable-next-line:max-line-length     
    findDocument(results, pattern, isFirstMatch, findOption, hierachicalPosition) {
        if (this.isPatternEmpty(pattern)) {
            return;
        }
        if (findOption === undefined) {
            findOption = 'None';
        }
        let inline = undefined;
        let selectionEnd = undefined;
        if (hierachicalPosition !== undefined) {
            selectionEnd = this.owner.selection.end;
        }
        if (hierachicalPosition !== undefined && isFirstMatch && selectionEnd !== undefined && selectionEnd.paragraph !== undefined) {
            if (selectionEnd.paragraph instanceof ParagraphWidget) {
                let indexInInline = 0;
                // tslint:disable-next-line:max-line-length 
                // IndexInInline Handled specifically for simple find operation to start from starting point
                let inlineElement = selectionEnd.currentWidget.getInline(this.owner.selection.start.offset, indexInInline);
                inline = inlineElement.element;
                indexInInline = inlineElement.index;
                if (!isNullOrUndefined(inline)) {
                    let nextParagraphWidget = undefined;
                    // tslint:disable-next-line:max-line-length  
                    nextParagraphWidget = this.findInline(inline, pattern, findOption, indexInInline, isFirstMatch, results, selectionEnd);
                    while (results.length === 0 && !isNullOrUndefined(nextParagraphWidget)) {
                        while (!isNullOrUndefined(nextParagraphWidget) && nextParagraphWidget.childWidgets.length === 0) {
                            // tslint:disable-next-line:max-line-length 
                            nextParagraphWidget = this.owner.selection.getNextParagraph(nextParagraphWidget.containerWidget);
                        }
                        if (isNullOrUndefined(nextParagraphWidget)) {
                            break;
                        }
                        let lineWidget = nextParagraphWidget.childWidgets[0];
                        if (lineWidget.children[0] instanceof ListTextElementBox) {
                            inline = (lineWidget.children[2] instanceof TextElementBox) ? lineWidget.children[2] : undefined;
                        }
                        else {
                            inline = lineWidget.children[0];
                        }
                        if (isNullOrUndefined(inline)) {
                            break;
                        }
                        // tslint:disable-next-line:max-line-length  
                        nextParagraphWidget = this.findInline(inline, pattern, findOption, 0, isFirstMatch, results, selectionEnd);
                    }
                    if (results.length > 0) {
                        return;
                    }
                }
            }
        }
        let section;
        section = this.viewer.pages[0].bodyWidgets[0];
        while (!isNullOrUndefined(section) && section.childWidgets.length === 0) {
            section = section.nextWidget;
        }
        if (isNullOrUndefined(section) || section.childWidgets.length === 0) {
            return;
        }
        this.isHeader = false;
        this.isFooter = false;
        this.findInlineText(section, pattern, findOption, isFirstMatch, results, selectionEnd);
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let headerWidget = this.viewer.pages[i].headerWidget;
            if (!isNullOrUndefined(headerWidget)) {
                this.isHeader = true;
                this.isFooter = false;
                this.findInlineText(headerWidget, pattern, findOption, isFirstMatch, results, selectionEnd);
            }
        }
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let footerWidget = this.viewer.pages[i].footerWidget;
            if (!isNullOrUndefined(footerWidget)) {
                this.isHeader = false;
                this.isFooter = true;
                this.findInlineText(footerWidget, pattern, findOption, isFirstMatch, results, selectionEnd);
            }
        }
        if (isFirstMatch && !isNullOrUndefined(results) && results.length > 0) {
            return;
        }
    }
    // tslint:disable-next-line:max-line-length
    findInlineText(section, pattern, findOption, isFirstMatch, results, selectionEnd) {
        let paragraphWidget = this.owner.selection.getFirstParagraphBlock(section.childWidgets[0]);
        // tslint:disable-next-line:max-line-length 
        while (!isNullOrUndefined(paragraphWidget) && paragraphWidget.childWidgets.length === 1 && paragraphWidget.childWidgets[0].children.length === 0) {
            paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
        }
        while (!isNullOrUndefined(paragraphWidget) && paragraphWidget.childWidgets.length > 0) {
            let inlineElement = paragraphWidget.childWidgets[0];
            let inlineEle = inlineElement.children[0];
            if (isNullOrUndefined(inlineEle)) {
                break;
            }
            this.findInline(inlineEle, pattern, findOption, 0, isFirstMatch, results, selectionEnd);
            paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
            // tslint:disable-next-line:max-line-length 
            while (!isNullOrUndefined(paragraphWidget) && (paragraphWidget.childWidgets.length === 1) && paragraphWidget.childWidgets[0].children.length === 0) {
                paragraphWidget = this.owner.selection.getNextParagraphBlock(paragraphWidget);
            }
        }
        if (isFirstMatch && !isNullOrUndefined(results) && results.length > 0) {
            return;
        }
    }
    // tslint:disable-next-line:max-line-length     
    findInline(inlineElement, pattern, option, indexInInline, isFirstMatch, results, selectionEnd) {
        let inlines = inlineElement;
        let textInfo = this.getElementInfo(inlineElement, indexInInline);
        let text = textInfo.fullText;
        let matches = [];
        let spans = textInfo.elementsWithOffset;
        let matchObject;
        //tslint:disable no-conditional-assignment
        while (!isNullOrUndefined(matchObject = pattern.exec(text))) {
            matches.push(matchObject);
        }
        this.updateMatchedTextLocation(matches, results, spans, indexInInline, inlines, isFirstMatch, selectionEnd);
        if (isFirstMatch) {
            return undefined;
        }
        // tslint:disable-next-line:max-line-length
        let paragraphWidget = this.owner.selection.getNextParagraphBlock(inlineElement.line.paragraph);
        return paragraphWidget;
    }
    /**
     * Method to get text position
     * @param {LineWidget} lineWidget
     * @param {string} hierarchicalIndex
     * @private
     */
    getTextPosition(lineWidget, hierarchicalIndex) {
        let textPosition = new TextPosition(this.owner);
        let index = textPosition.getHierarchicalIndex(lineWidget, hierarchicalIndex);
        textPosition.setPositionForCurrentIndex(index);
        return textPosition;
    }
}
/**
 * @private
 */
class SearchWidgetInfo {
    constructor(left, width) {
        this.leftInternal = 0;
        this.widthInternal = 0;
        this.leftInternal = left;
        this.widthInternal = width;
    }
    get left() {
        return this.leftInternal;
    }
    set left(value) {
        this.leftInternal = value;
    }
    get width() {
        return this.widthInternal;
    }
    set width(value) {
        this.widthInternal = value;
    }
}

/**
 * @private
 */
class TextSearchResult {
    constructor(owner) {
        this.startIn = undefined;
        this.endIn = undefined;
        this.owner = owner;
    }
    get viewer() {
        return this.owner.viewer;
    }
    get start() {
        return this.startIn;
    }
    set start(value) {
        this.startIn = value;
    }
    get end() {
        return this.endIn;
    }
    set end(value) {
        this.endIn = value;
    }
    get text() {
        return this.viewer.selection.getTextInternal(this.start, this.end, false);
    }
    destroy() {
        this.start = undefined;
        this.end = undefined;
    }
}

/**
 * @private
 */
class TextSearchResults {
    constructor(owner) {
        this.currentIndex = -1;
        this.owner = owner;
    }
    get length() {
        if (this.innerList === undefined) {
            return 0;
        }
        return this.innerList.length;
    }
    get currentSearchResult() {
        if (this.innerList === undefined || this.currentIndex < 0 || this.currentIndex >= this.length) {
            return undefined;
        }
        return this.innerList[this.currentIndex];
    }
    addResult() {
        let textSearchResult = new TextSearchResult(this.owner);
        if (isNullOrUndefined(this.innerList)) {
            this.innerList = [];
        }
        this.innerList.push(textSearchResult);
        return textSearchResult;
    }
    clearResults() {
        this.currentIndex = -1;
        if (!isNullOrUndefined(this.innerList)) {
            for (let i = this.innerList.length - 1; i >= 0; i--) {
                this.innerList[i].destroy();
                this.innerList.splice(i, 1);
            }
        }
    }
    indexOf(result) {
        if (isNullOrUndefined(this.innerList)) {
            return -1;
        }
        return this.innerList.indexOf(result);
    }
    destroy() {
        if (!isNullOrUndefined(this.innerList)) {
            this.clearResults();
        }
        this.innerList = undefined;
    }
}

/**
 * Search Result info
 */
class SearchResults {
    /**
     * Gets the length of search results.
     * @aspType int
     * @blazorType int
     */
    get length() {
        return this.searchModule.textSearchResults.length;
    }
    /**
     * Gets the index of current search result.
     * @aspType int
     * @blazorType int
     */
    get index() {
        return this.searchModule.textSearchResults.currentIndex;
    }
    /**
     * Set the index of current search result.
     * @aspType int
     * @blazorType int
     */
    set index(value) {
        if (this.length === 0 || value < 0 || value > this.searchModule.textSearchResults.length - 1) {
            return;
        }
        this.searchModule.textSearchResults.currentIndex = value;
        this.navigate(value);
    }
    /**
     * @private
     */
    constructor(search) {
        this.searchModule = search;
    }
    /**
     * Replace text in current search result.
     * @param textToReplace text to replace
     * @private
     */
    replace(textToReplace) {
        if (this.index === -1) {
            return;
        }
        this.searchModule.replaceInternal(textToReplace);
    }
    /**
     * Replace all the instance of search result.
     * @param textToReplace text to replace
     */
    replaceAll(textToReplace) {
        if (this.index === -1) {
            return;
        }
        this.searchModule.replaceAllInternal(textToReplace);
    }
    /**
     * @private
     */
    navigate(index) {
        this.searchModule.navigate(this.searchModule.textSearchResults.currentSearchResult);
        this.searchModule.highlight(this.searchModule.textSearchResults);
    }
    /**
     * Clears all the instance of search result.
     */
    clear() {
        this.searchModule.textSearchResults.clearResults();
        this.searchModule.clearSearchHighlight();
        this.searchModule.viewer.renderVisiblePages();
    }
}

/**
 * Search module
 */
class Search {
    /**
     * @private
     */
    constructor(owner) {
        /**
         * @private
         */
        this.searchHighlighters = undefined;
        this.isHandledOddPageHeader = undefined;
        this.isHandledEvenPageHeader = undefined;
        this.isHandledOddPageFooter = undefined;
        this.isHandledEvenPageFooter = undefined;
        this.owner = owner;
        this.searchHighlighters = new Dictionary();
        this.textSearch = new TextSearch(this.owner);
        this.textSearchResults = new TextSearchResults(this.owner);
        this.searchResultsInternal = new SearchResults(this);
    }
    /**
     * @private
     */
    get viewer() {
        return this.owner.viewer;
    }
    /**
     * Gets the search results object.
     * @aspType SearchResults
     * @blazorType SearchResults
     */
    get searchResults() {
        return this.searchResultsInternal;
    }
    /**
     * Get the module name.
     */
    getModuleName() {
        return 'Search';
    }
    //#region Find & Find All
    /**
     * Finds the immediate occurrence of specified text from cursor position in the document.
     * @param  {string} text
     * @param  {FindOption} findOption? - Default value of ‘findOptions’ parameter is 'None'.
     * @private
     */
    find(text, findOptions) {
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        let result = this.textSearch.find(text, findOptions);
        if (!isNullOrUndefined(result)) {
            this.navigate(result);
        }
    }
    /**
     * Finds all occurrence of specified text in the document.
     * @param  {string} text
     * @param  {FindOption} findOption? - Default value of ‘findOptions’ parameter is 'None'.
     */
    findAll(text, findOptions) {
        if (isNullOrUndefined(text || text === '')) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        let results = this.textSearch.findAll(text, findOptions);
        if (!isNullOrUndefined(results) && results.length > 0) {
            this.navigate(results.innerList[results.currentIndex]);
            this.highlight(results);
        }
    }
    //#endregion
    //#region Replace and Replace All   
    /**
     * Replace the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResult} result
     * @param  {TextSearchResults} results
     * @private
     */
    replace(replaceText, result, results) {
        if (isNullOrUndefined(this.viewer.owner) || this.viewer.owner.isReadOnlyMode || isNullOrUndefined(results)) {
            return 0;
        }
        if (!isNullOrUndefined(this.viewer)) {
            this.clearSearchHighlight();
        }
        this.navigate(result);
        let endPosition = this.viewer.selection.start;
        let index = results.indexOf(result);
        if (index < 0) {
            return 0;
        }
        this.owner.editorModule.insertTextInternal(replaceText, true);
        let endTextPosition = result.end;
        let startPosition = new TextPosition(this.viewer.owner);
        startPosition.setPositionParagraph(endTextPosition.currentWidget, endPosition.offset - replaceText.length);
        this.viewer.selection.selectRange(endPosition, startPosition);
        let eventArgs = { source: this.viewer.owner };
        this.viewer.owner.trigger('searchResultsChange', eventArgs);
        return 1;
    }
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {FindOption} findOptions? - Default value of ‘findOptions’ parameter is FindOption.None.
     * @private
     */
    replaceInternal(textToReplace, findOptions) {
        if ((textToReplace === '' || isNullOrUndefined(textToReplace))) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        let textToFind = this.textSearchResults.currentSearchResult.text;
        let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(textToFind, findOptions);
        let index = this.owner.selection.end.getHierarchicalIndexInternal();
        let result = this.viewer.owner.searchModule.textSearch.findNext(pattern, findOptions, index);
        if (!isNullOrUndefined(result)) {
            this.navigate(result);
            this.textSearchResults.addResult();
            this.textSearchResults.innerList[0] = result;
            this.replace(textToReplace, result, this.textSearchResults);
            index = this.owner.selection.end.getHierarchicalIndexInternal();
            result = this.textSearch.findNext(textToFind, findOptions, index);
            if (result) {
                this.textSearchResults.addResult();
                this.textSearchResults.innerList[0] = result;
                this.navigate(result);
            }
        }
    }
    /**
     * Replace all the searched string with specified string
     * @param  {string} replaceText
     * @param  {TextSearchResults} results
     * @private
     */
    replaceAll(replaceText, results) {
        if (isNullOrUndefined(this.viewer.owner) || this.viewer.owner.isReadOnlyMode || isNullOrUndefined(results)) {
            return 0;
        }
        if (this.owner.editorHistory) {
            this.owner.editorHistory.initComplexHistory(this.owner.selection, 'ReplaceAll');
        }
        let count = results.length;
        this.viewer.owner.isLayoutEnabled = false;
        for (let i = count - 1; i >= 0; i--) {
            let result = results.innerList[i];
            this.navigate(results.innerList[i]);
            this.owner.editorModule.insertTextInternal(replaceText, true);
            if (result.isHeader || result.isFooter) {
                this.viewer.layout.updateHeaderFooterToParent(this.viewer.selection.start.paragraph.bodyWidget);
            }
            results.innerList[i].destroy();
        }
        if (this.owner.editorHistory && !isNullOrUndefined(this.owner.editorHistory.currentHistoryInfo)) {
            this.owner.editorHistory.updateComplexHistory();
        }
        else {
            this.owner.editorModule.updateComplexWithoutHistory(2);
        }
        this.searchResults.clear();
        return count;
    }
    /**
     * Find the textToFind string in current document and replace the specified string.
     * @param  {string} textToFind
     * @param  {string} textToReplace
     * @param  {FindOption} findOptions? - Default value of ‘findOptions’ parameter is FindOption.None.
     * @private
     */
    replaceAllInternal(textToReplace, findOptions) {
        if ((textToReplace === '' || isNullOrUndefined(textToReplace))) {
            return;
        }
        if (isNullOrUndefined(findOptions)) {
            findOptions = 'None';
        }
        if (this.textSearchResults.length > 0) {
            this.navigate(this.textSearchResults.innerList[this.textSearchResults.currentIndex]);
            this.highlight(this.textSearchResults);
            this.replaceAll(textToReplace, this.textSearchResults);
        }
    }
    //#endregion
    //#region Highlight Search Result
    /**
     * @private
     */
    navigate(textSearchResult) {
        if (textSearchResult) {
            let start = textSearchResult.start;
            let end = textSearchResult.end;
            if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.owner.selection) && !isNullOrUndefined(start) &&
                !isNullOrUndefined(end) && !isNullOrUndefined(start.paragraph) && !isNullOrUndefined(end.paragraph)) {
                this.owner.selection.selectRange(start, end);
            }
        }
    }
    /**
     * @private
     */
    highlight(textSearchResults) {
        this.searchHighlighters = new Dictionary();
        for (let i = 0; i < textSearchResults.innerList.length; i++) {
            let result = textSearchResults.innerList[i];
            this.highlightResult(result);
        }
        this.viewer.renderVisiblePages();
    }
    /**
     * @private
     */
    highlightResult(result) {
        this.highlightSearchResult(result.start.paragraph, result.start, result.end);
    }
    /**
     * Highlight search result
     * @private
     */
    // tslint:disable:max-func-body-length
    highlightSearchResult(paragraph, start, end) {
        let selectionStartIndex = 0;
        let selectionEndIndex = 0;
        let startElement = null;
        let endElement = null;
        // tslint:disable-next-line:max-line-length
        let lineWidget = this.viewer.selection.getStartLineWidget(paragraph, start, startElement, selectionStartIndex);
        selectionStartIndex = lineWidget.index;
        startElement = lineWidget.element;
        let startLineWidget = startElement ? startElement.line : paragraph.childWidgets[0];
        let endLine = this.viewer.selection.getEndLineWidget(end, endElement, selectionEndIndex);
        selectionEndIndex = endLine.index;
        endElement = endLine.element;
        let endLineWidget = endElement ? endElement.line :
            end.paragraph.childWidgets[end.paragraph.childWidgets.length - 1];
        let top = this.viewer.selection.getTop(startLineWidget);
        let left = this.viewer.selection.getLeftInternal(startLineWidget, startElement, selectionStartIndex);
        if (!isNullOrUndefined(startLineWidget) && startLineWidget === endLineWidget) {
            //find result ends in current line.
            let right = this.viewer.selection.getLeftInternal(endLineWidget, endElement, selectionEndIndex);
            let isRtlText = false;
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            let width = 0;
            width = Math.abs(right - left);
            if (!isRtlText && startElement instanceof TextElementBox) {
                isRtlText = startElement.isRightToLeft;
            }
            // Handled the highlighting approach as genric for normal and rtl text.
            if (isRtlText || paragraph.bidi) {
                // tslint:disable-next-line:max-line-length
                let elementBox = this.viewer.selection.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                if (elementBox && elementBox.length > 1) {
                    for (let i = 0; i < elementBox.length; i++) {
                        let element = elementBox[i];
                        let elementIsRTL = false;
                        let index = element instanceof TextElementBox ? element.length : 1;
                        if (element === startElement) {
                            left = this.viewer.selection.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, index);
                        }
                        else if (element === endElement) {
                            left = this.viewer.selection.getLeftInternal(startLineWidget, element, 0);
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, selectionEndIndex);
                        }
                        else {
                            left = this.viewer.selection.getLeftInternal(startLineWidget, element, 0);
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, index);
                        }
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top);
                    }
                }
                else {
                    this.createHighlightBorder(startLineWidget, width, isRtlText ? right : left, top);
                }
            }
            else {
                // Start element and end element will be in reverese for Bidi paragraph highlighting. 
                // So, the right is considered based on Bidi property. 
                this.createHighlightBorder(startLineWidget, width, left, top);
            }
        }
        else {
            if (!isNullOrUndefined(startLineWidget)) {
                if (paragraph !== startLineWidget.paragraph) {
                    paragraph = startLineWidget.paragraph;
                }
                let width = this.viewer.selection.getWidth(startLineWidget, true) - (left - startLineWidget.paragraph.x);
                // Handled the  highlighting approach as genric for normal and rtl text.
                if (paragraph.bidi || (startElement instanceof TextElementBox && startElement.isRightToLeft)) {
                    let right = 0;
                    // tslint:disable-next-line:max-line-length
                    let elementCollection = this.viewer.selection.getElementsForward(startLineWidget, startElement, endElement, paragraph.bidi);
                    if (elementCollection) {
                        let elementIsRTL = false;
                        for (let i = 0; i < elementCollection.length; i++) {
                            let element = elementCollection[i];
                            let index = element instanceof TextElementBox ? element.length : 1;
                            right = this.viewer.selection.getLeftInternal(startLineWidget, element, index);
                            elementIsRTL = false;
                            if (element === startElement) {
                                left = this.viewer.selection.getLeftInternal(startLineWidget, element, selectionStartIndex);
                            }
                            else {
                                left = this.viewer.selection.getLeftInternal(startLineWidget, element, 0);
                            }
                            if (element instanceof TextElementBox) {
                                elementIsRTL = element.isRightToLeft;
                            }
                            width = Math.abs(right - left);
                            this.createHighlightBorder(startLineWidget, width, elementIsRTL ? right : left, top);
                        }
                        // Highlight the Paragrph mark for last line.
                    }
                }
                else {
                    this.createHighlightBorder(startLineWidget, width, left, top);
                }
                let lineIndex = startLineWidget.paragraph.childWidgets.indexOf(startLineWidget);
                //Iterates to last item of paragraph or search result end.
                for (let i = 0; i < paragraph.childWidgets.length; i++) {
                    if (paragraph === startLineWidget.paragraph) {
                        lineIndex += 1;
                    }
                    this.highlightSearchResultParaWidget(paragraph, lineIndex, endLineWidget, endElement, selectionEndIndex);
                    if (paragraph === endLineWidget.paragraph) {
                        return;
                    }
                    else {
                        lineIndex = 0;
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    createHighlightBorder(lineWidget, width, left, top) {
        let findHighLight = this.addSearchHighlightBorder(lineWidget);
        let page = this.viewer.owner.selection.getPage(lineWidget.paragraph);
        let pageTop = page.boundingRectangle.y;
        let pageLeft = page.boundingRectangle.x;
        findHighLight.left = Math.ceil(left);
        top = Math.ceil(top);
        findHighLight.width = Math.floor(width);
        let height = Math.floor(lineWidget.height);
        let context = this.viewer.containerContext;
    }
    /**
     * Adds search highlight border.
     * @private
     */
    addSearchHighlightBorder(lineWidget) {
        let highlighters = undefined;
        let collection = this.searchHighlighters;
        if (collection.containsKey(lineWidget)) {
            highlighters = collection.get(lineWidget);
        }
        else {
            highlighters = [];
            collection.add(lineWidget, highlighters);
        }
        let searchHighlight = new SearchWidgetInfo(0, 0);
        highlighters.push(searchHighlight);
        return searchHighlight;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    highlightSearchResultParaWidget(widget, startIndex, endLine, endElement, endIndex) {
        let top = 0;
        let width = 0;
        let isRtlText = false;
        for (let j = startIndex; j < widget.childWidgets.length; j++) {
            let lineWidget = widget.childWidgets[j];
            if (j === startIndex) {
                top = this.viewer.selection.getTop(lineWidget);
            }
            let left = this.viewer.selection.getLeft(lineWidget);
            if (endElement instanceof TextElementBox) {
                isRtlText = endElement.isRightToLeft;
            }
            if (lineWidget === endLine) {
                //Selection ends in current line.
                let right = 0;
                // Handled the highlighting using the element box highlighting approach as genric for normal and rtl text.
                if (isRtlText || widget.bidi) {
                    // tslint:disable-next-line:max-line-length
                    let elementBox = this.viewer.selection.getElementsBackward(lineWidget, endElement, endElement, widget.bidi);
                    for (let i = 0; i < elementBox.length; i++) {
                        let element = elementBox[i];
                        let elementIsRTL = false;
                        left = this.viewer.selection.getLeftInternal(lineWidget, element, 0);
                        if (element === endElement) {
                            right = this.viewer.selection.getLeftInternal(lineWidget, element, endIndex);
                        }
                        else {
                            let index = element instanceof TextElementBox ? element.length : 1;
                            right = this.viewer.selection.getLeftInternal(lineWidget, element, index);
                        }
                        if (element instanceof TextElementBox) {
                            elementIsRTL = element.isRightToLeft;
                        }
                        width = Math.abs(right - left);
                        this.createHighlightBorder(lineWidget, width, elementIsRTL ? right : left, top);
                    }
                    return;
                }
                else {
                    right = this.viewer.selection.getLeftInternal(endLine, endElement, endIndex);
                    width = Math.abs(right - left);
                    this.createHighlightBorder(lineWidget, width, isRtlText ? right : left, top);
                    return;
                }
            }
            else {
                width = this.viewer.selection.getWidth(lineWidget, true) - (left - widget.x);
                this.createHighlightBorder(lineWidget, width, left, top);
                top += lineWidget.height;
            }
        }
    }
    //#endregion
    //#region Get find result view
    /**
     * @private
     */
    addSearchResultItems(result) {
        if (isNullOrUndefined(result) || result === '') {
            return;
        }
        if (isNullOrUndefined(this.owner.findResultsList)) {
            this.owner.findResultsList = [];
        }
        this.owner.findResultsList.push(result);
    }
    /**
     * @private
     */
    addFindResultView(textSearchResults) {
        for (let i = 0; i < textSearchResults.innerList.length; i++) {
            let result = textSearchResults.innerList[i];
            this.addFindResultViewForSearch(result);
        }
        this.isHandledOddPageHeader = true;
        this.isHandledOddPageFooter = true;
        this.isHandledEvenPageHeader = true;
        this.isHandledEvenPageFooter = true;
    }
    /**
     * @private
     */
    // tslint:disable:max-func-body-length
    addFindResultViewForSearch(result) {
        if (result.start != null && result.end != null && result.start.paragraph != null && result.end.paragraph != null) {
            let prefixText;
            let suffixtext;
            let currentText;
            let startIndex = 0;
            let inlineObj = result.start.currentWidget.getInline(result.start.offset, startIndex);
            let inline = inlineObj.element;
            startIndex = inlineObj.index;
            let prefix = '';
            let lastIndex = 0;
            if (inline instanceof FieldElementBox) {
                let elementInfo = this.owner.selection.getRenderedInline(inline, startIndex);
                if (elementInfo.element.nextNode instanceof TextElementBox) {
                    inline = elementInfo.element.nextNode;
                    startIndex = elementInfo.index;
                }
                else {
                    inline = elementInfo.element;
                    startIndex = elementInfo.index;
                }
            }
            let boxObj = this.owner.selection.getElementBoxInternal(inline, startIndex);
            let box = boxObj.element;
            startIndex = boxObj.index;
            if (box != null) {
                if (box instanceof TextElementBox && startIndex > 0) {
                    prefix = box.text.substring(0, startIndex);
                }
                let boxIndex = box.line.children.indexOf(box);
                // tslint:disable-next-line:max-line-length
                lastIndex = prefix.lastIndexOf(' ');
                while (lastIndex < 0 && boxIndex > 0 && box.line.children[boxIndex - 1] instanceof TextElementBox) {
                    prefix = box.line.children[boxIndex - 1].text + prefix;
                    boxIndex--;
                    lastIndex = prefix.lastIndexOf(' ');
                }
            }
            let shiftIndex = prefix.lastIndexOf('\v');
            if (shiftIndex > 0) {
                prefix = prefix.substring(0, shiftIndex);
            }
            else {
                lastIndex = prefix.lastIndexOf(' ');
                prefixText = lastIndex < 0 ? prefix : prefix.substring(lastIndex + 1);
            }
            currentText = result.text;
            let endIndex = 0;
            let endInlineObj = result.end.currentWidget.getInline(result.end.offset, endIndex);
            let endInline = endInlineObj.element;
            endIndex = endInlineObj.index;
            suffixtext = '';
            //Checks prefix element box is empty
            if (boxObj != null) {
                // Gets the element box using endIndex of the text and set as suffix
                boxObj = this.owner.selection.getElementBoxInternal(endInline, endIndex);
                box = boxObj.element;
                endIndex = boxObj.index;
            }
            //Checks suffix element box is empty.
            if (box != null) {
                if (box instanceof TextElementBox && endIndex < box.length) {
                    suffixtext = box.text.substring(endIndex);
                }
                let boxIndex = box.line.children.indexOf(box);
                // tslint:disable-next-line:max-line-length
                while (boxIndex + 1 < box.line.children.length && (box.line.children[boxIndex + 1] instanceof TextElementBox) || (box.line.children[boxIndex + 1] instanceof FieldElementBox)) {
                    if (box.line.children[boxIndex + 1] instanceof FieldElementBox) {
                        boxIndex = boxIndex + 2;
                    }
                    else {
                        suffixtext = suffixtext + box.line.children[boxIndex + 1].text;
                        boxIndex = boxIndex + 1;
                    }
                }
            }
            lastIndex = suffixtext.lastIndexOf(' ');
            suffixtext = suffixtext === '\v' ? suffixtext = '' : suffixtext;
            let headerFooterString = '';
            if (result.isHeader) {
                headerFooterString = '<span class="e-de-header-footer-list">' + 'Header' + ': ' + '</span>';
            }
            else if (result.isFooter) {
                headerFooterString = '<span class="e-de-header-footer-list">' + 'Footer' + ': ' + '</span>';
            }
            else {
                headerFooterString = '';
                headerFooterString = '';
                this.isHandledOddPageHeader = true;
                this.isHandledEvenPageHeader = true;
                this.isHandledOddPageFooter = true;
                this.isHandledEvenPageFooter = true;
            }
            let listElement = '';
            let page = result.viewer.selection.getPage(result.start.paragraph);
            if (isNullOrUndefined(this.isHandledEvenPageHeader) && isNullOrUndefined(this.isHandledEvenPageFooter)) {
                this.isHandledEvenPageHeader = true;
                this.isHandledEvenPageFooter = true;
            }
            else if (isNullOrUndefined(this.isHandledOddPageHeader) && isNullOrUndefined(this.isHandledOddPageFooter)) {
                this.isHandledOddPageHeader = true;
                this.isHandledOddPageFooter = true;
            }
            if (result.isHeader) {
                if (page.headerWidget.headerFooterType === 'FirstPageHeader' && page.bodyWidgets[0].sectionFormat.differentFirstPage) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                }
                else if (page.headerWidget.headerFooterType === 'EvenHeader' && this.isHandledEvenPageHeader) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledEvenPageHeader = false;
                    // tslint:disable-next-line:max-line-length
                }
                else if (page.headerWidget.headerFooterType === 'OddHeader' && this.isHandledOddPageHeader) {
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledOddPageHeader = false;
                }
            }
            else if (result.isFooter) {
                if (page.footerWidget.headerFooterType === 'FirstPageFooter' && page.bodyWidgets[0].sectionFormat.differentFirstPage) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                }
                else if (page.footerWidget.headerFooterType === 'EvenFooter' && this.isHandledEvenPageFooter) {
                    // tslint:disable-next-line:max-line-length
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledEvenPageFooter = false;
                    // tslint:disable-next-line:max-line-length
                }
                else if (page.footerWidget.headerFooterType === 'OddFooter' && this.isHandledOddPageFooter) {
                    listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
                    this.isHandledOddPageFooter = false;
                }
                // tslint:disable-next-line:max-line-length
            }
            else if (!result.isHeader && !result.isFooter) {
                listElement = '<li tabindex=0 class="e-de-search-result-item e-de-op-search-txt">' + headerFooterString + prefix + '<span class="e-de-op-search-word" style="pointer-events:none">' + result.text + '</span>' + suffixtext + '</li>';
            }
            this.addSearchResultItems(listElement);
        }
    }
    //#endregion
    /**
     * Clears search highlight.
     * @private
     */
    clearSearchHighlight() {
        if (!isNullOrUndefined(this.searchHighlighters)) {
            this.searchHighlighters.clear();
            this.searchHighlighters = undefined;
        }
        let eventArgs = { source: this.viewer.owner };
        this.viewer.owner.trigger('searchResultsChange', eventArgs);
    }
    /**
     * @private
     */
    destroy() {
        if (this.textSearchResults) {
            this.textSearchResults.destroy();
        }
    }
}

/**
 * Options Pane class.
 */
class OptionsPane {
    /**
     * Constructor for Options pane module
     * @param {LayoutViewer} layoutViewer
     * @private
     */
    constructor(layoutViewer) {
        /**
         * @private
         */
        this.isOptionsPaneShow = false;
        this.findOption = 'None';
        this.matchCase = undefined;
        this.wholeWord = undefined;
        // private regular: CheckBox = undefined;
        this.searchText = 'Navigation';
        this.resultsText = 'Results';
        this.messageDivText = 'No matches';
        this.replaceButtonText = 'Replace';
        this.replaceAllButtonText = 'Replace All';
        this.focusedIndex = -1;
        this.focusedElement = [];
        this.isOptionsPane = true;
        this.replacePaneText = 'Replace';
        this.findPaneText = 'Find';
        this.matchDivReplaceText = 'No matches';
        /**
         * @private
         */
        this.tabInstance = undefined;
        /**
         * @private
         */
        this.isReplace = false;
        /**
         * Gets selected tab item which tab is selected.
         * @param {SelectEventArgs} args - Specifies which tab will be opened.
         * @private
         */
        this.selectedTabItem = (args) => {
            let contentParent = this.findTab.getElementsByClassName('e-content').item(0);
            if (args.previousIndex !== args.selectedIndex) {
                let previousTab = contentParent.children[args.previousIndex];
                let nextTab = contentParent.children[args.selectedIndex];
                let element = previousTab.firstElementChild;
                element.parentElement.removeChild(element);
                nextTab.appendChild(element);
            }
            let selectedElement = contentParent.children[args.selectedIndex];
            if (!isNullOrUndefined(selectedElement)) {
                if (args.selectedIndex === 0) {
                    this.isOptionsPane = true;
                    this.onFindPane();
                }
                else {
                    this.isOptionsPane = false;
                    this.onReplacePane();
                }
            }
        };
        this.searchOptionChange = () => {
            this.clearSearchResultItems();
            this.viewer.owner.searchModule.clearSearchHighlight();
            let inputText = this.searchInput.value;
            if (inputText === '') {
                return;
            }
            let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(inputText, this.findOption);
            let endSelection = this.viewer.selection.end;
            let selectionIndex = endSelection.getHierarchicalIndexInternal();
            this.results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, selectionIndex);
            if (this.results != null && this.results.length > 0) {
                this.navigateSearchResult(false);
            }
            else {
                this.viewer.renderVisiblePages();
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'block';
                this.resultsListBlock.style.display = 'none';
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
            }
        };
        /**
         * Apply find option based on whole words value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        this.wholeWordsChange = (args) => {
            if (this.matchInput.checked && this.wholeInput.checked) {
                this.findOption = 'CaseSensitiveWholeWord';
            }
            else if (this.matchInput.checked && !(this.wholeInput.checked)) {
                this.findOption = 'CaseSensitive';
            }
            else if (!(this.matchInput.checked) && this.wholeInput.checked) {
                this.findOption = 'WholeWord';
            }
            else {
                this.findOption = 'None';
            }
            this.searchOptionChange();
        };
        /**
         * Apply find option based on match value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        this.matchChange = (args) => {
            if (this.matchInput.checked && this.wholeInput.checked) {
                this.findOption = 'CaseSensitiveWholeWord';
            }
            else if (!(this.matchInput.checked) && this.wholeInput.checked) {
                this.findOption = 'WholeWord';
            }
            else if (this.matchInput.checked && !(this.wholeInput.checked)) {
                this.findOption = 'CaseSensitive';
            }
            else {
                this.findOption = 'None';
            }
            this.searchOptionChange();
        };
        /**
         * Apply find options based on regular value.
         * @param {ChangeEventArgs} args - Specifies the search options value.
         * @private
         */
        // public regularChange = (args: ChangeEventArgs): void => {
        //     if (args.checked) {
        //         this.matchCase.element.parentElement.parentElement.classList.add('e-checkbox-disabled');
        //         this.wholeWord.element.parentElement.parentElement.classList.add('e-checkbox-disabled');
        //         this.matchCase.checked = false;
        //         this.wholeWord.checked = false;
        //         this.findOption = 'None';
        //         this.onKeyDownInternal();
        //     } else {
        //         this.matchCase.element.parentElement.parentElement.classList.remove('e-checkbox-disabled');
        //         this.wholeWord.element.parentElement.parentElement.classList.remove('e-checkbox-disabled');
        //     }
        // }
        // tslint:enable:no-any 
        /**
         * Binding events from the element when optins pane creation.
         * @private
         */
        this.onWireEvents = () => {
            this.searchIcon.addEventListener('click', this.searchIconClickInternal);
            this.navigateToNextResult.addEventListener('click', this.navigateNextResultButtonClick);
            this.navigateToPreviousResult.addEventListener('click', this.navigatePreviousResultButtonClick);
            this.searchInput.addEventListener('keydown', this.onKeyDown);
            this.searchInput.addEventListener('keyup', this.onEnableDisableReplaceButton);
            this.resultsListBlock.addEventListener('click', this.resultListBlockClick);
            this.closeButton.addEventListener('click', this.close);
            this.replaceButton.addEventListener('click', this.onReplaceButtonClick);
            this.replaceAllButton.addEventListener('click', this.onReplaceAllButtonClick);
        };
        /**
         * Enable find pane only.
         * @private
         */
        this.onFindPane = () => {
            this.replaceDiv.style.display = 'none';
            this.occurrenceDiv.style.display = 'none';
            if (!isNullOrUndefined(this.results) && this.results.length === 0) {
                this.resultsListBlock.innerHTML = '';
                this.resultsListBlock.style.display = 'none';
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
            }
            let height = this.isOptionsPane ? 215 : 292;
            let resultsContainerHeight = this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
            this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            this.replaceTabContentDiv.style.display = 'none';
            this.findDiv.style.display = 'block';
            this.messageDiv.style.display = 'block';
            this.focusedElement = [];
            // tslint:disable-next-line:max-line-length
            this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput);
            this.focusedIndex = 3;
            this.searchInput.select();
            this.getMessageDivHeight();
        };
        this.onEnableDisableReplaceButton = () => {
            if (this.searchInput.value.length !== 0) {
                this.replaceButton.disabled = false;
                this.replaceAllButton.disabled = false;
            }
            else {
                this.replaceButton.disabled = true;
                this.replaceAllButton.disabled = true;
            }
        };
        /**
         * Enable replace pane only.
         * @private
         */
        this.onReplacePane = () => {
            this.findDiv.style.display = 'block';
            this.replaceDiv.style.display = 'block';
            this.replaceTabContentDiv.style.display = 'block';
            let height = this.isOptionsPane ? 215 : 292;
            let resultsContainerHeight = this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
            this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            this.isOptionsPane = false;
            if (this.searchInput.value.length !== 0) {
                this.replaceButton.disabled = false;
                this.replaceAllButton.disabled = false;
            }
            else {
                this.replaceButton.disabled = true;
                this.replaceAllButton.disabled = true;
            }
            this.focusedElement = [];
            // tslint:disable-next-line:max-line-length
            this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput, this.replaceWith, this.replaceButton, this.replaceAllButton);
            this.focusedIndex = 9;
            if (this.searchInput.value === '') {
                this.searchInput.select();
            }
            else {
                this.replaceWith.select();
            }
            this.getMessageDivHeight();
        };
        /**
         * Fires on key down on options pane.
         * @param {KeyboardEvent} event - Specifies the focus of current element.
         * @private
         */
        this.onKeyDownOnOptionPane = (event) => {
            // if (event.keyCode === 70) {
            //     event.preventDefault();
            //     return;
            // }
            if (event.keyCode === 9) {
                event.preventDefault();
                let focusIndex = undefined;
                if (event.shiftKey) {
                    focusIndex = (this.focusedIndex === 0 || isNullOrUndefined(this.focusedIndex)) ?
                        this.focusedElement.length - 1 : this.focusedIndex - 1;
                }
                else {
                    focusIndex = (this.focusedElement.length - 1 === this.focusedIndex || isNullOrUndefined(this.focusedIndex)) ?
                        0 : this.focusedIndex + 1;
                }
                let element = this.focusedElement[focusIndex];
                element.focus();
                if (element instanceof HTMLInputElement) {
                    element.select();
                }
                this.focusedIndex = focusIndex;
                if (element instanceof HTMLLIElement) {
                    this.scrollToPosition(element);
                }
            }
            else if (event.keyCode === 13) {
                // tslint:disable-next-line:max-line-length
                if (event.target !== this.searchInput && event.target !== this.closeButton) {
                    event.preventDefault();
                    let index = this.focusedElement.indexOf(event.target);
                    if (index !== -1) {
                        let list = this.focusedElement[index];
                        list.click();
                        list.focus();
                        this.focusedIndex = index;
                    }
                }
            }
            else if (event.keyCode === 40 || event.keyCode === 38) {
                if (this.resultsListBlock.style.display !== 'none') {
                    let index;
                    let element;
                    if (event.keyCode === 40) {
                        if (this.focusedIndex > 7) {
                            if (this.focusedIndex + 1 < this.focusedElement.length) {
                                element = this.focusedElement[this.focusedIndex + 1];
                                element.focus();
                                this.focusedIndex = this.focusedIndex + 1;
                            }
                        }
                        else {
                            index = (this.focusedElement.length - this.resultsListBlock.children.length) + this.results.currentIndex + 1;
                            if (index < this.focusedElement.length) {
                                element = this.focusedElement[index];
                                element.focus();
                                this.focusedIndex = index;
                            }
                        }
                    }
                    else {
                        if (this.focusedIndex > 8) {
                            index = this.focusedIndex - 1;
                            element = this.focusedElement[index];
                            element.focus();
                            this.focusedIndex = index;
                        }
                    }
                }
            }
        };
        /**
         * Fires on replace.
         * @private
         */
        this.onReplaceButtonClick = () => {
            let optionsPane = this.optionsPane;
            let findText = this.searchInput.value;
            let replaceText = this.replaceWith.value;
            let results = this.viewer.owner.searchModule.textSearchResults;
            if (findText !== '' && !isNullOrUndefined(findText)) {
                if (this.viewer.owner.selection != null) {
                    let selectionText = this.viewer.owner.selection.text;
                    if (!this.viewer.owner.selection.isEmpty) {
                        if (this.viewer.owner.selection.isForward) {
                            this.viewer.owner.selection.selectContent(this.viewer.owner.selection.start, true);
                        }
                        else {
                            this.viewer.owner.selection.selectContent(this.viewer.owner.selection.end, true);
                        }
                    }
                    if (!isNullOrUndefined(results) && !isNullOrUndefined(results.currentSearchResult)) {
                        let result = results.currentSearchResult;
                        this.viewer.owner.searchModule.navigate(result);
                        if (result.text === selectionText) {
                            let replace = isNullOrUndefined(replaceText) ? '' : replaceText;
                            this.viewer.owner.searchModule.replace(replace, result, results);
                            let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(findText, this.findOption);
                            let endSelection = this.viewer.selection.end;
                            let index = endSelection.getHierarchicalIndexInternal();
                            // tslint:disable-next-line:max-line-length
                            this.viewer.owner.searchModule.textSearchResults = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
                            this.results = this.viewer.owner.searchModule.textSearchResults;
                            if (!isNullOrUndefined(this.results) && !isNullOrUndefined(this.results.currentSearchResult)) {
                                this.viewer.owner.searchModule.navigate(this.results.currentSearchResult);
                            }
                            else {
                                this.messageDiv.style.display = 'block';
                                this.messageDiv.innerHTML = this.localeValue.getConstant(this.matchDivReplaceText);
                            }
                            this.viewer.owner.findResultsList = [];
                            if (!isNullOrUndefined(this.results) && this.results.innerList.length > 0) {
                                this.navigateSearchResult(true);
                            }
                            else {
                                this.resultsListBlock.innerHTML = '';
                            }
                        }
                    }
                    else {
                        this.messageDiv.style.display = 'block';
                        this.messageDiv.innerHTML = this.localeValue.getConstant(this.matchDivReplaceText);
                    }
                }
            }
        };
        /**
         * Fires on replace all.
         * @private
         */
        this.onReplaceAllButtonClick = () => {
            this.replaceAll();
            this.resultsListBlock.style.display = 'none';
            this.messageDiv.innerHTML = '';
        };
        /**
         * Fires on search icon.
         * @private
         */
        this.searchIconClickInternal = () => {
            // tslint:disable:no-any 
            let inputElement = document.getElementById(this.viewer.owner.containerId + '_option_search_text_box');
            // tslint:enable:no-any
            let text = inputElement.value;
            if (text === '') {
                return;
            }
            if (this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                this.searchIcon.classList.add('e-de-op-search-icon');
                this.searchIcon.classList.remove('e-de-op-search-close-icon');
                inputElement.value = '';
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'block';
                this.resultsListBlock.style.display = 'none';
                this.matchDiv.style.display = 'none';
                this.occurrenceDiv.style.display = 'none';
                this.onEnableDisableReplaceButton();
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
                this.clearSearchResultItems();
                this.viewer.owner.searchModule.clearSearchHighlight();
                this.viewer.renderVisiblePages();
                return;
            }
            if (this.searchIcon.classList.contains('e-de-op-search-icon') && text.length >= 1) {
                this.searchIcon.classList.add('e-de-op-search-close-icon');
                this.searchIcon.classList.remove('e-de-op-search-icon');
                this.onEnableDisableReplaceButton();
            }
            this.clearSearchResultItems();
            this.viewer.owner.searchModule.clearSearchHighlight();
            let patterns = this.viewer.owner.searchModule.textSearch.stringToRegex(text, this.findOption);
            let endSelection = this.viewer.selection.end;
            let index = endSelection.getHierarchicalIndexInternal();
            this.results = this.viewer.owner.searchModule.textSearch.findAll(patterns, this.findOption, index);
            if (this.results != null && this.results.length > 0) {
                let start = this.results.innerList[this.results.currentIndex].start;
                let end = this.results.innerList[this.results.currentIndex].end;
                this.viewer.scrollToPosition(start, end, true);
                this.navigateSearchResult(false);
                this.getMessageDivHeight();
                let height = this.isOptionsPane ? 215 : 292;
                let resultsContainerHeight = this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
                this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            }
            else {
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'block';
                this.resultsListBlock.style.display = 'none';
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
            }
        };
        /**
         * Fires on getting next results.
         * @private
         */
        this.navigateNextResultButtonClick = () => {
            if (document.getElementById(this.viewer.owner.containerId + '_list_box_container') != null &&
                document.getElementById(this.viewer.owner.containerId + '_list_box_container').style.display !== 'none') {
                let selectionEnd = this.viewer.owner.selection.end;
                let nextResult;
                let currentIndex = 0;
                if (selectionEnd.isExistAfter(this.results.currentSearchResult.start)) {
                    currentIndex = this.results.currentIndex;
                }
                for (let i = currentIndex; i < this.results.length; i++) {
                    let result = this.results.innerList[i];
                    if (selectionEnd.isExistBefore(result.start) || selectionEnd.isAtSamePosition(result.start)) {
                        nextResult = result;
                        this.results.currentIndex = i;
                        break;
                    }
                }
                if (isNullOrUndefined(nextResult)) {
                    this.results.currentIndex = 0;
                    nextResult = this.results.innerList[0];
                }
                // tslint:disable-next-line:max-line-length
                this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (this.results.currentIndex + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
                this.updateListItems(nextResult);
                this.focusedIndex = this.focusedElement.indexOf(this.navigateToNextResult);
            }
        };
        /**
         * Fires on getting previous results.
         * @private
         */
        this.navigatePreviousResultButtonClick = () => {
            if (document.getElementById(this.viewer.owner.containerId + '_list_box_container') != null &&
                document.getElementById(this.viewer.owner.containerId + '_list_box_container').style.display !== 'none') {
                let previousResult;
                let selectionStart = this.viewer.owner.selection.start;
                let currentIndex = this.results.currentIndex;
                if (selectionStart.isExistAfter(this.results.currentSearchResult.start)) {
                    currentIndex = this.results.length - 1;
                }
                for (let i = currentIndex; i >= 0; i--) {
                    let result = this.results.innerList[i];
                    if (selectionStart.isExistAfter(result.start) || this.viewer.owner.selection.end.isAtSamePosition(result.start)) {
                        previousResult = result;
                        this.results.currentIndex = i;
                        break;
                    }
                }
                if (isNullOrUndefined(previousResult)) {
                    this.results.currentIndex = this.results.length - 1;
                    previousResult = this.results.innerList[this.results.currentIndex];
                }
                // tslint:disable-next-line:max-line-length
                this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (this.results.currentIndex + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
                this.updateListItems(previousResult);
                this.focusedIndex = this.focusedElement.indexOf(this.navigateToPreviousResult);
            }
        };
        /**
         * Fires on key down
         * @param {KeyboardEvent} event - Speficies key down actions.
         * @private
         */
        this.onKeyDown = (event) => {
            let code = event.which || event.keyCode;
            if (code === 13 && event.keyCode !== 9 && event.keyCode !== 40) {
                event.preventDefault();
                this.findDiv.style.height = '';
                this.onKeyDownInternal();
            }
            else if (code === 8 && (this.searchInput.value.length === 0)) {
                this.resultContainer.style.display = 'block';
            }
            else if (event.keyCode !== 9 && event.keyCode !== 40 && event.keyCode !== 27) {
                this.viewer.owner.searchModule.clearSearchHighlight();
                this.clearSearchResultItems();
                this.viewer.renderVisiblePages();
                this.resultsListBlock.style.display = 'none';
                this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
                this.resultContainer.style.display = 'none';
                this.clearFocusElement();
                this.resultsListBlock.innerHTML = '';
                if (this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                    this.searchIcon.classList.add('e-de-op-search-icon');
                    this.searchIcon.classList.remove('e-de-op-search-close-icon');
                }
            }
            else if (code === 27 && event.keyCode === 27) {
                this.showHideOptionsPane(false);
            }
        };
        /**
         * Close the optios pane.
         * @private
         */
        this.close = () => {
            this.clearFocusElement();
            this.showHideOptionsPane(false);
            this.resultsListBlock.innerHTML = '';
            this.focusedIndex = 1;
            this.isOptionsPane = true;
        };
        /**
         * Fires on results list block.
         * @param {MouseEvent} args - Specifies which list was clicked.
         * @private
         */
        this.resultListBlockClick = (args) => {
            let currentlist = args.target;
            let element = this.resultsListBlock.children;
            let index = 0;
            for (let i = 0; i < element.length; i++) {
                let list = element[i];
                if (list.classList.contains('e-de-search-result-hglt')) {
                    list.classList.remove('e-de-search-result-hglt');
                    list.children[0].classList.remove('e-de-op-search-word-text');
                    list.classList.add('e-de-search-result-item');
                }
            }
            let list;
            for (let i = 0; i < element.length; i++) {
                if (currentlist === element[i]) {
                    index = i;
                    list = element[i];
                    if (list.classList.contains('e-de-search-result-item')) {
                        list.classList.remove('e-de-search-result-item');
                        list.classList.add('e-de-search-result-hglt');
                        list.children[0].classList.add('e-de-op-search-word-text');
                        this.focusedIndex = this.focusedElement.indexOf(list);
                    }
                }
            }
            let currentelement = this.results.innerList[index];
            this.results.currentIndex = index;
            // tslint:disable-next-line:max-line-length
            this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (index + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
            this.viewer.owner.searchModule.navigate(currentelement);
            this.viewer.owner.searchModule.highlight(this.results);
            list.focus();
        };
        this.viewer = layoutViewer;
    }
    /**
     * Get the module name.
     */
    getModuleName() {
        return 'OptionsPane';
    }
    /**
     * Initialize the options pane.
     * @param {L10n} localeValue - Specifies the localization based on culture.
     * @private
     */
    // tslint:disable:max-func-body-length
    initOptionsPane(localeValue, isRtl) {
        let viewer = this.viewer;
        this.localeValue = localeValue;
        this.optionsPane = createElement('div', { className: 'e-de-op', styles: 'display:none;' });
        this.optionsPane.addEventListener('keydown', this.onKeyDownOnOptionPane);
        this.searchDiv = createElement('div', {
            className: this.viewer.owner.containerId + '_searchDiv e-de-op-header',
            innerHTML: localeValue.getConstant(this.searchText)
        });
        this.optionsPane.appendChild(this.searchDiv);
        // tslint:disable-next-line:max-line-length
        this.closeButton = createElement('button', {
            className: 'e-de-op-close-button e-de-op-icon-btn e-btn e-flat e-icon-btn', id: 'close',
            attrs: { type: 'button' }
        });
        this.optionsPane.appendChild(this.closeButton);
        let closeSpan = createElement('span', { className: 'e-de-op-close-icon e-btn-icon e-icons' });
        this.closeButton.appendChild(closeSpan);
        this.focusedElement.push(this.closeButton);
        this.findTab = createElement('div', { id: this.viewer.owner.containerId + '_findTabDiv', className: 'e-de-op-tab' });
        this.optionsPane.appendChild(this.findTab);
        let tabHeader = createElement('div', { className: 'e-tab-header' });
        this.findTab.appendChild(tabHeader);
        this.findTabButton = createElement('div', { innerHTML: localeValue.getConstant(this.findPaneText) });
        this.focusedElement.push(this.findTabButtonHeader);
        tabHeader.appendChild(this.findTabButton);
        this.replaceTabButton = createElement('div', { innerHTML: localeValue.getConstant(this.replacePaneText) });
        this.focusedElement.push(this.replaceTabButtonHeader);
        tabHeader.appendChild(this.replaceTabButton);
        let tabContent = createElement('div', { className: 'e-content' });
        let findTabContent = createElement('div', { id: 'findTabContent' });
        tabContent.appendChild(findTabContent);
        this.findTabContentDiv = createElement('div', { className: 'e-de-search-tab-content' });
        this.searchTextBoxContainer = createElement('div', { className: 'e-input-group e-de-op-input-group' });
        this.findTabContentDiv.appendChild(this.searchTextBoxContainer);
        // tslint:disable-next-line:max-line-length
        this.searchInput = createElement('input', { className: 'e-input e-de-search-input', id: this.viewer.owner.containerId + '_option_search_text_box', attrs: { placeholder: localeValue.getConstant('Search for') } });
        this.searchTextBoxContainer.appendChild(this.searchInput);
        this.searchIcon = createElement('span', {
            className: 'e-de-op-icon e-de-op-search-icon e-input-group-icon e-icon',
            id: this.viewer.owner.containerId + '_search-icon'
        });
        this.searchIcon.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.searchIcon);
        this.focusedElement.push(this.searchIcon);
        // tslint:disable-next-line:max-line-length
        this.navigateToPreviousResult = createElement('span', { className: 'e-de-op-icon e-de-op-nav-btn e-arrow-up e-spin-up e-btn-icon e-icon e-input-group-icon' });
        this.navigateToPreviousResult.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.navigateToPreviousResult);
        this.focusedElement.push(this.navigateToPreviousResult);
        // tslint:disable-next-line:max-line-length
        this.navigateToNextResult = createElement('span', { className: 'e-de-op-icon e-de-op-nav-btn e-arrow-down e-spin-down e-btn-icon e-icon e-input-group-icon' });
        this.navigateToNextResult.tabIndex = 0;
        this.searchTextBoxContainer.appendChild(this.navigateToNextResult);
        this.focusedElement.push(this.navigateToNextResult);
        let div = createElement('div', { className: 'e-de-op-more-less' });
        this.matchInput = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_matchCase'
        });
        div.appendChild(this.matchInput);
        // tslint:disable-next-line:max-line-length
        this.matchCase = new CheckBox({ label: localeValue.getConstant('Match case'), enableRtl: isRtl, checked: false, change: this.matchChange });
        this.matchCase.appendTo(this.matchInput);
        this.focusedElement.push(this.matchInput);
        this.matchInput.tabIndex = 0;
        let wholeWordLabel;
        if (isRtl) {
            wholeWordLabel = '_e-de-rtl';
        }
        else {
            wholeWordLabel = '_e-de-ltr';
        }
        this.wholeInput = createElement('input', {
            attrs: { type: 'checkbox' },
            id: this.viewer.owner.containerId + '_wholeWord' + wholeWordLabel
        });
        div.appendChild(this.wholeInput);
        // tslint:disable-next-line:max-line-length
        this.wholeWord = new CheckBox({ label: localeValue.getConstant('Whole words'), enableRtl: isRtl, checked: false, change: this.wholeWordsChange });
        this.wholeWord.appendTo(this.wholeInput);
        this.focusedElement.push(this.wholeInput);
        this.wholeInput.tabIndex = 0;
        this.findTabContentDiv.appendChild(div);
        let replaceTabContent = createElement('div');
        tabContent.appendChild(replaceTabContent);
        this.replaceTabContentDiv = createElement('div', { className: 'e-de-op-replacetabcontentdiv', styles: 'display:none;' });
        tabContent.appendChild(this.replaceTabContentDiv);
        this.findTabContentDiv.appendChild(this.replaceTabContentDiv);
        this.createReplacePane(isRtl);
        this.findDiv = createElement('div', { className: 'findDiv', styles: 'display:block;' });
        findTabContent.appendChild(this.findTabContentDiv);
        this.resultContainer = createElement('div', { styles: 'width:85%;display:block;', className: 'e-de-op-result-container' });
        this.findDiv.appendChild(this.resultContainer);
        // tslint:disable-next-line:max-line-length
        this.messageDiv = createElement('div', { className: this.viewer.owner.containerId + '_messageDiv e-de-op-msg', innerHTML: this.localeValue.getConstant(this.messageDivText), id: this.viewer.owner.containerId + '_search_status' });
        this.resultContainer.appendChild(this.messageDiv);
        // tslint:disable-next-line:max-line-length
        this.resultsListBlock = createElement('div', { id: this.viewer.owner.containerId + '_list_box_container', styles: 'display:none;width:270px;list-style:none;padding-right:5px;overflow:auto;', className: 'e-de-result-list-block' });
        this.findDiv.appendChild(this.resultsListBlock);
        this.findTabContentDiv.appendChild(this.findDiv);
        this.findTab.appendChild(tabContent);
        this.tabInstance = new Tab({ enableRtl: isRtl, selected: this.selectedTabItem });
        this.tabInstance.appendTo(this.findTab);
        let findHeader = this.tabInstance.element.getElementsByClassName('e-item e-toolbar-item')[0];
        this.findTabButtonHeader = findHeader.getElementsByClassName('e-tab-wrap')[0];
        this.findTabButtonHeader.classList.add('e-de-op-find-tab-header');
        this.findTabButtonHeader.tabIndex = 0;
        let replaceHeader = this.tabInstance.element.getElementsByClassName('e-item e-toolbar-item')[1];
        this.replaceTabButtonHeader = replaceHeader.getElementsByClassName('e-tab-wrap')[0];
        this.replaceTabButtonHeader.classList.add('e-de-op-replace-tab-header');
        this.replaceTabButtonHeader.tabIndex = 0;
        this.onWireEvents();
        if (isRtl) {
            this.optionsPane.classList.add('e-de-rtl');
            this.closeButton.classList.add('e-de-rtl');
            this.searchDiv.classList.add('e-de-rtl');
            this.findTabButtonHeader.classList.add('e-de-rtl');
        }
    }
    /**
     * Create replace pane instances.
     */
    createReplacePane(isRtl) {
        this.replaceDiv = createElement('div');
        this.replaceTabContentDiv.appendChild(this.replaceDiv);
        this.replaceWith = createElement('input', {
            className: 'e-de-op-replacewith e-input',
            attrs: { placeholder: this.localeValue.getConstant('Replace with') }
        });
        this.replaceDiv.appendChild(this.replaceWith);
        let replaceButtonDivTextAlign;
        let replaceButtonMargin;
        if (isRtl) {
            replaceButtonDivTextAlign = 'text-align:left';
            replaceButtonMargin = 'margin-left:10px';
        }
        else {
            replaceButtonDivTextAlign = 'text-align:right';
            replaceButtonMargin = 'margin-right:10px';
        }
        let replaceButtonDiv = createElement('div', { styles: replaceButtonDivTextAlign, className: 'e-de-op-dlg-footer' });
        this.replaceDiv.appendChild(replaceButtonDiv);
        this.replaceButton = createElement('button', {
            className: 'e-control e-btn e-flat e-replace',
            styles: replaceButtonMargin,
            innerHTML: this.localeValue.getConstant(this.replaceButtonText),
            attrs: { type: 'button' }
        });
        replaceButtonDiv.appendChild(this.replaceButton);
        this.replaceAllButton = createElement('button', {
            className: 'e-control e-btn e-flat e-replaceall',
            innerHTML: this.localeValue.getConstant(this.replaceAllButtonText),
            attrs: { type: 'button' }
        });
        replaceButtonDiv.appendChild(this.replaceAllButton);
        this.matchDiv = createElement('div', { styles: 'display:none;padding-top:10px;' });
        this.replaceDiv.appendChild(this.matchDiv);
        let emptyDiv6 = createElement('div', { className: 'e-de-op-search-replacediv' });
        this.replaceDiv.appendChild(emptyDiv6);
        this.occurrenceDiv = createElement('div', { styles: 'display:none;' });
        this.replaceDiv.appendChild(this.occurrenceDiv);
    }
    navigateSearchResult(navigate) {
        if (navigate) {
            this.viewer.owner.searchModule.navigate(this.results.innerList[this.results.currentIndex]);
        }
        this.viewer.owner.searchModule.highlight(this.results);
        this.viewer.owner.searchModule.addFindResultView(this.results);
        this.resultsListBlock.style.display = 'block';
        this.resultContainer.style.display = 'block';
        let lists = this.viewer.owner.findResultsList;
        let text = '';
        for (let i = 0; i < lists.length; i++) {
            text += lists[i];
        }
        this.clearFocusElement();
        this.resultsListBlock.innerHTML = text;
        for (let i = 0; i < this.resultsListBlock.children.length; i++) {
            this.focusedElement.push(this.resultsListBlock.children[i]);
        }
        let currentIndexValue = this.results.currentIndex;
        // tslint:disable-next-line:max-line-length
        this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (currentIndexValue + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
        let listElement = this.resultsListBlock.children[currentIndexValue];
        if (listElement.classList.contains('e-de-search-result-item')) {
            listElement.classList.remove('e-de-search-result-item');
            listElement.classList.add('e-de-search-result-hglt');
            listElement.children[0].classList.add('e-de-op-search-word-text');
            this.scrollToPosition(listElement);
        }
    }
    /**
     * Fires on key down actions done.
     * @private
     */
    onKeyDownInternal() {
        // tslint:disable-next-line:max-line-length
        let inputElement = document.getElementById(this.viewer.owner.containerId + '_option_search_text_box');
        inputElement.blur();
        let text = inputElement.value;
        if (text === '') {
            return;
        }
        if (text.length >= 1 && this.searchIcon.classList.contains('e-de-op-search-icon')) {
            this.searchIcon.classList.add('e-de-op-search-close-icon');
            this.searchIcon.classList.remove('e-de-op-search-icon');
        }
        let height = this.isOptionsPane ? 215 : 292;
        let resultsContainerHeight = this.viewer.owner.getDocumentEditorElement().offsetHeight - height;
        this.clearSearchResultItems();
        this.viewer.owner.searchModule.clearSearchHighlight();
        let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(text, this.findOption);
        let endSelection = this.viewer.selection.end;
        let index = endSelection.getHierarchicalIndexInternal();
        this.results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
        let results = this.results;
        if (isNullOrUndefined(results)) {
            this.viewer.renderVisiblePages();
        }
        if (results != null && results.length > 0) {
            if ((this.focusedElement.indexOf(this.navigateToPreviousResult) === -1) && this.isOptionsPane) {
                this.focusedElement.push(this.navigateToPreviousResult);
            }
            if ((this.focusedElement.indexOf(this.navigateToNextResult) === -1) && this.isOptionsPane) {
                this.focusedElement.push(this.navigateToNextResult);
            }
            this.viewer.owner.searchModule.navigate(this.results.innerList[this.results.currentIndex]);
            this.viewer.owner.searchModule.highlight(results);
            this.viewer.owner.searchModule.addFindResultView(results);
            // if (this.isOptionsPane) {
            this.resultsListBlock.style.display = 'block';
            this.resultsListBlock.style.height = resultsContainerHeight + 'px';
            this.resultContainer.style.display = 'block';
            let list = this.viewer.owner.findResultsList;
            let text = '';
            this.clearFocusElement();
            this.resultsListBlock.innerHTML = '';
            for (let i = 0; i < list.length; i++) {
                text += list[i];
            }
            this.resultsListBlock.innerHTML = text;
            for (let i = 0; i < this.resultsListBlock.children.length; i++) {
                this.focusedElement.push(this.resultsListBlock.children[i]);
            }
            let lists = this.resultsListBlock.children;
            let currentIndex = this.results.currentIndex;
            // tslint:disable-next-line:max-line-length
            this.messageDiv.innerHTML = this.localeValue.getConstant('Result') + ' ' + (currentIndex + 1) + ' ' + this.localeValue.getConstant('of') + ' ' + this.resultsListBlock.children.length;
            let listElement = this.resultsListBlock.children[currentIndex];
            if (listElement.classList.contains('e-de-search-result-item')) {
                listElement.classList.remove('e-de-search-result-item');
                listElement.classList.add('e-de-search-result-hglt');
                listElement.children[0].classList.add('e-de-op-search-word-text');
            }
            this.navigateToNextResult.focus();
            this.focusedIndex = 6;
            this.getMessageDivHeight();
            // } else {
            //this.focusedIndex = 4;
            // }
        }
        else {
            this.messageDiv.innerHTML = this.localeValue.getConstant('No matches');
            this.resultContainer.style.display = 'block';
            this.resultsListBlock.style.display = 'none';
            this.clearFocusElement();
            this.resultsListBlock.innerHTML = '';
        }
    }
    getMessageDivHeight() {
        if (!this.isOptionsPane && this.messageDiv.classList.contains('e-de-op-msg')) {
            this.messageDiv.classList.add('e-de-op-replace-messagediv');
            this.messageDiv.classList.remove('e-de-op-msg');
        }
        else if (this.isOptionsPane && this.messageDiv.classList.contains('e-de-op-replace-messagediv')) {
            this.messageDiv.classList.add('e-de-op-msg');
            this.messageDiv.classList.remove('e-de-op-replace-messagediv');
        }
    }
    /**
     * Replace all.
     * @private
     */
    replaceAll() {
        let optionsPane = this.optionsPane;
        let findText = this.searchInput.value;
        let replaceText = this.replaceWith.value;
        if (findText !== '' && !isNullOrUndefined(findText)) {
            let pattern = this.viewer.owner.searchModule.textSearch.stringToRegex(findText, this.findOption);
            let endSelection = this.viewer.selection.end;
            let index = endSelection.getHierarchicalIndexInternal();
            let results = this.viewer.owner.searchModule.textSearch.findAll(pattern, this.findOption, index);
            let replace = isNullOrUndefined(replaceText) ? '' : replaceText;
            let count = isNullOrUndefined(results) ? 0 : results.length;
            this.viewer.owner.searchModule.replaceAll(replace, results);
            this.matchDiv.style.display = 'block';
            this.matchDiv.innerHTML = this.localeValue.getConstant('All Done') + '!';
            this.occurrenceDiv.style.display = 'block';
            // tslint:disable-next-line:max-line-length
            this.occurrenceDiv.innerHTML = this.localeValue.getConstant('We replaced all') + ' ' + count + ' ' + this.localeValue.getConstant('instances') + ' ' + this.localeValue.getConstant('of') + ' "' + findText + '" ' + this.localeValue.getConstant('with') + ' "' + replaceText + '" ';
        }
    }
    updateListItems(textSearchResult) {
        let searchElements = this.resultsListBlock.getElementsByClassName('e-de-search-result-hglt');
        for (let j = 0; j < searchElements.length; j++) {
            let list = searchElements[j];
            classList(list, ['e-de-search-result-item'], ['e-de-search-result-hglt']);
            classList(list.children[0], [], ['e-de-op-search-word-text']);
        }
        let listElement = this.resultsListBlock.children[this.results.currentIndex];
        classList(listElement, ['e-de-search-result-hglt'], ['e-de-search-result-item']);
        classList(listElement.children[0], ['e-de-op-search-word-text'], []);
        this.scrollToPosition(listElement);
        this.viewer.owner.searchModule.navigate(textSearchResult);
        this.viewer.owner.searchModule.highlight(this.results);
    }
    /**
     * Scrolls to position.
     * @param {HTMLElement} list - Specifies the list element.
     * @private
     */
    scrollToPosition(list) {
        let rect = list.getBoundingClientRect();
        let top;
        if (rect.top > 0) {
            top = rect.top - list.parentElement.getBoundingClientRect().top;
            if ((list.parentElement.offsetHeight - top) <= list.offsetHeight) {
                if (Math.ceil(top + list.offsetHeight) === list.parentElement.scrollHeight) {
                    list.parentElement.scrollTop = top;
                }
                list.parentElement.scrollTop = list.parentElement.scrollTop + (list.parentElement.offsetHeight / 100) * 30;
            }
            else if (top < 0) {
                list.parentElement.scrollTop = list.parentElement.scrollTop - (list.parentElement.offsetHeight / 100) * 30;
            }
        }
        else {
            list.parentElement.scrollTop = 0;
        }
    }
    /**
     * Clear the focus elements.
     * @private
     */
    clearFocusElement() {
        for (let i = 0; i < this.resultsListBlock.children.length; i++) {
            let index = this.focusedElement.indexOf(this.resultsListBlock.children[i]);
            if (index !== -1) {
                this.focusedElement.splice(index, 1);
            }
        }
        this.focusedIndex = 0;
    }
    /**
     * Show or hide option pane based on boolean value.
     * @param {boolean} show - Specifies showing or hiding the options pane.
     * @private
     */
    showHideOptionsPane(show) {
        if (!isNullOrUndefined(this.viewer.owner.selectionModule)) {
            if (show) {
                this.localeValue = new L10n('documenteditor', this.viewer.owner.defaultLocale);
                this.localeValue.setLocale(this.viewer.owner.locale);
                if (isNullOrUndefined(this.optionsPane)) {
                    this.initOptionsPane(this.localeValue, this.viewer.owner.enableRtl);
                    //Add Option Pane
                    let isRtl = this.viewer.owner.enableRtl;
                    let optionsPaneContainerStyle;
                    if (isRtl) {
                        optionsPaneContainerStyle = 'display:inline-flex;direction:rtl;';
                    }
                    else {
                        optionsPaneContainerStyle = 'display:inline-flex;';
                    }
                    this.viewer.optionsPaneContainer.setAttribute('style', optionsPaneContainerStyle);
                    // tslint:disable-next-line:max-line-length
                    this.viewer.optionsPaneContainer.insertBefore(this.viewer.owner.optionsPaneModule.optionsPane, this.viewer.viewerContainer);
                }
                this.optionsPane.style.display = 'block';
                if (this.viewer.owner.isReadOnlyMode) {
                    this.tabInstance.hideTab(1);
                }
                else {
                    this.tabInstance.hideTab(1, false);
                }
                if (this.isReplace && !this.viewer.owner.isReadOnlyMode) {
                    this.tabInstance.select(1);
                    this.isReplace = false;
                    this.isOptionsPane = false;
                }
                else {
                    this.tabInstance.select(0);
                }
                this.searchDiv.innerHTML = this.localeValue.getConstant(this.searchText);
                this.isOptionsPaneShow = true;
                // tslint:disable-next-line:max-line-length
                let textBox = document.getElementById(this.viewer.owner.getDocumentEditorElement().id + '_option_search_text_box');
                let selectedText = this.viewer.owner.selection.text;
                if (!isNullOrUndefined(selectedText)) {
                    let char = ['\v', '\r'];
                    let index = HelperMethods.indexOfAny(selectedText, char);
                    selectedText = index < 0 ? selectedText : selectedText.substring(0, index);
                }
                textBox.value = selectedText;
                textBox.select();
                this.messageDiv.innerHTML = '';
                if (this.searchIcon.classList.contains('e-de-op-search-close-icon')) {
                    this.searchIcon.classList.add('e-de-op-search-icon');
                    this.searchIcon.classList.remove('e-de-op-search-close-icon');
                }
                this.viewer.selection.caret.style.display = 'none';
                this.focusedIndex = 3;
                this.focusedElement = [];
                if (this.isOptionsPane) {
                    // tslint:disable-next-line:max-line-length
                    this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput);
                }
                else {
                    // tslint:disable-next-line:max-line-length
                    this.focusedElement.push(this.closeButton, this.findTabButtonHeader, this.replaceTabButtonHeader, this.searchInput, this.searchIcon, this.navigateToPreviousResult, this.navigateToNextResult, this.matchInput, this.wholeInput, this.replaceWith, this.replaceButton, this.replaceAllButton);
                }
                this.viewer.updateViewerSize();
            }
            else {
                if (!isNullOrUndefined(this.optionsPane)) {
                    this.clearSearchResultItems();
                    this.viewer.owner.searchModule.clearSearchHighlight();
                    this.isOptionsPaneShow = false;
                    let resultListBox = document.getElementById(this.viewer.owner.containerId + '_list_box_container');
                    let message = document.getElementById(this.viewer.owner.containerId + '_search_status');
                    if (!isNullOrUndefined(resultListBox) && !isNullOrUndefined(message)) {
                        resultListBox.style.display = 'none';
                        this.clearFocusElement();
                        resultListBox.innerHTML = '';
                        message.innerHTML = this.localeValue.getConstant('No matches');
                    }
                }
                this.viewer.updateViewerSize();
                if (!isNullOrUndefined(this.optionsPane)) {
                    if (this.optionsPane.style.display !== 'none') {
                        this.viewer.selection.updateCaretPosition();
                        this.optionsPane.style.display = 'none';
                    }
                }
                this.viewer.updateFocus();
                this.viewer.selection.caret.style.display = 'block';
            }
        }
    }
    /**
     * Clears search results.
     * @private
     */
    clearSearchResultItems() {
        if (!isNullOrUndefined(this.viewer.owner.findResultsList)) {
            this.viewer.owner.findResultsList = [];
        }
    }
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    destroy() {
        if (this.optionsPane) {
            this.optionsPane.innerHTML = '';
            this.optionsPane = undefined;
        }
        if (this.resultsListBlock) {
            this.resultsListBlock.innerHTML = '';
            this.resultsListBlock = undefined;
        }
        if (this.messageDiv) {
            this.messageDiv.innerHTML = '';
            this.messageDiv = undefined;
        }
        if (this.resultContainer) {
            this.resultContainer.innerHTML = '';
        }
        this.resultContainer = undefined;
        if (this.searchInput) {
            this.searchInput.value = '';
            this.searchInput = undefined;
        }
        if (this.searchDiv) {
            this.searchDiv.innerHTML = '';
            this.searchDiv = undefined;
        }
        if (this.searchTextBoxContainer) {
            this.searchTextBoxContainer.innerHTML = '';
            this.searchTextBoxContainer = undefined;
        }
        if (this.replaceWith) {
            this.replaceWith.innerHTML = '';
            this.replaceWith = undefined;
        }
        if (this.findDiv) {
            this.findDiv.innerHTML = '';
            this.findDiv = undefined;
        }
        if (this.replaceButton) {
            this.replaceButton.innerHTML = '';
            this.replaceButton = undefined;
        }
        if (this.replaceAllButton) {
            this.replaceAllButton.innerHTML = '';
            this.replaceAllButton = undefined;
        }
        if (this.matchInput) {
            this.matchInput.innerHTML = '';
            this.matchCase = undefined;
        }
        if (this.wholeInput) {
            this.wholeInput.innerHTML = '';
            this.wholeWord = undefined;
        }
        // if (this.regularInput) {
        //     this.regularInput.innerHTML = '';
        //     this.regular = undefined;
        // }
        if (!isNullOrUndefined(this.results)) {
            this.results.destroy();
        }
        if (this.focusedElement) {
            this.focusedElement = [];
        }
        this.focusedElement = undefined;
        this.destroyInternal();
    }
    /**
     * Dispose the internal objects which are maintained.
     */
    destroyInternal() {
        if (this.searchText) {
            this.searchText = undefined;
        }
        if (this.resultsText) {
            this.resultsText = undefined;
        }
        if (this.messageDivText) {
            this.messageDivText = undefined;
        }
        if (this.replaceButtonText) {
            this.replaceButtonText = undefined;
        }
        if (this.replaceAllButtonText) {
            this.replaceAllButtonText = undefined;
        }
    }
}

/**
 * Search Export
 */

/**
 * @private
 */
class TableResizer {
    /**
     * @private
     */
    constructor(node) {
        this.resizeNode = 0;
        this.resizerPosition = -1;
        this.currentResizingTable = undefined;
        this.owner = node;
        this.startingPoint = new Point(0, 0);
    }
    /**
     * @private
     */
    get viewer() {
        return this.owner.viewer;
    }
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'TableResizer';
    }
    /**
     * @private
     */
    updateResizingHistory(touchPoint) {
        if (this.owner.editorHistory) {
            this.owner.editorHistory.updateResizingHistory(touchPoint, this);
        }
        this.viewer.isRowOrCellResizing = false;
        this.resizerPosition = -1;
    }
    handleResize(point) {
        this.owner.viewer.isRowOrCellResizing = true;
        this.startingPoint.x = point.x;
        this.startingPoint.y = point.y;
        //Initialize resizing history.
        this.owner.editorHistory.initResizingHistory(point, this);
    }
    //Table Resizing implementation starts
    /**
     * @private
     */
    isInRowResizerArea(touchPoint) {
        let position = this.getRowReSizerPosition(undefined, touchPoint);
        if (position === -1) {
            return false;
        }
        else {
            this.resizeNode = 1;
            this.resizerPosition = position;
            return true;
        }
    }
    isInCellResizerArea(touchPoint) {
        let position = this.getCellReSizerPosition(touchPoint);
        if (position === -1) {
            return false;
        }
        else {
            this.resizeNode = 0;
            this.resizerPosition = position;
            return true;
        }
    }
    /**
     * Gets cell resizer position.
     * @param {Point} point
     * @private
     */
    getCellReSizerPosition(touchPoint) {
        let position = -1;
        let resizerBoundaryWidth = 2;
        let tableWidget = this.getTableWidget(touchPoint);
        let cellWidget = this.getTableCellWidget(touchPoint);
        let cellSpacing = isNullOrUndefined(tableWidget) ? 0 : tableWidget.tableFormat.cellSpacing;
        if (tableWidget && cellSpacing > 0) {
            this.currentResizingTable = tableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.viewer.isInsideRect(tableWidget.x - HelperMethods.convertPointToPixel(tableWidget.leftBorderWidth) - 0.25, tableWidget.y, HelperMethods.convertPointToPixel(tableWidget.leftBorderWidth) + 0.5, tableWidget.height, touchPoint)) {
                return position = 0;
            }
            let startingPointX = tableWidget.x;
            for (let i = 0; i < tableWidget.tableHolder.columns.length; i++) {
                let preferredWidth = HelperMethods.convertPointToPixel(tableWidget.tableHolder.columns[i].preferredWidth);
                // tslint:disable-next-line:max-line-length
                if ((this.viewer.isInsideRect(startingPointX - 1, tableWidget.y, tableWidget.leftBorderWidth + resizerBoundaryWidth, tableWidget.height, touchPoint))) {
                    return position = i > 0 ? i : 0;
                    // tslint:disable-next-line:max-line-length
                }
                else if (i > 0 && (this.viewer.isInsideRect(startingPointX + preferredWidth - resizerBoundaryWidth / 2, tableWidget.y, resizerBoundaryWidth, tableWidget.height, touchPoint))) {
                    return position = (i + 1);
                }
                startingPointX = startingPointX + preferredWidth;
            }
        }
        else {
            if (!isNullOrUndefined(cellWidget)) {
                this.currentResizingTable = cellWidget.ownerTable;
                // tslint:disable-next-line:max-line-length
                if (this.viewer.isInsideRect(cellWidget.x - cellWidget.margin.left - resizerBoundaryWidth / 2, cellWidget.y - cellWidget.margin.top, resizerBoundaryWidth, cellWidget.height, touchPoint)) {
                    return position = cellWidget.columnIndex;
                    // tslint:disable-next-line:max-line-length
                }
                else if (isNullOrUndefined(cellWidget.nextRenderedWidget)
                    && this.viewer.isInsideRect(cellWidget.x + cellWidget.margin.right + cellWidget.width - resizerBoundaryWidth / 2, cellWidget.y - cellWidget.margin.top, resizerBoundaryWidth, cellWidget.height, touchPoint)) {
                    return position = (cellWidget.columnIndex + cellWidget.cellFormat.columnSpan);
                }
                else if (cellWidget.childWidgets.length > 0) {
                    return this.getCellReSizerPositionInternal(cellWidget, touchPoint); // Gets the nested table resizer position.
                }
            }
        }
        return position;
    }
    /**
     * Gets cell resizer position.
     * @param {TableCellWidget} cellWidget
     * @param {Point} touchPoint
     */
    getCellReSizerPositionInternal(cellWidget, touchPoint) {
        let position = -1;
        let childTableWidget = this.getTableWidgetFromWidget(touchPoint, cellWidget);
        let childCellWidget = undefined;
        if (!isNullOrUndefined(childTableWidget) && childTableWidget.tableFormat.cellSpacing > 0) {
            this.currentResizingTable = childTableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.viewer.isInsideRect(childTableWidget.x - childTableWidget.leftBorderWidth - 0.25, childTableWidget.y, childTableWidget.leftBorderWidth + 0.5, childTableWidget.height, touchPoint)) {
                return position = 0;
            }
            let startingPointX = childTableWidget.x;
            for (let i = 0; i < childTableWidget.tableHolder.columns.length; i++) {
                // tslint:disable-next-line:max-line-length
                let preferredWidth = HelperMethods.convertPointToPixel(childTableWidget.tableHolder.columns[i].preferredWidth);
                // tslint:disable-next-line:max-line-length
                if ((this.viewer.isInsideRect(startingPointX - 1, childTableWidget.y, childTableWidget.leftBorderWidth + 2, childTableWidget.height, touchPoint))) {
                    return position = i > 0 ? i : 0;
                    // tslint:disable-next-line:max-line-length
                }
                else if (i > 0 && (this.viewer.isInsideRect(startingPointX + preferredWidth - 1, childTableWidget.y, 2, childTableWidget.height, touchPoint))) {
                    return position = (i + 1);
                }
                startingPointX = startingPointX + preferredWidth;
            }
        }
        else {
            if (!isNullOrUndefined(childTableWidget)) {
                childCellWidget = childTableWidget.getTableCellWidget(touchPoint);
            }
            if (!isNullOrUndefined(childCellWidget)) {
                this.currentResizingTable = childCellWidget.ownerTable;
                // tslint:disable-next-line:max-line-length
                if (this.viewer.isInsideRect(childCellWidget.x - childCellWidget.margin.left - 1, childCellWidget.y - childCellWidget.margin.top, 2, childCellWidget.height, touchPoint)) {
                    return position = childCellWidget.columnIndex;
                }
                else if (isNullOrUndefined(childCellWidget.nextRenderedWidget)
                    // tslint:disable-next-line:max-line-length
                    && this.viewer.isInsideRect(childCellWidget.x + childCellWidget.margin.right + childCellWidget.width - 1, childCellWidget.y - childCellWidget.margin.top, 2, childCellWidget.height, touchPoint)) {
                    return position = (childCellWidget.columnIndex + childCellWidget.cellFormat.columnSpan);
                }
                else if (childCellWidget.childWidgets.length > 0) {
                    return this.getCellReSizerPositionInternal(childCellWidget, touchPoint);
                }
            }
        }
        return position;
    }
    getRowReSizerPosition(widget, touchPoint) {
        let tableWidget = undefined;
        let cellWidget = undefined;
        if (isNullOrUndefined(widget)) {
            tableWidget = this.getTableWidget(touchPoint);
            cellWidget = this.getTableCellWidget(touchPoint);
        }
        else {
            tableWidget = this.getTableWidgetFromWidget(touchPoint, widget);
        }
        let cellSpacing = isNullOrUndefined(tableWidget) ? 0 : tableWidget.tableFormat.cellSpacing;
        if (tableWidget && cellSpacing > 0) {
            this.currentResizingTable = tableWidget;
            // tslint:disable-next-line:max-line-length
            if (this.owner.viewer.isInsideRect(tableWidget.x, tableWidget.y + tableWidget.height - cellSpacing, this.getActualWidth(tableWidget.lastChild), (isNullOrUndefined(tableWidget.nextSplitWidget) ? tableWidget.bottomBorderWidth + cellSpacing : 0), touchPoint)) {
                return tableWidget.lastChild.rowIndex;
            }
            for (let i = 0; i < tableWidget.childWidgets.length; i++) {
                //Need to consider for splitted widgets
                let rowWidget = tableWidget.childWidgets[i];
                if (tableWidget.childWidgets.indexOf(rowWidget) > -1
                    // tslint:disable-next-line:max-line-length
                    && (this.owner.viewer.isInsideRect(rowWidget.x, rowWidget.y + rowWidget.height + cellSpacing / 2, this.getActualWidth(rowWidget), cellSpacing / 2, touchPoint))) {
                    return rowWidget.rowIndex;
                }
            }
        }
        else {
            if (tableWidget && cellWidget) {
                cellWidget = this.getTableCellWidget(touchPoint);
            }
            if (cellWidget) {
                let rowWidget = cellWidget.containerWidget;
                let height = 0;
                if (rowWidget.rowIndex === rowWidget.ownerTable.childWidgets.length - 1) {
                    height = rowWidget.bottomBorderWidth + 2;
                }
                else {
                    height = rowWidget.nextRenderedWidget.topBorderWidth + 2;
                }
                // tslint:disable-next-line:max-line-length
                if (this.owner.viewer.isInsideRect(rowWidget.x, rowWidget.y + rowWidget.height - height, rowWidget.width, height * 2, touchPoint)) {
                    this.currentResizingTable = rowWidget.ownerTable;
                    return rowWidget.rowIndex;
                }
                else {
                    if (cellWidget.childWidgets.length > 0) {
                        return this.getRowReSizerPosition(cellWidget, touchPoint);
                    }
                }
            }
        }
        return -1;
    }
    /**
     * To handle Table Row and cell resize
     * @param touchPoint
     * @private
     */
    handleResizing(touchPoint) {
        let dragValue = 0;
        if (this.resizeNode === 0) {
            dragValue = touchPoint.x - this.startingPoint.x;
            this.resizeTableCellColumn(dragValue);
        }
        else {
            dragValue = touchPoint.y - this.startingPoint.y;
            this.resizeTableRow(dragValue);
        }
    }
    resizeTableRow(dragValue) {
        let table = this.currentResizingTable;
        if (isNullOrUndefined(table) || dragValue === 0 || this.resizerPosition === -1) {
            return;
        }
        let selection = this.owner.selection;
        if (table.isInsideTable) {
            this.owner.isLayoutEnabled = false; //Layouting is disabled to skip the child table layouting. 
        }
        let row = undefined;
        if (this.resizerPosition > -1) {
            row = table.childWidgets[this.resizerPosition];
            this.updateRowHeight(row, dragValue);
            selection.selectPosition(selection.start, selection.end);
        }
        if (table.isInsideTable) {
            let parentTable = this.owner.viewer.layout.getParentTable(table);
            this.owner.isLayoutEnabled = true; //layouting is enabled to layout the parent table of the nested table.
            table = parentTable;
        }
        this.startingPoint.y += HelperMethods.convertPointToPixel(dragValue);
        this.owner.viewer.layout.reLayoutTable(table);
        this.owner.editorModule.reLayout(this.owner.selection);
        this.currentResizingTable = row.ownerTable;
    }
    /**
     * Gets the table widget from given cursor point
     * @param cursorPoint
     */
    getTableWidget(cursorPoint) {
        let widget = undefined;
        let currentPage = this.owner.viewer.currentPage;
        if (!isNullOrUndefined(currentPage)) {
            for (let i = 0; i < currentPage.bodyWidgets.length; i++) {
                let bodyWidget = currentPage.bodyWidgets[i];
                widget = this.getTableWidgetFromWidget(cursorPoint, bodyWidget);
                if (!isNullOrUndefined(widget)) {
                    break;
                }
            }
        }
        return widget;
    }
    getTableWidgetFromWidget(point, widget) {
        for (let j = 0; j < widget.childWidgets.length; j++) {
            if (widget.childWidgets[j] instanceof TableWidget) {
                let childWidget = widget.childWidgets[j];
                if (childWidget.y <= point.y && (childWidget.y + childWidget.height) >= point.y) {
                    return childWidget;
                }
            }
        }
        return undefined;
    }
    /**
     * Return the table cell widget from the given cursor point
     * @param cursorPoint
     * @private
     */
    getTableCellWidget(cursorPoint) {
        let widget = undefined;
        let currentPage = this.owner.viewer.currentPage;
        if (!isNullOrUndefined(currentPage)) {
            for (let i = 0; i < currentPage.bodyWidgets.length; i++) {
                let bodyWidget = currentPage.bodyWidgets[i];
                widget = bodyWidget.getTableCellWidget(cursorPoint);
                if (!isNullOrUndefined(widget)) {
                    break;
                }
            }
        }
        return widget;
    }
    updateRowHeight(row, dragValue) {
        let rowFormat = row.rowFormat;
        if (rowFormat.heightType === 'Auto') {
            rowFormat.heightType = 'AtLeast';
            let row = rowFormat.ownerBase;
            let currentHeight = this.owner.viewer.layout.getRowHeight(row, [row]);
            //the minimum height of the Row in MS word is 2.7 points which is equal to 3.6 pixel.
            if (currentHeight + dragValue >= 2.7 && rowFormat.height !== currentHeight + dragValue) {
                rowFormat.height = currentHeight + dragValue;
            }
        }
        else {
            //the minimum height of the Row in MS word is 2.7 points which is equal to 3.6 pixel.
            if (rowFormat.height + dragValue >= 2.7 && rowFormat.height !== rowFormat.height + dragValue) {
                rowFormat.height = rowFormat.height + dragValue;
            }
        }
    }
    //Resize Table cell
    resizeTableCellColumn(dragValue) {
        let table = this.currentResizingTable;
        if (isNullOrUndefined(table) || dragValue === 0 || isNullOrUndefined(table.childWidgets) || this.resizerPosition < 0) {
            return;
        }
        let selectionFlag = true;
        let selection = this.owner.selection;
        this.owner.editor.setOffsetValue(selection);
        table = table.combineWidget(this.viewer);
        this.owner.isLayoutEnabled = false;
        // table.PreserveGrid = true;
        this.setPreferredWidth(table);
        let containerWidth = table.getOwnerWidth(true);
        let newIndent = table.leftIndent;
        let tableAlignment = table.tableFormat.tableAlignment;
        if (!selection.isEmpty) {
            selectionFlag = this.resizeColumnWithSelection(selection, table, dragValue);
        }
        if (!selectionFlag) {
            this.owner.isLayoutEnabled = true;
            return;
        }
        if (this.resizerPosition === 0) {
            // Todo: need to handle the resizing of first column and table indent.
            let columnIndex = this.resizerPosition;
            let rightColumn = table.tableHolder.columns[columnIndex];
            let width = rightColumn.preferredWidth;
            if (dragValue > 0) {
                let prevDragValue = dragValue;
                do {
                    let newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                    if (newWidth >= rightColumn.minWidth) {
                        rightColumn.preferredWidth = newWidth;
                        newIndent = table.leftIndent + dragValue;
                        newIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        break;
                    }
                    else {
                        prevDragValue = dragValue;
                        dragValue += newWidth - rightColumn.minWidth;
                    }
                } while (dragValue !== prevDragValue);
            }
            else {
                let prevDragValue = dragValue;
                do {
                    let newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                    if (newWidth <= 2112) {
                        rightColumn.preferredWidth = newWidth;
                        newIndent = table.leftIndent + dragValue;
                        newIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        break;
                    }
                    else {
                        prevDragValue = dragValue;
                        dragValue -= newWidth - 2112;
                    }
                } while (dragValue !== prevDragValue);
            }
            let dragOffset = dragValue;
            // tslint:disable-next-line:max-line-length
            if (tableAlignment !== 'Left' && (table.tableHolder.getTotalWidth(0) > containerWidth) && table.tableFormat.preferredWidthType === 'Auto') {
                if (table.tableHolder.isFitColumns(containerWidth, table.tableHolder.tableWidth, table.tableFormat.preferredWidthType === 'Auto')) {
                    // tslint:disable-next-line:max-line-length
                    table.tableHolder.fitColumns(containerWidth, table.tableHolder.tableWidth, table.tableFormat.preferredWidthType === 'Auto');
                }
                else {
                    rightColumn.preferredWidth = width;
                }
                dragOffset = 0;
            }
            if (tableAlignment === 'Center'
                && (table.tableHolder.getTotalWidth(0) < containerWidth || table.tableFormat.preferredWidthType !== 'Auto')) {
                dragOffset = dragOffset / 2;
            }
            table.tableFormat.leftIndent = tableAlignment === 'Left' ? newIndent : 0;
            table.tableHolder.tableWidth = table.tableHolder.getTotalWidth(0);
            this.updateCellPreferredWidths(table);
            this.updateGridValue(table, true, dragOffset);
        }
        else if (table !== null && this.resizerPosition === table.tableHolder.columns.length) {
            // Todo: need to handle the resizing of last column and table width.
            this.resizeColumnAtLastColumnIndex(table, dragValue, containerWidth);
        }
        else {
            if (this.resizerPosition === -1) {
                this.owner.isLayoutEnabled = true;
                return;
            }
            this.resizeCellAtMiddle(table, dragValue);
        }
        // table.PreserveGrid = false;
        this.owner.isLayoutEnabled = true;
        selection.selectPosition(selection.start, selection.end);
    }
    /**
     * Resize Selected Cells
     */
    resizeColumnWithSelection(selection, table, dragValue) {
        let newIndent = table.leftIndent;
        let cellwidget = this.getTableCellWidget(this.startingPoint);
        if (cellwidget && (selection.selectedWidgets.containsKey(cellwidget) || (cellwidget.previousWidget
            && selection.selectedWidgets.containsKey((cellwidget.previousWidget))))) {
            let selectedCells = selection.getSelectedCells();
            if (this.resizerPosition === 0) {
                this.resizeColumnAtStart(table, dragValue, selectedCells);
            }
            else if (table !== null && this.resizerPosition === table.tableHolder.columns.length) {
                let leftColumnCollection = this.getColumnCells(table, this.resizerPosition, true);
                for (let i = 0; i < leftColumnCollection.length; i++) {
                    let cell = leftColumnCollection[i];
                    if (selectedCells.indexOf(cell) !== -1) {
                        this.increaseOrDecreaseWidth(cell, dragValue, true);
                    }
                }
                //Updates the grid after value for all the rows.
                this.updateRowsGridAfterWidth(table);
                table.updateWidth(dragValue);
                table.tableFormat.allowAutoFit = false;
                this.updateGridValue(table, true, dragValue);
            }
            else {
                if (this.resizerPosition === -1) {
                    return false;
                }
                let columnIndex = this.resizerPosition;
                let leftColumnCollection = this.getColumnCells(table, columnIndex, true);
                let rightColumnCollection = this.getColumnCells(table, columnIndex, false);
                let isColumnResizing = this.isColumnSelected(table, columnIndex);
                if (leftColumnCollection.length > 0 && !isColumnResizing) {
                    for (let i = 0; i < leftColumnCollection.length; i++) {
                        if (selectedCells.indexOf(leftColumnCollection[i]) === -1) {
                            leftColumnCollection.splice(i, 1);
                            i--;
                        }
                    }
                }
                if (rightColumnCollection.length > 0 && !isColumnResizing) {
                    for (let i = 0; i < rightColumnCollection.length; i++) {
                        if (selectedCells.indexOf(rightColumnCollection[i]) === -1) {
                            rightColumnCollection.splice(i, 1);
                            i--;
                        }
                    }
                }
                //Getting the adjacent cell collections for left side selected cells in the right column collection.
                if (leftColumnCollection.length === 0 && rightColumnCollection.length > 0) {
                    for (let i = 0; i < rightColumnCollection.length; i++) {
                        let cell = rightColumnCollection[i];
                        if (cell.previousWidget) {
                            leftColumnCollection.push(cell.previousWidget);
                        }
                    }
                }
                else if (rightColumnCollection.length === 0 && leftColumnCollection.length > 0) {
                    for (let i = 0; i < leftColumnCollection.length; i++) {
                        let cell = leftColumnCollection[i];
                        if (cell.nextWidget) {
                            rightColumnCollection.push(cell.nextWidget);
                        }
                    }
                }
                this.changeWidthOfCells(table, leftColumnCollection, rightColumnCollection, dragValue, true);
                if (table.tableFormat.allowAutoFit) {
                    table.updateWidth(dragValue);
                }
                table.tableFormat.allowAutoFit = false;
                this.updateGridValue(table, true, dragValue);
            }
            selection.selectPosition(selection.start, selection.end);
        }
        return false;
    }
    /**
     * Resize selected cells at resizer position 0
     */
    resizeColumnAtStart(table, dragValue, selectedCells) {
        let newIndent = table.leftIndent;
        let rightColumnCollection = this.getColumnCells(table, this.resizerPosition, false);
        let offset = 0;
        let selectedRow = selectedCells[0].ownerRow;
        let rowFormat = selectedRow.rowFormat;
        if (rowFormat.beforeWidth > 0) {
            let newGridBefore = rowFormat.beforeWidth + dragValue;
            if (newGridBefore > 0) {
                this.updateGridBefore(selectedRow, dragValue);
            }
            else {
                let leastGridBefore = this.getLeastGridBefore(table, selectedRow);
                if (newGridBefore < leastGridBefore && offset !== newGridBefore) {
                    newIndent = table.leftIndent + newGridBefore;
                    table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                    for (let i = 0; i < table.childWidgets.length; i++) {
                        let tableRow = table.childWidgets[i];
                        if (selectedRow !== tableRow) {
                            this.updateGridBefore(tableRow, -newGridBefore);
                        }
                    }
                }
            }
        }
        else {
            if (dragValue < 0) {
                newIndent = table.leftIndent + dragValue;
                table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                this.updateWidthForCells(table, selectedCells, dragValue);
            }
            else {
                let leastGridBefore = this.getLeastGridBefore(table, selectedRow);
                let currentTableIndent = table.tableFormat.leftIndent;
                if (currentTableIndent === 0) {
                    for (let i = 0; i < table.childWidgets.length; i++) {
                        let tableRow = table.childWidgets[i];
                        if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                            this.updateGridBefore(tableRow, dragValue);
                            this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
                        }
                    }
                }
                else {
                    let difference = leastGridBefore - dragValue;
                    if (difference > 0) {
                        newIndent = table.leftIndent + dragValue;
                        table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        this.updateWidthForCells(table, selectedCells, dragValue);
                    }
                    else {
                        newIndent = table.leftIndent + leastGridBefore;
                        table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                        for (let i = 0; i < table.childWidgets.length; i++) {
                            let tableRow = table.childWidgets[i];
                            if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                                this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
                                this.updateGridBefore(tableRow, dragValue - leastGridBefore);
                            }
                            else {
                                this.updateGridBefore(tableRow, -leastGridBefore);
                            }
                        }
                    }
                }
            }
        }
        table.tableFormat.allowAutoFit = false;
        this.updateGridValue(table, true, dragValue);
    }
    updateWidthForCells(table, selectedCells, dragValue) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let tableRow = table.childWidgets[i];
            if (selectedCells.indexOf(tableRow.childWidgets[0]) !== -1) {
                this.increaseOrDecreaseWidth(tableRow.childWidgets[0], dragValue, false);
            }
            else {
                this.updateGridBefore(tableRow, -dragValue);
            }
        }
    }
    /**
     * Resize selected cells at last column
     */
    resizeColumnAtLastColumnIndex(table, dragValue, containerWidth) {
        let tableAlignment = table.tableFormat.tableAlignment;
        let preferredWidth = table.tableFormat.preferredWidth;
        let hasTableWidth = preferredWidth;
        let columnIndex = this.resizerPosition;
        let leftColumn = table.tableHolder.columns[columnIndex - 1];
        let prevDragValue = 0;
        while (dragValue !== prevDragValue) {
            let newWidth = HelperMethods.round(leftColumn.preferredWidth + dragValue, 1);
            if (newWidth >= leftColumn.minWidth) {
                leftColumn.preferredWidth = newWidth;
                prevDragValue = dragValue;
            }
            else {
                prevDragValue = dragValue;
                dragValue -= newWidth - leftColumn.minWidth;
            }
        }
        this.updateCellPreferredWidths(table);
        if (hasTableWidth || table.tableHolder.getTotalWidth(0) > containerWidth) {
            table.tableFormat.allowAutoFit = false;
            table.updateWidth(dragValue);
            table.tableHolder.tableWidth = table.tableHolder.getTotalWidth(0);
        }
        let dragOffset = dragValue;
        if (tableAlignment === 'Right') {
            dragOffset = 0;
        }
        else if (tableAlignment === 'Center') {
            dragOffset = dragOffset / 2;
        }
        this.updateGridValue(table, true, dragOffset);
    }
    /**
     *  Resize selected cells at middle column
     */
    resizeCellAtMiddle(table, dragValue) {
        let columnIndex = this.resizerPosition;
        let leftColumn = table.tableHolder.columns[columnIndex - 1];
        let rightColumn = table.tableHolder.columns[columnIndex];
        if (dragValue > 0) {
            let isContinue = true;
            while (isContinue) {
                let newWidth = HelperMethods.round(rightColumn.preferredWidth - dragValue, 1);
                if (newWidth >= rightColumn.minWidth) {
                    rightColumn.preferredWidth = newWidth;
                    leftColumn.preferredWidth = leftColumn.preferredWidth + dragValue;
                    isContinue = false;
                }
                else {
                    dragValue += newWidth - rightColumn.minWidth;
                }
            }
        }
        else {
            let isContinue = true;
            while (isContinue) {
                let newWidth = HelperMethods.round(leftColumn.preferredWidth + dragValue, 1);
                if (newWidth >= leftColumn.minWidth) {
                    leftColumn.preferredWidth = newWidth;
                    rightColumn.preferredWidth = rightColumn.preferredWidth - dragValue;
                    isContinue = false;
                }
                else {
                    dragValue -= newWidth - leftColumn.minWidth;
                }
            }
        }
        // Update the cell widths based on the columns preferred width
        this.updateCellPreferredWidths(table);
        if (table.tableFormat.allowAutoFit) {
            table.updateWidth(dragValue);
        }
        table.tableFormat.allowAutoFit = false;
        table.tableHolder.tableWidth = table.tableHolder.getTotalWidth(0);
        this.updateGridValue(table, false, dragValue);
    }
    updateGridValue(table, isUpdate, dragValue) {
        if (isUpdate) {
            table.calculateGrid();
            table.isGridUpdated = false;
        }
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.owner.isLayoutEnabled = true;
        if (table.isInsideTable) {
            let parentTable = this.viewer.layout.getParentTable(table);
            this.viewer.layout.reLayoutTable(parentTable); // Need to optmize this.
        }
        else {
            this.viewer.layout.reLayoutTable(table);
        }
        this.owner.editor.getOffsetValue(this.viewer.selection);
        this.owner.editorModule.reLayout(this.owner.selection);
        if (dragValue) {
            this.startingPoint.x += HelperMethods.convertPointToPixel(dragValue);
            this.resizerPosition = this.getCellReSizerPosition(this.startingPoint);
        }
    }
    getColumnCells(table, columnIndex, isLeftSideCollection) {
        let cells = [];
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                if (isLeftSideCollection) {
                    if (cell.columnIndex + cell.cellFormat.columnSpan === columnIndex) {
                        cells.push(cell);
                    }
                }
                else {
                    if (cell.columnIndex === columnIndex) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    }
    updateGridBefore(row, offset) {
        if (row.rowFormat.beforeWidth + offset !== row.rowFormat.beforeWidth) {
            row.rowFormat.beforeWidth = row.rowFormat.beforeWidth + offset;
            row.rowFormat.gridBeforeWidth = row.rowFormat.beforeWidth;
        }
    }
    getLeastGridBefore(table, ignoreRow) {
        let gridBefore = 0;
        let flag = 0;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row !== ignoreRow) {
                if (flag === 0) {
                    gridBefore = row.rowFormat.beforeWidth;
                    flag++;
                }
                if (row.rowFormat.beforeWidth <= gridBefore) {
                    gridBefore = row.rowFormat.beforeWidth;
                }
            }
        }
        return gridBefore;
    }
    increaseOrDecreaseWidth(cell, dragValue, isIncrease) {
        let preferredWidth = cell.cellFormat.preferredWidth;
        if (cell.cellFormat.preferredWidthType === 'Auto') {
            preferredWidth = cell.cellFormat.cellWidth;
            cell.cellFormat.preferredWidthType = 'Point';
        }
        let minimumWidth = cell.ownerColumn.minWidth;
        if (cell.cellFormat.preferredWidthType === 'Percent') {
            minimumWidth = cell.convertPointToPercent(minimumWidth);
        }
        // Margins properties usedd for internal purpose.
        if (isIncrease) {
            cell.cellFormat.preferredWidth = preferredWidth + dragValue > minimumWidth ? preferredWidth + dragValue : minimumWidth;
        }
        else {
            cell.cellFormat.preferredWidth = preferredWidth - dragValue > minimumWidth ? preferredWidth - dragValue : minimumWidth;
        }
    }
    // tslint:disable-next-line:max-line-length
    changeWidthOfCells(table, leftColumnCollection, rightColumnCollection, dragValue, isSelection) {
        if (leftColumnCollection.length > 0) {
            let flag = false;
            for (let i = 0; i < leftColumnCollection.length; i++) {
                let cell = leftColumnCollection[i];
                this.increaseOrDecreaseWidth(cell, dragValue, true);
                if (cell.cellIndex === cell.ownerRow.childWidgets.length - 1) {
                    flag = true;
                }
            }
            if (flag) {
                this.updateRowsGridAfterWidth(table);
            }
        }
        if (rightColumnCollection.length > 0) {
            let diff = 0;
            for (let i = 0; i < rightColumnCollection.length; i++) {
                let cell = rightColumnCollection[i];
                if (cell.cellIndex === 0) {
                    let newGridBefore = cell.ownerRow.rowFormat.beforeWidth + dragValue;
                    if (newGridBefore >= 0) {
                        this.updateGridBefore(cell.ownerRow, dragValue);
                    }
                    else {
                        if (diff !== newGridBefore) {
                            diff = newGridBefore;
                        }
                        cell.ownerRow.rowFormat.gridBeforeWidth = 0;
                        cell.ownerRow.rowFormat.gridBeforeWidthType = 'Auto';
                    }
                }
                this.increaseOrDecreaseWidth(cell, dragValue, false);
            }
            if (diff !== 0) {
                let newIndent = table.leftIndent + diff;
                table.tableFormat.leftIndent = newIndent >= -1440 ? (newIndent <= 1440 ? newIndent : 1440) : -1440;
                for (let j = 0; j < table.childWidgets.length; j++) {
                    let row = table.childWidgets[j];
                    if (rightColumnCollection.indexOf(row.childWidgets[0]) === -1) {
                        this.updateGridBefore(row, diff > 0 ? diff : -diff);
                    }
                }
            }
        }
    }
    updateRowsGridAfterWidth(table) {
        let maxRowWidth = this.getMaxRowWidth(table, true);
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let currentRowWidth = this.getRowWidth(row, true);
            if (maxRowWidth >= currentRowWidth && row.rowFormat.afterWidth !== maxRowWidth - currentRowWidth) {
                let value = maxRowWidth - currentRowWidth;
                row.rowFormat.gridAfterWidth = value;
                row.rowFormat.afterWidth = value;
            }
        }
    }
    getRowWidth(row, toUpdateGridAfter) {
        let rowWidth = 0;
        if (toUpdateGridAfter) {
            rowWidth = rowWidth + row.rowFormat.beforeWidth;
        }
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            rowWidth += cell.cellFormat.cellWidth;
        }
        return rowWidth;
    }
    getMaxRowWidth(table, toUpdateGridAfter) {
        let width = 0;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowWidth = 0;
            if (toUpdateGridAfter) {
                rowWidth = rowWidth + row.rowFormat.beforeWidth;
            }
            for (let i = 0; i < row.childWidgets.length; i++) {
                let cell = row.childWidgets[i];
                rowWidth += cell.cellFormat.cellWidth;
            }
            if (width < rowWidth) {
                width = rowWidth;
            }
        }
        return width;
    }
    isColumnSelected(table, columnIndex) {
        let selection = this.owner.selection;
        let selectedCells = selection.getSelectedCells();
        let leftColumnCells = this.getColumnCells(table, columnIndex, true);
        let rightColumnCells = this.getColumnCells(table, columnIndex, false);
        let isColumnSelected = false;
        for (let i = 0; i < leftColumnCells.length; i++) {
            let columnCell = leftColumnCells[i];
            isColumnSelected = selectedCells.indexOf(columnCell) !== -1 ? true : false;
        }
        if (!isColumnSelected) {
            for (let i = 0; i < rightColumnCells.length; i++) {
                let columnCell = rightColumnCells[i];
                isColumnSelected = selectedCells.indexOf(columnCell) !== -1 ? true : false;
            }
        }
        return isColumnSelected;
    }
    applyProperties(table, tableHistoryInfo) {
        if (isNullOrUndefined(tableHistoryInfo)) {
            return;
        }
        table = table;
        // PreserveGrid = true;
        if (tableHistoryInfo.tableHolder) {
            table.tableHolder = tableHistoryInfo.tableHolder.clone();
        }
        if (tableHistoryInfo.tableFormat !== null) {
            table.tableFormat.leftIndent = tableHistoryInfo.tableFormat.leftIndent;
            table.tableFormat.preferredWidth = tableHistoryInfo.tableFormat.preferredWidth;
            table.tableFormat.preferredWidthType = tableHistoryInfo.tableFormat.preferredWidthType;
            table.tableFormat.allowAutoFit = tableHistoryInfo.tableFormat.allowAutoFit;
        }
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowFormat = tableHistoryInfo.rows[i];
            row.rowFormat.gridBefore = rowFormat.gridBefore;
            row.rowFormat.gridBeforeWidth = rowFormat.gridBeforeWidth;
            row.rowFormat.gridBeforeWidthType = rowFormat.gridBeforeWidthType;
            row.rowFormat.gridAfter = rowFormat.gridAfter;
            row.rowFormat.gridAfterWidth = rowFormat.gridAfterWidth;
            row.rowFormat.gridAfterWidthType = rowFormat.gridAfterWidthType;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellFormat = rowFormat.cells[j];
                cell.columnIndex = cellFormat.columnIndex;
                cell.cellFormat.columnSpan = cellFormat.columnSpan;
                cell.cellFormat.preferredWidth = cellFormat.preferredWidth;
                cell.cellFormat.preferredWidthType = cellFormat.preferredWidthType;
            }
        }
        let containerWidth = table.getOwnerWidth(true);
        let tableWidth = table.getTableClientWidth(containerWidth);
        //Sets the width to cells
        table.setWidthToCells(tableWidth, table.tableFormat.preferredWidthType === 'Auto');
        // PreserveGrid = false;
    }
    /**
     * Return table row width
     */
    getActualWidth(row) {
        let width = 0;
        if (row.childWidgets.length > 0) {
            for (let i = 0; i < row.childWidgets.length; i++) {
                width += row.childWidgets[i].cellFormat.cellWidth;
            }
        }
        return width;
    }
    setPreferredWidth(table) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let rw = table.childWidgets[i];
            let rowFormat = rw.rowFormat;
            if (rowFormat.gridBefore > 0) {
                rowFormat.gridBeforeWidth = rowFormat.beforeWidth;
                rowFormat.gridBeforeWidthType = 'Point';
            }
            for (let j = 0; j < rw.childWidgets.length; j++) {
                let cell = rw.childWidgets[j];
                cell.cellFormat.preferredWidth = cell.cellFormat.cellWidth;
                cell.cellFormat.preferredWidthType = 'Point';
            }
            if (rowFormat.gridAfter > 0) {
                rowFormat.gridAfterWidth = rowFormat.afterWidth;
                rowFormat.gridAfterWidthType = 'Point';
            }
        }
    }
    updateCellPreferredWidths(table) {
        let tableWidth = table.tableHolder.tableWidth;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.rowFormat.gridBefore > 0) {
                let width = table.tableHolder.getCellWidth(0, row.rowFormat.gridBefore, tableWidth);
                this.updateGridBeforeWidth(width, row);
            }
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                cell.updateWidth(table.tableHolder.getCellWidth(cell.columnIndex, cell.cellFormat.columnSpan, tableWidth));
            }
            if (row.rowFormat.gridAfter > 0) {
                // tslint:disable-next-line:max-line-length
                this.updateGridAfterWidth(table.tableHolder.getCellWidth(row.childWidgets.length, row.rowFormat.gridAfter, tableWidth), row);
            }
        }
    }
    /**
     * Update grid before width value
     */
    updateGridBeforeWidth(width, row) {
        let rowFormat = row.rowFormat;
        if (width !== rowFormat.beforeWidth) {
            rowFormat.beforeWidth = width;
            if (rowFormat.gridBeforeWidthType === 'Auto') {
                rowFormat.gridBeforeWidthType = 'Point';
            }
            if (rowFormat.gridBeforeWidthType === 'Point') {
                rowFormat.gridBeforeWidth = rowFormat.beforeWidth;
            }
            else {
                // The value is calculated from the pixel values hence, its converted to percent using method. 
                let ownerWidth = row.ownerTable.getTableClientWidth(row.ownerTable.getOwnerWidth(true));
                let value = row.ownerTable.convertPointToPercent(rowFormat.beforeWidth, ownerWidth);
                rowFormat.gridBeforeWidth = value;
            }
        }
    }
    /**
     * Update grid after width value
     */
    updateGridAfterWidth(width, row) {
        let rowFormat = row.rowFormat;
        if (width !== rowFormat.afterWidth) {
            rowFormat.afterWidth = width;
        }
        if (rowFormat.gridAfterWidthType === 'Auto') {
            rowFormat.gridAfterWidthType = 'Point';
        }
        if (rowFormat.gridAfterWidthType === 'Point') {
            rowFormat.gridAfterWidth = rowFormat.afterWidth;
        }
        else {
            // The value is calculated from the pixel values hence, its converted to percent using method. 
            let ownerWidth = row.ownerTable.getTableClientWidth(row.ownerTable.getOwnerWidth(true));
            let value = row.ownerTable.convertPointToPercent(rowFormat.afterWidth, ownerWidth);
            rowFormat.gridAfterWidth = value;
        }
    }
}

/**
 * Editor module
 */
class Editor {
    /**
     * Initialize the editor module
     * @param  {LayoutViewer} viewer
     * @private
     */
    constructor(viewer) {
        this.nodes = [];
        this.editHyperlinkInternal = false;
        this.startParagraph = undefined;
        this.endParagraph = undefined;
        this.removeEditRange = false;
        /**
         * @private
         */
        this.isHandledComplex = false;
        /**
         * @private
         */
        this.tableResize = undefined;
        /**
         * @private
         */
        this.tocStyles = {};
        this.refListNumber = undefined;
        this.incrementListNumber = -1;
        this.removedBookmarkElements = [];
        /**
         * @private
         */
        this.tocBookmarkId = 0;
        /**
         * @private
         */
        this.copiedData = undefined;
        this.pageRefFields = {};
        this.delBlockContinue = false;
        this.delBlock = undefined;
        this.delSection = undefined;
        /**
         * @private
         */
        this.isInsertingTOC = false;
        this.editStartRangeCollection = [];
        /* tslint:disable:no-any */
        this.copiedContent = '';
        /* tslint:enable:no-any */
        this.copiedTextContent = '';
        this.pasteTextPosition = undefined;
        this.isSkipHistory = false;
        this.isPaste = false;
        this.isPasteListUpdated = false;
        /**
         * @private
         */
        this.isBordersAndShadingDialog = false;
        /**
         * @private
         */
        this.onTextInputInternal = (event) => {
            if (Browser.isDevice) {
                let viewer = this.viewer;
                let nbsp = new RegExp(String.fromCharCode(160), 'g');
                let lineFeed = new RegExp(String.fromCharCode(10), 'g');
                viewer.prefix = viewer.prefix.replace(nbsp, ' ').replace(lineFeed, ' ');
                let text = viewer.editableDiv.textContent.replace(nbsp, ' ').replace(lineFeed, ' ');
                let textBoxText = text.substring(2);
                if (viewer.isCompositionStart && viewer.isCompositionUpdated) {
                    viewer.isCompositionUpdated = false;
                    if (!viewer.owner.isReadOnlyMode && viewer.owner.isDocumentLoaded) {
                        if (viewer.prefix.substring(2) !== textBoxText) {
                            if (this.selection.isEmpty) {
                                // tslint:disable-next-line:max-line-length
                                this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, this.selection.start.offset - (viewer.prefix.length - 2));
                                this.handleTextInput(textBoxText);
                                viewer.prefix = '@' + String.fromCharCode(160) + textBoxText;
                            }
                            else {
                                this.handleTextInput(textBoxText);
                                viewer.prefix = '@' + String.fromCharCode(160) + textBoxText;
                            }
                        }
                    }
                    return;
                }
                else if (viewer.isCompositionStart && viewer.isCompositionEnd && viewer.suffix === '') {
                    if (viewer.prefix.substring(2) !== textBoxText) {
                        if (this.selection.isEmpty && viewer.isCompositionStart) {
                            viewer.isCompositionStart = false;
                            // tslint:disable-next-line:max-line-length
                            this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, this.selection.start.offset - viewer.prefix.substring(2).length);
                            this.selection.retrieveCurrentFormatProperties();
                            if (viewer.suffix === '' || textBoxText === '') {
                                this.handleTextInput(textBoxText);
                            }
                        }
                        else if (!this.selection.isEmpty) {
                            viewer.isCompositionStart = false;
                            this.handleTextInput(textBoxText);
                        }
                    }
                    else if (textBoxText === '') {
                        viewer.isCompositionStart = false;
                        this.handleBackKey();
                    }
                    else if (viewer.prefix.substring(2) === textBoxText && viewer.suffix === '') {
                        viewer.isCompositionStart = false;
                        this.handleTextInput(' ');
                    }
                    viewer.isCompositionEnd = false;
                    return;
                }
                else if (viewer.isCompositionEnd || viewer.isCompositionStart && !viewer.isCompositionUpdated) {
                    if (textBoxText.length < viewer.prefix.length &&
                        textBoxText === viewer.prefix.substring(2, viewer.prefix.length - 1) || viewer.editableDiv.innerText.length < 2) {
                        this.handleBackKey();
                        return;
                    }
                    else if (viewer.suffix !== '' &&
                        viewer.editableDiv.innerText[viewer.editableDiv.innerText.length - 1] !== String.fromCharCode(160)) {
                        viewer.isCompositionStart = false;
                        //When cursor is placed in between a word and chosen a word from predicted words.
                        // tslint:disable-next-line:max-line-length
                        this.selection.start.setPositionForLineWidget(viewer.selection.start.currentWidget, this.selection.start.offset - (viewer.prefix.length - 2));
                        this.selection.end.setPositionForLineWidget(viewer.selection.end.currentWidget, this.selection.end.offset + viewer.suffix.length);
                        //Retrieve the character format properties. Since the selection was changed manually.
                        this.selection.retrieveCurrentFormatProperties();
                        this.handleTextInput(textBoxText);
                        return;
                    }
                }
                // tslint:disable-next-line:max-line-length
                if (text !== '\r' && text !== '\b' && text !== '\u001B' && !viewer.owner.isReadOnlyMode && viewer.isControlPressed === false) {
                    if (text === '@' || text[0] !== '@' || text === '' || text.length < viewer.prefix.length &&
                        textBoxText === viewer.prefix.substring(2, viewer.prefix.length - 1)) {
                        this.handleBackKey();
                        if (viewer.editableDiv.innerText.length < 2) {
                            this.predictText();
                        }
                    }
                    else if (text.indexOf(viewer.prefix) === 0 && text.length > viewer.prefix.length) {
                        this.handleTextInput(text.substring(viewer.prefix.length));
                    }
                    else if (text.indexOf(viewer.prefix) === -1 && text[text.length - 1] !== String.fromCharCode(160)
                        && text[text.length - 1] !== ' ') {
                        if ((textBoxText.charAt(0).toLowerCase() + textBoxText.slice(1)) === viewer.prefix.substring(2)) {
                            // tslint:disable-next-line:max-line-length
                            this.selection.start.setPositionParagraph(viewer.selection.start.currentWidget, this.selection.start.offset - (viewer.prefix.length - 2));
                        }
                        this.handleTextInput(textBoxText);
                    }
                    else if (text.length !== 2) {
                        this.handleTextInput(' ');
                    }
                }
            }
            else {
                let text = this.viewer.editableDiv.innerText;
                if (text !== String.fromCharCode(160)) {
                    // tslint:disable-next-line:max-line-length
                    if (text !== '\r' && text !== '\b' && text !== '\u001B' && !this.owner.isReadOnlyMode && this.viewer.isControlPressed === false) {
                        this.handleTextInput(text);
                    }
                }
                else {
                    this.handleTextInput(' ');
                }
                this.viewer.editableDiv.innerText = '';
            }
        };
        /**
         * Fired on paste.
         * @param {ClipboardEvent} event
         * @private
         */
        this.onPaste = (event) => {
            if (!this.owner.isReadOnlyMode) {
                this.pasteInternal(event);
            }
            event.preventDefault();
        };
        this.viewer = viewer;
        this.tableResize = new TableResizer(this.viewer.owner);
        this.base64 = new Base64();
    }
    /**
     * @private
     */
    get restrictFormatting() {
        return this.viewer.isDocumentProtected && (this.viewer.restrictFormatting
            || (!this.viewer.restrictFormatting && !this.selection.isSelectionIsAtEditRegion(false)));
    }
    /**
     * @private
     */
    get restrictEditing() {
        return this.viewer.isDocumentProtected && this.viewer.protectionType === 'ReadOnly'
            && !this.selection.isSelectionIsAtEditRegion(false);
    }
    get editorHistory() {
        return this.viewer.owner.editorHistory;
    }
    get selection() {
        if (this.viewer) {
            return this.viewer.selection;
        }
        return undefined;
    }
    get owner() {
        return this.viewer.owner;
    }
    getModuleName() {
        return 'Editor';
    }
    /**
     * Inserts the specified field at cursor position
     * @param code
     * @param result
     */
    insertField(code, result) {
        let fieldCode = code;
        if (isNullOrUndefined(result)) {
            fieldCode = HelperMethods.trimStart(fieldCode);
            if (fieldCode.substring(0, 10) === 'MERGEFIELD') {
                fieldCode = fieldCode.substring(10).trim();
                let index = fieldCode.indexOf('\\*');
                result = '«' + fieldCode.substring(0, index).trim() + '»';
            }
        }
        let paragraph = new ParagraphWidget();
        let insertFormat = new WCharacterFormat();
        let selectionFormat = this.copyInsertFormat(insertFormat, false);
        let line = new LineWidget(paragraph);
        let fieldBegin = new FieldElementBox(0);
        fieldBegin.characterFormat.mergeFormat(selectionFormat);
        line.children.push(fieldBegin);
        let fieldCodeSpan = new TextElementBox();
        fieldCodeSpan.text = code;
        line.children.push(fieldCodeSpan);
        let fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldBegin.fieldSeparator = fieldSeparator;
        line.children.push(fieldSeparator);
        let fieldResultSpan = new TextElementBox();
        fieldResultSpan.text = result;
        fieldResultSpan.characterFormat.mergeFormat(selectionFormat);
        line.children.push(fieldResultSpan);
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.characterFormat.mergeFormat(selectionFormat);
        fieldEnd.fieldSeparator = fieldSeparator;
        fieldEnd.fieldBegin = fieldBegin;
        fieldBegin.fieldEnd = fieldEnd;
        fieldSeparator.fieldEnd = fieldEnd;
        line.children.push(fieldEnd);
        fieldBegin.line = line;
        paragraph.childWidgets.push(line);
        this.viewer.fields.push(fieldBegin);
        let widgets = [];
        widgets.push(paragraph);
        this.pasteContentsInternal(widgets);
    }
    /**
     * To update style for paragraph
     * @param style - style name
     * @param clearDirectFormatting - Removes manual formatting (formatting not applied using a style)
     * from the selected text, to match the formatting of the applied style. Default value is false.
     */
    applyStyle(style, clearDirectFormatting) {
        clearDirectFormatting = isNullOrUndefined(clearDirectFormatting) ? false : clearDirectFormatting;
        if (clearDirectFormatting) {
            this.initComplexHistory('ApplyStyle');
            this.clearFormatting();
        }
        let styleObj = this.viewer.styles.findByName(style);
        if (styleObj !== undefined) {
            this.onApplyParagraphFormat('styleName', styleObj, false, true);
        }
        else {
            // tslint:disable-next-line:max-line-length
            this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.viewer.preDefinedStyles.get(style)), this.viewer.styles);
            this.applyStyle(style);
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action === 'ApplyStyle') {
            this.editorHistory.updateComplexHistory();
        }
    }
    // Public Implementation Starts
    /**
     * Moves the selected content in the document editor control to clipboard.
     */
    cut() {
        if (this.owner.isReadOnlyMode || this.selection.isEmpty) {
            return;
        }
        this.selection.copySelectedContent(true);
    }
    /**
     * Insert editing region in current selection range.
     */
    insertEditingRegion(user) {
        this.insertEditRangeElement(user && user !== '' ? user : 'Everyone');
    }
    /**
     * Enforce document protection.
     */
    enforceProtection(credential, limitToFormatting, isReadOnly) {
        this.viewer.restrictFormatting = limitToFormatting;
        this.viewer.protectionType = isReadOnly ? 'ReadOnly' : this.viewer.protectionType;
        this.selection.isHighlightEditRegion = true;
        this.addProtection(credential);
    }
    getCommentHierarchicalIndex(comment) {
        let index = '';
        while (comment.ownerComment) {
            index = comment.ownerComment.replyComments.indexOf(comment) + ';' + index;
            comment = comment.ownerComment;
        }
        index = 'C;' + this.viewer.comments.indexOf(comment) + ';' + index;
        return index;
    }
    /**
     * Insert comment
     * @param text - comment text.
     */
    // Comment implementation starts
    insertComment(text) {
        if (isNullOrUndefined(this.selection.start) || this.owner.isReadOnlyMode) {
            return;
        }
        if (isNullOrUndefined(text)) {
            text = '';
        }
        this.insertCommentInternal(text);
    }
    insertCommentInternal(text) {
        if (this.selection.isEmpty) {
            this.selection.selectCurrentWord();
        }
        let paragraphInfo = this.selection.getParagraphInfo(this.selection.start);
        let startIndex = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        let endParagraphInfo = this.selection.getParagraphInfo(this.selection.start);
        let endIndex = this.selection.getHierarchicalIndex(endParagraphInfo.paragraph, endParagraphInfo.offset.toString());
        this.initComplexHistory('InsertComment');
        let startPosition = this.selection.start;
        let endPosition = this.selection.end;
        let position = new TextPosition(this.owner);
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        // Clones the end position.
        position.setPositionInternal(endPosition);
        let commentRangeStart = new CommentCharacterElementBox(0);
        let commentRangeEnd = new CommentCharacterElementBox(1);
        let isAtSameParagraph = startPosition.isInSameParagraph(endPosition);
        // Adds comment start at selection start position.
        endPosition.setPositionInternal(startPosition);
        this.initInsertInline(commentRangeStart);
        // Updates the cloned position, since comment start is added in the same paragraph.
        if (isAtSameParagraph) {
            position.setPositionParagraph(position.currentWidget, position.offset + commentRangeStart.length);
        }
        // Adds comment end and comment at selection end position.
        startPosition.setPositionInternal(position);
        endPosition.setPositionInternal(position);
        this.initInsertInline(commentRangeEnd);
        let commentAdv = new CommentElementBox(new Date().toISOString());
        if (this.owner.editorHistory) {
            this.initHistory('InsertCommentWidget');
            this.owner.editorHistory.currentBaseHistoryInfo.removedNodes.push(commentAdv);
        }
        commentAdv.author = this.owner.currentUser ? this.owner.currentUser : 'Guest user';
        commentAdv.text = text;
        commentAdv.commentId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        commentRangeStart.comment = commentAdv;
        commentRangeStart.commentId = commentAdv.commentId;
        commentRangeEnd.comment = commentAdv;
        commentRangeEnd.commentId = commentAdv.commentId;
        commentAdv.commentStart = commentRangeStart;
        commentAdv.commentEnd = commentRangeEnd;
        this.addCommentWidget(commentAdv, true);
        if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(commentAdv);
            this.editorHistory.updateHistory();
        }
        //tslint:disable-next-line:max-line-length
        // this.selection.selectPosition(this.selection.getTextPosBasedOnLogicalIndex(startIndex), this.selection.getTextPosBasedOnLogicalIndex(endIndex));
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
        }
        this.reLayout(this.selection, false);
    }
    /**
     * Delete all the comments in current document
     */
    deleteAllComments() {
        if (this.viewer.comments.length === 0) {
            return;
        }
        // this.viewer.clearSearchHighlight();
        this.initComplexHistory('DeleteAllComments');
        this.owner.isLayoutEnabled = false;
        let historyInfo;
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            historyInfo = this.editorHistory.currentHistoryInfo;
        }
        while (this.viewer.comments.length > 0) {
            let comment = this.viewer.comments[0];
            this.initComplexHistory('DeleteComment');
            this.deleteCommentInternal(comment);
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                historyInfo.addModifiedAction(this.editorHistory.currentHistoryInfo);
            }
        }
        this.selection.selectContent(this.owner.documentStart, true);
        if (this.editorHistory) {
            this.editorHistory.currentHistoryInfo = historyInfo;
            this.editorHistory.updateComplexHistory();
        }
    }
    /**
     * Delete current selected comment.
     */
    deleteComment() {
        if (this.owner.isReadOnlyMode || isNullOrUndefined(this.owner) || isNullOrUndefined(this.owner.viewer)
            || isNullOrUndefined(this.owner.viewer.currentSelectedComment)) {
            return;
        }
        this.deleteCommentInternal(this.owner.viewer.currentSelectedComment);
    }
    /**
     * @private
     */
    deleteCommentInternal(comment) {
        this.initComplexHistory('DeleteComment');
        if (comment) {
            let commentStart = comment.commentStart;
            let commentEnd = comment.commentEnd;
            this.removeInline(commentEnd);
            this.removeInline(commentStart);
            commentStart.removeCommentMark();
            if (comment.replyComments.length > 0) {
                for (let i = comment.replyComments.length - 1; i >= 0; i--) {
                    this.deleteCommentInternal(comment.replyComments[i]);
                }
            }
            if (this.owner.editorHistory) {
                this.initHistory('DeleteCommentWidget');
                this.owner.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(comment);
                this.owner.editorHistory.currentBaseHistoryInfo.removedNodes.push(comment);
            }
            this.deleteCommentWidget(comment);
            if (this.editorHistory) {
                this.editorHistory.updateHistory();
            }
        }
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistory();
        }
    }
    /**
     * @private
     */
    deleteCommentWidget(comment) {
        let commentIndex = this.viewer.comments.indexOf(comment);
        if (commentIndex !== -1) {
            this.viewer.comments.splice(commentIndex, 1);
        }
        else if (comment.isReply && comment.ownerComment) {
            commentIndex = comment.ownerComment.replyComments.indexOf(comment);
            comment.ownerComment.replyComments.splice(commentIndex, 1);
        }
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.deleteComment(comment);
            if (this.viewer.currentSelectedComment === comment) {
                this.viewer.currentSelectedComment = undefined;
            }
        }
    }
    /**
     * @private
     */
    resolveComment(comment) {
        this.resolveOrReopenComment(comment, true);
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.resolveComment(comment);
        }
    }
    /**
     * @private
     */
    reopenComment(comment) {
        this.resolveOrReopenComment(comment, false);
        if (this.owner.commentReviewPane) {
            this.owner.commentReviewPane.reopenComment(comment);
        }
    }
    resolveOrReopenComment(comment, resolve) {
        comment.isResolved = resolve;
        for (let i = 0; i < comment.replyComments.length; i++) {
            comment.replyComments[i].isResolved = resolve;
        }
    }
    /**
     * @private
     */
    replyComment(parentComment, text) {
        let commentWidget = parentComment;
        if (parentComment) {
            this.initComplexHistory('InsertComment');
            let currentCmtStart = commentWidget.commentStart;
            let currentCmtEnd = commentWidget.commentEnd;
            let offset = currentCmtStart.line.getOffset(currentCmtStart, 1);
            let startPosition = new TextPosition(this.viewer.owner);
            startPosition.setPositionParagraph(currentCmtStart.line, offset);
            let endOffset = currentCmtEnd.line.getOffset(currentCmtEnd, 1);
            let endPosition = new TextPosition(this.viewer.owner);
            endPosition.setPositionParagraph(currentCmtEnd.line, endOffset);
            this.selection.start.setPositionInternal(startPosition);
            this.selection.end.setPositionInternal(endPosition);
            startPosition = this.selection.start;
            endPosition = this.selection.end;
            let position = new TextPosition(this.owner);
            // Clones the end position.
            position.setPositionInternal(endPosition);
            let commentRangeStart = new CommentCharacterElementBox(0);
            let commentRangeEnd = new CommentCharacterElementBox(1);
            let isAtSameParagraph = startPosition.isInSameParagraph(endPosition);
            // Adds comment start at selection start position.
            endPosition.setPositionInternal(startPosition);
            this.initInsertInline(commentRangeStart);
            // Updates the cloned position, since comment start is added in the same paragraph.
            if (isAtSameParagraph) {
                position.setPositionParagraph(position.currentWidget, position.offset + commentRangeStart.length);
            }
            // Adds comment end and comment at selection end position.
            startPosition.setPositionInternal(position);
            endPosition.setPositionInternal(position);
            this.initInsertInline(commentRangeEnd);
            let replyComment = new CommentElementBox(new Date().toISOString());
            replyComment.author = this.owner.currentUser ? this.owner.currentUser : 'Guest user';
            replyComment.text = text ? text : '';
            //tslint:disable-next-line:max-line-length
            replyComment.commentId = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
            replyComment.isReply = true;
            commentWidget.replyComments.push(replyComment);
            replyComment.ownerComment = commentWidget;
            if (this.owner.editorHistory) {
                this.initHistory('InsertCommentWidget');
                this.owner.editorHistory.currentBaseHistoryInfo.removedNodes.push(replyComment);
            }
            commentRangeStart.comment = replyComment;
            commentRangeStart.commentId = replyComment.commentId;
            commentRangeEnd.comment = replyComment;
            commentRangeEnd.commentId = replyComment.commentId;
            replyComment.commentStart = commentRangeStart;
            replyComment.commentEnd = commentRangeEnd;
            if (this.owner.commentReviewPane) {
                this.owner.commentReviewPane.addReply(replyComment, false);
            }
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = this.getCommentHierarchicalIndex(replyComment);
                this.editorHistory.updateHistory();
            }
            if (this.editorHistory) {
                this.editorHistory.updateComplexHistory();
            }
            this.reLayout(this.selection);
        }
    }
    removeInline(element) {
        this.selection.start.setPositionParagraph(element.line, element.line.getOffset(element, 0));
        this.selection.end.setPositionParagraph(this.selection.start.currentWidget, this.selection.start.offset + element.length);
        this.initHistory('RemoveInline');
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.updateHistoryPosition(this.selection.start, true);
        }
        this.removeSelectedContents(this.viewer.selection);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.fireContentChange();
    }
    /**
     * @private
     */
    addCommentWidget(commentWidget, isNewComment) {
        if (this.viewer.comments.indexOf(commentWidget) === -1) {
            let isInserted = false;
            if (this.viewer.comments.length > 0) {
                // tslint:disable-next-line:max-line-length
                let currentStart = this.selection.getElementPosition(commentWidget.commentStart).startPosition;
                for (let i = 0; i < this.viewer.comments.length; i++) {
                    let paraIndex = this.selection.getElementPosition(this.viewer.comments[i].commentStart).startPosition;
                    if (currentStart.isExistBefore(paraIndex)) {
                        isInserted = true;
                        this.viewer.comments.splice(i, 0, commentWidget);
                        break;
                    }
                }
            }
            if (!isInserted) {
                this.viewer.comments.push(commentWidget);
            }
            if (this.owner.commentReviewPane) {
                this.owner.showComments = true;
                this.owner.commentReviewPane.addComment(commentWidget, isNewComment);
                this.owner.selection.selectComment(commentWidget);
            }
        }
    }
    /**
     * @private
     */
    addReplyComment(comment, hierarchicalIndex) {
        let index = hierarchicalIndex.split(';');
        let ownerComment = this.viewer.comments[parseInt(index[1], 10)];
        if (index[2] !== '') {
            ownerComment.replyComments.splice(parseInt(index[2], 10), 0, comment);
            comment.ownerComment = ownerComment;
        }
        if (this.owner.commentReviewPane) {
            this.owner.showComments = true;
            this.owner.commentReviewPane.addReply(comment, false);
            this.owner.selection.selectComment(comment);
        }
    }
    /**
     * @private
     */
    addProtection(password) {
        let enforceProtectionHandler = new XmlHttpRequestHandler();
        let passwordBase64 = this.base64.encodeString(password);
        /* tslint:disable:no-any */
        let formObject = {
            passwordBase64: passwordBase64,
            saltBase64: '',
            spinCount: 100000
        };
        /* tslint:enable:no-any */
        let url = this.owner.serviceUrl + this.owner.serverActionSettings.restrictEditing;
        enforceProtectionHandler.url = url;
        enforceProtectionHandler.contentType = 'application/json;charset=UTF-8';
        enforceProtectionHandler.onSuccess = this.enforceProtectionInternal.bind(this);
        enforceProtectionHandler.onFailure = this.protectionFailureHandler.bind(this);
        enforceProtectionHandler.onError = this.protectionFailureHandler.bind(this);
        enforceProtectionHandler.customHeaders = this.owner.headers;
        enforceProtectionHandler.send(formObject);
    }
    /* tslint:disable:no-any */
    protectionFailureHandler(result) {
        let localeValue = new L10n('documenteditor', this.owner.defaultLocale);
        localeValue.setLocale(this.viewer.owner.locale);
        if (result.name === 'onError') {
            DialogUtility.alert(localeValue.getConstant('Error in establishing connection with web server'));
        }
        else {
            console.error(result.statusText);
        }
    }
    enforceProtectionInternal(result) {
        let data = JSON.parse(result.data);
        this.viewer.saltValue = data[0];
        this.viewer.hashValue = data[1];
        this.protectDocument();
    }
    /* tslint:enable:no-any */
    protectDocument() {
        this.protect(this.viewer.protectionType);
        let restrictPane = this.viewer.restrictEditingPane.restrictPane;
        if (restrictPane && restrictPane.style.display === 'block') {
            this.viewer.restrictEditingPane.showStopProtectionPane(true);
            this.viewer.restrictEditingPane.loadPaneValue();
            this.viewer.dialog.hide();
        }
    }
    /**
     * Stop document protection.
     */
    /* tslint:disable:no-any */
    stopProtection(password) {
        if (this.viewer.isDocumentProtected) {
            let unProtectDocumentHandler = new XmlHttpRequestHandler();
            let passwordBase64 = this.base64.encodeString(password);
            let formObject = {
                passwordBase64: passwordBase64,
                saltBase64: this.viewer.saltValue,
                spinCount: 100000
            };
            unProtectDocumentHandler.url = this.owner.serviceUrl + this.owner.serverActionSettings.restrictEditing;
            unProtectDocumentHandler.contentType = 'application/json;charset=UTF-8';
            unProtectDocumentHandler.customHeaders = this.owner.headers;
            unProtectDocumentHandler.onSuccess = this.onUnProtectionSuccess.bind(this);
            unProtectDocumentHandler.onFailure = this.protectionFailureHandler.bind(this);
            unProtectDocumentHandler.onError = this.protectionFailureHandler.bind(this);
            unProtectDocumentHandler.send(formObject);
        }
    }
    onUnProtectionSuccess(result) {
        let encodeString = JSON.parse(result.data);
        this.validateHashValue(encodeString[1]);
    }
    /* tslint:enable:no-any */
    validateHashValue(currentHashValue) {
        let localeValue = new L10n('documenteditor', this.owner.defaultLocale);
        localeValue.setLocale(this.viewer.owner.locale);
        let decodeUserHashValue = this.base64.decodeString(currentHashValue);
        let documentHashValue = this.viewer.hashValue;
        let defaultHashValue = this.base64.decodeString(documentHashValue);
        let stopProtection = true;
        if (decodeUserHashValue.length === defaultHashValue.length) {
            for (let i = 0; i < decodeUserHashValue.length; i++) {
                if (decodeUserHashValue[i] !== defaultHashValue[i]) {
                    stopProtection = false;
                    break;
                }
            }
        }
        else {
            stopProtection = false;
        }
        if (stopProtection) {
            this.viewer.isDocumentProtected = false;
            this.viewer.restrictFormatting = false;
            this.viewer.selection.highlightEditRegion();
            let restrictPane = this.viewer.restrictEditingPane.restrictPane;
            if (restrictPane && restrictPane.style.display === 'block') {
                this.viewer.restrictEditingPane.showStopProtectionPane(false);
            }
            this.viewer.dialog.hide();
        }
        else {
            DialogUtility.alert(localeValue.getConstant('The password is incorrect'));
        }
    }
    /**
     * Notify content change event
     * @private
     */
    fireContentChange() {
        if (this.selection.isHighlightEditRegion) {
            this.selection.onHighlight();
        }
        if (!this.isPaste) {
            this.copiedContent = undefined;
            this.copiedTextContent = '';
            this.selection.isViewPasteOptions = false;
            if (this.isPasteListUpdated) {
                this.isPasteListUpdated = false;
            }
            this.selection.showHidePasteOptions(undefined, undefined);
        }
        if (this.viewer.owner.isLayoutEnabled && !this.viewer.owner.isShiftingEnabled) {
            this.viewer.owner.fireContentChange();
        }
    }
    /**
     * Update physical location for text position
     * @private
     */
    updateSelectionTextPosition(isSelectionChanged) {
        this.getOffsetValue(this.selection);
        this.selection.start.updatePhysicalPosition(true);
        if (this.selection.isEmpty) {
            this.selection.end.setPositionInternal(this.selection.start);
        }
        else {
            this.selection.end.updatePhysicalPosition(true);
        }
        this.selection.upDownSelectionLength = this.selection.end.location.x;
        this.selection.fireSelectionChanged(isSelectionChanged);
    }
    /**
     * Predict text
     * @private
     */
    predictText() {
        this.viewer.suffix = '';
        if (this.selection.start.paragraph.isEmpty() || this.selection.start.offset === 0 &&
            this.selection.start.currentWidget.isFirstLine() || this.selection.end.offset === 0 &&
            this.selection.end.currentWidget.isFirstLine()) {
            this.viewer.prefix = '';
        }
        else {
            this.getPrefixAndSuffix();
        }
        this.viewer.prefix = '@' + String.fromCharCode(160) + this.viewer.prefix; // &nbsp;
        this.viewer.editableDiv.innerText = this.viewer.prefix;
        this.viewer.selection.setEditableDivCaretPosition(this.viewer.prefix.length);
    }
    /**
     * Gets prefix and suffix.
     * @private
     */
    /* tslint:disable:max-func-body-length */
    getPrefixAndSuffix() {
        let viewer = this.viewer;
        if (this.selection.text !== '') {
            viewer.prefix = '';
            return;
        }
        else {
            let startIndex = 0;
            let inlineInfo = this.selection.start.currentWidget.getInline(this.selection.start.offset, startIndex);
            let inline = inlineInfo.element;
            startIndex = inlineInfo.index;
            if (inline !== undefined) {
                let boxInfo = this.selection.getElementBoxInternal(inline, startIndex);
                let box = boxInfo.element;
                startIndex = boxInfo.index;
                let spaceIndex = 0;
                if (!isNullOrUndefined(box)) {
                    let prefixAdded = false;
                    if (box instanceof TextElementBox && startIndex > 0 && box.line.isFirstLine()) {
                        viewer.prefix = '';
                    }
                    if (!(inline instanceof TextElementBox)) {
                        inline = this.selection.getPreviousTextElement(inline);
                    }
                    /* tslint:disable:no-conditional-assignment */
                    while ((spaceIndex = viewer.prefix.lastIndexOf(' ')) < 0 && inline instanceof TextElementBox) {
                        if (inline.previousNode instanceof TextElementBox && viewer.prefix.indexOf(' ') === -1) {
                            if (!prefixAdded) {
                                viewer.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            }
                            else {
                                viewer.prefix = inline.text + viewer.prefix;
                            }
                            inline = inline.previousNode;
                            // If the line has no elements then break the loop to avoid the exception.
                            if (inline instanceof ListTextElementBox) {
                                break;
                            }
                            if (!(inline instanceof TextElementBox)) {
                                inline = this.selection.getPreviousTextElement(inline);
                            }
                        }
                        else if (!(inline.previousNode instanceof TextElementBox)) {
                            if (!prefixAdded) {
                                viewer.prefix = inline.text.substring(0, startIndex);
                                prefixAdded = true;
                            }
                            else {
                                viewer.prefix = inline.text + viewer.prefix;
                            }
                            break;
                        }
                    }
                    if (!(viewer.prefix.length > 1 && viewer.prefix[viewer.prefix.length - 1] === ' ' &&
                        viewer.prefix[viewer.prefix.length - 2] === '.')) {
                        spaceIndex = viewer.prefix.lastIndexOf(' ');
                    }
                    else {
                        spaceIndex = -1;
                        viewer.prefix = '';
                    }
                    viewer.prefix = spaceIndex < 0 ? viewer.prefix : viewer.prefix.substring(spaceIndex);
                    if (viewer.prefix.indexOf(' ') === 0 && viewer.prefix.length >= 1) {
                        viewer.prefix = viewer.prefix.substring(1);
                    }
                    // suffix text prediction
                    let endIndex = 0;
                    let endInlineInfo = this.selection.end.currentWidget.getInline(this.selection.end.offset, endIndex);
                    let endInline = endInlineInfo.element;
                    endIndex = endInlineInfo.index;
                    boxInfo = this.selection.getElementBoxInternal(endInline, endIndex);
                    box = boxInfo.element;
                    endIndex = boxInfo.index;
                    if (box) {
                        let suffixAdded = false;
                        if (box instanceof TextElementBox && endIndex < box.length) {
                            viewer.suffix = '';
                        }
                        // boxIndex = renderedElements.get(endInline).indexOf(box);
                        while ((spaceIndex = viewer.suffix.indexOf(' ')) < 0 && endInline instanceof TextElementBox) {
                            if (endInline.nextNode instanceof TextElementBox && viewer.suffix.indexOf(' ') === -1) {
                                if (!suffixAdded) {
                                    viewer.suffix = box.text.substring(endIndex);
                                    suffixAdded = true;
                                }
                                else {
                                    viewer.suffix = viewer.suffix + endInline.text;
                                }
                                endInline = endInline.nextNode;
                            }
                            else if (!(endInline.nextNode instanceof TextElementBox)) {
                                if (!suffixAdded) {
                                    viewer.suffix = box.text.substring(endIndex);
                                    suffixAdded = true;
                                }
                                else {
                                    viewer.suffix = viewer.suffix + endInline.text;
                                }
                                break;
                            }
                        }
                        spaceIndex = viewer.suffix.indexOf(' ');
                        viewer.suffix = spaceIndex < 0 ? viewer.suffix : viewer.suffix.substring(0, spaceIndex);
                    }
                }
            }
        }
    }
    /**
     * key action
     * @private
     */
    // tslint:disable:max-func-body-length
    onKeyDownInternal(event, ctrl, shift, alt) {
        let key = event.which || event.keyCode;
        if (ctrl && !shift && !alt) {
            this.viewer.isControlPressed = true;
            switch (key) {
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(false, false);
                    }
                    break;
                case 13:
                    event.preventDefault();
                    this.insertPageBreak();
                    break;
                case 48:
                    event.preventDefault();
                    this.onApplyParagraphFormat('beforeSpacing', 0, false, false);
                    break;
                case 49:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 1, false, false);
                    }
                    break;
                case 50:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 2, false, false);
                    }
                    break;
                case 53:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyParagraphFormat('lineSpacing', 1.5, false, false);
                    }
                    break;
                case 66:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBold();
                    }
                    break;
                case 68:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.fontDialogModule) {
                        this.owner.fontDialogModule.showFontDialog();
                    }
                    break;
                case 69:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Center');
                    }
                    event.preventDefault();
                    break;
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnly && this.owner.optionsPaneModule) {
                        this.owner.optionsPaneModule.isReplace = true;
                        this.owner.optionsPaneModule.showHideOptionsPane(true);
                    }
                    break;
                case 73:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleItalic();
                    }
                    break;
                case 74:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Justify');
                    }
                    event.preventDefault();
                    break;
                case 75:
                    event.preventDefault();
                    if (this.owner.hyperlinkDialogModule && !this.owner.isReadOnlyMode) {
                        this.owner.hyperlinkDialogModule.show();
                    }
                    break;
                case 76:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Left');
                    }
                    event.preventDefault();
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.increaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 78:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.openBlank();
                    }
                    break;
                case 82:
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleTextAlignment('Right');
                    }
                    event.preventDefault();
                    break;
                case 85:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.toggleUnderline('Single');
                    }
                    break;
                case 88:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.editor.cut();
                    }
                    break;
                case 89:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.redo();
                        event.preventDefault();
                    }
                    break;
                case 90:
                    if (this.owner.enableEditorHistory) {
                        this.editorHistory.undo();
                        event.preventDefault();
                    }
                    break;
                case 219:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 221:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBaselineAlignment('Subscript');
                    }
                    break;
            }
        }
        else if (shift && !ctrl && !alt) {
            switch (key) {
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(false, true);
                    }
                    break;
                case 13:
                    this.handleShiftEnter();
                    event.preventDefault();
                    break;
            }
        }
        else if (shift && ctrl && !alt) {
            switch (key) {
                case 68:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.toggleUnderline('Double');
                    }
                    break;
                case 77:
                    if (!this.owner.isReadOnlyMode) {
                        this.owner.selection.decreaseIndent();
                    }
                    event.preventDefault();
                    break;
                case 188:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'decrement', true);
                    }
                    break;
                case 190:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.onApplyCharacterFormat('fontSize', 'increment', true);
                    }
                    break;
                case 187:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode) {
                        this.toggleBaselineAlignment('Superscript');
                    }
            }
        }
        else if (!shift && ctrl && alt) {
            switch (key) {
                case 72:
                    event.preventDefault();
                    if (!this.owner.isReadOnlyMode && this.owner.isDocumentLoaded) {
                        this.toggleHighlightColor();
                    }
                    break;
            }
        }
        else {
            switch (key) {
                case 8:
                    event.preventDefault();
                    this.handleBackKey();
                    break;
                case 9:
                    event.preventDefault();
                    if (this.owner.acceptTab) {
                        this.selection.handleTabKey(true, false);
                    }
                    break;
                case 13:
                    event.preventDefault();
                    this.viewer.triggerSpellCheck = true;
                    this.handleEnterKey();
                    this.viewer.triggerSpellCheck = false;
                    break;
                case 27:
                    event.preventDefault();
                    if (!this.isPaste) {
                        this.copiedContent = undefined;
                        this.copiedTextContent = '';
                        this.selection.isViewPasteOptions = false;
                        if (this.isPasteListUpdated) {
                            this.isPasteListUpdated = false;
                        }
                        this.selection.showHidePasteOptions(undefined, undefined);
                    }
                    break;
                case 46:
                    this.handleDelete();
                    event.preventDefault();
                    break;
            }
        }
    }
    /**
     * @private
     */
    handleShiftEnter() {
        if (!this.owner.isReadOnlyMode) {
            this.handleTextInput('\v');
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles back key.
     * @private
     */
    handleBackKey() {
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.onBackSpace();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles delete
     * @private
     */
    handleDelete() {
        if (!this.owner.isReadOnlyMode) {
            this.owner.editorModule.delete();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Handles enter key.
     * @private
     */
    handleEnterKey() {
        if (!this.owner.isReadOnlyMode) {
            if (Browser.isDevice) {
                this.viewer.isCompositionStart = false;
            }
            this.owner.editorModule.onEnter();
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * @private
     */
    handleTextInput(text) {
        if (!this.owner.isReadOnlyMode) {
            if (this.animationTimer) {
                clearTimeout(this.animationTimer);
            }
            classList(this.selection.caret, [], ['e-de-cursor-animation']);
            this.owner.editorModule.insertText(text);
            /* tslint:disable:align */
            this.animationTimer = setTimeout(() => {
                if (this.animationTimer) {
                    clearTimeout(this.animationTimer);
                }
                if (this.selection && this.selection.caret) {
                    classList(this.selection.caret, ['e-de-cursor-animation'], []);
                }
            }, 600);
        }
        this.selection.checkForCursorVisibility();
    }
    /**
     * Copies to format.
     * @param  {WCharacterFormat} format
     * @private
     */
    copyInsertFormat(format, copy) {
        let insertFormat = new WCharacterFormat();
        let sFormat = this.selection.characterFormat;
        if (copy) {
            insertFormat.copyFormat(format);
        }
        if (!isNullOrUndefined(sFormat.bold) && format.bold !== sFormat.bold) {
            insertFormat.bold = sFormat.bold;
        }
        if (!isNullOrUndefined(sFormat.italic) && format.italic !== sFormat.italic) {
            insertFormat.italic = sFormat.italic;
        }
        if (sFormat.fontSize > 0 && format.fontSize !== sFormat.fontSize) {
            insertFormat.fontSize = sFormat.fontSize;
        }
        if (!isNullOrUndefined(sFormat.fontFamily) && format.fontFamily !== sFormat.fontFamily) {
            insertFormat.fontFamily = sFormat.fontFamily;
        }
        if (!isNullOrUndefined(sFormat.highlightColor) && format.highlightColor !== sFormat.highlightColor) {
            insertFormat.highlightColor = sFormat.highlightColor;
        }
        if (!isNullOrUndefined(sFormat.baselineAlignment) && format.baselineAlignment !== sFormat.baselineAlignment) {
            insertFormat.baselineAlignment = sFormat.baselineAlignment;
        }
        if (!isNullOrUndefined(sFormat.fontColor) && format.fontColor !== sFormat.fontColor) {
            insertFormat.fontColor = sFormat.fontColor;
        }
        if (!isNullOrUndefined(sFormat.underline) && format.underline !== sFormat.underline) {
            insertFormat.underline = sFormat.underline;
        }
        if (!isNullOrUndefined(sFormat.strikethrough) && format.strikethrough !== sFormat.strikethrough) {
            insertFormat.strikethrough = sFormat.strikethrough;
        }
        return insertFormat;
    }
    /**
     * Inserts the specified text at cursor position
     * @param  {string} text - text to insert
     */
    insertText(text) {
        if (isNullOrUndefined(text) || text === '') {
            return;
        }
        this.insertTextInternal(text, false);
    }
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    insertTextInternal(text, isReplace) {
        let selection = this.viewer.selection;
        let insertPosition;
        let isRemoved = true;
        this.isListTextSelected();
        this.initHistory('Insert');
        let paragraphInfo = this.selection.getParagraphInfo(selection.start);
        selection.editPosition = selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        let bidi = selection.start.paragraph.paragraphFormat.bidi;
        if (!bidi && this.viewer.layout.isContainsRtl(selection.start.currentWidget)) {
            this.viewer.layout.reArrangeElementsForRtl(selection.start.currentWidget, bidi);
        }
        if ((!selection.isEmpty && !selection.isImageSelected) ||
            this.viewer.isListTextSelected && selection.contextType === 'List') {
            selection.isSkipLayouting = true;
            selection.skipFormatRetrieval = true;
            isRemoved = this.removeSelectedContents(selection);
            selection.skipFormatRetrieval = false;
            selection.isSkipLayouting = false;
        }
        else if (selection.isEmpty && !this.viewer.isListTextSelected && !isReplace) {
            this.viewer.isTextInput = true;
        }
        paragraphInfo = this.selection.getParagraphInfo(selection.start);
        if (isRemoved) {
            selection.owner.isShiftingEnabled = true;
            this.updateInsertPosition();
            insertPosition = selection.start;
            if (insertPosition.paragraph.isEmpty()) {
                let span = new TextElementBox();
                let insertFormat = this.copyInsertFormat(insertPosition.paragraph.characterFormat, true);
                span.characterFormat.copyFormat(insertFormat);
                span.text = text;
                let isBidi = this.viewer.textHelper.getRtlLanguage(text).isRtl;
                span.characterFormat.bidi = isBidi;
                span.line = insertPosition.paragraph.childWidgets[0];
                span.margin = new Margin(0, 0, 0, 0);
                span.line.children.push(span);
                if ((insertPosition.paragraph.paragraphFormat.textAlignment === 'Center'
                    || insertPosition.paragraph.paragraphFormat.textAlignment === 'Right') &&
                    insertPosition.paragraph.paragraphFormat.listFormat.listId === -1) {
                    insertPosition.paragraph.x = this.viewer.clientActiveArea.x;
                }
                this.viewer.layout.reLayoutParagraph(insertPosition.paragraph, 0, 0);
            }
            else {
                let indexInInline = 0;
                // tslint:disable-next-line:max-line-length
                let inlineObj = insertPosition.currentWidget.getInline(insertPosition.offset, indexInInline, bidi, (isReplace) ? false : true);
                let inline = inlineObj.element;
                indexInInline = inlineObj.index;
                inline.ischangeDetected = true;
                if (inline instanceof TextElementBox && text !== ' ' && this.viewer.owner.enableSpellCheck) {
                    this.owner.spellChecker.removeErrorsFromCollection({ 'element': inline, 'text': inline.text });
                    if (!isReplace) {
                        inline.ignoreOnceItems = [];
                    }
                }
                if (inline.canTrigger && inline.text.length <= 1) {
                    inline.canTrigger = false;
                }
                // Todo: compare selection format
                let insertFormat = this.copyInsertFormat(inline.characterFormat, true);
                let isBidi = this.viewer.textHelper.getRtlLanguage(text).isRtl;
                let insertLangId = this.viewer.textHelper.getRtlLanguage(text).id;
                let inlineLangId = 0;
                let isRtl = false;
                if (inline instanceof TextElementBox) {
                    inlineLangId = this.viewer.textHelper.getRtlLanguage(inline.text).id;
                    isRtl = this.viewer.textHelper.getRtlLanguage(inline.text).isRtl;
                }
                if (isBidi || !this.viewer.owner.enableSpellCheck) {
                    insertFormat.bidi = isBidi;
                }
                // tslint:disable-next-line:max-line-length
                if ((!this.viewer.owner.enableSpellCheck || (text !== ' ' && inline.text !== ' ')) && insertFormat.isSameFormat(inline.characterFormat) && (!isBidi || (isBidi && insertLangId === inlineLangId))
                    || (text.trim() === '' && !isBidi && inline.characterFormat.bidi)) {
                    this.insertTextInline(inline, selection, text, indexInInline);
                }
                else {
                    let tempSpan = new TextElementBox();
                    tempSpan.text = text;
                    tempSpan.line = inline.line;
                    tempSpan.characterFormat.copyFormat(insertFormat);
                    let insertIndex = inline.indexInOwner;
                    if (indexInInline === inline.length) {
                        let isParaBidi = inline.line.paragraph.bidi;
                        if (isParaBidi && inline instanceof FieldElementBox && inline.fieldType === 1) {
                            inline = inline.fieldBegin;
                            insertIndex = inline.indexInOwner;
                        }
                        inline.line.children.splice(isParaBidi ? insertIndex : insertIndex + 1, 0, tempSpan);
                    }
                    else if (indexInInline === 0) {
                        if (isRtl && !isBidi) {
                            inline.line.children.splice(insertIndex + 1, 0, tempSpan);
                        }
                        else {
                            inline.line.children.splice(insertIndex, 0, tempSpan);
                        }
                    }
                    else {
                        if (inline instanceof TextElementBox) {
                            let splittedSpan = new TextElementBox();
                            splittedSpan.line = inline.line;
                            splittedSpan.characterFormat.copyFormat(inline.characterFormat);
                            if (bidi && isRtl && !isBidi) {
                                splittedSpan.text = inline.text.slice(0, indexInInline);
                                inline.text = inline.text.substring(indexInInline);
                            }
                            else {
                                splittedSpan.text = inline.text.substring(indexInInline);
                                inline.text = inline.text.slice(0, indexInInline);
                            }
                            if (this.owner.enableSpellCheck) {
                                this.owner.spellChecker.updateSplittedElementError(inline, splittedSpan);
                            }
                            inline.line.children.splice(insertIndex + 1, 0, splittedSpan);
                        }
                        inline.line.children.splice(insertIndex + 1, 0, tempSpan);
                    }
                    this.viewer.layout.reLayoutParagraph(insertPosition.paragraph, inline.line.indexInOwner, 0);
                }
            }
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + text.length, true);
            this.updateEndPosition();
            if (!isNullOrUndefined(this.editorHistory) && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)
                && (this.editorHistory.currentHistoryInfo.action === 'ListSelect') &&
                this.viewer.isListTextSelected) {
                this.editorHistory.updateHistory();
                this.editorHistory.updateComplexHistory();
            }
            this.reLayout(selection);
            this.viewer.isTextInput = false;
        }
        if (!isReplace && isRemoved && (text === ' ' || text === '\t' || text === '\v')) {
            let isList = false;
            if (!(text === '\v')) {
                isList = this.checkAndConvertList(selection, text === '\t');
            }
            if (!isList) {
                if (!isNullOrUndefined(selection.getHyperlinkField())) {
                    return;
                }
                //Checks if the previous text is URL, then it is auto formatted to hyperlink.
                this.checkAndConvertToHyperlink(selection, false);
            }
        }
    }
    /**
     * @private
     */
    insertIMEText(text, isUpdate) {
        if (this.viewer.lastComposedText === text && isUpdate) {
            return;
        }
        // Clone selection start position
        let paragraphInfo = this.selection.getParagraphInfo(this.selection.start);
        let startPosition = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        // Insert IME text in current selection
        this.insertText(text);
        this.viewer.lastComposedText = text;
        // update selection start
        let start = this.selection.start;
        this.setPositionForCurrentIndex(start, startPosition);
        // Update selection end
        let endPosition = new TextPosition(this.owner);
        endPosition.setPositionForLineWidget(start.currentWidget, start.offset + text.length);
        this.selection.selectPosition(isUpdate ? start : endPosition, endPosition);
    }
    /**
     * Insert Section break at cursor position
     */
    insertSectionBreak() {
        let selection = this.viewer.selection;
        if (isNullOrUndefined(selection) || this.owner.isReadOnlyMode || selection.start.paragraph.isInHeaderFooter) {
            return;
        }
        this.initHistory('SectionBreak');
        if (!selection.isEmpty) {
            selection.selectContent(selection.isForward ? selection.start : selection.end, true);
        }
        this.viewer.owner.isShiftingEnabled = true;
        this.updateInsertPosition();
        this.insertSection(selection, true);
        this.updateEndPosition();
        this.reLayout(selection, true);
    }
    /**
     * @private
     */
    insertSection(selection, selectFirstBlock) {
        let newSectionFormat = this.selection.start.paragraph.bodyWidget.sectionFormat.cloneFormat();
        let lastBlock;
        let firstBlock;
        if (selection.start.paragraph.isInsideTable) {
            let table = this.viewer.layout.getParentTable(selection.start.paragraph);
            table = table.combineWidget(this.viewer);
            let insertBefore = false;
            if (selection.start.paragraph.associatedCell.rowIndex === 0) {
                insertBefore = true;
            }
            let newParagraph = new ParagraphWidget();
            let previousBlock = table.previousRenderedWidget;
            if (!insertBefore) {
                lastBlock = this.splitTable(table, selection.start.paragraph.associatedCell.ownerRow);
                this.viewer.layout.layoutBodyWidgetCollection(lastBlock.index, lastBlock.containerWidget, lastBlock, false);
                lastBlock = lastBlock.getSplitWidgets().pop();
            }
            else {
                lastBlock = table;
            }
            let insertIndex = 0;
            if ((isNullOrUndefined(previousBlock) || !previousBlock.bodyWidget.equals(lastBlock.bodyWidget)) && insertBefore) {
                insertIndex = 0;
                newParagraph.index = 0;
            }
            else {
                insertIndex = lastBlock.indexInOwner + 1;
                newParagraph.index = lastBlock.index + 1;
            }
            lastBlock.containerWidget.childWidgets.splice(insertIndex, 0, newParagraph);
            newParagraph.containerWidget = lastBlock.containerWidget;
            this.updateNextBlocksIndex(newParagraph, true);
            this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.containerWidget, newParagraph, false);
            lastBlock = newParagraph;
        }
        else {
            let paragraphInfo = this.selection.getParagraphInfo(selection.start);
            let selectionStart = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
            //Split Paragraph
            this.splitParagraphInternal(selection, selection.start.paragraph, selection.start.currentWidget, selection.start.offset);
            this.setPositionForCurrentIndex(selection.start, selectionStart);
            lastBlock = selection.start.paragraph.getSplitWidgets().pop();
        }
        //Split body widget
        firstBlock = this.splitBodyWidget(lastBlock.bodyWidget, newSectionFormat, lastBlock).firstChild;
        if (firstBlock instanceof TableWidget) {
            firstBlock.updateRowIndex(0);
        }
        this.viewer.layout.layoutBodyWidgetCollection(firstBlock.index, firstBlock.containerWidget, firstBlock, false);
        if (firstBlock instanceof TableWidget) {
            firstBlock = selection.getFirstParagraphInFirstCell(firstBlock);
        }
        if (selectFirstBlock) {
            selection.selectParagraphInternal(firstBlock, true);
        }
        return firstBlock;
    }
    splitBodyWidget(bodyWidget, sectionFormat, startBlock) {
        let newBodyWidget = this.viewer.layout.moveBlocksToNextPage(startBlock);
        //Update SectionIndex for splitted body widget
        this.updateSectionIndex(sectionFormat, newBodyWidget, true);
        // insert New header footer widget in to section index 
        this.insertRemoveHeaderFooter(newBodyWidget.sectionIndex, true);
        //update header and footer for splitted widget
        this.viewer.layout.layoutHeaderFooter(newBodyWidget, this.viewer, newBodyWidget.page);
        //Update Child item index from 0 for new Section
        this.updateBlockIndex(0, newBodyWidget.firstChild);
        // Start sinfting from first block
        this.viewer.updateClientArea(newBodyWidget.sectionFormat, newBodyWidget.page);
        return newBodyWidget;
    }
    insertRemoveHeaderFooter(sectionIndex, insert) {
        if (this.viewer.headersFooters[sectionIndex]) {
            // Need to handle further
        }
        else {
            this.viewer.headersFooters[sectionIndex] = {};
        }
    }
    updateBlockIndex(blockIndex, block) {
        let blocks;
        let sectionIndex = block.bodyWidget.sectionIndex;
        do {
            blocks = block.getSplitWidgets();
            for (let i = 0; i < blocks.length; i++) {
                blocks[i].index = blockIndex;
            }
            blockIndex++;
            block = blocks.pop().nextRenderedWidget;
        } while (!isNullOrUndefined(block) && block.bodyWidget.sectionIndex === sectionIndex);
    }
    updateSectionIndex(sectionFormat, startBodyWidget, increaseIndex) {
        let currentSectionIndex = startBodyWidget.sectionIndex;
        let bodyWidget = startBodyWidget;
        do {
            if (bodyWidget.index === currentSectionIndex && sectionFormat) {
                bodyWidget.sectionFormat = sectionFormat;
            }
            if (increaseIndex) {
                bodyWidget.index++;
            }
            else {
                bodyWidget.index--;
            }
            bodyWidget = bodyWidget.nextRenderedWidget;
        } while (bodyWidget);
    }
    //Auto convert List
    checkAndConvertList(selection, isTab) {
        let list = selection.paragraphFormat.getList();
        if (!isNullOrUndefined(list)) {
            return false;
        }
        let convertList = false;
        let isLeadingZero = false;
        let indexInInline = 0;
        let inlineObj = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (!(inline instanceof TextElementBox)) {
            return false;
        }
        let span = inline;
        let text = span.text.substring(0, indexInInline);
        let tabValue = 0;
        let length = 0;
        while (!isNullOrUndefined(span.previousNode)) {
            // tslint:disable-next-line:max-line-length
            if (span.previousNode instanceof TextElementBox && (span.previousNode.text === '\t' || span.previousNode.text.trim().length === 0)) {
                (span.previousNode.text === '\t') ? tabValue += 36 : length = span.previousNode.text.length * 2.5;
                span = span.previousNode;
                continue;
            }
            return false;
        }
        span = inline;
        let index = 0;
        let tabIndex = text.lastIndexOf('\t');
        index = (tabIndex >= 0) ? tabIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousNode instanceof TextElementBox && index === 0) {
            span = span.previousNode;
            let previousText = span.text;
            tabIndex = previousText.lastIndexOf('\t');
            index = (tabIndex >= 0) ? tabIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
            text = text.substring(index);
        }
        text = HelperMethods.trimStart(text);
        let numberFormat = text.substring(1, 2);
        let previousList = undefined;
        let listLevelPattern = this.getListLevelPattern(text.substring(0, 1));
        if (listLevelPattern !== 'None' && this.checkNumberFormat(numberFormat, listLevelPattern === 'Bullet', text)) {
            convertList = true;
        }
        else if (this.checkLeadingZero(text)) {
            isLeadingZero = true;
            convertList = true;
        }
        else {
            previousList = this.checkNextLevelAutoList(text);
            if (!isNullOrUndefined(previousList)) {
                convertList = true;
            }
        }
        if (convertList) {
            this.initComplexHistory('AutoList');
            let paragraph = inline.paragraph;
            // tslint:disable-next-line:max-line-length
            selection.start.setPositionParagraph(paragraph.childWidgets[0], paragraph.childWidgets[0].getOffset(inline, indexInInline + 1));
            selection.end.setPositionParagraph(paragraph.childWidgets[0], 0);
            this.initHistory('Delete');
            this.deleteSelectedContents(selection, false);
            this.reLayout(selection, false);
            let followCharacter = isTab ? 'Tab' : 'Space';
            numberFormat = !isLeadingZero ? '%1' + numberFormat : '%1' + text.substring(text.length - 1, text.length);
            let leadingZeroText = text.substring(text.length - 3, text.length - 1);
            listLevelPattern = !isLeadingZero ? listLevelPattern : this.getListLevelPattern(leadingZeroText);
            let listLevel = new WListLevel(undefined);
            listLevel.listLevelPattern = listLevelPattern;
            if (listLevelPattern === 'Bullet') {
                if (text === '*') {
                    listLevel.numberFormat = '\uf0b7';
                    listLevel.characterFormat.fontFamily = 'Symbol';
                }
                else if (text === '-') {
                    listLevel.numberFormat = '-';
                }
            }
            else {
                listLevel.numberFormat = numberFormat;
            }
            listLevel.followCharacter = followCharacter;
            let leftIndent = selection.paragraphFormat.leftIndent;
            if (tabValue !== 0 || length !== 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18 + tabValue + length;
            }
            else if (indexInInline > 2) {
                listLevel.paragraphFormat.leftIndent = leftIndent + (indexInInline - 2) * 2.5 + 18;
            }
            else if (leftIndent > 0) {
                listLevel.paragraphFormat.leftIndent = leftIndent + 18;
            }
            else {
                listLevel.paragraphFormat.leftIndent = 36;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            if ((!isLeadingZero && text.substring(0, 1) === '0') || leadingZeroText === '00') {
                listLevel.startAt = 0;
            }
            else {
                listLevel.startAt = 1;
            }
            if (!isNullOrUndefined(previousList)) {
                selection.paragraphFormat.setList(previousList);
            }
            else {
                this.autoConvertList(selection, listLevel);
            }
            if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
                this.editorHistory.updateComplexHistory();
            }
            else {
                this.reLayout(selection);
            }
        }
        return convertList;
    }
    checkNextLevelAutoList(text) {
        let selection = this.viewer.selection;
        let previousList = undefined;
        let convertList = false;
        let currentParagraph = selection.start.paragraph;
        let prevParagraph = selection.getPreviousParagraphBlock(currentParagraph);
        let isList = false;
        while (!isNullOrUndefined(prevParagraph) && prevParagraph instanceof ParagraphWidget) {
            if (prevParagraph.paragraphFormat.listFormat && prevParagraph.paragraphFormat.listFormat.listId !== -1) {
                isList = true;
                break;
            }
            prevParagraph = selection.getPreviousParagraphBlock(prevParagraph);
        }
        if (isList) {
            let listNumber = this.viewer.layout.getListNumber(prevParagraph.paragraphFormat.listFormat, true);
            let prevListText = listNumber.substring(0, listNumber.length - 1);
            let currentListText = text.substring(0, text.length - 1);
            //check if numberFormat equal
            let inputString;
            if (listNumber.substring(listNumber.length - 1) !== text.substring(text.length - 1)) {
                convertList = false;
            }
            else if (currentListText.match(/^[0-9]+$/) && prevListText.match(/^[0-9]+$/)) {
                inputString = parseInt(currentListText, 10);
                if (parseInt(prevListText, 10) === inputString || parseInt(prevListText, 10) + 1 === inputString
                    || parseInt(prevListText, 10) + 2 === inputString) {
                    convertList = true;
                }
            }
            else if (currentListText.match(/^[a-zA-Z]+$/) && prevListText.match(/^[a-zA-Z]+$/)) {
                if (prevListText.charCodeAt(0) === text.charCodeAt(0) || prevListText.charCodeAt(0) + 1 === text.charCodeAt(0)
                    || prevListText.charCodeAt(0) + 2 === text.charCodeAt(0)) {
                    convertList = true;
                }
                else if (currentListText.match(/^[MDCLXVImdclxvi]+$/) && prevListText.match(/^[MDCLXVImdclxvi]+$/)) {
                    let prevListNumber = this.getNumber(prevListText.toUpperCase());
                    let currentListNumber = this.getNumber(currentListText.toUpperCase());
                    if (prevListNumber === currentListNumber || prevListNumber + 1 === currentListNumber
                        || prevListNumber + 2 === currentListNumber) {
                        convertList = true;
                    }
                }
            }
            if (convertList) {
                previousList = this.viewer.getListById(prevParagraph.paragraphFormat.listFormat.listId);
            }
        }
        return previousList;
    }
    getNumber(roman) {
        let conversion = { 'M': 1000, 'D': 500, 'C': 100, 'L': 50, 'X': 10, 'V': 5, 'I': 1 };
        let arr = roman.split('');
        let num = 0;
        for (let i = 0; i < arr.length; i++) {
            let currentValue = conversion[arr[i]];
            let nextValue = conversion[arr[i + 1]];
            if (currentValue < nextValue) {
                num -= (currentValue);
            }
            else {
                num += (currentValue);
            }
        }
        return num;
    }
    getListLevelPattern(value) {
        switch (value) {
            case '0':
            case '1':
                return 'Arabic';
            case 'I':
                return 'UpRoman';
            case 'i':
                return 'LowRoman';
            case 'A':
                return 'UpLetter';
            case 'a':
                return 'LowLetter';
            case '*':
            case '-':
                return 'Bullet';
            case '00':
            case '01':
                return 'LeadingZero';
            default:
                return 'None';
        }
    }
    autoConvertList(selection, listLevel) {
        let start = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        let newList = new WList();
        if (this.viewer.lists.length > 0) {
            newList.listId = this.viewer.lists[this.viewer.lists.length - 1].listId + 1;
        }
        else {
            newList.listId = 0;
        }
        let newAbstractList = new WAbstractList();
        let layout = this.viewer;
        if (layout.abstractLists.length > 0) {
            newAbstractList.abstractListId = layout.abstractLists[layout.abstractLists.length - 1].abstractListId + 1;
        }
        else {
            newAbstractList.abstractListId = 0;
        }
        newList.abstractListId = newAbstractList.abstractListId;
        newList.abstractList = newAbstractList;
        layout.abstractLists.push(newAbstractList);
        newAbstractList.levels.push(listLevel);
        listLevel.ownerBase = newAbstractList;
        selection.paragraphFormat.setList(newList);
        selection.paragraphFormat.listLevelNumber = 0;
    }
    checkNumberFormat(numberFormat, isBullet, text) {
        if (isBullet) {
            return numberFormat === '';
        }
        else {
            let index = text.indexOf(numberFormat);
            return (numberFormat === '.' || numberFormat === ')'
                || numberFormat === '>' || numberFormat === '-') && text.substring(index, text.length - 1) === '';
        }
    }
    checkLeadingZero(text) {
        let j;
        let isZero = false;
        for (let i = 0; i <= text.length - 1; i++) {
            if (text.charAt(i) === '0') {
                isZero = true;
                continue;
            }
            j = i;
            break;
        }
        let numberFormat = undefined;
        if (text.charAt(j) === '1') {
            numberFormat = text.charAt(j + 1);
        }
        else {
            numberFormat = text.charAt(j);
        }
        return isZero && this.checkNumberFormat(numberFormat, false, text);
    }
    getPageFromBlockWidget(block) {
        let page = undefined;
        if (block.containerWidget instanceof BodyWidget) {
            page = block.containerWidget.page;
        }
        else if (block.containerWidget instanceof HeaderFooterWidget) {
            page = block.containerWidget.page;
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            page = block.containerWidget.bodyWidget.page;
        }
        return page;
    }
    /**
     * @private
     */
    insertTextInline(element, selection, text, index) {
        if (element instanceof TextElementBox) {
            element.text = HelperMethods.insert(element.text, index, text);
            let paragraph = element.line.paragraph;
            let lineIndex = paragraph.childWidgets.indexOf(element.line);
            let elementIndex = element.line.children.indexOf(element);
            if (element.line.paragraph.bidi) {
                this.viewer.layout.reArrangeElementsForRtl(element.line, element.line.paragraph.bidi);
            }
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex, element.line.paragraph.bidi);
        }
        else if (element instanceof ImageElementBox) {
            this.insertImageText(element, selection, text, index);
        }
        else if (element instanceof FieldElementBox) {
            if (element.fieldType === 0) {
                this.insertFieldBeginText(element, selection, text, index);
            }
            else if (element.fieldType === 2) {
                this.insertFieldSeparatorText(element, selection, text, index);
            }
            else {
                this.insertFieldEndText(element, selection, text, index);
            }
        }
        else if (element instanceof BookmarkElementBox) {
            this.insertBookMarkText(element, selection, text, index);
        }
    }
    insertFieldBeginText(fieldBegin, selection, text, index) {
        let spanObj = new TextElementBox();
        spanObj.text = text;
        let lineIndex = fieldBegin.line.paragraph.childWidgets.indexOf(fieldBegin.line);
        let spanIndex = fieldBegin.line.children.indexOf(fieldBegin);
        spanObj.characterFormat.copyFormat(fieldBegin.characterFormat);
        fieldBegin.line.children.splice(spanIndex, 0, spanObj);
        spanObj.line = fieldBegin.line;
        this.viewer.layout.reLayoutParagraph(fieldBegin.line.paragraph, lineIndex, spanIndex);
    }
    insertBookMarkText(element, selection, text, index) {
        let spanObj = new TextElementBox();
        spanObj.text = text;
        let lineIndex = element.line.paragraph.childWidgets.indexOf(element.line);
        let spanIndex = element.line.children.indexOf(element);
        spanObj.characterFormat.copyFormat(element.characterFormat);
        element.line.children.splice(spanIndex, 0, spanObj);
        spanObj.line = element.line;
        this.viewer.layout.reLayoutParagraph(element.line.paragraph, lineIndex, spanIndex);
    }
    insertFieldSeparatorText(fieldSeparator, selection, text, index) {
        let previousInline = selection.getPreviousTextInline(fieldSeparator);
        let nextInline = selection.getNextTextInline(fieldSeparator);
        let span = new TextElementBox();
        span.text = text;
        let spanIndex = fieldSeparator.line.children.indexOf(fieldSeparator);
        if (index === fieldSeparator.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInline) && isNullOrUndefined(nextInline)) {
            span.characterFormat.copyFormat(fieldSeparator.line.paragraph.characterFormat);
        }
        else if (isNullOrUndefined(previousInline)) {
            span.characterFormat.copyFormat(nextInline.characterFormat);
        }
        else {
            span.characterFormat.copyFormat(previousInline.characterFormat);
        }
        fieldSeparator.line.children.splice(spanIndex, 0, span);
        span.line = fieldSeparator.line;
        let lineIndex = fieldSeparator.line.paragraph.childWidgets.indexOf(fieldSeparator.line);
        this.viewer.layout.reLayoutParagraph(fieldSeparator.line.paragraph, lineIndex, spanIndex);
    }
    insertFieldEndText(fieldEnd, selection, text, index) {
        let span = new TextElementBox();
        span.text = text;
        let spanIndex = fieldEnd.line.children.indexOf(fieldEnd);
        span.characterFormat.copyFormat(fieldEnd.characterFormat);
        fieldEnd.line.children.splice(spanIndex + 1, 0, span);
        span.line = fieldEnd.line;
        let lineIndex = fieldEnd.line.paragraph.childWidgets.indexOf(fieldEnd.line);
        this.viewer.layout.reLayoutParagraph(fieldEnd.line.paragraph, lineIndex, spanIndex);
    }
    insertImageText(image, selection, text, index) {
        let previousInlineObj = selection.getPreviousTextInline(image);
        let nextInlineObj = selection.getNextTextInline(image);
        let line = image.line;
        let element = new TextElementBox();
        let paragraph = line.paragraph;
        let lineIndex = paragraph.childWidgets.indexOf(line);
        element.text = text;
        let spanIndex = line.children.indexOf(image);
        if (index === image.length) {
            spanIndex++;
        }
        if (isNullOrUndefined(previousInlineObj) && isNullOrUndefined(nextInlineObj)) {
            element.characterFormat.copyFormat(paragraph.characterFormat);
        }
        else if (isNullOrUndefined(previousInlineObj)) {
            element.characterFormat.copyFormat(nextInlineObj.characterFormat);
        }
        else {
            element.characterFormat.copyFormat(previousInlineObj.characterFormat);
        }
        line.children.splice(spanIndex, 0, element);
        element.line = line;
        this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, spanIndex);
    }
    /**
     * @private
     */
    isListTextSelected() {
        if (this.viewer.isListTextSelected) {
            this.initComplexHistory('ListSelect');
            // tslint:disable-next-line:max-line-length
            if (this.viewer.selection.start.paragraph.paragraphFormat.listFormat && this.viewer.selection.start.paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
    }
    //Auto Format and insert Hyperlink Implementation starts
    checkAndConvertToHyperlink(selection, isEnter, paragraph) {
        let text;
        let span;
        if (isEnter) {
            span = paragraph.lastChild.children[paragraph.lastChild.children.length - 1];
            text = span.text;
        }
        else {
            let indexInInline = 0;
            let inlineObj = selection.start.currentWidget.getInline(selection.start.offset - 1, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!(inline instanceof TextElementBox)) {
                return;
            }
            span = inline;
            text = span.text.substring(0, indexInInline);
        }
        let index = 0;
        let tabCharIndex = text.lastIndexOf('\t');
        index = (tabCharIndex >= 0) ? tabCharIndex + 1 : text.lastIndexOf(' ') + 1;
        while (span.previousNode instanceof TextElementBox && index === 0) {
            span = span.previousNode;
            let previousText = span.text;
            tabCharIndex = previousText.lastIndexOf('\t');
            index = (tabCharIndex >= 0) ? tabCharIndex + 1 : previousText.lastIndexOf(' ') + 1;
            text = span.text + text;
        }
        text = text.substring(index);
        let lowerCaseText = text.toLowerCase();
        let containsURL = false;
        if (lowerCaseText.substring(0, 8) === 'file:///'
            || (lowerCaseText.substring(0, 7) === 'http://' && lowerCaseText.length > 7)
            || (lowerCaseText.substring(0, 8) === 'https://' && lowerCaseText.length > 8)
            || (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4)
            || (lowerCaseText.substring(0, 3) === '\\' && lowerCaseText.length > 3)
            || (lowerCaseText.substring(0, 7) === 'mailto:' && lowerCaseText.length > 7)) {
            containsURL = true;
            if (lowerCaseText.substring(0, 4) === 'www.' && lowerCaseText.length > 4) {
                text = 'http://' + text;
            }
        }
        else {
            let atIndex = text.indexOf('@');
            let dotIndex = text.indexOf('.');
            if (atIndex > 0 && atIndex < dotIndex && dotIndex < text.length - 1) {
                containsURL = true;
                text = 'mailto:' + text;
            }
        }
        if (containsURL) {
            let startPos = new TextPosition(this.viewer.owner);
            startPos.setPositionParagraph(span.line, span.line.getOffset(span, index));
            let endPos = new TextPosition(this.viewer.owner);
            if (isEnter) {
                endPos.setPositionParagraph(span.line, span.line.getEndOffset());
            }
            else {
                if (selection.end.currentWidget.children.length === 0 && selection.end.offset === 0) {
                    let prevLine = selection.end.currentWidget.previousLine;
                    endPos.setPositionParagraph(prevLine, prevLine.getEndOffset());
                }
                else {
                    endPos.setPositionParagraph(selection.end.currentWidget, selection.end.offset - 1);
                }
            }
            this.autoFormatHyperlink(selection, text, startPos, endPos);
        }
    }
    autoFormatHyperlink(selection, url, startPosition, endPosition) {
        this.initComplexHistory('AutoFormatHyperlink');
        let blockInfo = this.selection.getParagraphInfo(startPosition);
        let start = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.insertPosition = start;
        }
        // Moves the selection to URL text start and end position.
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(endPosition);
        // Preserves the character format for hyperlink field.
        let temp = this.getCharacterFormat(selection);
        let format = new WCharacterFormat();
        format.copyFormat(temp);
        let fieldEnd = this.createHyperlinkElement(url, startPosition, endPosition, format);
        // Moves the selection to the end of field end position.
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 1));
        // Moves to next text position. (To achieve common behavior for space and enter).
        selection.start.moveNextPosition();
        selection.end.setPositionInternal(selection.start);
        blockInfo = this.selection.getParagraphInfo(selection.end);
        let end = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.endPosition = end;
            this.editorHistory.updateComplexHistory();
            this.reLayout(selection);
        }
        else {
            this.updateComplexWithoutHistory(0, start, end);
        }
    }
    appylingHyperlinkFormat(selection) {
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'Single', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', '#0563c1', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
    }
    // tslint:disable-next-line:max-line-length
    createHyperlinkElement(url, startPosition, endPosition, format) {
        let selection = this.selection;
        this.viewer.layout.allowLayout = false;
        this.appylingHyperlinkFormat(selection);
        this.viewer.layout.allowLayout = true;
        // Adds the field end at the URL text end position.
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.characterFormat.copyFormat(format);
        fieldEnd.line = selection.end.currentWidget;
        selection.start.setPositionInternal(selection.end);
        // this.insertElementInCurrentLine(selection, fieldEnd, true);
        this.initInsertInline(fieldEnd);
        // Moves the selection to URL text start position.        
        selection.start.setPositionInternal(startPosition);
        selection.end.setPositionInternal(selection.start);
        // Adds field begin, field code and field separator at the URL text start position.
        let begin = this.insertHyperlinkfield(selection, format, url);
        let lineIndex = selection.start.paragraph.childWidgets.indexOf(begin.line);
        let index = begin.line.children.indexOf(begin);
        fieldEnd.linkFieldCharacter(this.viewer);
        this.viewer.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
        return fieldEnd;
    }
    insertHyperlinkfield(selection, format, url, isBookmark) {
        // Adds field begin, field code and field separator at the URL text start position.
        let begin = new FieldElementBox(0);
        begin.characterFormat.copyFormat(format);
        begin.line = selection.start.currentWidget;
        this.initInsertInline(begin);
        let span = new TextElementBox();
        span.characterFormat.copyFormat(format);
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        }
        else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        span.line = selection.start.currentWidget;
        this.initInsertInline(span);
        let separator = new FieldElementBox(2);
        separator.characterFormat.copyFormat(format);
        separator.line = selection.start.currentWidget;
        this.initInsertInline(separator);
        return begin;
    }
    unLinkFieldCharacter(inline) {
        if (inline instanceof FieldElementBox && inline.fieldType === 0) {
            if (inline.fieldEnd) {
                if (this.viewer) {
                    this.viewer.fieldToLayout = inline;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                // inline.line.paragraph.addFieldCharacter(inline.fieldEnd);
                inline.fieldEnd = undefined;
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (!isNullOrUndefined(inline.fieldEnd)) {
                if (this.viewer) {
                    this.viewer.fieldToLayout = inline.fieldBegin;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                inline.fieldBegin.fieldSeparator = undefined;
                inline.fieldEnd.fieldSeparator = undefined;
            }
        }
        else if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            if (inline.fieldBegin) {
                if (!isNullOrUndefined(this.viewer)) {
                    this.viewer.fieldToLayout = inline.fieldBegin;
                    this.viewer.fieldEndParagraph = inline.line.paragraph;
                }
                let fieldIndex = this.viewer.fields.indexOf(inline.fieldBegin);
                if (fieldIndex !== -1) {
                    this.viewer.fields.splice(fieldIndex, 1);
                }
                inline.fieldBegin = undefined;
            }
        }
    }
    getCharacterFormat(selection) {
        if (selection.start.paragraph.isEmpty()) {
            return selection.start.paragraph.characterFormat;
        }
        else {
            let info = selection.start.currentWidget.getInline(selection.start.offset, 0);
            return info.element.characterFormat;
        }
    }
    /**
     * Insert Hyperlink
     * @param  {string} address - Hyperlink URL
     * @param  {string} displayText - Display text for the hyperlink
     */
    insertHyperlink(address, displayText) {
        if (isNullOrUndefined(displayText)) {
            displayText = address;
        }
        this.insertHyperlinkInternal(address, displayText, this.owner.selection.text !== displayText, false);
    }
    /**
     * @private
     */
    insertHyperlinkInternal(url, displayText, remove, isBookmark) {
        let selection = this.viewer.selection;
        if (selection.start.paragraph.associatedCell !== selection.end.paragraph.associatedCell) {
            return;
        }
        if (remove) {
            //Empty selection Hyperlink insert
            this.insertHyperlinkInternalInternal(selection, url, displayText, isBookmark);
        }
        else {
            //Non-Empty Selection- change the selected text to Field       
            // this.preservedFontCol = this.getFontColor();
            let startPosition = selection.start;
            let endPosition = selection.end;
            if (!selection.isForward) {
                startPosition = selection.end;
                endPosition = selection.start;
            }
            let fieldStartPosition = new TextPosition(this.viewer.owner);
            fieldStartPosition.setPositionInternal(startPosition);
            let temp = this.getCharacterFormat(selection);
            let format = new WCharacterFormat(undefined);
            format.copyFormat(temp);
            this.initComplexHistory('InsertHyperlink');
            let blockInfo = this.selection.getParagraphInfo(startPosition);
            let start = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                // tslint:disable-next-line:max-line-length
                this.editorHistory.currentHistoryInfo.insertPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            }
            this.appylingHyperlinkFormat(selection);
            this.viewer.layout.allowLayout = true;
            startPosition.setPositionInternal(endPosition);
            // Adds the field end at the URL text end position.
            let fieldEnd = new FieldElementBox(1);
            fieldEnd.characterFormat.copyFormat(format);
            fieldEnd.line = selection.end.currentWidget;
            startPosition.setPositionInternal(endPosition);
            // this.insertElementInCurrentLine(selection, fieldEnd, true);
            this.initInsertInline(fieldEnd);
            // Moves the selection to URL text start position.        
            startPosition.setPositionInternal(fieldStartPosition);
            endPosition.setPositionInternal(startPosition);
            // Adds field begin, field code and field separator at the URL text start position.
            let begin = this.insertHyperlinkfield(selection, format, url, isBookmark);
            fieldEnd.linkFieldCharacter(this.viewer);
            let lineIndex = selection.start.paragraph.childWidgets.indexOf(begin.line);
            let index = begin.line.children.indexOf(begin);
            this.viewer.layout.reLayoutParagraph(selection.start.paragraph, lineIndex, index);
            let lineWidget = fieldEnd.line;
            selection.selects(lineWidget, lineWidget.getOffset(fieldEnd, fieldEnd.length), true);
            blockInfo = this.selection.getParagraphInfo(endPosition);
            let end = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
                // tslint:disable-next-line:max-line-length
                this.editorHistory.currentHistoryInfo.endPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
                this.editorHistory.updateComplexHistory();
            }
            else {
                this.updateComplexWithoutHistory(1, start, end);
            }
        }
    }
    insertHyperlinkInternalInternal(selection, url, displayText, isBookmark) {
        if (isNullOrUndefined(selection.start)) {
            return;
        }
        if (this.editHyperlink(selection, url, displayText)) {
            return;
        }
        this.initHistory('InsertHyperlink');
        let isRemoved = true;
        if (!selection.isEmpty) {
            isRemoved = this.removeSelectedContents(selection);
        }
        if (isRemoved) {
            // Preserves the character format for hyperlink field.
            let temp = this.getCharacterFormat(selection);
            let format = new WCharacterFormat();
            format.copyFormat(temp);
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
        }
        //else
        //    this.Select(Start, true);
    }
    // tslint:disable-next-line:max-line-length
    insertHyperlinkByFormat(selection, url, displayText, format, isBookmark) {
        this.updateInsertPosition();
        selection.owner.isShiftingEnabled = true;
        let element = [];
        let fieldBegin = new FieldElementBox(0);
        element.push(fieldBegin);
        let span = new TextElementBox();
        if (isBookmark) {
            span.text = ' HYPERLINK \\l \"' + url + '\" ';
        }
        else {
            span.text = ' HYPERLINK \"' + url + '\" ';
        }
        element.push(span);
        let fieldSeparator = new FieldElementBox(2);
        element.push(fieldSeparator);
        if (!isNullOrUndefined(displayText) && displayText !== '') {
            span = new TextElementBox();
            span.characterFormat.underline = 'Single';
            span.characterFormat.fontColor = '#0563c1';
            span.text = displayText;
            element.push(span);
        }
        let fieldEnd = new FieldElementBox(1);
        element.push(fieldEnd);
        this.insertElement(element);
        let paragraph = selection.start.paragraph;
        fieldEnd.linkFieldCharacter(this.viewer);
        if (this.viewer.fields.indexOf(fieldBegin) === -1) {
            this.viewer.fields.push(fieldBegin);
        }
        let offset = fieldEnd.line.getOffset(fieldEnd, 1);
        selection.selects(fieldEnd.line, fieldEnd.line.getOffset(fieldEnd, fieldEnd.length), true);
        this.updateEndPosition();
        this.reLayout(selection, true);
    }
    initInsertInline(element, insertHyperlink) {
        this.initHistory('InsertInline');
        this.insertInlineInSelection(this.viewer.selection, element);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
    }
    /**
     * @private
     */
    insertElementInCurrentLine(selection, inline, isReLayout) {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        this.updateInsertPosition();
        this.insertElement([inline]);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    }
    /**
     * Edit Hyperlink
     * @param  {Selection} selection
     * @param  {string} url
     * @param  {string} displayText
     * @private
     */
    editHyperlink(selection, url, displayText, isBookmark) {
        let fieldBegin = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return false;
        }
        this.initHistory('InsertHyperlink');
        this.editHyperlinkInternal = isNullOrUndefined(this.editorHistory)
            || (this.editorHistory && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo));
        let fieldResult = '';
        let isNestedField = false;
        // Preserves the character format for hyperlink field.
        let temp = this.getCharacterFormat(selection);
        let format = new WCharacterFormat();
        format.copyFormat(temp);
        let fieldSeparator = undefined;
        if (!isNullOrUndefined(fieldBegin.fieldSeparator)) {
            fieldSeparator = fieldBegin.fieldSeparator;
            // tslint:disable-next-line:max-line-length
            let fieldObj = selection.getHyperlinkDisplayText(fieldBegin.fieldSeparator.line.paragraph, fieldBegin.fieldSeparator, fieldBegin.fieldEnd, isNestedField, format);
            fieldResult = fieldObj.displayText;
            isNestedField = fieldObj.isNestedField;
            format = fieldObj.format;
        }
        let offset = fieldBegin.line.getOffset(fieldBegin, 0);
        selection.start.setPositionParagraph(fieldBegin.line, offset);
        offset = fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, 1);
        selection.end.setPositionParagraph(fieldBegin.fieldEnd.line, offset);
        this.deleteSelectedContents(selection, false);
        if (!isNestedField && fieldResult !== displayText || isNullOrUndefined(fieldSeparator)) {
            this.insertHyperlinkByFormat(selection, url, displayText, format, isBookmark);
        }
        else {
            //Modify the new hyperlink url. Inserts field begin, url and field separator.
            this.updateInsertPosition();
            let newFieldBegin = new FieldElementBox(0);
            newFieldBegin.characterFormat.copyFormat(fieldBegin.characterFormat);
            newFieldBegin.line = selection.start.currentWidget;
            this.insertInlineInternal(newFieldBegin);
            let span = new TextElementBox();
            span.characterFormat.copyFormat(fieldBegin.characterFormat);
            if (isBookmark) {
                span.text = ' HYPERLINK \\l \"' + url + '\" ';
            }
            else {
                span.text = ' HYPERLINK \"' + url + '\" ';
            }
            span.line = selection.start.currentWidget;
            this.insertInlineInternal(span);
            let nodes = this.editorHistory && this.editorHistory.currentBaseHistoryInfo ?
                this.editorHistory.currentBaseHistoryInfo.removedNodes : this.nodes;
            this.insertClonedFieldResult(selection, nodes, fieldSeparator);
            let fieldEnd = selection.end.currentWidget.getInline(selection.end.offset, 0).element;
            fieldEnd.linkFieldCharacter(this.viewer);
            let paragraph = newFieldBegin.line.paragraph;
            let lineIndex = newFieldBegin.line.paragraph.childWidgets.indexOf(newFieldBegin.line);
            let elementIndex = newFieldBegin.line.children.indexOf(newFieldBegin);
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
            selection.selects(newFieldBegin.fieldEnd.line, offset, true);
            this.updateEndPosition();
            this.reLayout(selection, true);
        }
        this.editHyperlinkInternal = false;
        this.nodes = [];
        return true;
    }
    /* tslint:disable:no-any */
    insertClonedFieldResult(selection, nodes, fieldSeparator) {
        let isStarted = false;
        for (let i = nodes.length - 1; i > -1; i--) {
            let node = nodes[i];
            /* tslint:enable:no-any */
            if (!isStarted) {
                if (fieldSeparator === node) {
                    isStarted = true;
                }
                else {
                    if (node instanceof ParagraphWidget && node === fieldSeparator.line.paragraph) {
                        isStarted = true;
                        let paragraph = undefined;
                        if (i === nodes.length - 1) {
                            paragraph = selection.start.paragraph;
                            let fieldParagraph = fieldSeparator.line.paragraph;
                            this.getClonedFieldResultWithSel(fieldParagraph, selection, fieldSeparator);
                        }
                        else {
                            paragraph = this.getClonedFieldResult(fieldSeparator.line.paragraph, fieldSeparator);
                            this.insertParagraph(paragraph, true);
                        }
                        selection.selectParagraphInternal(selection.getNextParagraphBlock(paragraph), true);
                    }
                    continue;
                }
            }
            if (node instanceof ElementBox) {
                this.insertInlineInternal(node.clone());
            }
            else if (node instanceof BlockWidget) {
                this.insertBlock(node.clone());
            }
            // else if (node instanceof WSection)
            //     editor.insertSection((node as WSection)._Clone());
        }
    }
    getClonedFieldResultWithSel(paragraph, selection, fieldSeparator) {
        let lineIndex = paragraph.childWidgets.indexOf(fieldSeparator.line);
        let elementIndex = paragraph.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (let j = lineIndex; j < paragraph.childWidgets.length; j++) {
            let lineWidget = paragraph.childWidgets[j];
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (let i = elementIndex; i < lineWidget.children.length; i++) {
                this.insertInlineInternal(lineWidget.children[i].clone());
            }
        }
    }
    getClonedFieldResult(curParagraph, fieldSeparator) {
        let paragraph = new ParagraphWidget();
        paragraph.characterFormat.copyFormat(curParagraph.characterFormat);
        paragraph.paragraphFormat.copyFormat(curParagraph.paragraphFormat);
        let lineIndex = curParagraph.childWidgets.indexOf(fieldSeparator.line);
        let elementIndex = curParagraph.childWidgets[lineIndex].children.indexOf(fieldSeparator);
        for (let j = lineIndex; j < curParagraph.childWidgets.length; j++) {
            let lineWidget = curParagraph.childWidgets[j];
            if (j !== lineIndex) {
                elementIndex = 0;
            }
            for (let i = elementIndex; i < lineWidget.children.length; i++) {
                paragraph.childWidgets[0].children.push(lineWidget.children[i]);
            }
        }
        return paragraph;
    }
    /**
     * Removes the hyperlink if selection is within hyperlink.
     */
    removeHyperlink() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let selection = this.selection;
        let fieldBegin = selection.getHyperlinkField();
        if (isNullOrUndefined(fieldBegin)) {
            return;
        }
        let fieldEnd = fieldBegin.fieldEnd;
        let fieldSeparator = fieldBegin.fieldSeparator;
        let fieldStartPosition = new TextPosition(selection.owner);
        // tslint:disable-next-line:max-line-length
        fieldStartPosition.setPositionParagraph(fieldBegin.line, (fieldBegin.line).getOffset(fieldBegin, 0));
        let fieldSeparatorPosition = new TextPosition(selection.owner);
        // tslint:disable-next-line:max-line-length
        fieldSeparatorPosition.setPositionParagraph(fieldSeparator.line, (fieldSeparator.line).getOffset(fieldSeparator, fieldSeparator.length));
        this.initComplexHistory('RemoveHyperlink');
        selection.start.setPositionParagraph(fieldEnd.line, (fieldEnd.line).getOffset(fieldEnd, 0));
        selection.end.setPositionInternal(selection.start);
        this.delete();
        selection.start.setPositionInternal(fieldSeparatorPosition);
        this.initHistory('Underline');
        this.updateCharacterFormatWithUpdate(selection, 'underline', 'None', false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        // Applies font color for field result.
        this.initHistory('FontColor');
        this.updateCharacterFormatWithUpdate(selection, 'fontColor', undefined, false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.reLayout(selection, false);
        selection.end.setPositionInternal(selection.start);
        selection.start.setPositionInternal(fieldStartPosition);
        this.initHistory('Delete');
        this.deleteSelectedContents(selection, false);
        this.reLayout(selection, true);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            this.editorHistory.updateComplexHistory();
        }
    }
    //Paste Implementation starts
    /**
     * Paste copied clipboard content on Paste event
     * @param  {ClipboardEvent} event
     * @param  {any} pasteWindow?
     * @private
     */
    /* tslint:disable:no-any */
    pasteInternal(event, pasteWindow) {
        this.currentPasteOptions = this.owner.defaultPasteOption;
        if (this.viewer.owner.enableLocalPaste) {
            this.paste();
        }
        else {
            this.selection.isViewPasteOptions = true;
            if (this.selection.pasteElement) {
                this.selection.pasteElement.style.display = 'none';
            }
            if (isNullOrUndefined(pasteWindow)) {
                pasteWindow = window;
            }
            /* tslint:enable:no-any */
            let textContent = '';
            let htmlContent = '';
            let rtfContent = '';
            let clipbordData = pasteWindow.clipboardData ? pasteWindow.clipboardData : event.clipboardData;
            if (Browser.info.name !== 'msie') {
                rtfContent = clipbordData.getData('Text/Rtf');
                htmlContent = clipbordData.getData('Text/Html');
            }
            this.copiedTextContent = textContent = clipbordData.getData('Text');
            if (rtfContent !== '') {
                this.pasteAjax(rtfContent, '.rtf');
            }
            else if (htmlContent !== '') {
                let doc = new DOMParser().parseFromString(htmlContent, 'text/html');
                let result = new XMLSerializer().serializeToString(doc);
                result = result.replace(/<!--StartFragment-->/gi, '');
                result = result.replace(/<!--EndFragment-->/gi, '');
                this.pasteAjax(result, '.html');
            }
            else if (textContent !== '') {
                this.pasteContents(textContent);
                this.applyPasteOptions(this.currentPasteOptions);
                this.viewer.editableDiv.innerHTML = '';
            }
            // if (textContent !== '') {
            //     this.pasteContents(textContent);
            //     this.viewer.editableDiv.innerHTML = '';
            // }
        }
        this.viewer.updateFocus();
    }
    /**
     * @private
     */
    pasteAjax(content, type) {
        let proxy = this;
        /* tslint:disable:no-any */
        let formObject = {
            content: content,
            type: type
        };
        this.pasteRequestHandler = new XmlHttpRequestHandler();
        this.pasteRequestHandler.url = proxy.owner.serviceUrl + this.owner.serverActionSettings.systemClipboard;
        this.pasteRequestHandler.responseType = 'json';
        this.pasteRequestHandler.contentType = 'application/json;charset=UTF-8';
        this.pasteRequestHandler.customHeaders = proxy.owner.headers;
        this.pasteRequestHandler.send(formObject);
        showSpinner(this.owner.element);
        this.pasteRequestHandler.onSuccess = this.pasteFormattedContent.bind(this);
        this.pasteRequestHandler.onFailure = this.onPasteFailure.bind(this);
        this.pasteRequestHandler.onError = this.onPasteFailure.bind(this);
    }
    pasteFormattedContent(result) {
        if (this.isPasteListUpdated) {
            this.isPasteListUpdated = false;
        }
        this.pasteContents(isNullOrUndefined(result.data) ? this.copiedTextContent : result.data);
        this.applyPasteOptions(this.currentPasteOptions);
        hideSpinner(this.owner.element);
    }
    onPasteFailure(result) {
        console.error(result.status, result.statusText);
        hideSpinner(this.owner.element);
    }
    /**
     * Pastes provided sfdt content or the data present in local clipboard if any .
     * @param {string} sfdt? insert the specified sfdt content at current position
     */
    paste(sfdt, defaultPasteOption) {
        if (isNullOrUndefined(sfdt)) {
            sfdt = this.owner.enableLocalPaste ? this.copiedData : undefined;
        }
        if (!isNullOrUndefined(defaultPasteOption)) {
            this.currentPasteOptions = defaultPasteOption;
        }
        /* tslint:disable:no-any */
        if (sfdt) {
            let document = JSON.parse(sfdt);
            this.pasteContents(document);
            this.applyPasteOptions(this.currentPasteOptions);
        }
    }
    getUniqueListOrAbstractListId(isList) {
        if (isList && this.viewer.lists.length) {
            let sortedList = this.viewer.lists.slice().sort((a, b) => {
                return a.listId - b.listId;
            });
            return sortedList[sortedList.length - 1].listId + 1;
        }
        else if (this.viewer.abstractLists.length) {
            let sortedAbsList = this.viewer.abstractLists.slice().sort((a, b) => {
                return a.abstractListId - b.abstractListId;
            });
            return sortedAbsList[sortedAbsList.length - 1].abstractListId + 1;
        }
        return 0;
    }
    checkSameLevelFormat(lstLevelNo, abstractList, list) {
        return abstractList.levels[lstLevelNo].listLevelPattern === list.abstractList.levels[lstLevelNo].listLevelPattern
            && abstractList.levels[lstLevelNo].numberFormat === list.abstractList.levels[lstLevelNo].numberFormat;
    }
    listLevelPatternInCollection(lstLevelNo, listLevelPattern, numberFormat) {
        return this.viewer.lists.filter((list) => {
            return list.abstractList.levels[lstLevelNo].listLevelPattern === listLevelPattern
                && list.abstractList.levels[lstLevelNo].numberFormat === numberFormat;
        })[0];
    }
    getBlocksToUpdate(blocks) {
        let blcks = [];
        blocks.forEach((obj) => {
            if (obj.paragraphFormat && obj.paragraphFormat.listFormat
                && Object.keys(obj.paragraphFormat.listFormat).length > 0) {
                blcks.push(obj);
            }
            else if (obj.rows) {
                obj.rows.forEach((row) => {
                    row.cells.forEach((cell) => {
                        blcks = blcks.concat(this.getBlocksToUpdate(cell.blocks));
                    });
                });
            }
        });
        return blcks;
    }
    updateListIdForBlocks(blocks, abstractList, list, id, idToUpdate) {
        let update = false;
        blocks.forEach((obj) => {
            if (obj.paragraphFormat && obj.paragraphFormat.listFormat
                && Object.keys(obj.paragraphFormat.listFormat).length > 0) {
                let format = obj.paragraphFormat.listFormat;
                // tslint:disable-next-line:max-line-length
                let existingList = this.listLevelPatternInCollection(format.listLevelNumber, abstractList.levels[format.listLevelNumber].listLevelPattern, abstractList.levels[format.listLevelNumber].numberFormat);
                if (format.listId === id) {
                    if (isNullOrUndefined(existingList) && (!list || (list
                        && !this.checkSameLevelFormat(format.listLevelNumber, abstractList, list)))) {
                        update = true;
                        format.listId = idToUpdate;
                    }
                    else if (!isNullOrUndefined(existingList)
                        && this.checkSameLevelFormat(format.listLevelNumber, abstractList, existingList)) {
                        if (!format.isUpdated) {
                            format.listId = existingList.listId;
                            format.isUpdated = true;
                        }
                        update = false;
                    }
                }
            }
            else if (obj.rows) {
                obj.rows.forEach((row) => {
                    row.cells.forEach((cell) => {
                        let toUpdate = this.updateListIdForBlocks(cell.blocks, abstractList, list, id, idToUpdate);
                        if (!update) {
                            update = toUpdate;
                        }
                    });
                });
            }
        });
        return update;
    }
    updatePasteContent(pasteContent, sectionId) {
        let uniqueListId = this.getUniqueListOrAbstractListId(true);
        if (pasteContent.lists.filter((obj) => { return obj.listId === uniqueListId; }).length > 0) {
            let sortedPasteList = pasteContent.lists.slice().sort((a, b) => {
                return a.listId - b.listId;
            });
            uniqueListId = sortedPasteList[sortedPasteList.length - 1].listId + 1;
        }
        let uniqueAbsLstId = this.getUniqueListOrAbstractListId(false);
        if (pasteContent.abstractLists.filter((obj) => {
            return obj.abstractListId === uniqueAbsLstId;
        }).length > 0) {
            let sortedPasteAbsList = pasteContent.abstractLists.slice().sort((a, b) => {
                return a.abstractListId - b.abstractListId;
            });
            uniqueAbsLstId = sortedPasteAbsList[sortedPasteAbsList.length - 1].abstractListId + 1;
        }
        for (let k = 0; k < pasteContent.lists.length; k++) {
            let list = pasteContent.lists[k];
            let abstractList = pasteContent.abstractLists.filter((obj) => {
                return obj.abstractListId === list.abstractListId;
            })[0];
            let lstDup = this.viewer.lists.filter((obj) => {
                return obj.listId === list.listId;
            });
            // tslint:disable-next-line:max-line-length
            let isUpdate = this.updateListIdForBlocks(pasteContent.sections[sectionId].blocks, abstractList, lstDup[0], list.listId, uniqueListId);
            if (isUpdate) {
                abstractList.abstractListId = uniqueAbsLstId;
                list.listId = uniqueListId;
                list.abstractListId = uniqueAbsLstId;
                uniqueListId++;
                uniqueAbsLstId++;
            }
            else {
                pasteContent.lists.splice(k, 1);
                pasteContent.abstractLists.splice(pasteContent.abstractLists.indexOf(abstractList), 1);
                k--;
            }
        }
        this.getBlocksToUpdate(pasteContent.sections[sectionId].blocks).forEach((blck) => {
            delete blck.paragraphFormat.listFormat.isUpdated;
        });
    }
    getBlocks(pasteContent) {
        let widgets = [];
        if (typeof (pasteContent) === 'string') {
            let startParagraph = this.selection.start.paragraph;
            if (!this.selection.isForward) {
                startParagraph = this.selection.end.paragraph;
            }
            let arr = [];
            let txt = pasteContent;
            txt = txt.replace(/\r\n/g, '\r');
            arr = txt.split('\r');
            for (let i = 0; i < arr.length; i++) {
                let currentInline = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
                let element = this.selection.getPreviousValidElement(currentInline.element);
                let insertFormat = element ? element.characterFormat :
                    this.copyInsertFormat(startParagraph.characterFormat, false);
                let insertParaFormat = this.viewer.selection.copySelectionParagraphFormat();
                let paragraph = new ParagraphWidget();
                paragraph.paragraphFormat.copyFormat(insertParaFormat);
                let line = new LineWidget(paragraph);
                if (arr[i].length > 0) {
                    let textElement = new TextElementBox();
                    textElement.characterFormat.copyFormat(insertFormat);
                    textElement.text = arr[i];
                    line.children.push(textElement);
                    textElement.line = line;
                }
                paragraph.childWidgets.push(line);
                widgets.push(paragraph);
            }
        }
        else {
            for (let i = 0; i < pasteContent.sections.length; i++) {
                let parser = this.viewer.owner.parser;
                if (!this.isPasteListUpdated && !isNullOrUndefined(pasteContent.lists)) {
                    if (this.viewer.lists.length > 0) {
                        this.updatePasteContent(pasteContent, i);
                    }
                    this.isPasteListUpdated = true;
                    if (!isNullOrUndefined(pasteContent.abstractLists)) {
                        parser.parseAbstractList(pasteContent, this.viewer.abstractLists);
                    }
                    if (!isNullOrUndefined(pasteContent.lists)) {
                        parser.parseList(pasteContent, this.viewer.lists);
                    }
                }
                parser.parseBody(pasteContent.sections[i].blocks, widgets);
            }
        }
        if (this.currentPasteOptions === 'MergeWithExistingFormatting') {
            this.applyMergeFormat(widgets);
        }
        return widgets;
    }
    applyMergeFormat(widgets) {
        let startParagraph = this.selection.start.paragraph;
        let currentInline = this.selection.start.currentWidget.getInline(this.selection.start.offset, 0);
        let element = this.selection.getPreviousValidElement(currentInline.element);
        let insertFormat = element ? element.characterFormat :
            this.copyInsertFormat(startParagraph.characterFormat, false);
        let insertParaFormat = this.viewer.selection.copySelectionParagraphFormat();
        for (let i = 0; i < widgets.length; i++) {
            let widget = widgets[i];
            if (widget instanceof ParagraphWidget) {
                widget.paragraphFormat.copyFormat(insertParaFormat);
                this.applyFormatInternal(widget, insertFormat);
            }
            else {
                for (let j = 0; j < widget.childWidgets.length; j++) {
                    let row = widget.childWidgets[j];
                    for (let k = 0; k < row.childWidgets.length; k++) {
                        let cell = row.childWidgets[k];
                        for (let l = 0; l < cell.childWidgets.length; l++) {
                            this.applyFormatInternal(cell.childWidgets[l], insertFormat);
                        }
                    }
                }
            }
        }
    }
    applyFormatInternal(widget, insertFormat) {
        if (widget instanceof ParagraphWidget) {
            for (let j = 0; j < widget.childWidgets.length; j++) {
                let lineWidget = widget.childWidgets[j];
                for (let k = 0; k < lineWidget.children.length; k++) {
                    let inlineCharacterFormat = lineWidget.children[k].characterFormat;
                    let characterFormat = inlineCharacterFormat.cloneFormat();
                    lineWidget.children[k].characterFormat = insertFormat;
                    if (characterFormat.bold) {
                        lineWidget.children[k].characterFormat.bold = characterFormat.bold;
                    }
                    if (characterFormat.italic) {
                        lineWidget.children[k].characterFormat.italic = characterFormat.italic;
                    }
                }
            }
        }
        else {
            for (let j = 0; j < widget.childWidgets.length; j++) {
                let rowWidget = widget.childWidgets[j];
                for (let k = 0; k < rowWidget.childWidgets.length; k++) {
                    let cellWidget = rowWidget.childWidgets[k];
                    for (let l = 0; l < cellWidget.childWidgets.length; l++) {
                        this.applyFormatInternal(cellWidget.childWidgets[l], insertFormat);
                    }
                }
            }
        }
    }
    applyPasteOptions(options) {
        if (isNullOrUndefined(this.copiedContent) || this.copiedTextContent === '') {
            return;
        }
        this.isSkipHistory = true;
        this.currentPasteOptions = options;
        this.selection.start.setPositionInternal(this.pasteTextPosition.startPosition);
        this.selection.end.setPositionInternal(this.pasteTextPosition.endPosition);
        switch (options) {
            case 'KeepSourceFormatting':
                this.pasteContents(this.copiedContent !== '' ? this.copiedContent : this.copiedTextContent);
                break;
            case 'MergeWithExistingFormatting':
                let start = this.selection.isForward ? this.selection.start : this.selection.end;
                let currentFormat = start.paragraph.paragraphFormat;
                this.pasteContents(this.copiedContent !== '' ? this.copiedContent : this.copiedTextContent, currentFormat);
                break;
            case 'KeepTextOnly':
                this.pasteContents(this.copiedTextContent);
                break;
        }
        this.isSkipHistory = false;
    }
    pasteContents(content, currentFormat) {
        if (typeof (content) !== 'string') {
            this.copiedContent = content;
        }
        this.pasteContentsInternal(this.getBlocks(content), currentFormat);
    }
    pasteContentsInternal(widgets, currentFormat) {
        this.isPaste = true;
        /* tslint:enable:no-any */
        let selection = this.viewer.selection;
        let isRemoved = true;
        if (!this.isSkipHistory) {
            this.initComplexHistory('Paste');
        }
        if (this.viewer.isListTextSelected) {
            let paragraph = selection.start.paragraph;
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
            }
        }
        if (!this.isSkipHistory) {
            this.initHistory('Paste');
        }
        if (!selection.isEmpty || this.viewer.isListTextSelected) {
            isRemoved = this.removeSelectedContentInternal(selection, selection.start, selection.end);
        }
        if (isRemoved) {
            this.pasteContent(widgets, currentFormat);
        }
        else if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo = undefined;
        }
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.updateHistory();
            this.editorHistory.updateComplexHistory();
        }
        else {
            this.reLayout(selection, selection.isEmpty);
        }
        this.isPaste = false;
    }
    /* tslint:disable:no-any */
    pasteContent(widgets, currentFormat) {
        /* tslint:enable:no-any */
        this.viewer.owner.isShiftingEnabled = true;
        let insertPosition = '';
        this.updateInsertPosition();
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            insertPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
        }
        else {
            let position = this.selection.start;
            if (!this.selection.isForward) {
                position = this.selection.end;
            }
            let blockInfo = this.selection.getParagraphInfo(position);
            insertPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        }
        this.viewer.owner.isLayoutEnabled = true;
        this.viewer.owner.isPastingContent = true;
        this.pasteCopiedData(widgets, currentFormat);
        let endPosition = '';
        this.updateEndPosition();
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            endPosition = this.editorHistory.currentBaseHistoryInfo.endPosition;
        }
        else {
            let blockInfo = this.selection.getParagraphInfo(this.selection.start);
            endPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        }
        let startPosition = new TextPosition(this.viewer.owner);
        this.setPositionForCurrentIndex(startPosition, insertPosition);
        let end = new TextPosition(this.viewer.owner);
        this.setPositionForCurrentIndex(end, endPosition);
        this.pasteTextPosition = { startPosition: startPosition, endPosition: end };
        this.viewer.owner.isPastingContent = false;
        this.viewer.selection.fireSelectionChanged(true);
    }
    pasteCopiedData(widgets, currentFormat) {
        if (this.viewer.layout.isBidiReLayout) {
            this.viewer.layout.isBidiReLayout = false;
        }
        for (let j = 0; j < widgets.length; j++) {
            let widget = widgets[j];
            if (widget instanceof ParagraphWidget && widget.childWidgets.length === 0) {
                widget.childWidgets[0] = new LineWidget(widget);
            }
            if (widget instanceof ParagraphWidget && !isNullOrUndefined(currentFormat)) {
                widget.paragraphFormat.copyFormat(currentFormat);
                let insertFormat = this.copyInsertFormat(this.selection.start.paragraph.characterFormat, false);
                widget.characterFormat.mergeFormat(insertFormat);
            }
            if (j === widgets.length - 1 && widget instanceof ParagraphWidget) {
                let newParagraph = widget;
                if (newParagraph.childWidgets.length > 0
                    && newParagraph.childWidgets[0].children.length > 0) {
                    let insertPosition = this.selection.start;
                    if ((insertPosition.paragraph.paragraphFormat.textAlignment === 'Center'
                        || insertPosition.paragraph.paragraphFormat.textAlignment === 'Right') &&
                        insertPosition.paragraph.paragraphFormat.listFormat.listId === -1) {
                        insertPosition.paragraph.x = this.viewer.clientActiveArea.x;
                    }
                    this.insertElement(newParagraph.childWidgets[0].children, newParagraph.paragraphFormat);
                }
            }
            else if (widget instanceof BlockWidget) {
                let startParagraph = this.selection.start.paragraph;
                if (widget instanceof TableWidget && startParagraph.isInsideTable) {
                    let table = widget;
                    //Handled to resize table based on parent cell width.
                    let clientWidth = startParagraph.getContainerWidth();
                    table.fitCellsToClientArea(clientWidth);
                }
                if (widget instanceof TableWidget && startParagraph.isEmpty()
                    && startParagraph.previousWidget instanceof TableWidget) {
                    this.insertTableRows(widget, startParagraph.previousWidget);
                }
                else {
                    this.insertBlockInternal(widget);
                }
            }
        }
    }
    /**
     * Insert Table on undo
     * @param  {WTable} table
     * @param  {WTable} newTable
     * @param  {boolean} moveRows
     * @private
     */
    insertTableInternal(table, newTable, moveRows) {
        //Gets the index of current table.
        let insertIndex = table.getIndex();
        if (moveRows) {
            //Moves the rows to table.
            for (let i = 0, index = 0; i < table.childWidgets.length; i++, index++) {
                let row = table.childWidgets[i];
                newTable.childWidgets.splice(index, 0, row);
                row.containerWidget = newTable;
                table.childWidgets.splice(i, 1);
                i--;
            }
        }
        let owner = table.containerWidget;
        this.removeBlock(table, true);
        //Inserts table in the current table position.        
        let blockAdvCollection = owner.childWidgets;
        blockAdvCollection.splice(insertIndex, 0, newTable);
        newTable.index = table.index;
        table.containerWidget = undefined;
        newTable.containerWidget = owner;
        this.viewer.layout.clearTableWidget(newTable, true, true, true);
        newTable.buildTableColumns();
        newTable.isGridUpdated = true;
        this.updateNextBlocksIndex(newTable, true);
        this.viewer.layout.linkFieldInTable(newTable);
        this.viewer.layout.layoutBodyWidgetCollection(newTable.index, owner, newTable, false);
    }
    /**
     * Insert Table on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @param  {WTable} table
     * @private
     */
    insertBlockTable(selection, block, table) {
        let offset = selection.start.offset;
        let lineIndex = selection.start.paragraph.childWidgets.indexOf(selection.start.currentWidget);
        if (block instanceof ParagraphWidget && offset > 0) {
            //Moves the inline items before selection start to the inserted paragraph.
            // tslint:disable-next-line:max-line-length
            this.moveInlines(selection.start.paragraph, block, 0, 0, selection.start.paragraph.firstChild, offset, selection.start.currentWidget);
            selection.selectParagraphInternal(selection.start.paragraph, true);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(this.selection.getHierarchicalIndex(block, offset.toString()), true);
            }
        }
        if (offset > 0 && this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
        }
        let index = table.indexInOwner;
        table.containerWidget.childWidgets.splice(index, 0, block);
        block.containerWidget = table.containerWidget;
        block.index = table.index;
        this.updateNextBlocksIndex(block, true);
        this.viewer.layout.layoutBodyWidgetCollection(block.index, block.containerWidget, block, false);
        if (this.checkInsertPosition(selection)) {
            let paragraph = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block;
            }
            if (block instanceof TableWidget) {
                paragraph = selection.getFirstParagraphInFirstCell(block);
            }
            this.updateHistoryPosition(this.selection.getHierarchicalIndex(paragraph, '0'), true);
        }
    }
    /**
     * On cut handle selected content remove and relayout
     * @param  {Selection} selection
     * @param  {TextPosition} startPosition
     * @param  {TextPosition} endPosition
     * @private
     */
    handleCut(selection) {
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.owner.isShiftingEnabled = true;
        let blockInfo = this.selection.getParagraphInfo(startPosition);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        if (startPosition.paragraph === endPosition.paragraph && startPosition.offset + 1 === endPosition.offset) {
            //Gets selected image and copy image to clipboard.
            let index = 0;
            let currentInline = startPosition.paragraph.getInline(endPosition.offset, index);
            let inline = currentInline.element;
            
        }
        this.initHistory('Cut');
        selection.owner.isShiftingEnabled = true;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(selection.editPosition, true);
            }
        }
        this.deleteSelectedContent(endPosition.paragraph, selection, startPosition, endPosition, 3);
        let textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            if (this.checkEndPosition(selection)) {
                this.updateHistoryPosition(selection.end, false);
            }
        }
        this.reLayout(selection);
    }
    insertInlineInternal(element) {
        let selection = this.selection;
        let length = element.length;
        let paragraphInfo = this.selection.getParagraphInfo(selection.start);
        if (selection.start.paragraph.isEmpty()) {
            let paragraph = selection.start.paragraph;
            if ((paragraph.paragraphFormat.textAlignment === 'Center' || paragraph.paragraphFormat.textAlignment === 'Right')
                && paragraph.paragraphFormat.listFormat.listId === -1) {
                paragraph.x = this.viewer.clientActiveArea.x;
            }
            paragraph.childWidgets[0].children.push(element);
            element.line = paragraph.childWidgets[0];
            element.linkFieldCharacter(this.viewer);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
        else {
            let indexInInline = 0;
            let inlineObj = selection.start.currentWidget.getInline(selection.start.offset, indexInInline);
            let curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            this.insertElementInternal(curInline, element, indexInInline, true);
        }
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
    }
    insertElement(element, paragraphFormat) {
        let selection = this.selection;
        let length = 0;
        let paragraph = undefined;
        let lineIndex = -1;
        let lineWidget = undefined;
        let insertIndex = 0;
        let paragraphInfo = this.selection.getParagraphInfo(selection.start);
        if (selection.start.paragraph.isEmpty()) {
            paragraph = selection.start.paragraph;
            lineWidget = paragraph.childWidgets[0];
            lineIndex = 0;
        }
        else {
            let indexInInline = 0;
            let bidi = selection.start.paragraph.paragraphFormat.bidi;
            let inlineObj = selection.start.currentWidget.getInline(selection.start.offset, indexInInline, bidi);
            let curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            paragraph = curInline.line.paragraph;
            lineIndex = paragraph.childWidgets.indexOf(curInline.line);
            insertIndex = curInline.indexInOwner;
            lineWidget = curInline.line;
            if (indexInInline === curInline.length) { // Add new Element in current 
                insertIndex++;
            }
            else if (indexInInline === 0) {
                if (isNullOrUndefined(curInline.previousNode)) {
                    insertIndex = 0;
                }
            }
            else {
                insertIndex++;
                let prevElement = new TextElementBox();
                prevElement.characterFormat.copyFormat(curInline.characterFormat);
                prevElement.text = curInline.text.substring(indexInInline);
                curInline.text = curInline.text.substr(0, indexInInline);
                lineWidget.children.splice(insertIndex, 0, prevElement);
                prevElement.line = curInline.line;
            }
        }
        for (let i = 0; i < element.length; i++) {
            length += element[i].length;
            if (element[i] instanceof TextElementBox && element[i].text.indexOf(' ') >= 0) {
                this.viewer.triggerSpellCheck = true;
            }
            element[i].ischangeDetected = true;
            lineWidget.children.splice(insertIndex, 0, element[i]);
            element[i].line = lineWidget;
            element[i].linkFieldCharacter(this.viewer);
            insertIndex++;
        }
        if (paragraphFormat) {
            paragraph.paragraphFormat.copyFormat(paragraphFormat);
        }
        this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, 0, paragraph.paragraphFormat.bidi);
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
    }
    insertElementInternal(element, newElement, index, relayout) {
        let line = element.line;
        let paragraph = line.paragraph;
        let lineIndex = line.indexInOwner;
        let insertIndex = element.indexInOwner;
        let isBidi = paragraph.paragraphFormat.bidi && element.isRightToLeft;
        if (index === element.length) {
            // Add new Element in current 
            if (!isBidi) {
                insertIndex++;
            }
            line.children.splice(insertIndex, 0, newElement);
        }
        else if (index === 0) {
            if (isNullOrUndefined(element.previousNode)) {
                element.line.children.splice(0, 0, newElement);
                insertIndex = 0;
            }
            else {
                element.line.children.splice(insertIndex, 0, newElement);
            }
        }
        else {
            if (!isBidi) {
                insertIndex++;
            }
            let textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(element.characterFormat);
            textElement.text = element.text.substring(index);
            element.text = element.text.substr(0, index);
            line.children.splice(insertIndex, 0, textElement);
            textElement.line = element.line;
            //Inserts the new inline.
            line.children.splice(isBidi ? insertIndex + 1 : insertIndex, 0, newElement);
            insertIndex -= 1;
        }
        newElement.line = element.line;
        newElement.linkFieldCharacter(this.viewer);
        if (relayout) {
            this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, insertIndex);
        }
    }
    /**
     * Insert Block on undo
     * @param  {Selection} selection
     * @param  {WBlock} block
     * @private
     */
    insertBlock(block) {
        let isRemoved = true;
        let selection = this.selection;
        if (!selection.isEmpty) {
            isRemoved = this.removeSelectedContents(selection);
        }
        if (!isRemoved) {
            selection.selectContent(selection.start, false);
        }
        this.insertBlockInternal(block);
        if (this.checkInsertPosition(selection)) {
            let paragraph = undefined;
            if (block instanceof ParagraphWidget) {
                paragraph = block;
            }
            else {
                paragraph = this.selection.getFirstParagraphInFirstCell(block);
            }
            // tslint:disable-next-line:max-line-length
            this.updateHistoryPosition(this.selection.getHierarchicalIndex(paragraph, '0'), true);
        }
        this.fireContentChange();
    }
    /**
     * Insert new Block on specific index
     * @param  {Selection} selection
     * @param  {BlockWidget} block
     * @private
     */
    insertBlockInternal(block) {
        let selection = this.selection;
        let startPara = this.selection.start.paragraph;
        if (!selection.start.isAtParagraphStart) {
            if (block instanceof ParagraphWidget) {
                this.insertNewParagraphWidget(block, false);
                return;
            }
            this.updateInsertPosition();
            startPara = startPara.combineWidget(this.viewer);
            // tslint:disable-next-line:max-line-length
            this.splitParagraph(startPara, startPara.firstChild, 0, selection.start.currentWidget, selection.start.offset, false);
            selection.selectParagraphInternal(this.selection.start.paragraph, true);
        }
        let bodyWidget = selection.start.paragraph.containerWidget;
        let blockIndex = selection.start.paragraph.index;
        let insertIndex = bodyWidget.childWidgets.indexOf(selection.start.paragraph);
        if (!isNullOrUndefined(bodyWidget)) {
            bodyWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = bodyWidget;
            block.index = blockIndex;
            block.height = 0;
            if (block instanceof TableWidget) {
                block.isGridUpdated = false;
                block.buildTableColumns();
                block.isGridUpdated = true;
            }
            this.updateNextBlocksIndex(block, true);
            this.viewer.layout.layoutBodyWidgetCollection(blockIndex, bodyWidget, block, false);
        }
    }
    /**
     * Inserts the image with specified size at cursor position in the document editor.
     * @param {string} imageString  Base64 string, web URL or file URL.
     * @param {number} width? Image width
     * @param {number} height? Image height
     */
    insertImage(imageString, width, height) {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        if (isNullOrUndefined(width)) {
            width = 100;
        }
        if (isNullOrUndefined(height)) {
            height = 100;
        }
        this.insertPicture(imageString, width, height);
    }
    /**
     * Inserts a table of specified size at cursor position
     *  in the document editor.
     * @param {number} rows Default value of ‘rows’ parameter is 1.
     * @param {number} columns Default value of ‘columns’ parameter is 1.
     */
    insertTable(rows, columns) {
        let startPos = this.selection.start;
        if (this.owner.isReadOnlyMode) {
            return;
        }
        rows = rows || 1;
        columns = columns || 1;
        let table = this.createTable(rows, columns);
        let clientWidth = startPos.paragraph.getContainerWidth();
        table.splitWidthToTableCells(clientWidth);
        let prevBlock = startPos.paragraph.previousWidget;
        if (startPos.currentWidget.isFirstLine() && startPos.offset === 0 && prevBlock instanceof TableWidget) {
            this.insertTableRows(table, prevBlock);
            table.destroy();
            return;
        }
        else {
            this.initHistory('InsertTable');
            this.viewer.owner.isShiftingEnabled = true;
            this.insertBlock(table);
        }
        let startLine = this.selection.getFirstParagraphInFirstCell(table).childWidgets[0];
        startPos.setPosition(startLine, true);
        this.selection.end.setPositionInternal(startPos);
        let lastParagraph = this.selection.getLastParagraphInLastCell(table.getSplitWidgets().pop());
        let endOffset = lastParagraph.getLength() + 1;
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            // tslint:disable-next-line:max-line-length
            this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(lastParagraph, endOffset.toString());
        }
        this.reLayout(this.selection);
    }
    /**
     * Inserts the specified number of rows to the table above or below to the row at cursor position.
     * @param {boolean} above The above parameter is optional and if omitted,
     * it takes the value as false and inserts below the row at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    insertRow(above, count) {
        let rowPlacement = above ? 'Above' : 'Below';
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(rowPlacement === 'Above' ? 'InsertRowAbove' : 'InsertRowBelow');
            }
            this.viewer.owner.isShiftingEnabled = true;
            let startCell = this.getOwnerCell(this.selection.isForward).getSplitWidgets()[0];
            let endCell = this.getOwnerCell(!this.selection.isForward).getSplitWidgets()[0];
            let table = startCell.ownerTable.combineWidget(this.viewer);
            let row = rowPlacement === 'Below' ? endCell.ownerRow : startCell.ownerRow;
            if (this.editorHistory) {
                let clonedTable = this.cloneTableToHistoryInfo(table);
            }
            let rowCount = count ? count : this.getRowCountToInsert();
            let rows = [];
            let index = row.rowIndex;
            if (rowPlacement === 'Below') {
                index++;
                let isAffectedByRowSpannedCell = isNullOrUndefined(endCell.previousWidget)
                    || endCell.columnIndex === endCell.previousWidget.columnIndex + 1;
                let isRowSpanEnd = endCell.cellIndex !== endCell.columnIndex && isAffectedByRowSpannedCell
                    && row.rowIndex + startCell.cellFormat.rowSpan - 1 === endCell.ownerRow.rowIndex;
                if (!isRowSpanEnd) {
                    if (endCell.cellFormat.rowSpan > 1) {
                        if (!isNullOrUndefined(row.nextWidget) && row.nextWidget instanceof TableRowWidget) {
                            endCell.cellFormat.rowSpan += rowCount;
                            row = row.nextWidget;
                        }
                    }
                }
            }
            for (let i = 0; i < rowCount; i++) {
                let cellCountInfo = this.updateRowspan(row, rowPlacement === 'Below' ? endCell : startCell, rowPlacement);
                let newRow = this.createRowAndColumn(cellCountInfo.count, i);
                newRow.rowFormat.copyFormat(row.rowFormat);
                this.updateCellFormatForInsertedRow(newRow, cellCountInfo.cellFormats);
                rows.push(newRow);
            }
            table.insertTableRowsInternal(rows, index);
            let cell = undefined;
            let paragraph = undefined;
            if ((table.childWidgets[index] instanceof TableRowWidget)) {
                cell = table.childWidgets[index].firstChild;
                paragraph = this.selection.getFirstParagraph(cell);
            }
            else {
                let widget = undefined;
                while (!(widget instanceof TableWidget)) {
                    widget = table.nextRenderedWidget;
                }
                paragraph = this.selection.getFirstParagraphInFirstCell(widget);
            }
            this.viewer.layout.reLayoutTable(table);
            this.selection.selectParagraphInternal(paragraph, true);
        }
        this.reLayout(this.selection, true);
    }
    /**
     * Fits the table based on AutoFitType.
     * @param {AutoFitType} - auto fit type
     */
    autoFitTable(fitType) {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        let startPosition = this.selection.start;
        let endPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        let tableAdv = this.selection.getTable(startPosition, endPosition);
        tableAdv = tableAdv.getSplitWidgets()[0];
        let parentTable = this.viewer.layout.getParentTable(tableAdv);
        if (!isNullOrUndefined(parentTable)) {
            this.setOffsetValue(this.selection);
            parentTable = parentTable.combineWidget(this.viewer);
            // tslint:disable-next-line:max-line-length
            this.initHistory(fitType === 'FitToContents' ? 'TableAutoFitToContents' : fitType === 'FitToWindow' ? 'TableAutoFitToWindow' : 'TableFixedColumnWidth');
            if (this.viewer.owner.editorHistoryModule) {
                this.cloneTableToHistoryInfo(parentTable);
            }
            parentTable.updateProperties(true, tableAdv, fitType);
            this.viewer.owner.isShiftingEnabled = true;
            //Layouts the table.
            this.viewer.layout.reLayoutTable(tableAdv);
            this.reLayout(this.selection, true);
        }
    }
    updateCellFormatForInsertedRow(newRow, cellFormats) {
        for (let i = 0; i < newRow.childWidgets.length; i++) {
            newRow.childWidgets[i].cellFormat.copyFormat(cellFormats[i]);
            newRow.childWidgets[i].cellFormat.rowSpan = 1;
        }
    }
    updateRowspan(row, startCell, rowPlacement) {
        let spannedCells = row.getPreviousRowSpannedCells(true);
        let count = 0;
        let cellFormats = [];
        for (let i = 0; i < row.childWidgets.length; i++) {
            let cell = row.childWidgets[i];
            let isCellIncluded = false;
            // Need to check with all the row spanned cells. if the start cell contains rowspan greater than 1, 
            // and when inserting below, need to increment rowspan for all row spanned cells by 1 except
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            // and when inserting above, if cloned cell placed in the same row of start cell or
            // if the cloned cell has equal column index, need to skip updating rowspan value of cloned cell.
            // else update row span value for spanned cell except 
            // if the spanned cells is placed in the same column or cell to be cloned has the same row index of cloned cell row index.
            let isRowSpanned = (isNullOrUndefined(cell.previousWidget)
                || cell.columnIndex !== cell.previousWidget.columnIndex + 1);
            for (let j = 0; j < spannedCells.length; j++) {
                if (isRowSpanned) {
                    let spannedCell = spannedCells[j];
                    let clonedRowIndex = spannedCell.ownerRow.rowIndex + spannedCell.cellFormat.rowSpan - 1;
                    if (cell.columnIndex < spannedCell.columnIndex && cell.cellIndex !== cell.columnIndex) {
                        isCellIncluded = true;
                        count++;
                        cellFormats.push(cell.cellFormat);
                    }
                    if (startCell.cellFormat.rowSpan === 1) {
                        // Need to check whether cell is affected by a row spanned cell. if cell is placed on the row where it is affected 
                        // by row spanned cell, then if we are inserting row below, need to add new cell with spanned cell width
                        // or if we are inserting above, need to update row span value of the spanned cell.
                        // if cell is placed inbetween the spanned cell , 
                        // then if we are inserting below, need to update row span value of spanned cell or
                        // if we are inserting above, need to skip updating row span value except
                        // if start cell is placed on the same row of spanned cell or if start cell placed in the same column.
                        if (clonedRowIndex > cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above'
                                && spannedCell.ownerRow === startCell.ownerRow) {
                                continue;
                            }
                            else {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        }
                        else if (cell.cellIndex !== cell.columnIndex && isRowSpanned && clonedRowIndex === cell.ownerRow.rowIndex) {
                            if (rowPlacement === 'Above') {
                                spannedCell.cellFormat.rowSpan += 1;
                                spannedCells.splice(j, 1);
                                j--;
                            }
                            else {
                                count++;
                                cellFormats.push(spannedCell.cellFormat);
                                spannedCells.splice(j, 1);
                                j--;
                            }
                        }
                    }
                    else {
                        if (spannedCell !== startCell) {
                            if (rowPlacement === 'Above'
                                && (spannedCell.ownerRow === startCell.ownerRow || spannedCell.columnIndex === startCell.columnIndex)) {
                                continue;
                            }
                            else {
                                if (spannedCell.columnIndex !== startCell.columnIndex
                                    && spannedCell.ownerRow.rowIndex !== cell.ownerRow.rowIndex
                                    && (clonedRowIndex > startCell.ownerRow.rowIndex
                                        || (rowPlacement === 'Above' && clonedRowIndex === startCell.ownerRow.rowIndex))) {
                                    spannedCell.cellFormat.rowSpan += 1;
                                    spannedCells.splice(j, 1);
                                    j--;
                                }
                            }
                        }
                    }
                }
            }
            if (spannedCells.indexOf(cell) === -1 && cell.cellFormat.rowSpan > 1) {
                isCellIncluded = true;
            }
            if (!isCellIncluded) {
                count++;
                cellFormats.push(cell.cellFormat);
            }
        }
        return { count, cellFormats };
    }
    insertTableRows(table, prevBlock) {
        this.initHistory('InsertRowBelow');
        table.containerWidget = prevBlock.containerWidget;
        prevBlock = prevBlock.combineWidget(this.viewer);
        if (this.editorHistory) {
            let clonedTable = this.cloneTableToHistoryInfo(prevBlock);
        }
        let row = prevBlock.childWidgets[prevBlock.childWidgets.length - 1];
        prevBlock.insertTableRowsInternal(table.childWidgets, prevBlock.childWidgets.length);
        let paragraph = this.selection.getFirstParagraph(row.nextWidget.childWidgets[0]);
        prevBlock.isDefaultFormatUpdated = false;
        this.viewer.layout.reLayoutTable(prevBlock);
        this.selection.selectParagraphInternal(paragraph, true);
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
            this.updateHistoryPosition(this.selection.start, true);
            this.updateHistoryPosition(this.selection.end, false);
        }
        this.reLayout(this.selection);
    }
    /**
     * Inserts the specified number of columns to the table left or right to the column at cursor position.
     * @param {number} left The left parameter is optional and if omitted, it takes the value as false and
     * inserts to the right of column at cursor position.
     * @param {number} count The count parameter is optional and if omitted, it takes the value as 1.
     */
    insertColumn(left, count) {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let columnPlacement = left ? 'Left' : 'Right';
        if (this.selection.start.paragraph.isInsideTable) {
            if (this.checkIsNotRedoing()) {
                this.initHistory(columnPlacement === 'Left' ? 'InsertColumnLeft' : 'InsertColumnRight');
            }
            this.selection.owner.isShiftingEnabled = true;
            let startCell = this.getOwnerCell(this.selection.isForward);
            let endCell = this.getOwnerCell(!this.selection.isForward);
            let table = startCell.ownerRow.ownerTable.combineWidget(this.viewer);
            if (this.editorHistory) {
                //Clones the entire table to preserve in history.
                let clonedTable = this.cloneTableToHistoryInfo(table);
            }
            this.selection.owner.isLayoutEnabled = false;
            let cellIndex = startCell.columnIndex;
            if (columnPlacement === 'Right') {
                cellIndex = endCell.columnIndex + endCell.cellFormat.columnSpan;
            }
            let startParagraph = undefined;
            let newCell = undefined;
            let columnCount = count ? count : this.getColumnCountToInsert();
            let rowSpannedCells = [];
            for (let i = 0; i < columnCount; i++) {
                for (let j = 0; j < table.childWidgets.length; j++) {
                    let row = table.childWidgets[j];
                    newCell = this.createColumn(this.selection.getLastParagraph(startCell));
                    newCell.index = j;
                    newCell.rowIndex = row.rowIndex;
                    newCell.containerWidget = row;
                    newCell.cellFormat.copyFormat(startCell.cellFormat);
                    newCell.cellFormat.rowSpan = 1;
                    if (isNullOrUndefined(startParagraph)) {
                        startParagraph = this.selection.getFirstParagraph(newCell);
                    }
                    if (cellIndex === 0) {
                        row.childWidgets.splice(cellIndex, 0, newCell);
                    }
                    else {
                        let isCellInserted = false;
                        for (let j = 0; j < row.childWidgets.length; j++) {
                            let rowCell = row.childWidgets[j];
                            // Add the row spanned cells to colection for adding column before / after row spnned cells.
                            if (rowCell.cellFormat.rowSpan > 1) {
                                rowSpannedCells.push(rowCell);
                            }
                            if (rowCell.columnIndex + rowCell.cellFormat.columnSpan === cellIndex) {
                                row.childWidgets.splice(rowCell.cellIndex + 1, 0, newCell);
                                isCellInserted = true;
                            }
                            else if (cellIndex > rowCell.columnIndex && rowCell.columnIndex + rowCell.cellFormat.columnSpan > cellIndex
                                && cellIndex < rowCell.columnIndex + rowCell.cellFormat.columnSpan) {
                                row.childWidgets.splice(rowCell.cellIndex, 0, newCell);
                                isCellInserted = true;
                            }
                            if (isCellInserted) {
                                break;
                            }
                        }
                        // If the cell is not inserted for row, then check for row spanned cells.
                        if (!isCellInserted) {
                            if (rowSpannedCells.length > 0) {
                                for (let k = 0; k < rowSpannedCells.length; k++) {
                                    let rowSpannedCell = rowSpannedCells[k];
                                    if (rowSpannedCell.ownerRow !== row
                                        && row.rowIndex <= rowSpannedCell.ownerRow.rowIndex + rowSpannedCell.cellFormat.rowSpan - 1) {
                                        if (rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan === cellIndex) {
                                            if (rowSpannedCell.cellIndex > row.childWidgets.length) {
                                                row.childWidgets.push(newCell);
                                            }
                                            else {
                                                row.childWidgets.splice(rowSpannedCell.cellIndex, 0, newCell);
                                            }
                                            isCellInserted = true;
                                        }
                                        else if (cellIndex > rowSpannedCell.columnIndex &&
                                            rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan > cellIndex
                                            && cellIndex < rowSpannedCell.columnIndex + rowSpannedCell.cellFormat.columnSpan) {
                                            row.childWidgets.splice(rowSpannedCell.columnIndex, 0, newCell);
                                            isCellInserted = true;
                                        }
                                    }
                                    if (isCellInserted) {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            table.updateRowIndex(0);
            let parentTable = this.viewer.layout.getParentTable(table);
            if (parentTable) {
                parentTable.fitChildToClientArea();
            }
            else {
                table.fitChildToClientArea();
            }
            this.selection.owner.isLayoutEnabled = true;
            table.isGridUpdated = false;
            table.buildTableColumns();
            table.isGridUpdated = true;
            this.viewer.skipScrollToPosition = true;
            this.viewer.layout.reLayoutTable(table);
            this.selection.start.setPosition(startParagraph.firstChild, true);
            this.selection.end.setPosition(this.selection.getLastParagraph(newCell).firstChild, false);
            if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
                this.reLayout(this.selection);
            }
        }
    }
    /**
     * Creates table with specified rows and columns.
     * @private
     */
    createTable(rows, columns) {
        let startPara = this.selection.start.paragraph;
        let table = new TableWidget();
        table.tableFormat = new WTableFormat(table);
        table.tableFormat.preferredWidthType = 'Auto';
        table.tableFormat.initializeTableBorders();
        let index = 0;
        while (index < rows) {
            let tableRow = this.createRowAndColumn(columns, index);
            tableRow.rowFormat.heightType = 'Auto';
            tableRow.containerWidget = table;
            table.childWidgets.push(tableRow);
            index++;
        }
        return table;
    }
    createRowAndColumn(columns, rowIndex) {
        let startPara = this.selection.start.paragraph;
        let tableRow = new TableRowWidget();
        tableRow.rowFormat = new WRowFormat(tableRow);
        tableRow.index = rowIndex;
        for (let i = 0; i < columns; i++) {
            let tableCell = this.createColumn(startPara);
            tableCell.index = i;
            tableCell.rowIndex = rowIndex;
            tableCell.containerWidget = tableRow;
            tableRow.childWidgets.push(tableCell);
        }
        return tableRow;
    }
    createColumn(paragraph) {
        let tableCell = new TableCellWidget();
        let para = new ParagraphWidget();
        para.paragraphFormat.copyFormat(paragraph.paragraphFormat);
        para.characterFormat.copyFormat(paragraph.characterFormat);
        para.containerWidget = tableCell;
        tableCell.childWidgets.push(para);
        tableCell.cellFormat = new WCellFormat(tableCell);
        return tableCell;
    }
    getColumnCountToInsert() {
        let count = 1;
        let start = this.selection.start;
        let end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (start && end && this.selection.getTable(start, end)) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell) {
                return count = 1;
            }
            if (start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = count + end.paragraph.associatedCell.cellIndex - start.paragraph.associatedCell.cellIndex;
            }
            else {
                count = 0;
                // tslint:disable-next-line:max-line-length
                let selectedCells = start.paragraph.associatedCell.ownerTable.getColumnCellsForSelection(start.paragraph.associatedCell, end.paragraph.associatedCell);
                for (let i = 0; i < selectedCells.length; i++) {
                    if (start.paragraph.associatedCell.ownerRow === selectedCells[i].ownerRow) {
                        count++;
                    }
                }
            }
        }
        return count === 0 ? 1 : count;
    }
    getRowCountToInsert() {
        let count = 1;
        let start = this.selection.start;
        let end = this.selection.end;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        if (!isNullOrUndefined(start) && !isNullOrUndefined(end) && !isNullOrUndefined(this.selection.getTable(start, end))) {
            if (start.paragraph.associatedCell === end.paragraph.associatedCell ||
                start.paragraph.associatedCell.ownerRow === end.paragraph.associatedCell.ownerRow) {
                return count = 1;
            }
            else {
                return count = count +
                    this.getOwnerRow(!this.selection.isForward).rowIndex - this.getOwnerRow(this.selection.isForward).rowIndex;
            }
        }
        return count === 0 ? 1 : count;
    }
    getOwnerCell(isStart) {
        let cell = undefined;
        let startCell = isStart ? this.selection.start.paragraph.associatedCell
            : this.selection.end.paragraph.associatedCell;
        let endCell = isStart ? this.selection.end.paragraph.associatedCell
            : this.selection.start.paragraph.associatedCell;
        cell = startCell;
        let owner = cell.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endCell.ownerTable) {
            cell = owner.containerWidget;
            owner = cell.ownerTable;
        }
        return cell;
    }
    getOwnerRow(isStart) {
        let row;
        let startRow = isStart ? this.selection.start.paragraph.associatedCell.ownerRow
            : this.selection.end.paragraph.associatedCell.ownerRow;
        let endRow = isStart ? this.selection.end.paragraph.associatedCell.ownerRow
            : this.selection.start.paragraph.associatedCell.ownerRow;
        row = startRow;
        let owner = row.ownerTable;
        while (!isNullOrUndefined(owner) && owner.containerWidget instanceof TableCellWidget && owner !== endRow.ownerTable) {
            row = owner.containerWidget.ownerRow;
            owner = row.ownerTable;
        }
        return row;
    }
    getOwnerTable(isStart) {
        let table = undefined;
        let startTable = this.selection.start.paragraph.associatedCell.ownerTable;
        let endTable = this.selection.end.paragraph.associatedCell.ownerTable;
        table = isStart ? startTable : endTable;
        while (table.containerWidget instanceof TableCellWidget && table !== (isStart ? endTable : startTable)) {
            table = table.containerWidget.ownerTable;
        }
        return table;
    }
    /**
     * Merge Selected cells
     * @private
     */
    mergeSelectedCellsInTable() {
        if (!this.canMergeCells()) {
            return;
        }
        if (this.checkIsNotRedoing()) {
            this.initHistory('MergeCells');
        }
        this.selection.owner.isShiftingEnabled = true;
        let startPosition = this.selection.start;
        let endPosition = this.selection.end;
        if (!this.selection.isForward) {
            startPosition = this.selection.end;
            endPosition = this.selection.start;
        }
        let startOwnerCell = this.getOwnerCell(this.selection.isForward);
        let endOwnerCell = this.getOwnerCell(!this.selection.isForward);
        let containerCell = this.selection.getContainerCellOf(startOwnerCell, endOwnerCell);
        if (containerCell.ownerTable.contains(endOwnerCell)) {
            if (!this.selection.containsCell(containerCell, endOwnerCell)) {
                //Start and End are in different cells.               
                let table = startOwnerCell.ownerTable.combineWidget(this.viewer);
                startOwnerCell = this.selection.getSelectedCell(startOwnerCell, containerCell);
                endOwnerCell = this.selection.getSelectedCell(endOwnerCell, containerCell);
                //Merges the selected cells.               
                let mergedCell = this.mergeSelectedCells(table, startOwnerCell, endOwnerCell);
                let firstParagraph = this.selection.getFirstParagraph(mergedCell);
                startPosition.setPosition(firstParagraph.firstChild, true);
                let lastParagraph = this.selection.getLastParagraph(mergedCell);
                endPosition.setPosition(lastParagraph.lastChild, false);
            }
        }
        if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
            this.reLayout(this.selection, false);
        }
    }
    mergeSelectedCells(table, startCell, endCell) {
        //Clones the entire table to preserve in history.
        let clonedTable = this.cloneTableToHistoryInfo(table);
        this.selection.owner.isLayoutEnabled = false;
        //Merges the selected cells.
        let start = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let end = start + startCell.cellFormat.cellWidth;
        let endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(start, end, endCellLeft, endCellRight);
        start = cellInfo.start;
        end = cellInfo.end;
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        let mergedCell = undefined;
        let firstBlock;
        for (let i = rowStartIndex; i <= count; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellStart = this.selection.getCellLeft(row, cell);
                if (HelperMethods.round(start, 2) <= HelperMethods.round(cellStart, 2)
                    && HelperMethods.round(cellStart, 2) < HelperMethods.round(end, 2)) {
                    let lastBlock = cell.lastChild;
                    if (lastBlock instanceof ParagraphWidget && lastBlock.isEmpty()) {
                        cell.childWidgets.pop();
                    }
                    if (isNullOrUndefined(mergedCell)) {
                        mergedCell = cell;
                        firstBlock = lastBlock;
                    }
                    else {
                        if (i === rowStartIndex) {
                            mergedCell.cellFormat.preferredWidth += cell.cellFormat.preferredWidth;
                            mergedCell.cellFormat.columnSpan += cell.cellFormat.columnSpan;
                            this.mergeBorders(mergedCell, cell);
                        }
                        for (let k = 0; k < cell.childWidgets.length; k++) {
                            let block = cell.childWidgets[k];
                            let newBlock = block.clone();
                            newBlock.containerWidget = mergedCell;
                            mergedCell.childWidgets.push(newBlock);
                        }
                        row.childWidgets.splice(j, 1);
                        cell.destroy();
                        j--;
                    }
                }
            }
            //To Ensure minimul content. 
            // tslint:disable-next-line:max-line-length
            if ((mergedCell.childWidgets.length === 0 || mergedCell.childWidgets.length === 1 && mergedCell.childWidgets[0] instanceof TableWidget) && firstBlock) {
                let newBlock = firstBlock.clone();
                mergedCell.childWidgets.push(newBlock);
                newBlock.containerWidget = mergedCell;
            }
            if (row.childWidgets.length === 0) {
                let rowIndex = table.childWidgets.indexOf(row);
                row.updateRowBySpannedCells();
                table.childWidgets.splice(rowIndex, 1);
                row.destroy();
                count--;
                i--;
            }
        }
        if (!isNullOrUndefined(mergedCell) && rowStartIndex < count) {
            mergedCell.cellFormat.rowSpan = count - rowStartIndex + 1;
        }
        this.updateBlockIndexAfterMerge(mergedCell);
        table.updateRowIndex(0);
        table.calculateGrid();
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.layout.reLayoutTable(table);
        //Layouts the table after merging cells.
        this.selection.owner.isLayoutEnabled = true;
        return mergedCell;
    }
    mergeBorders(mergedCell, tableCell) {
        let mergedCellborders = undefined;
        let cellBorders = null;
        if (!isNullOrUndefined(mergedCell.cellFormat.borders)) {
            mergedCellborders = mergedCell.cellFormat.borders;
        }
        if (!isNullOrUndefined(tableCell.cellFormat.borders)) {
            cellBorders = tableCell.cellFormat.borders;
        }
        if (isNullOrUndefined(mergedCellborders) && isNullOrUndefined(cellBorders)) {
            return;
        }
        if (isNullOrUndefined(mergedCellborders)) {
            mergedCellborders = new WBorders(mergedCell.cellFormat);
            mergedCellborders.copyFormat(cellBorders);
        }
        else if (isNullOrUndefined(cellBorders)) {
            return;
        }
        else {
            if (mergedCell.ownerRow.rowIndex === tableCell.ownerRow.rowIndex) {
                mergedCellborders.top = mergedCell.getBorderBasedOnPriority(mergedCellborders.top, cellBorders.bottom);
                mergedCellborders.bottom = mergedCell.getBorderBasedOnPriority(mergedCellborders.bottom, cellBorders.bottom);
            }
        }
    }
    updateBlockIndexAfterMerge(cell) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            cell.childWidgets[i].index = i;
        }
    }
    /**
     * Determines whether merge cell operation can be done.
     */
    canMergeCells() {
        if (this.selection.isEmpty || !this.selection.start.paragraph.isInsideTable || !this.selection.end.paragraph.isInsideTable) {
            return false;
        }
        let startPos = this.selection.start;
        let endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        let startCell = this.getOwnerCell(this.selection.isForward);
        let endCell = this.getOwnerCell(!this.selection.isForward);
        let containerCell = this.selection.getContainerCellOf(startCell, endCell);
        if (containerCell.ownerTable.contains(endCell)) {
            if (!this.selection.containsCell(containerCell, endCell)) {
                startCell = this.selection.getSelectedCell(startCell, containerCell);
                endCell = this.selection.getSelectedCell(endCell, containerCell);
                let rowSpan = 1;
                if (startCell.ownerRow === endCell.ownerRow) {
                    let startCellIndex = startCell.ownerRow.childWidgets.indexOf(startCell);
                    for (let i = startCellIndex; i <= startCell.ownerRow.childWidgets.indexOf(endCell); i++) {
                        let cell = startCell.ownerRow.childWidgets[i];
                        let prevCell = cell.previousWidget;
                        if (i !== startCellIndex) {
                            if (cell.cellFormat.rowSpan !== rowSpan) {
                                return false;
                            }
                            if (!isNullOrUndefined(prevCell)
                                && cell.columnIndex !== (prevCell.cellFormat.columnSpan + prevCell.columnIndex)) {
                                return false;
                            }
                        }
                        rowSpan = cell.cellFormat.rowSpan;
                    }
                    return true;
                }
                return this.canMergeSelectedCellsInTable(startCell.ownerTable, startCell, endCell);
            }
        }
        return false;
    }
    canMergeSelectedCellsInTable(table, startCell, endCell) {
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        let startLeft = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let endLeft = startLeft + startCell.cellFormat.cellWidth;
        let endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(startLeft, endLeft, endCellLeft, endCellRight);
        startLeft = cellInfo.start;
        endLeft = cellInfo.end;
        let selectionLeft = 0;
        let selectionRight = 0;
        let isRowLeftWithinSel = false;
        let isRowRightWithinSel = false;
        let rowSpannedCells = [];
        for (let i = rowStartIndex; i <= count; i++) {
            let row = table.childWidgets[i];
            let rowLeft = 0;
            let rowRight = 0;
            let isStarted = false;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellStart = this.selection.getCellLeft(row, cell);
                if (this.checkCellWithInSelection(startLeft, endLeft, cellStart)) {
                    isRowLeftWithinSel = false;
                    isRowRightWithinSel = false;
                    if (cell.cellFormat.rowSpan > 1) {
                        rowSpannedCells.push(cell);
                    }
                    if (!isStarted) {
                        rowLeft = cellStart;
                        rowRight = cellStart;
                        isStarted = true;
                    }
                    let prevCell = cell.previousWidget;
                    if (rowRight !== 0 && HelperMethods.round(rowRight, 0) !== HelperMethods.round(cellStart, 0)) {
                        rowRight = cellStart;
                    }
                    rowRight += HelperMethods.convertPointToPixel(cell.cellFormat.cellWidth);
                    let isPrevCellWithinSel = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, true);
                    let isNextCellWithinSel = this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false);
                    // When selected cell not having row spanned cells and column index is not having immediate cell index value,
                    // then returned false.
                    let isNoRowSpan = rowSpannedCells.length === 0 || rowSpannedCells.length === 1 && rowSpannedCells[0] === cell;
                    // checks whether current cell is with in selection.
                    let isCellWithInSel = this.checkCurrentCell(rowSpannedCells, cell, isPrevCellWithinSel, isNextCellWithinSel);
                    // when last selected row not having equal row span then returned false.
                    if (i === count && !isNullOrUndefined(prevCell) && cell.cellFormat.rowSpan > prevCell.cellFormat.rowSpan
                        && !isCellWithInSel) {
                        return false;
                    }
                    if (i !== rowStartIndex) {
                        for (let m = 0; m < rowSpannedCells.length; m++) {
                            {
                                let rowSpan = (rowSpannedCells[m].ownerRow.rowIndex + rowSpannedCells[m].cellFormat.rowSpan) - 1;
                                if (rowSpan >= row.rowIndex) {
                                    if (rowSpannedCells[m].columnIndex > cell.columnIndex) {
                                        isRowRightWithinSel = true;
                                    }
                                    else {
                                        isRowLeftWithinSel = true;
                                    }
                                    if (i === count && rowSpannedCells[m] !== cell
                                        && rowSpan > (cell.ownerRow.rowIndex + cell.cellFormat.rowSpan - 1)) {
                                        return false;
                                    }
                                    if (rowSpan === row.rowIndex && !this.checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, false)) {
                                        rowSpannedCells.splice(rowSpannedCells.indexOf(rowSpannedCells[m]), 1);
                                    }
                                }
                            }
                        }
                    }
                    if (isPrevCellWithinSel && !isNullOrUndefined(prevCell)
                        && isNoRowSpan
                        && (cell.columnIndex !== prevCell.columnIndex + 1 && this.checkCellWidth(cell))) {
                        return false;
                    }
                }
            }
            if (i === rowStartIndex) {
                selectionLeft = rowLeft;
                selectionRight = rowRight;
            }
            else {
                if (rowRight > 0 && rowLeft > 0) {
                    if (!((isRowLeftWithinSel || Math.round(selectionLeft) === Math.round(rowLeft))
                        && (isRowRightWithinSel || Math.round(selectionRight) === Math.round(rowRight)))) {
                        return false;
                    }
                }
                if (i === count) {
                    return true;
                }
            }
        }
        return false;
    }
    checkCellWidth(cell) {
        let prevCell = cell.previousWidget;
        let cellLeft = this.viewer.selection.getCellLeft(cell.ownerRow, cell);
        let prevCellLeft = this.viewer.selection.getCellLeft(cell.ownerRow, prevCell);
        let left = prevCellLeft + HelperMethods.convertPointToPixel(prevCell.cellFormat.cellWidth);
        if (HelperMethods.round(left, 2) !== HelperMethods.round(cellLeft, 2)) {
            return true;
        }
        return false;
    }
    ;
    checkCellWithInSelection(startLeft, endLeft, cellStart) {
        if (HelperMethods.round(startLeft, 2) <= HelperMethods.round(cellStart, 2)
            && HelperMethods.round(cellStart, 2) < HelperMethods.round(endLeft, 2)) {
            return true;
        }
        return false;
    }
    ;
    checkPrevOrNextCellIsWithinSel(startLeft, endLeft, cell, isPrev) {
        let prevOrNextCell = isPrev ? cell.previousWidget : cell.nextWidget;
        let cellStart = 0;
        if (isNullOrUndefined(prevOrNextCell)) {
            return false;
        }
        cellStart = this.viewer.selection.getCellLeft(prevOrNextCell.ownerRow, prevOrNextCell);
        return this.checkCellWithInSelection(startLeft, endLeft, cellStart);
    }
    // tslint:disable-next-line:max-line-length
    checkCurrentCell(rowSpannedCells, cell, isPrevCellWithInSel, isNextCellWithinSel) {
        let cellOwner = cell.ownerRow;
        if (rowSpannedCells.length > 0) {
            for (let i = 0; i < rowSpannedCells.length; i++) {
                let spannedCellOwner = rowSpannedCells[i].ownerRow;
                let rowSpan = (spannedCellOwner.rowIndex + rowSpannedCells[i].cellFormat.rowSpan) - 1;
                if (rowSpannedCells[i] === cell && (rowSpannedCells.length === 1 || this.checkRowSpannedCells(rowSpannedCells, cell))
                    && !(isNextCellWithinSel || isPrevCellWithInSel)) {
                    return true;
                }
                if (rowSpannedCells[i] !== cell && spannedCellOwner.rowIndex < cellOwner.rowIndex
                    && rowSpan === (cellOwner.rowIndex + cell.cellFormat.rowSpan - 1)) {
                    return true;
                }
            }
        }
        return false;
    }
    checkRowSpannedCells(rowSpannedCells, cell) {
        for (let i = 0; i < rowSpannedCells.length; i++) {
            if (rowSpannedCells[i] !== cell && rowSpannedCells[i].columnIndex === cell.columnIndex) {
                return true;
            }
        }
        return false;
    }
    /**
     * @private
     */
    insertNewParagraphWidget(newParagraph, insertAfter) {
        this.updateInsertPosition();
        this.insertParagraph(newParagraph, insertAfter);
        if (!insertAfter) {
            let nextParagraph;
            let currentParagraph = newParagraph;
            do {
                nextParagraph = this.selection.getNextParagraphBlock(currentParagraph);
                currentParagraph = nextParagraph;
            } while (nextParagraph && nextParagraph.equals(newParagraph));
            if (!isNullOrUndefined(nextParagraph)) {
                this.selection.selectParagraphInternal(nextParagraph, true);
            }
            else {
                this.selection.selectParagraphInternal(newParagraph, true);
            }
        }
        this.fireContentChange();
    }
    insertParagraph(newParagraph, insertAfter) {
        let lineWidget = this.selection.start.currentWidget;
        let offset = this.selection.start.offset;
        let currentParagraph = this.selection.start.paragraph;
        currentParagraph = currentParagraph.combineWidget(this.viewer);
        if (insertAfter) {
            // tslint:disable-next-line:max-line-length
            let length = this.selection.getLineLength(currentParagraph.lastChild);
            let insertIndex = newParagraph.firstChild ? newParagraph.firstChild.children.length : 0;
            // tslint:disable-next-line:max-line-length
            this.moveInlines(currentParagraph, newParagraph, insertIndex, offset, lineWidget, length, currentParagraph.lastChild);
        }
        else if (offset > 0) {
            this.moveInlines(currentParagraph, newParagraph, 0, 0, currentParagraph.firstChild, offset, lineWidget);
        }
        let splittedWidget = currentParagraph.getSplitWidgets();
        currentParagraph = insertAfter ? splittedWidget[splittedWidget.length - 1] : splittedWidget[0];
        let insertIndex = currentParagraph.containerWidget.childWidgets.indexOf(currentParagraph);
        if (insertAfter) {
            insertIndex++;
        }
        let bodyWidget = currentParagraph.containerWidget;
        newParagraph.index = currentParagraph.index;
        newParagraph.containerWidget = bodyWidget;
        bodyWidget.childWidgets.splice(insertIndex, 0, newParagraph);
        this.updateNextBlocksIndex(insertAfter ? currentParagraph : newParagraph, true);
        newParagraph.height = 0;
        this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, bodyWidget, newParagraph, false);
    }
    // tslint:disable-next-line:max-line-length
    moveInlines(currentParagraph, newParagraph, insertIndex, startOffset, startLine, endOffset, endLine) {
        if (newParagraph.childWidgets.length === 0) {
            let line = new LineWidget(newParagraph);
            newParagraph.childWidgets.push(line);
        }
        let isMoved = false;
        this.viewer.layout.clearListElementBox(currentParagraph);
        this.viewer.layout.clearListElementBox(newParagraph);
        for (let j = 0; j < currentParagraph.childWidgets.length; j++) {
            let lineWidget = currentParagraph.childWidgets[j];
            if (startLine === lineWidget && endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, startOffset, endOffset, insertIndex, newParagraph);
                break;
            }
            if (endLine === lineWidget) {
                insertIndex = this.moveContent(lineWidget, 0, endOffset, insertIndex, newParagraph);
                break;
            }
            else if (startLine === lineWidget) {
                isMoved = true;
                // tslint:disable-next-line:max-line-length
                insertIndex = this.moveContent(lineWidget, startOffset, this.viewer.selection.getLineLength(lineWidget), insertIndex, newParagraph);
            }
            else if (isMoved) {
                insertIndex = this.moveContent(lineWidget, 0, this.viewer.selection.getLineLength(lineWidget), insertIndex, newParagraph);
            }
        }
        this.removeEmptyLine(currentParagraph);
        if (!currentParagraph.isInsideTable) {
            this.viewer.layout.reLayoutParagraph(currentParagraph, 0, 0);
        }
    }
    /**
     * @private
     */
    //tslint:disable-next-line:max-line-length
    moveContent(lineWidget, startOffset, endOffset, insertIndex, paragraph) {
        let count = 0;
        let lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        for (let i = 0; i < lineWidget.children.length; i++) {
            let inline = lineWidget.children[i];
            if (startOffset >= count + inline.length || inline instanceof ListTextElementBox) {
                if (!(inline instanceof ListTextElementBox)) {
                    count += inline.length;
                }
                continue;
            }
            let startIndex = 0;
            if (startOffset > count) {
                startIndex = startOffset - count;
            }
            let endIndex = endOffset - count;
            if (endIndex > inline.length) {
                endIndex = inline.length;
            }
            if (startIndex > 0) {
                count += startIndex;
            }
            if (startIndex === 0 && endIndex === inline.length) {
                paragraph.firstChild.children.splice(insertIndex, 0, inline);
                inline.line = paragraph.firstChild;
                insertIndex++;
                // if (editAction < 4) {
                // this.unLinkFieldCharacter(inline);
                lineWidget.children.splice(i, 1);
                i--;
                // }
            }
            else if (inline instanceof TextElementBox) {
                // if (editAction < 4) {
                let span = new TextElementBox();
                span.characterFormat.copyFormat(inline.characterFormat);
                span.text = inline.text.substr(startIndex, endIndex - startIndex);
                inline.ischangeDetected = true;
                span.ischangeDetected = true;
                paragraph.firstChild.children.splice(insertIndex, 0, span);
                span.line = paragraph.firstChild;
                insertIndex++;
                inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
                inline.ischangeDetected = true;
            }
            if (endOffset <= count + endIndex - startIndex) {
                break;
            }
            count += endIndex - startIndex;
        }
        return insertIndex;
    }
    /**
     * update complex changes when history is not preserved
     * @param  {number} action?
     * @param  {string} start?
     * @param  {string} end?
     * @private
     */
    updateComplexWithoutHistory(action, start, end) {
        let selection = this.viewer.selection;
        if (action === 0) {
            let startPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            this.setPositionForCurrentIndex(selection.start, end);
            this.setPositionForCurrentIndex(selection.end, end);
        }
        if (action === 1) {
            let startPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(startPosition, start);
            let endPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(endPosition, end);
            this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
            if (endPosition.paragraph !== startPosition.paragraph) {
                this.viewer.layout.reLayoutParagraph(endPosition.paragraph, 0, 0);
            }
        }
        if (selection.owner.isShiftingEnabled) {
            this.viewer.layout.shiftLayoutedItems();
            if (this.viewer.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
        }
        selection.owner.isShiftingEnabled = false;
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        selection.fireSelectionChanged(true);
        this.viewer.updateFocus();
        this.viewer.updateScrollBars();
        this.fireContentChange();
        this.isHandledComplex = true;
    }
    /**
     * reLayout
     * @param selection
     * @param isSelectionChanged
     * @private
     */
    reLayout(selection, isSelectionChanged) {
        if (!this.viewer.isComposingIME && this.editorHistory && this.editorHistory.isHandledComplexHistory()) {
            if (this.editorHistory.currentHistoryInfo && this.editorHistory.currentHistoryInfo.action !== 'ClearFormat') {
                this.startParagraph = undefined;
                this.endParagraph = undefined;
            }
            this.isHandledComplex = false;
            return;
        }
        if (isNullOrUndefined(this.viewer.blockToShift)) {
            this.viewer.removeEmptyPages();
            this.viewer.layout.updateFieldElements();
            this.viewer.updateScrollBars();
            if (!selection.owner.isShiftingEnabled) {
                selection.fireSelectionChanged(true);
                this.startParagraph = undefined;
                this.endParagraph = undefined;
            }
        }
        if (isNullOrUndefined(isSelectionChanged)) {
            isSelectionChanged = selection.isEmpty;
        }
        if (selection.owner.isShiftingEnabled) {
            selection.owner.isShiftingEnabled = false;
            selection.owner.isLayoutEnabled = true;
            this.viewer.layout.shiftLayoutedItems();
            if (this.viewer.owner.enableHeaderAndFooter) {
                this.updateHeaderFooterWidget();
            }
            this.getOffsetValue(selection);
            selection.upDownSelectionLength = selection.end.location.x;
            selection.fireSelectionChanged(true);
            this.viewer.updateFocus();
            this.startParagraph = undefined;
            this.endParagraph = undefined;
            this.viewer.layout.allowLayout = true;
        }
        if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo &&
            ((this.editorHistory.currentBaseHistoryInfo.action !== 'RowResizing'
                && this.editorHistory.currentBaseHistoryInfo.action !== 'CellResizing')
                || (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
            if (this.editorHistory.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                this.editorHistory.currentBaseHistoryInfo.updateSelection();
            }
            this.editorHistory.updateHistory();
        }
        this.fireContentChange();
    }
    /**
     * @private
     */
    updateHeaderFooterWidget() {
        this.updateHeaderFooterWidgetToPage(this.selection.start.paragraph.bodyWidget);
        let headerFooterWidget = this.selection.start.paragraph.bodyWidget;
        this.shiftPageContent(headerFooterWidget.headerFooterType, headerFooterWidget.sectionFormat);
    }
    /**
     * @private
     */
    updateHeaderFooterWidgetToPage(node) {
        let currentPage = node.page;
        node = this.viewer.layout.updateHeaderFooterToParent(node);
        let isEvenPage = (node.headerFooterType === 'EvenHeader' || node.headerFooterType === 'EvenFooter');
        for (let i = 0; i < this.viewer.pages.length; i++) {
            let page = this.viewer.pages[i];
            if ((i + 1 === 1) && page.bodyWidgets[0].sectionFormat.differentFirstPage &&
                node.headerFooterType.indexOf('FirstPage') !== -1) {
                return;
            }
            if (page.index === 0 && page.bodyWidgets[0].sectionFormat.differentFirstPage &&
                node.headerFooterType.indexOf('FirstPage') === -1) {
                continue;
            }
            if (currentPage !== page) {
                if (page.bodyWidgets[0].sectionFormat.differentOddAndEvenPages) {
                    if (isEvenPage && (i + 1) % 2 === 0) {
                        this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                    }
                    else if ((!isEvenPage && (i + 1) % 2 !== 0)) {
                        if (page.bodyWidgets[0].sectionFormat.differentFirstPage && (i + 1 !== 1)) {
                            this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                        }
                    }
                }
                else {
                    this.updateHeaderFooterWidgetToPageInternal(page, node, node.headerFooterType.indexOf('Header') !== -1);
                }
            }
        }
    }
    /**
     * @private
     */
    updateHeaderFooterWidgetToPageInternal(page, widget, isHeader) {
        if (widget.page !== page) {
            let hfWidget = widget.clone();
            hfWidget.page = page;
            this.viewer.updateHFClientArea(hfWidget.sectionFormat, isHeader);
            hfWidget = this.viewer.layout.layoutHeaderFooterItems(this.viewer, hfWidget);
            let headerOrFooter;
            if (isHeader) {
                headerOrFooter = page.headerWidget;
                page.headerWidget = hfWidget;
            }
            else {
                headerOrFooter = page.footerWidget;
                page.footerWidget = hfWidget;
            }
            this.removeFieldInWidget(headerOrFooter);
            headerOrFooter.destroy();
        }
    }
    /**
     * @private
     */
    removeFieldInWidget(widget, isBookmark) {
        if (isNullOrUndefined(isBookmark)) {
            isBookmark = false;
        }
        for (let i = 0; i < widget.childWidgets.length; i++) {
            this.removeFieldInBlock(widget.childWidgets[i], isBookmark);
        }
    }
    /**
     * @private
     */
    removeFieldInBlock(block, isBookmark) {
        if (block instanceof TableWidget) {
            this.removeFieldTable(block, isBookmark);
        }
        else {
            this.removeField(block, isBookmark);
        }
    }
    /**
     * @private
     */
    removeFieldTable(table, isBookmark) {
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.removeFieldInWidget(row.childWidgets[j], isBookmark);
            }
        }
    }
    /**
     * @private
     */
    shiftPageContent(type, sectionFormat) {
        // let type: HeaderFooterType = headerFooter.headerFooterType;
        let pageIndex;
        if (type.indexOf('First') !== -1) {
            pageIndex = 0;
        }
        else if (sectionFormat.differentOddAndEvenPages) {
            let isEven = type.indexOf('Even') !== -1;
            if (sectionFormat.differentFirstPage) {
                pageIndex = isEven ? 1 : 2;
            }
            else {
                pageIndex = !isEven ? 0 : 1;
            }
        }
        else {
            pageIndex = sectionFormat.differentFirstPage ? 1 : 0;
            if (pageIndex === 1 && this.viewer.pages.length === 1) {
                pageIndex = 0;
            }
        }
        let section = this.viewer.pages[pageIndex].bodyWidgets[0];
        do {
            if (type.indexOf('Header') !== -1) {
                let widget = section.page.headerWidget;
                let isNotEmpty = !widget.isEmpty || widget.isEmpty && this.owner.enableHeaderAndFooter;
                let firstBlock = section.firstChild;
                let top = HelperMethods.convertPointToPixel(sectionFormat.topMargin);
                let headerDistance = HelperMethods.convertPointToPixel(sectionFormat.headerDistance);
                if (isNotEmpty) {
                    top = Math.max(headerDistance + section.page.headerWidget.height, top);
                }
                if (firstBlock.y !== top) {
                    this.viewer.updateClientArea(section.sectionFormat, section.page);
                    firstBlock = firstBlock.combineWidget(this.viewer);
                    let prevWidget = firstBlock.previousRenderedWidget;
                    if (prevWidget) {
                        if (firstBlock.containerWidget.equals(prevWidget.containerWidget)) {
                            this.viewer.cutFromTop(prevWidget.y + prevWidget.height);
                            // tslint:disable-next-line:max-line-length
                            this.viewer.layout.updateContainerWidget(firstBlock, prevWidget.containerWidget, prevWidget.indexInOwner + 1, false);
                        }
                    }
                    this.viewer.blockToShift = firstBlock;
                }
            }
            else {
                this.checkAndShiftFromBottom(section.page, section.page.footerWidget);
            }
            if (this.viewer.blockToShift) {
                this.viewer.renderedLists.clear();
                this.viewer.layout.shiftLayoutedItems();
            }
            while (section) {
                let splittedSection = section.getSplitWidgets();
                section = splittedSection[splittedSection.length - 1].nextRenderedWidget;
                if (section) {
                    if (pageIndex === 0) {
                        break;
                    }
                    else {
                        if (section.page.index + 1 % 2 === 0 && pageIndex === 1 ||
                            (section.page.index + 1 % 2 !== 0 && pageIndex === 2)) {
                            break;
                        }
                        let nextPage = section.page.nextPage;
                        if (nextPage.bodyWidgets[0].equals(section)) {
                            section = nextPage.bodyWidgets[0];
                            break;
                        }
                    }
                }
            }
        } while (section);
    }
    /**
     * @private
     */
    checkAndShiftFromBottom(page, footerWidget) {
        let bodyWidget = page.bodyWidgets[0];
        let blockToShift;
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let block = bodyWidget.childWidgets[i];
            if (block.y + block.height > footerWidget.y) {
                blockToShift = block;
                break;
            }
            if (bodyWidget.childWidgets.length - 1 === i && block.y + block.height < footerWidget.y) {
                blockToShift = block;
                break;
            }
        }
        this.viewer.updateClientArea(bodyWidget.sectionFormat, page);
        this.viewer.cutFromTop(blockToShift.y);
        this.viewer.blockToShift = blockToShift;
    }
    //Paste Implementation ends
    //Character Format apply implementation starts
    /**
     * Change HighlightColor
     * @param  {HighlightColor} highlightColor
     * Applies character format for selection.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @private
     */
    onApplyCharacterFormat(property, value, update) {
        if (this.restrictFormatting) {
            return;
        }
        this.viewer.layout.isBidiReLayout = true;
        let selection = this.viewer.selection;
        if (selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded) {
            return;
        }
        update = isNullOrUndefined(update) ? false : update;
        let action = (property[0].toUpperCase() + property.slice(1));
        let paragraph = selection.start.paragraph;
        let lastLine = paragraph.childWidgets[paragraph.childWidgets.length - 1];
        if (selection.isEmpty && selection.contextType !== 'List') {
            selection.skipFormatRetrieval = true;
            if (selection.end.isAtParagraphEnd) {
                this.initHistory(action);
                this.viewer.owner.isShiftingEnabled = true;
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
                this.reLayout(this.viewer.selection);
                this.viewer.updateFocus();
            }
            else {
                selection.fireSelectionChanged(true);
            }
            selection.skipFormatRetrieval = false;
            return;
        }
        this.setOffsetValue(selection);
        this.initHistory(action);
        // Todo: Complete Microsoft Word behavior on apply formatting in empty selection
        // if (selection.isEmpty) {
        //     this.viewer.owner.isShiftingEnabled = true;
        //     this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
        //     this.reLayout(this.viewer.selection);
        //     this.viewer.updateFocus();
        //     return;
        // }
        if (selection.contextType === 'List') {
            // this.updateCharacterFormatForListText(selection, action, value, update);
            this.applyCharacterFormatForListText(selection, property, value, update);
        }
        else {
            //Iterate and update format.
            this.updateSelectionCharacterFormatting(property, value, update);
        }
        this.viewer.layout.isBidiReLayout = false;
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-line-length
    applyCharacterFormatForListText(selection, property, values, update) {
        let listLevel = this.getListLevel(selection.start.paragraph);
        if (isNullOrUndefined(listLevel)) {
            return;
        }
        let characterFormat = listLevel.characterFormat;
        switch (property) {
            case 'bold':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'bold', !(characterFormat.bold));
                break;
            case 'italic':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'italic', !(characterFormat.italic));
                break;
            case 'fontColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontColor', values);
                break;
            case 'fontFamily':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontFamily', values);
                break;
            case 'fontSize':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'fontSize', values);
                break;
            case 'highlightColor':
                this.applyListCharacterFormatByValue(selection, characterFormat, 'highlightColor', values);
                break;
            case 'baselineAlignment':
                if (characterFormat.baselineAlignment === values) {
                    values = 'Normal';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'baselineAlignment', values);
                break;
            case 'strikethrough':
                if (characterFormat.strikethrough === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'strikethrough', values);
                break;
            case 'underline':
                if (characterFormat.underline === values) {
                    values = 'None';
                }
                this.applyListCharacterFormatByValue(selection, characterFormat, 'underline', values);
                break;
            case 'characterFormat':
                this.applyListCharacterFormatByValue(selection, characterFormat, undefined, values);
                break;
        }
    }
    applyListCharacterFormatByValue(selection, format, property, value) {
        this.initHistory('ListCharacterFormat');
        this.applyCharFormatValue(format, property, value, false);
        this.editorHistory.updateHistory();
        this.reLayout(selection);
        this.fireContentChange();
    }
    /**
     * @private
     */
    updateListCharacterFormat(selection, property, value) {
        this.updateListTextSelRange(selection, property, value, false);
    }
    updateListTextSelRange(selection, property, value, update) {
        this.viewer.owner.isShiftingEnabled = true;
        let startPositionInternal = selection.start;
        let endPositionInternal = selection.end;
        if (!selection.isForward) {
            startPositionInternal = selection.end;
            endPositionInternal = selection.start;
        }
        this.initHistoryPosition(selection, startPositionInternal);
        let listLevel = this.getListLevel(selection.start.paragraph);
        this.applyCharFormatValue(listLevel.characterFormat, property, value, update);
        this.startSelectionReLayouting(startPositionInternal.paragraph, selection, startPositionInternal, endPositionInternal);
    }
    /**
     * @private
     */
    getListLevel(paragraph) {
        let currentList = undefined;
        let listLevelNumber = 0;
        if (!isNullOrUndefined(paragraph.paragraphFormat) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
        }
        if (!isNullOrUndefined(currentList) &&
            !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
            // && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels.getItem(listLevelNumber))) {
            && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels)) {
            return this.viewer.layout.getListLevel(currentList, listLevelNumber);
        }
        return undefined;
    }
    updateInsertPosition() {
        let selection = this.viewer.selection;
        let position = selection.start;
        if (!selection.isForward) {
            position = selection.end;
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && !isNullOrUndefined(position)) {
            if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.updateHistoryPosition(position, true);
            }
        }
    }
    /**
     * preserve paragraph and offset value for selection
     * @private
     */
    setOffsetValue(selection) {
        let info = this.selection.getParagraphInfo(selection.start);
        this.startParagraph = info.paragraph;
        this.startOffset = info.offset;
        info = this.selection.getParagraphInfo(selection.end);
        this.endParagraph = info.paragraph;
        this.endOffset = info.offset;
    }
    /**
     * Toggles the highlight color property of selected contents.
     * @param {HighlightColor} highlightColor Default value of ‘underline’ parameter is Yellow.
     */
    toggleHighlightColor(highlightColor) {
        let selection = this.viewer.selection;
        if (isNullOrUndefined(highlightColor) || highlightColor === 'NoColor') {
            highlightColor = 'Yellow';
        }
        //In Ms Word the highlight color is took from the ribbon. So we Have given yellow as constant.
        if (selection.characterFormat.highlightColor === highlightColor) {
            highlightColor = 'NoColor';
        }
        this.selection.characterFormat.highlightColor = highlightColor;
    }
    /**
     * Toggles the subscript formatting of selected contents.
     */
    toggleSubscript() {
        if (!this.owner.isReadOnlyMode) {
            let value = this.selection.characterFormat.baselineAlignment === 'Subscript' ? 'Normal' : 'Subscript';
            this.selection.characterFormat.baselineAlignment = value;
        }
    }
    /**
     * Toggles the superscript formatting of selected contents.
     */
    toggleSuperscript() {
        if (!this.owner.isReadOnlyMode) {
            let value = this.selection.characterFormat.baselineAlignment === 'Superscript' ? 'Normal' : 'Superscript';
            this.selection.characterFormat.baselineAlignment = value;
        }
    }
    /**
     * Toggles the text alignment property of selected contents.
     * @param {TextAlignment} textAlignment Default value of ‘textAlignment parameter is TextAlignment.Left.
     */
    /**
     * Increases the left indent of selected paragraphs to a factor of 36 points.
     */
    increaseIndent() {
        if (!this.owner.isReadOnlyMode) {
            this.onApplyParagraphFormat('leftIndent', this.viewer.defaultTabWidth, true, false);
        }
    }
    /**
     * Decreases the left indent of selected paragraphs to a factor of 36 points.
     */
    decreaseIndent() {
        if (!this.owner.isReadOnlyMode) {
            this.onApplyParagraphFormat('leftIndent', -this.viewer.defaultTabWidth, true, false);
        }
    }
    /**
     * Clears the list format for selected paragraphs.
     */
    clearList() {
        this.selection.owner.editorModule.onApplyList(undefined);
    }
    /**
     * Applies the bullet list to selected paragraphs.
     * @param {string} bullet Bullet character
     * @param {string} fontFamily Bullet font family
     */
    applyBullet(bullet, fontFamily) {
        if (!this.owner.isReadOnlyMode) {
            this.applyBulletOrNumbering(bullet, 'Bullet', fontFamily);
        }
    }
    /**
     * Applies the numbering list to selected paragraphs.
     * @param numberFormat  “%n” representations in ‘numberFormat’ parameter will be replaced by respective list level’s value.
     * `“%1)” will be displayed as “1)” `
     * @param listLevelPattern  Default value of ‘listLevelPattern’ parameter is ListLevelPattern.Arabic
     */
    applyNumbering(numberFormat, listLevelPattern) {
        if (!this.owner.isReadOnlyMode) {
            this.applyBulletOrNumbering(numberFormat, listLevelPattern, 'Verdana');
        }
    }
    /**
     * Toggles the baseline alignment property of selected contents.
     * @param  {Selection} selection
     * @param  {BaselineAlignment} baseAlignment
     */
    toggleBaselineAlignment(baseAlignment) {
        this.updateProperty(2, baseAlignment);
    }
    /**
     * Clears the formatting.
     */
    clearFormatting() {
        let selection = this.viewer.selection;
        this.initComplexHistory('ClearFormat');
        // let startIndex: string = selection.start.getHierarchicalIndexInternal();
        // let endIndex: string = selection.end.getHierarchicalIndexInternal();
        if (selection.isEmpty) {
            selection.start.moveToParagraphStartInternal(selection, false);
            selection.end.moveToParagraphEndInternal(selection, false);
        }
        this.setOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ClearCharacterFormat');
        }
        this.updateSelectionCharacterFormatting('ClearCharacterFormat', undefined, false);
        this.getOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.setOffsetValue(selection);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ClearParagraphFormat');
        }
        this.updateParagraphFormatInternal('ClearParagraphFormat', undefined, false);
        if (this.editorHistory) {
            this.editorHistory.updateHistory();
        }
        this.getOffsetValue(selection);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            this.editorHistory.updateComplexHistory();
        }
        this.startParagraph = undefined;
        this.endParagraph = undefined;
        // else {
        //     this.checkAndUpdatedSelection(startIndex, endIndex);
        // }
    }
    /**
     * Toggles the specified property. If property is assigned already. Then property will be changed
     * @param  {Selection} selection
     * @param  {number} type
     * @param  {Object} value
     * @private
     */
    updateProperty(type, value) {
        let selection = this.selection;
        if (selection.owner.isReadOnlyMode || !selection.owner.isDocumentLoaded) {
            return;
        }
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        let indexInInline = 0;
        let inlineObj = startPosition.currentWidget.getInline(startPosition.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        let paragraph = startPosition.paragraph;
        if (!isNullOrUndefined(inline) && inline.length === indexInInline && !this.selection.isEmpty) {
            inline = inline.nextNode;
        }
        if (type === 1) {
            let currentUnderline = 'None';
            if (!isNullOrUndefined(inline)) {
                currentUnderline = inline.characterFormat.underline;
            }
            else if (!isNullOrUndefined(paragraph)) {
                currentUnderline = paragraph.characterFormat.underline;
            }
            this.selection.characterFormat.underline = value === currentUnderline ? 'None' : value;
        }
        else {
            let script = 'Normal';
            if (!isNullOrUndefined(inline)) {
                script = inline.characterFormat.baselineAlignment;
            }
            else if (!isNullOrUndefined(paragraph)) {
                script = paragraph.characterFormat.baselineAlignment;
            }
            if (script === value) {
                value = 'Normal';
            }
            this.selection.characterFormat.baselineAlignment = value;
        }
    }
    getCompleteStyles() {
        let completeStylesString = '{"styles":[';
        for (let name of this.viewer.preDefinedStyles.keys) {
            completeStylesString += (this.viewer.preDefinedStyles.get(name) + ',');
        }
        return completeStylesString.slice(0, -1) + ']}';
    }
    /**
     * Initialize default styles
     * @private
     */
    intializeDefaultStyles() {
        let existingStyles = this.owner.getStyleNames('Paragraph');
        let defaultStyleNames = ['Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5', 'Heading 6'];
        let styleNames = defaultStyleNames.filter((val) => {
            return existingStyles.indexOf(val) === -1;
        });
        for (let name of styleNames) {
            this.createStyle(this.viewer.preDefinedStyles.get(name));
        }
    }
    /**
     * Creates a new instance of Style.
     */
    createStyle(styleString) {
        this.createStyleIn(styleString);
    }
    /**
     * Create a Style.
     * @private
     */
    createStyleIn(styleString) {
        /* tslint:disable:no-any */
        let style = JSON.parse(styleString);
        let styleObj = this.viewer.styles.findByName(style.name);
        if (styleObj !== undefined) {
            //Create a new style with new name and add it to collection.
            style.name = this.getUniqueStyleName(style.name);
        }
        this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), style, this.viewer.styles);
        return this.viewer.styles.findByName(style.name);
    }
    /**
     * @private
     */
    getUniqueStyleName(name) {
        let uniqueName = this.getUniqueName(name);
        let style = this.viewer.styles.findByName(uniqueName);
        while (!isNullOrUndefined(style)) {
            uniqueName = this.getUniqueStyleName(style.name);
            style = this.viewer.styles.findByName(uniqueName);
        }
        return uniqueName;
    }
    getUniqueName(name) {
        let matchArray = name.match(/\d+$/);
        if (!isNullOrUndefined(matchArray) && matchArray.length > 0) {
            return name.replace(matchArray[0], (parseInt(matchArray[0], 10) + 1).toString());
        }
        else {
            return name + '_1';
        }
    }
    /**
     * Update Character format for selection
     * @private
     */
    updateSelectionCharacterFormatting(property, values, update) {
        if (isNullOrUndefined(property)) {
            property = 'CharacterFormat';
        }
        switch (property) {
            case 'bold':
                this.updateCharacterFormat('bold', values);
                break;
            case 'italic':
                this.updateCharacterFormat('italic', values);
                break;
            case 'fontColor':
                this.updateCharacterFormat('fontColor', values);
                break;
            case 'fontFamily':
                this.updateCharacterFormat('fontFamily', values);
                break;
            case 'fontSize':
                this.viewer.layout.isBidiReLayout = false;
                this.updateCharacterFormatWithUpdate(this.viewer.selection, 'fontSize', values, update);
                break;
            case 'highlightColor':
                this.updateCharacterFormat('highlightColor', values);
                break;
            case 'baselineAlignment':
                this.updateCharacterFormat('baselineAlignment', values);
                break;
            case 'strikethrough':
                this.updateCharacterFormat('strikethrough', values);
                break;
            case 'underline':
                this.updateCharacterFormat('underline', values);
                break;
            case 'styleName':
                this.updateCharacterFormatWithUpdate(this.viewer.selection, 'styleName', values, true);
                break;
            case 'CharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
            case 'ClearCharacterFormat':
                this.updateCharacterFormat(undefined, values);
                break;
        }
        this.reLayout(this.viewer.selection);
    }
    /**
     * Update character format for selection range
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @returns void
     * @private
     */
    updateCharacterFormat(property, value) {
        this.updateCharacterFormatWithUpdate(this.viewer.selection, property, value, false);
    }
    updateCharacterFormatWithUpdate(selection, property, value, update) {
        this.viewer.owner.isShiftingEnabled = true;
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        this.applyCharFormatSelectedContent(startPosition.paragraph, selection, startPosition, endPosition, property, value, update);
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatSelectedContent(paragraph, selection, start, end, property, value, update) {
        //Selection start in cell.
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            let cell;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            this.applyCharFormatCell(cell, selection, start, end, property, value, update);
            let table = cell.ownerTable;
            // tslint:disable-next-line:max-line-length
            this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        }
        else {
            this.applyCharFormat(paragraph, selection, start, end, property, value, update);
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForSelectedPara(paragraph, selection, property, value, update) {
        for (let i = 0; i < paragraph.childWidgets.length; i++) {
            let line = paragraph.childWidgets[i];
            for (let j = 0; j < line.children.length; j++) {
                let element = line.children[j];
                this.applyCharFormatValue(element.characterFormat, property, value, update);
            }
        }
        this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
    }
    splittedLastParagraph(paragraph) {
        let splittedWidets = paragraph.getSplitWidgets();
        return splittedWidets[splittedWidets.length - 1];
    }
    // tslint:disable-next-line:max-line-length
    getNextParagraphForCharacterFormatting(block, start, end, property, value, update) {
        let widgetCollection = block.getSplitWidgets();
        block = widgetCollection[widgetCollection.length - 1];
        block = this.viewer.selection.getNextRenderedBlock(block);
        if (!isNullOrUndefined(block)) { //Goto the next block.
            if (block instanceof ParagraphWidget) {
                this.applyCharFormat(block, this.viewer.selection, start, end, property, value, update);
            }
            else {
                this.applyCharFormatForTable(0, block, this.viewer.selection, start, end, property, value, update);
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormat(paragraph, selection, start, end, property, value, update) {
        paragraph = paragraph.combineWidget(this.viewer);
        let startOffset = 0;
        let length = selection.getParagraphLength(paragraph);
        let startLineWidget = paragraph.childWidgets.indexOf(start.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(start.currentWidget) : 0;
        let endOffset = end.offset;
        let endLineWidget = paragraph.childWidgets.indexOf(end.currentWidget) !== -1 ?
            paragraph.childWidgets.indexOf(end.currentWidget) : paragraph.childWidgets.length - 1;
        if (!isNullOrUndefined(selection)) {
            if (paragraph === start.paragraph) {
                startOffset = start.offset;
            }
        }
        if (!paragraph.equals(end.paragraph)) {
            this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            endOffset = length;
        }
        else {
            let lastLine = paragraph.childWidgets[paragraph.childWidgets.length - 1];
            if (selection.isParagraphLastLine(lastLine) && end.currentWidget === lastLine
                && ((endOffset === selection.getLineLength(lastLine) + 1) || (selection.isEmpty && selection.end.isAtParagraphEnd))) {
                this.applyCharFormatValue(paragraph.characterFormat, property, value, update);
            }
        }
        // let count: number = 0;
        for (let i = startLineWidget; i <= endLineWidget; i++) {
            let line = paragraph.childWidgets[i];
            if (i !== startLineWidget) {
                startOffset = selection.getStartLineOffset(line);
            }
            if (line === end.currentWidget) {
                endOffset = end.offset;
            }
            else {
                endOffset = selection.getLineLength(line);
            }
            let count = 0;
            for (let j = 0; j < line.children.length; j++) {
                let inlineObj = line.children[j];
                if (inlineObj instanceof ListTextElementBox) {
                    continue;
                }
                if (startOffset >= count + inlineObj.length) {
                    count += inlineObj.length;
                    continue;
                }
                let startIndex = 0;
                if (startOffset > count) {
                    startIndex = startOffset - count;
                }
                let endIndex = endOffset - count;
                let inlineLength = inlineObj.length;
                if (endIndex > inlineLength) {
                    endIndex = inlineLength;
                }
                j += this.applyCharFormatInline(inlineObj, selection, startIndex, endIndex, property, value, update);
                if (endOffset <= count + inlineLength) {
                    break;
                }
                count += inlineLength;
            }
        }
        let endParagraph = end.paragraph;
        this.viewer.layout.reLayoutParagraph(paragraph, startLineWidget, 0);
        if (paragraph.equals(endParagraph)) {
            return;
        }
        this.getNextParagraphForCharacterFormatting(paragraph, start, end, property, value, update);
    }
    /**
     * Toggles the bold property of selected contents.
     */
    toggleBold() {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        let value = this.getCurrentSelectionValue('bold');
        this.selection.characterFormat.bold = value;
    }
    /**
     * Toggles the bold property of selected contents.
     */
    toggleItalic() {
        if (this.viewer.owner.isReadOnlyMode) {
            return;
        }
        let value = this.getCurrentSelectionValue('italic');
        this.selection.characterFormat.italic = value;
    }
    getCurrentSelectionValue(property) {
        let value = false;
        if ((property === 'bold' || property === 'italic')) {
            let index = 0;
            let start = this.selection.start;
            if (!this.selection.isForward) {
                start = this.selection.end;
            }
            let lineWidget = start.currentWidget;
            let inlineObj = lineWidget.getInline(start.offset, index);
            let inline = inlineObj.element;
            // inline.ownerBase
            index = inlineObj.index;
            let characterFormat = lineWidget.paragraph.characterFormat;
            if (!isNullOrUndefined(inline)) {
                if (!this.selection.isEmpty && index === inline.length) {
                    characterFormat = isNullOrUndefined(inline.nextNode) ? lineWidget.paragraph.characterFormat
                        : inline.nextNode.characterFormat;
                }
                else {
                    characterFormat = inline.characterFormat;
                }
            }
            if (property === 'bold') {
                value = !(characterFormat.bold);
            }
            if (property === 'italic') {
                value = !(characterFormat.italic);
            }
        }
        return value;
    }
    /**
     * Toggles the underline property of selected contents.
     * @param underline Default value of ‘underline’ parameter is Single.
     */
    toggleUnderline(underline) {
        if (!this.owner.isReadOnlyMode) {
            this.updateProperty(1, underline);
        }
    }
    /**
     * Toggles the strike through property of selected contents.
     * @param {Strikethrough} strikethrough Default value of strikethrough parameter is SingleStrike.
     */
    toggleStrikethrough(strikethrough) {
        if (!this.owner.isReadOnlyMode) {
            let value;
            if (isNullOrUndefined(strikethrough)) {
                value = this.selection.characterFormat.strikethrough === 'SingleStrike' ? 'None' : 'SingleStrike';
            }
            else {
                value = strikethrough;
            }
            this.selection.characterFormat.strikethrough = value;
        }
    }
    updateFontSize(format, value) {
        if (typeof (value) === 'number' && !(value < 0 && format.fontSize === 1)) {
            return format.fontSize + value;
        }
        let fontsizeCollection = [8, 9, 10, 11, 12, 14, 16, 18, 20, 24, 26, 28, 36, 48, 72];
        if (typeof (value) === 'string' && value === 'increment') {
            if (format.fontSize < 8) {
                return format.fontSize + 1;
            }
            else if (format.fontSize >= 72 && format.fontSize < 80) {
                return 80;
            }
            else if (format.fontSize >= 80) {
                return format.fontSize + 10;
            }
            else {
                for (let i = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize < fontsizeCollection[i]) {
                        return fontsizeCollection[i];
                    }
                }
            }
        }
        else if (typeof (value) === 'string' && value === 'decrement' && format.fontSize > 1) {
            if (format.fontSize <= 8) {
                return format.fontSize - 1;
            }
            else if (format.fontSize > 72 && format.fontSize <= 80) {
                return 72;
            }
            else if (format.fontSize > 80) {
                return format.fontSize - 10;
            }
            else {
                for (let i = 0; i < fontsizeCollection.length; i++) {
                    if (format.fontSize <= fontsizeCollection[i]) {
                        return fontsizeCollection[i - 1];
                    }
                }
            }
        }
        return format.fontSize;
    }
    // Inline
    // tslint:disable-next-line:max-line-length
    applyCharFormatInline(inline, selection, startIndex, endIndex, property, value, update) {
        if (startIndex === 0 && endIndex === inline.length) {
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
            return 0;
        }
        else if (inline instanceof TextElementBox) {
            return this.formatInline(inline, selection, startIndex, endIndex, property, value, update);
        }
        return 0;
    }
    // tslint:disable-next-line:max-line-length
    formatInline(inline, selection, startIndex, endIndex, property, value, update) {
        let x = 0;
        let node = inline;
        let index = inline.line.children.indexOf(node);
        let paragraph = inline.paragraph;
        let lineIndex = paragraph.childWidgets.indexOf(inline.line);
        let textElement;
        if (startIndex > 0) {
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            textElement.line = inline.line;
            textElement.text = inline.text.substr(startIndex, endIndex - startIndex);
            this.applyCharFormatValue(textElement.characterFormat, property, value, update);
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            // this.addToLinkedFields(span);                      
        }
        if (endIndex < node.length) {
            textElement = new TextElementBox();
            textElement.characterFormat.copyFormat(inline.characterFormat);
            textElement.text = node.text.substring(endIndex);
            textElement.line = inline.line;
            index++;
            node.line.children.splice(index, 0, textElement);
            x++;
            // this.addToLinkedFields(span);                       
        }
        if (startIndex === 0) {
            inline.text = inline.text.substr(0, endIndex);
            this.applyCharFormatValue(inline.characterFormat, property, value, update);
        }
        else {
            inline.text = inline.text.substr(0, startIndex);
        }
        return x;
    }
    // Cell
    // tslint:disable-next-line:max-line-length
    applyCharFormatCell(cell, selection, start, end, property, value, update) {
        if (end.paragraph.isInsideTable) {
            let containerCell = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = selection.getSelectedCell(cell, containerCell);
                let endCell = selection.getSelectedCell(end.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        value = this.getCharacterFormatValueOfCell(cell, selection, value, property);
                        this.applyCharFormatForSelectedCell(containerCell, selection, property, value, update);
                    }
                    else {
                        if (startCell === containerCell) {
                            this.applyCharFormat(start.paragraph, selection, start, end, property, value, update);
                        }
                        else {
                            this.applyCharFormatRow(startCell.ownerRow, selection, start, end, property, value, update);
                        }
                    }
                }
                else { //Format other selected cells in current table.
                    this.applyCharFormatForTableCell(containerCell.ownerTable, selection, containerCell, endCell, property, value, update);
                }
            }
            else {
                this.applyCharFormatRow(containerCell.ownerRow, selection, start, end, property, value, update);
            }
        }
        else {
            let tableCell = selection.getContainerCell(cell);
            this.applyCharFormatRow(tableCell.ownerRow, selection, start, end, property, value, update);
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForSelectedCell(cell, selection, property, value, update) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                this.applyCharFormatForSelectedPara(block, selection, property, value, update);
            }
            else {
                this.applyCharFormatForSelTable(block, selection, property, value, update);
            }
        }
    }
    // Row
    // tslint:disable-next-line:max-line-length
    applyCharFormatRow(row, selection, start, end, property, value, update) {
        value = this.getCharacterFormatValueOfCell(row.childWidgets[0], selection, value, property);
        this.applyCharFormatForTable(row.rowIndex, row.ownerTable, selection, start, end, property, value, update);
    }
    // Table
    // tslint:disable-next-line:max-line-length
    applyCharFormatForTable(index, table, selection, start, end, property, value, update) {
        table = table.combineWidget(this.viewer);
        for (let i = index; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return;
            }
        }
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        this.getNextParagraphForCharacterFormatting(table, start, end, property, value, update);
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForSelTable(tableWidget, selection, property, value, update) {
        for (let i = 0; i < tableWidget.childWidgets.length; i++) {
            let row = tableWidget.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    applyCharFormatForTableCell(table, selection, startCell, endCell, property, value, update) {
        let startCellLeft = selection.getCellLeft(startCell.ownerRow, startCell);
        let startCellRight = startCellLeft + startCell.cellFormat.cellWidth;
        let endCellLeft = selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(startCellLeft, startCellRight, endCellLeft, endCellRight);
        startCellLeft = cellInfo.start;
        startCellRight = cellInfo.end;
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let isStarted = false;
        for (let i = table.childWidgets.indexOf(startCell.ownerRow); i <= count; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let left = selection.getCellLeft(row, row.childWidgets[j]);
                if (HelperMethods.round(startCellLeft, 2) <= HelperMethods.round(left, 2) &&
                    HelperMethods.round(left, 2) < HelperMethods.round(startCellRight, 2)) {
                    if (!isStarted) {
                        value = this.getCharacterFormatValueOfCell(row.childWidgets[j], selection, value, property);
                        isStarted = true;
                    }
                    this.applyCharFormatForSelectedCell(row.childWidgets[j], selection, property, value, update);
                }
            }
        }
    }
    updateSelectedCellsInTable(start, end, endCellLeft, endCellRight) {
        let selection = this.viewer.selection;
        if (start > endCellLeft) {
            start = endCellLeft;
        }
        if (end < endCellRight) {
            end = endCellRight;
        }
        if (start > selection.upDownSelectionLength) {
            start = selection.upDownSelectionLength;
        }
        if (end < selection.upDownSelectionLength) {
            end = selection.upDownSelectionLength;
        }
        return { start: start, end: end };
    }
    getCharacterFormatValueOfCell(cell, selection, value, property) {
        if (typeof (value) === 'boolean' || (value === undefined && (property === 'bold' || property === 'italic'))) {
            let firstParagraph = selection.getFirstParagraph(cell);
            let format = firstParagraph.characterFormat;
            if (firstParagraph.childWidgets.length > 0 && firstParagraph.childWidgets[0].children.length > 0) {
                format = firstParagraph.childWidgets[0].children[0].characterFormat;
            }
            value = !format.getPropertyValue(property);
        }
        return value;
    }
    /**
     * Apply Character format for selection
     * @private
     */
    applyCharFormatValueInternal(selection, format, property, value) {
        this.applyCharFormatValue(format, property, value, false);
    }
    copyInlineCharacterFormat(sourceFormat, destFormat) {
        destFormat.uniqueCharacterFormat = sourceFormat.uniqueCharacterFormat;
        destFormat.baseCharStyle = sourceFormat.baseCharStyle;
    }
    applyCharFormatValue(format, property, value, update) {
        if (update && property === 'fontSize') {
            value = this.updateFontSize(format, value);
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedProperties(format, property, value);
        }
        if (value instanceof WCharacterFormat) {
            if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                this.copyInlineCharacterFormat(value, format);
            }
            else {
                format.copyFormat(value);
            }
            return;
        }
        if (isNullOrUndefined(value)) {
            format.clearFormat();
            return;
        }
        if (property === 'bold') {
            format.bold = value;
        }
        else if (property === 'italic') {
            format.italic = value;
        }
        else if (property === 'fontColor') {
            format.fontColor = value;
        }
        else if (property === 'fontFamily') {
            format.fontFamily = value;
        }
        else if (property === 'fontSize') {
            format.fontSize = value;
        }
        else if (property === 'highlightColor') {
            format.highlightColor = value;
        }
        else if (property === 'baselineAlignment') {
            format.baselineAlignment = value;
        }
        else if (property === 'strikethrough') {
            format.strikethrough = value;
        }
        else if (property === 'underline') {
            format.underline = value;
        }
        else if (property === 'styleName') {
            format.baseCharStyle = value;
        }
    }
    /**
     * @private
     */
    onImageFormat(elementBox, width, height) {
        let modifiedFormat = new ImageFormat(elementBox);
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ImageResizing');
            this.editorHistory.currentBaseHistoryInfo.modifiedProperties.push(modifiedFormat);
        }
        this.setOffsetValue(this.selection);
        elementBox.width = width;
        elementBox.height = height;
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.reLayoutParagraph(elementBox.line.paragraph, elementBox.line.indexInOwner, 0);
        this.reLayout(this.selection, false);
        if (this.viewer.owner.imageResizerModule) {
            this.viewer.owner.imageResizerModule.positionImageResizer(elementBox);
        }
    }
    /**
     * Toggles the text alignment of selected paragraphs.
     * @param  {TextAlignment} textAlignment
     */
    toggleTextAlignment(textAlignment) {
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        // Toggle performed based on current selection format similar to MS word behavior.
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.viewer.selection.paragraphFormat.textAlignment) && this.viewer.selection.paragraphFormat.textAlignment === textAlignment) {
            if (textAlignment === 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Justify', false, true);
            }
            else {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
            }
        }
        else {
            this.onApplyParagraphFormat('textAlignment', textAlignment, false, true);
        }
    }
    /**
     * Applies paragraph format for the selection ranges.
     * @param {string} property
     * @param {Object} value
     * @param {boolean} update
     * @param {boolean} isSelectionChanged
     * @private
     */
    onApplyParagraphFormat(property, value, update, isSelectionChanged) {
        if (this.restrictFormatting) {
            return;
        }
        let action = property === 'bidi' ? 'ParagraphBidi' : (property[0].toUpperCase() + property.slice(1));
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        this.initHistory(action);
        if (this.viewer.owner.isReadOnlyMode || !this.viewer.owner.isDocumentLoaded) {
            return;
        }
        if (property === 'leftIndent') {
            if (selection.paragraphFormat.listId !== -1 && update) {
                this.updateListLevel(value > 0);
                return;
            }
        }
        if (selection.isEmpty) {
            this.setOffsetValue(selection);
            let isBidiList = selection.paragraphFormat.bidi &&
                (property === 'listFormat' || selection.paragraphFormat.listId !== -1);
            if (!isBidiList) {
                this.viewer.layout.isBidiReLayout = true;
            }
            if (update && property === 'leftIndent') {
                value = this.getIndentIncrementValue(selection.start.paragraph, value);
            }
            let para = selection.start.paragraph.combineWidget(this.viewer);
            this.applyParaFormatProperty(para, property, value, update);
            this.layoutItemBlock(para, false);
            if (!isBidiList) {
                this.viewer.layout.isBidiReLayout = false;
            }
        }
        else {
            //Iterate and update formatting's.      
            if (action !== 'ParagraphBidi') {
                this.setOffsetValue(selection);
            }
            this.updateSelectionParagraphFormatting(property, value, update);
        }
        this.reLayout(selection);
    }
    /**
     * Update the list level
     * @param  {boolean} increaseLevel
     * @private
     */
    updateListLevel(increaseLevel) {
        // Increment or Decrement list level for Multilevel lists.
        let viewer = this.viewer;
        let listFormat = this.viewer.selection.start.paragraph.paragraphFormat.listFormat;
        let paragraphFormat = this.viewer.selection.start.paragraph.paragraphFormat;
        let list = viewer.getListById(paragraphFormat.listFormat.listId);
        let listLevel = viewer.layout.getListLevel(list, paragraphFormat.listFormat.listLevelNumber);
        let levelNumber;
        if (increaseLevel) {
            levelNumber = paragraphFormat.listFormat.listLevelNumber + 1;
        }
        else {
            levelNumber = paragraphFormat.listFormat.listLevelNumber - 1;
        }
        let nextListLevel = viewer.layout.getListLevel(list, levelNumber);
        if (!isNullOrUndefined(nextListLevel)) {
            this.onApplyListInternal(list, levelNumber);
            viewer.selection.start.updatePhysicalPosition(true);
            viewer.selection.end.updatePhysicalPosition(true);
            viewer.selection.updateCaretPosition();
        }
    }
    /**
     * Applies list
     * @param  {WList} list
     * @param  {number} listLevelNumber
     * @private
     */
    onApplyListInternal(list, listLevelNumber) {
        let selection = this.viewer.selection;
        let listFormat = new WListFormat();
        if (!isNullOrUndefined(list) && listLevelNumber >= 0 && listLevelNumber < 9) {
            listFormat.listId = list.listId;
            listFormat.listLevelNumber = listLevelNumber;
        }
        this.onApplyParagraphFormat('listFormat', listFormat, false, false);
    }
    /**
     * Apply paragraph format to selection range
     * @private
     */
    updateSelectionParagraphFormatting(property, value, update) {
        let selection = this.viewer.selection;
        if (property === 'leftIndent' && update) {
            if (!isNullOrUndefined(selection.start) && selection.start.isExistBefore(selection.end)) {
                value = this.getIndentIncrementValue(selection.start.paragraph, value);
            }
            else {
                value = this.getIndentIncrementValue(selection.end.paragraph, value);
            }
        }
        this.updateParagraphFormatInternal(property, value, update);
    }
    getIndentIncrementValue(currentParagraph, incrementFactor) {
        let currentParagraphIndent = currentParagraph.paragraphFormat.leftIndent;
        if (currentParagraphIndent < 0) {
            // In MS Word, if the current paragraph left indent is lesser that or equal to 0
            // then performing decrement indent will set left indent to 0. 
            if (incrementFactor < 0 || currentParagraphIndent + incrementFactor >= 0) {
                return -currentParagraphIndent;
            }
            else {
                let incrementValue = -this.getIndentIncrementValueInternal(-currentParagraphIndent, -incrementFactor);
                return incrementValue % incrementFactor === 0 ? incrementValue : incrementValue + incrementFactor;
            }
        }
        else {
            return this.getIndentIncrementValueInternal(currentParagraphIndent, incrementFactor);
        }
    }
    getIndentIncrementValueInternal(position, incrementFactor) {
        let tabValue = Math.abs(incrementFactor);
        if (position === 0 || tabValue === 0) {
            return incrementFactor > 0 ? tabValue : 0;
        }
        else {
            let diff = ((Math.round(position) * 100) % (Math.round(tabValue) * 100)) / 100;
            let cnt = (Math.round(position) - diff) / Math.round(tabValue);
            let fPosition = cnt * tabValue;
            if (incrementFactor > 0) {
                fPosition += tabValue;
            }
            return (fPosition - position) === 0 ? incrementFactor : fPosition - position;
        }
    }
    updateParagraphFormatInternal(property, value, update) {
        if (isNullOrUndefined(property)) {
            property = 'ParagraphFormat';
        }
        switch (property) {
            case 'afterSpacing':
                this.updateParagraphFormat('afterSpacing', value, false);
                break;
            case 'beforeSpacing':
                this.updateParagraphFormat('beforeSpacing', value, false);
                break;
            case 'rightIndent':
                this.updateParagraphFormat('rightIndent', value, false);
                break;
            case 'leftIndent':
                this.updateParagraphFormat('leftIndent', value, update);
                break;
            case 'firstLineIndent':
                this.updateParagraphFormat('firstLineIndent', value, false);
                break;
            case 'lineSpacing':
                this.updateParagraphFormat('lineSpacing', value, false);
                break;
            case 'lineSpacingType':
                this.updateParagraphFormat('lineSpacingType', value, false);
                break;
            case 'textAlignment':
                this.updateParagraphFormat('textAlignment', value, false);
                break;
            case 'listFormat':
                this.updateParagraphFormat('listFormat', value, false);
                break;
            case 'ParagraphFormat':
                this.updateParagraphFormat(undefined, value, false);
                break;
            case 'styleName':
                this.updateParagraphFormat('styleName', value, false);
                break;
            case 'ClearParagraphFormat':
                // this.initializeHistory('ClearParagraphFormat', selectionRange);
                this.updateParagraphFormat(undefined, value, false);
                break;
            case 'bidi':
                let isBidiList = this.selection.paragraphFormat.listId !== -1;
                if (!isBidiList) {
                    this.viewer.layout.isBidiReLayout = true;
                }
                this.updateParagraphFormat('bidi', value, false);
                if (!isBidiList) {
                    this.viewer.layout.isBidiReLayout = false;
                }
                break;
            case 'contextualSpacing':
                this.updateParagraphFormat('contextualSpacing', value, false);
                break;
        }
    }
    /**
     * Update paragraph format on undo
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @param  {boolean} update
     * @private
     */
    updateParagraphFormat(property, value, update) {
        let selection = this.viewer.selection;
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        // this.updateInsertPosition(selection, startPosition);
        this.applyParaFormatSelectedContent(startPosition, endPosition, property, value, update);
        // this.startSelectionReLayouting(startPosition.paragraph, selection, startPosition, endPosition);
    }
    applyParaFormatSelectedContent(start, end, property, value, update) {
        let selection = this.viewer.selection;
        if (start.paragraph.isInsideTable && (!end.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(start.paragraph.associatedCell, start, end))) {
            let cell;
            start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (this.checkInsertPosition(selection)) {
                this.updateHistoryPosition(start, true);
            }
            cell = start.paragraph.associatedCell;
            this.applyParaFormatInCell(cell, start, end, property, value, update);
            let table = cell.ownerTable;
            this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        }
        else {
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(value) && !this.selection.isEmpty && property === 'styleName' && this.applyCharacterStyle(start.paragraph, start, end, property, value, update)) {
                return;
            }
            else {
                this.applyParaFormat(start.paragraph, start, end, property, value, update);
            }
        }
    }
    /**
     * Apply Paragraph format
     * @private
     */
    applyParaFormatProperty(paragraph, property, value, update) {
        let format = paragraph.paragraphFormat;
        if (update && property === 'leftIndent') {
            value = format.leftIndent + value;
        }
        if (property === 'listFormat' && value instanceof WListFormat) {
            let listFormat = value;
            if (!listFormat.hasValue('listLevelNumber')) {
                listFormat.listLevelNumber = format.listFormat.listLevelNumber;
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForParagraphFormat(format, property, value);
        }
        if (value instanceof WParagraphFormat) {
            if (isNullOrUndefined(property)) {
                if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
                    this.copyParagraphFormat(value, format);
                }
                else {
                    format.copyFormat(value);
                }
            }
            else if (property === 'listFormat') {
                format.listFormat = value.listFormat;
                // this.handleListFormat(format, value as WParagraphFormat);
            }
        }
        if (isNullOrUndefined(value)) {
            format.clearFormat();
            this.viewer.layout.reLayoutParagraph(format.ownerBase, 0, 0);
            return;
        }
        if (property === 'afterSpacing') {
            format.afterSpacing = value;
        }
        else if (property === 'beforeSpacing') {
            format.beforeSpacing = value;
        }
        else if (property === 'leftIndent') {
            format.leftIndent = value;
        }
        else if (property === 'lineSpacingType') {
            format.lineSpacingType = value;
        }
        else if (property === 'lineSpacing') {
            format.lineSpacing = value;
        }
        else if (property === 'rightIndent') {
            format.rightIndent = value;
        }
        else if (property === 'firstLineIndent') {
            format.firstLineIndent = value;
        }
        else if (property === 'textAlignment') {
            format.textAlignment = value;
            this.viewer.layout.allowLayout = false;
        }
        else if (property === 'styleName') {
            if (typeof (value) === 'string') {
                value = this.viewer.styles.findByName(value);
            }
            format.ApplyStyle(value);
        }
        else if (property === 'listFormat') {
            if (value instanceof WParagraphFormat) {
                this.copyFromListLevelParagraphFormat(format, value);
                value = value.listFormat;
            }
            format.listFormat.copyFormat(value);
            this.viewer.layout.clearListElementBox(format.ownerBase);
            this.onListFormatChange(format.ownerBase, value, format);
            this.layoutItemBlock(format.ownerBase, false);
            return;
        }
        else if (property === 'bidi') {
            format.bidi = value;
        }
        else if (property === 'contextualSpacing') {
            format.contextualSpacing = value;
        }
    }
    copyParagraphFormat(sourceFormat, destFormat) {
        destFormat.uniqueParagraphFormat = sourceFormat.uniqueParagraphFormat;
        destFormat.listFormat = sourceFormat.listFormat;
        destFormat.baseStyle = sourceFormat.baseStyle;
    }
    onListFormatChange(paragraph, listFormat, paraFormat) {
        if (listFormat instanceof WListFormat) {
            this.updateListParagraphFormat(paragraph, listFormat);
        }
    }
    updateListParagraphFormat(paragraph, listFormat) {
        let list = this.viewer.getListById(listFormat.listId);
        let listlevel = undefined;
        if (!isNullOrUndefined(list)) {
            listlevel = this.viewer.layout.getListLevel(list, listFormat.listLevelNumber);
        }
        let isUpdateIndent = !this.editorHistory || (this.editorHistory && !this.editorHistory.isUndoing);
        if (isUpdateIndent) {
            if (paragraph instanceof ParagraphWidget && !isNullOrUndefined(listlevel)
                && !isNullOrUndefined(listlevel.paragraphFormat) && !isNullOrUndefined(paragraph.containerWidget)) {
                this.copyFromListLevelParagraphFormat(paragraph.paragraphFormat, listlevel.paragraphFormat);
            }
            else if (isNullOrUndefined(list)) {
                paragraph.paragraphFormat.leftIndent = undefined;
                paragraph.paragraphFormat.firstLineIndent = undefined;
            }
        }
    }
    /**
     * Copies list level paragraph format
     * @param  {WParagraphFormat} oldFormat
     * @param  {WParagraphFormat} newFormat
     * @private
     */
    copyFromListLevelParagraphFormat(oldFormat, newFormat) {
        if (!isNullOrUndefined(newFormat.leftIndent)) {
            oldFormat.leftIndent = newFormat.leftIndent;
        }
        if (!isNullOrUndefined(newFormat.firstLineIndent)) {
            oldFormat.firstLineIndent = newFormat.firstLineIndent;
        }
    }
    /**
     * @private
     */
    applyContinueNumbering(selection) {
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('ContinueNumbering');
        }
        this.applyContinueNumberingInternal(selection);
    }
    /**
     * @private
     */
    applyContinueNumberingInternal(selection) {
        let paragraph = selection.start.paragraph;
        let numberingInfo = this.getContinueNumberingInfo(paragraph);
        let paraFormat = this.getParagraphFormat(paragraph, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.changeListId(numberingInfo.currentList, paragraph, paraFormat, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.reLayout(selection, false);
        this.viewer.updateFocus();
    }
    /**
     * @private
     */
    getContinueNumberingInfo(paragraph) {
        let currentList = undefined;
        let listLevelNumber = 0;
        let listPattern = 'None';
        if (!isNullOrUndefined(paragraph.paragraphFormat)
            && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
            currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
        }
        let viewer = this.viewer;
        if (listLevelNumber !== 0 && !isNullOrUndefined(currentList) &&
            !isNullOrUndefined(viewer.getAbstractListById(currentList.abstractListId))
            && !isNullOrUndefined(viewer.getAbstractListById(currentList.abstractListId).levels[listLevelNumber])) {
            let listLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
            if (!isNullOrUndefined(listLevel)) {
                listPattern = listLevel.listLevelPattern;
            }
        }
        return {
            currentList: currentList,
            listLevelNumber: listLevelNumber,
            listPattern: listPattern
        };
    }
    /**
     * @private
     */
    revertContinueNumbering(selection, format) {
        let paragraph = selection.start.paragraph;
        let numberingInfo = this.getContinueNumberingInfo(paragraph);
        this.changeListId(numberingInfo.currentList, paragraph, format, numberingInfo.listLevelNumber, numberingInfo.listPattern);
        this.reLayout(selection, false);
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.updateHistory();
        }
    }
    changeListId(list, block, format, levelNum, listType) {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId
                && levelNum === block.paragraphFormat.listFormat.listLevelNumber) {
                if (this.editorHistory) {
                    let baseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                    if (!isNullOrUndefined(baseHistoryInfo)) {
                        format = baseHistoryInfo.addModifiedPropertiesForContinueNumbering(block.paragraphFormat, format);
                    }
                }
                block.paragraphFormat.copyFormat(format);
                this.viewer.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeListId(list, block.nextRenderedWidget, format, levelNum, listType);
    }
    getParagraphFormat(paragraph, levelNumber, listType) {
        if (!isNullOrUndefined(paragraph.previousRenderedWidget)) {
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                if (!isNullOrUndefined(paragraph.previousRenderedWidget.paragraphFormat.listFormat)
                    && paragraph.previousRenderedWidget.paragraphFormat.listFormat.listId !== -1) {
                    let listLevel = this.getListLevel(paragraph.previousRenderedWidget);
                    if (levelNumber === 0) {
                        return paragraph.previousRenderedWidget.paragraphFormat;
                    }
                    else if (listType === listLevel.listLevelPattern
                        || this.checkNumberArabic(listType, listLevel.listLevelPattern)) {
                        return paragraph.previousRenderedWidget.paragraphFormat;
                    }
                    else {
                        return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                    }
                }
                else {
                    return this.getParagraphFormat(paragraph.previousRenderedWidget, levelNumber, listType);
                }
            }
        }
        return undefined;
    }
    checkNumberArabic(listType, levelPattern) {
        if ((listType === 'Number' && levelPattern === 'Arabic')
            || (levelPattern === 'Number' && listType === 'Arabic')) {
            return true;
        }
        return false;
    }
    /**
     * @private
     */
    applyRestartNumbering(selection) {
        if (this.editorHistory) {
            this.editorHistory.initializeHistory('RestartNumbering');
        }
        this.restartListAt(selection);
    }
    /**
     * @private
     */
    restartListAt(selection) {
        let currentListLevel = this.getListLevel(selection.start.paragraph);
        let list = new WList();
        list.listId = this.viewer.lists[(this.viewer.lists.length - 1)].listId + 1;
        let abstractList = new WAbstractList();
        abstractList.abstractListId = this.viewer.abstractLists[(this.viewer.abstractLists.length - 1)].abstractListId + 1;
        list.abstractListId = abstractList.abstractListId;
        list.abstractList = abstractList;
        this.viewer.abstractLists.push(abstractList);
        this.createListLevels(abstractList, currentListLevel, list);
        this.viewer.lists.push(list);
        this.restartListAtInternal(selection, list.listId);
    }
    /**
     * @private
     */
    restartListAtInternal(selection, listId) {
        let numberingInfo = this.getContinueNumberingInfo(selection.start.paragraph);
        this.changeRestartNumbering(numberingInfo.currentList, selection.start.paragraph, listId);
        this.reLayout(selection, false);
        this.incrementListNumber = -1;
        this.refListNumber = undefined;
        this.viewer.updateFocus();
    }
    changeRestartNumbering(list, block, listId) {
        if (isNullOrUndefined(block)) {
            return;
        }
        if (block instanceof ParagraphWidget) {
            if (list.listId === block.paragraphFormat.listFormat.listId) {
                if (this.editorHistory) {
                    let baseHistoryInfo = this.editorHistory.currentBaseHistoryInfo;
                    if (!isNullOrUndefined(baseHistoryInfo)) {
                        listId = baseHistoryInfo.addModifiedPropertiesForRestartNumbering(block.paragraphFormat.listFormat, listId);
                    }
                }
                block.paragraphFormat.listFormat.listId = listId;
                if (this.refListNumber !== block.paragraphFormat.listFormat.listLevelNumber) {
                    this.incrementListNumber += 1;
                    this.refListNumber = block.paragraphFormat.listFormat.listLevelNumber;
                }
                block.paragraphFormat.listFormat.listLevelNumber = this.incrementListNumber;
                this.viewer.layout.reLayoutParagraph(block, 0, 0);
            }
        }
        return this.changeRestartNumbering(list, block.nextRenderedWidget, listId);
    }
    createListLevels(abstractList, currentListLevel, list) {
        let levelPattern = currentListLevel.listLevelPattern;
        let levelPatterns = [];
        let currentAbstractList = currentListLevel.ownerBase;
        for (let i = 0; i < 3; i++) {
            let listLevel = currentAbstractList.levels[i];
            if (!isNullOrUndefined(listLevel)) {
                levelPatterns.push(listLevel.listLevelPattern);
            }
        }
        let indexOfLevelPattern = levelPatterns.indexOf(levelPattern) === -1 ? 0 : levelPatterns.indexOf(levelPattern);
        let numberFormat = currentListLevel.numberFormat.charAt(currentListLevel.numberFormat.length - 1);
        for (let i = 0; i < currentAbstractList.levels.length; i++) {
            let listLevel = new WListLevel(abstractList);
            if (i === 0) {
                listLevel.listLevelPattern = levelPattern;
            }
            else {
                if (indexOfLevelPattern === 0 || indexOfLevelPattern < levelPatterns.length - 1) {
                    indexOfLevelPattern++;
                }
                else {
                    indexOfLevelPattern = 0;
                }
                listLevel.listLevelPattern = levelPatterns[indexOfLevelPattern];
            }
            listLevel.numberFormat = '%' + (i + 1) + numberFormat;
            listLevel.startAt = 1;
            listLevel.characterFormat.copyFormat(currentListLevel.characterFormat);
            listLevel.paragraphFormat.copyFormat(currentListLevel.paragraphFormat);
            listLevel.restartLevel = i;
            abstractList.levels.push(listLevel);
        }
    }
    // tslint:disable-next-line:max-line-length
    applyParaFormat(paragraph, start, end, property, value, update) {
        this.setOffsetValue(this.selection);
        paragraph = paragraph.combineWidget(this.viewer);
        //Apply Paragraph Format for spitted paragraph
        this.applyParaFormatProperty(paragraph, property, value, update);
        this.layoutItemBlock(paragraph, false);
        this.getOffsetValue(this.selection);
        if (paragraph.equals(end.paragraph)) {
            return;
        }
        this.getNextParagraphForFormatting(paragraph, start, end, property, value, update);
    }
    /* tslint:disable-next-line:max-line-length */
    applyCharacterStyle(paragraph, start, end, property, value, update) {
        let paragraphWidget = paragraph.getSplitWidgets();
        let selection = end.owner.selection;
        let lastLine = end.currentWidget;
        let isParaSelected = start.offset === 0 && (selection.isParagraphLastLine(lastLine) && end.currentWidget === lastLine
            && end.offset === selection.getLineLength(lastLine) + 1 || end.isAtParagraphEnd);
        if (!isParaSelected && (end.paragraph === paragraph || paragraphWidget.indexOf(end.paragraph) !== -1)) {
            if (((value.type === 'Paragraph') && ((value.link) instanceof WCharacterStyle)) || (value.type === 'Character')) {
                let obj = (value.type === 'Character') ? value : value.link;
                this.updateSelectionCharacterFormatting(property, obj, update);
                return true;
            }
        }
        return false;
    }
    // Cell
    // tslint:disable-next-line:max-line-length
    applyParaFormatInCell(cell, start, end, property, value, update) {
        let selection = this.viewer.selection;
        if (end.paragraph.isInsideTable) {
            let cellContainer = selection.getContainerCellOf(cell, end.paragraph.associatedCell);
            if (cellContainer.ownerTable.contains(end.paragraph.associatedCell)) {
                let startCell = selection.getSelectedCell(cell, cellContainer);
                let endCell = selection.getSelectedCell(end.paragraph.associatedCell, cellContainer);
                if (selection.containsCell(cellContainer, end.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(cellContainer, start, end)) {
                        value = this.getParaFormatValueInCell(cellContainer, property, value);
                        this.applyParaFormatCellInternal(cellContainer, property, value, update);
                    }
                    else {
                        if (startCell === cellContainer) {
                            this.applyParaFormat(start.paragraph, start, end, property, value, update);
                        }
                        else {
                            this.applyParagraphFormatRow(startCell.ownerRow, start, end, property, value, update);
                        }
                    }
                }
                else {
                    //Format other selected cells in current table.
                    this.applyParaFormatTableCell(cellContainer.ownerTable, cellContainer, endCell, property, value, update);
                }
            }
            else {
                this.applyParagraphFormatRow(cellContainer.ownerRow, start, end, property, value, update);
            }
        }
        else {
            let wCell = selection.getContainerCell(cell);
            this.applyParagraphFormatRow(wCell.ownerRow, start, end, property, value, update);
        }
    }
    applyParaFormatCellInternal(cell, property, value, update) {
        for (let i = 0; i < cell.childWidgets.length; i++) {
            let block = cell.childWidgets[i];
            if (block instanceof ParagraphWidget) {
                this.applyParaFormatProperty(block, property, value, update);
            }
            else {
                this.applyParagraphFormatTableInternal(block, property, value, update);
            }
        }
    }
    getParaFormatValueInCell(cell, property, value) {
        if (typeof value === 'boolean') {
            let firstPara = this.viewer.selection.getFirstParagraph(cell);
            value = !firstPara.paragraphFormat.getPropertyValue(property);
        }
        return value;
    }
    // Row
    // tslint:disable-next-line:max-line-length
    applyParagraphFormatRow(wRow, start, end, property, value, update) {
        value = this.getParaFormatValueInCell(wRow.childWidgets[0], property, value);
        for (let i = wRow.rowIndex; i < wRow.ownerTable.childWidgets.length; i++) {
            let row = wRow.ownerTable.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                this.applyParaFormatCellInternal(row.childWidgets[j], property, value, update);
            }
            if (end.paragraph.isInsideTable && this.viewer.selection.containsRow(row, end.paragraph.associatedCell)) {
                return;
            }
        }
        this.getNextParagraphForFormatting(wRow.ownerTable, start, end, property, value, update);
    }
    // Table
    // tslint:disable-next-line:max-line-length
    applyParaFormatTableCell(table, startCell, endCell, property, value, update) {
        let selection = this.viewer.selection;
        let startValue = selection.getCellLeft(startCell.ownerRow, startCell);
        let endValue = startValue + startCell.cellFormat.cellWidth;
        let endCellLeft = selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(startValue, endValue, endCellLeft, endCellRight);
        startValue = cellInfo.start;
        endValue = cellInfo.end;
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let isStarted = false;
        for (let m = table.childWidgets.indexOf(startCell.ownerRow); m <= count; m++) {
            let row = table.childWidgets[m];
            for (let j = 0; j < row.childWidgets.length; j++) {
                let left = selection.getCellLeft(row, row.childWidgets[j]);
                if (Math.round(startValue) <= Math.round(left) && Math.round(left) < Math.round(endValue)) {
                    if (!isStarted) {
                        value = this.getParaFormatValueInCell(row.childWidgets[j], property, value);
                        isStarted = true;
                    }
                    this.applyParaFormatCellInternal(row.childWidgets[j], property, value, update);
                }
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    applyParaFormatTable(table, start, end, property, value, update) {
        table = table.combineWidget(this.viewer);
        let selection = this.viewer.selection;
        for (let m = 0; m < table.childWidgets.length; m++) {
            let tableRow = table.childWidgets[m];
            for (let k = 0; k < tableRow.childWidgets.length; k++) {
                this.applyParaFormatCellInternal(tableRow.childWidgets[k], property, value, update);
            }
            if (end.paragraph.isInsideTable && selection.containsRow(tableRow, end.paragraph.associatedCell)) {
                this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
                return;
            }
        }
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        this.getNextParagraphForFormatting(table, start, end, property, value, update);
    }
    // tslint:disable-next-line:max-line-length
    getNextParagraphForFormatting(block, start, end, property, value, update) {
        let widgetCollection = block.getSplitWidgets();
        block = widgetCollection[widgetCollection.length - 1];
        block = this.viewer.selection.getNextRenderedBlock(block);
        if (!isNullOrUndefined(block)) { //Goto the next block.
            if (block instanceof ParagraphWidget) {
                this.applyParaFormat(block, start, end, property, value, update);
            }
            else {
                this.applyParaFormatTable(block, start, end, property, value, update);
            }
        }
    }
    applyParagraphFormatTableInternal(table, property, value, update) {
        for (let x = 0; x < table.childWidgets.length; x++) {
            let row = table.childWidgets[x];
            for (let y = 0; y < row.childWidgets.length; y++) {
                this.applyParaFormatCellInternal(row.childWidgets[y], property, value, update);
            }
        }
    }
    //Paragraph Format apply implementation Ends
    // Apply Selection Section Format Option Implementation Starts
    /**
     * Apply section format selection changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplySectionFormat(property, value) {
        if (this.restrictFormatting) {
            return;
        }
        if (!isNullOrUndefined(property)) {
            let action = (property[0].toUpperCase() + property.slice(1));
            this.initHistory(action);
        }
        else {
            this.initHistory('SectionFormat');
        }
        this.updateSectionFormat(property, value);
    }
    /**
     * Update section format
     * @param  {string} property
     * @param  {Object} value
     * @returns TextPosition
     * @private
     */
    updateSectionFormat(property, value) {
        let selection = this.viewer.selection;
        selection.owner.isShiftingEnabled = true;
        let startPosition = selection.start;
        let endPosition = selection.end;
        if (!selection.isForward) {
            startPosition = selection.end;
            endPosition = selection.start;
        }
        let startPageIndex;
        let endPageIndex;
        this.viewer.clearContent();
        let startSectionIndex = startPosition.paragraph.bodyWidget.sectionIndex;
        let endSectionIndex = endPosition.paragraph.bodyWidget.sectionIndex;
        for (let i = 0; i < this.viewer.pages.length; i++) {
            if (this.viewer.pages[i].bodyWidgets[0].index === startSectionIndex) {
                startPageIndex = i;
                break;
            }
        }
        for (let i = startPageIndex; i < this.viewer.pages.length; i++) {
            let bodyWidget = this.viewer.pages[i].bodyWidgets[0];
            endPageIndex = i;
            if ((bodyWidget.index === startSectionIndex)) {
                continue;
            }
            else if ((bodyWidget.index >= startSectionIndex) && bodyWidget.index <= endSectionIndex) {
                continue;
            }
            else {
                endPageIndex = i - 1;
                break;
            }
        }
        // let startPageIndex: number = this.viewer.pages.indexOf((selection.start.paragraph.containerWidget as BodyWidget).page);
        // let endPageIndex: number = this.viewer.pages.indexOf((selection.end.paragraph.containerWidget as BodyWidget).page);
        let update = true;
        let index = 0;
        for (let i = startPageIndex; i <= endPageIndex; i++) {
            if (index !== this.viewer.pages[i].bodyWidgets[0].index && !update) {
                update = true;
            }
            this.applyPropertyValueForSection(this.viewer.pages[i].bodyWidgets[0].sectionFormat, property, value, update);
            index = this.viewer.pages[i].bodyWidgets[0].index;
            update = false;
        }
        this.layoutWholeDocument();
        this.fireContentChange();
    }
    //Apply Selection Table Format option implementation starts
    /**
     * Apply table format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableFormat(property, value) {
        if (this.restrictFormatting) {
            return;
        }
        let action = this.getTableFormatAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        let table = selection.start.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyTablePropertyValue(selection, property, value, table);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        table.calculateGrid();
        this.selection.owner.isLayoutEnabled = true;
        this.viewer.layout.reLayoutTable(table);
        this.reLayout(selection, false);
    }
    getTableFormatAction(property) {
        switch (property) {
            case 'tableAlignment':
                return 'TableAlignment';
            case 'leftIndent':
                return 'TableLeftIndent';
            case 'leftMargin':
                return 'DefaultCellLeftMargin';
            case 'rightMargin':
                return 'DefaultCellRightMargin';
            case 'bottomMargin':
                return 'DefaultCellBottomMargin';
            case 'topMargin':
                return 'DefaultCellTopMargin';
            case 'preferredWidth':
                return 'TablePreferredWidth';
            case 'preferredWidthType':
                return 'TablePreferredWidthType';
            case 'shading':
                return 'Shading';
            case 'bidi':
                return 'TableBidi';
            default:
                return 'DefaultCellSpacing';
        }
    }
    // Apply Selection Row Format Option Implementation Starts
    /**
     * Apply table row format property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableRowFormat(property, value) {
        if (this.restrictFormatting) {
            return;
        }
        let action = this.getRowAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        if (selection.isEmpty) {
            this.initHistory(action);
            let table = selection.start.paragraph.associatedCell.ownerRow.ownerTable;
            this.applyRowPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.ownerRow);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    }
    getRowAction(property) {
        switch (property) {
            case 'height':
                return 'RowHeight';
            case 'heightType':
                return 'RowHeightType';
            case 'isHeader':
                return 'RowHeader';
            default:
                return 'AllowBreakAcrossPages';
        }
    }
    /**
     * Apply table cell property changes
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    onApplyTableCellFormat(property, value) {
        if (this.restrictFormatting) {
            return;
        }
        let action = this.getTableCellAction(property);
        this.viewer.owner.isShiftingEnabled = true;
        let selection = this.viewer.selection;
        let table = selection.start.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (selection.isEmpty) {
            this.initHistory(action);
            this.applyCellPropertyValue(selection, property, value, selection.start.paragraph.associatedCell.cellFormat);
            table.calculateGrid();
            this.selection.owner.isLayoutEnabled = true;
            this.viewer.layout.reLayoutTable(table);
        }
        else {
            this.updateSelectionTableFormat(this.selection, action, value);
        }
        this.reLayout(selection, false);
    }
    getTableCellAction(property) {
        switch (property) {
            case 'verticalAlignment':
                return 'CellContentVerticalAlignment';
            case 'leftMargin':
                return 'CellLeftMargin';
            case 'rightMargin':
                return 'CellRightMargin';
            case 'bottomMargin':
                return 'CellBottomMargin';
            case 'topMargin':
                return 'CellTopMargin';
            case 'preferredWidth':
                return 'CellPreferredWidth';
            case 'shading':
                return 'Shading';
            default:
                return 'CellPreferredWidthType';
        }
    }
    applyPropertyValueForSection(sectionFormat, property, value, update) {
        let selection = this.viewer.selection;
        if (update && this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedPropertiesForSection(sectionFormat, property, value);
        }
        if (isNullOrUndefined(value)) {
            return;
        }
        if (value instanceof WSectionFormat) {
            if (isNullOrUndefined(property)) {
                sectionFormat.copyFormat(value, this.editorHistory);
            }
            return;
        }
        if (property === 'pageHeight') {
            sectionFormat.pageHeight = value;
        }
        else if (property === 'pageWidth') {
            sectionFormat.pageWidth = value;
        }
        else if (property === 'leftMargin') {
            sectionFormat.leftMargin = value;
        }
        else if (property === 'rightMargin') {
            sectionFormat.rightMargin = value;
        }
        else if (property === 'topMargin') {
            sectionFormat.topMargin = value;
        }
        else if (property === 'bottomMargin') {
            sectionFormat.bottomMargin = value;
        }
        else if (property === 'differentFirstPage') {
            sectionFormat.differentFirstPage = value;
        }
        else if (property === 'differentOddAndEvenPages') {
            sectionFormat.differentOddAndEvenPages = value;
        }
        else if (property === 'headerDistance') {
            sectionFormat.headerDistance = value;
        }
        else if (property === 'footerDistance') {
            sectionFormat.footerDistance = value;
        }
    }
    /**
     * @private
     */
    layoutWholeDocument() {
        let startPosition = this.viewer.selection.start;
        let endPosition = this.viewer.selection.end;
        if (startPosition.isExistAfter(endPosition)) {
            startPosition = this.viewer.selection.end;
            endPosition = this.viewer.selection.start;
        }
        let startInfo = this.selection.getParagraphInfo(startPosition);
        let endInfo = this.selection.getParagraphInfo(startPosition);
        let startIndex = this.selection.getHierarchicalIndex(startInfo.paragraph, startInfo.offset.toString());
        let endIndex = this.selection.getHierarchicalIndex(endInfo.paragraph, endInfo.offset.toString());
        this.viewer.renderedLists.clear();
        // this.viewer.owner.isLayoutEnabled = true;
        let sections = this.combineSection();
        this.viewer.clearContent();
        this.viewer.layout.layoutItems(sections);
        this.viewer.owner.isShiftingEnabled = false;
        this.setPositionForCurrentIndex(startPosition, startIndex);
        this.setPositionForCurrentIndex(endPosition, endIndex);
        this.viewer.selection.selectPosition(startPosition, endPosition);
        this.reLayout(this.viewer.selection);
    }
    combineSection() {
        let sections = [];
        let nextSection = this.viewer.pages[0].bodyWidgets[0];
        do {
            nextSection = this.combineSectionChild(nextSection, sections);
        } while (nextSection);
        return sections;
    }
    combineSectionChild(bodyWidget, sections) {
        let previousBodyWidget = bodyWidget;
        let temp = new BodyWidget();
        temp.sectionFormat = bodyWidget.sectionFormat;
        temp.index = previousBodyWidget.index;
        do {
            previousBodyWidget = bodyWidget;
            if (bodyWidget.lastChild) {
                bodyWidget.lastChild.combineWidget(this.viewer);
            }
            bodyWidget = bodyWidget.nextRenderedWidget;
            for (let j = 0; j < previousBodyWidget.childWidgets.length; j++) {
                let block = previousBodyWidget.childWidgets[j];
                if (block instanceof TableWidget) {
                    this.viewer.layout.clearTableWidget(block, true, true, true);
                }
                else {
                    block.x = 0;
                    block.y = 0;
                    block.width = 0;
                    block.height = 0;
                }
                temp.childWidgets.push(block);
                previousBodyWidget.childWidgets.splice(j, 1);
                j--;
                block.containerWidget = temp;
            }
            previousBodyWidget.page.destroy();
            // this.viewer.pages.splice(previousBodyWidget.page.index, 1);
        } while (bodyWidget && previousBodyWidget.equals(bodyWidget));
        sections.push(temp);
        return bodyWidget;
    }
    updateSelectionTableFormat(selection, action, value) {
        switch (action) {
            case 'TableAlignment':
                this.editorHistory.initializeHistory('TableAlignment');
                this.updateTableFormat(selection, 'tableAlignment', value);
                break;
            case 'TableLeftIndent':
                this.editorHistory.initializeHistory('TableLeftIndent');
                this.updateTableFormat(selection, 'leftIndent', value);
                break;
            case 'DefaultCellSpacing':
                this.editorHistory.initializeHistory('DefaultCellSpacing');
                this.updateTableFormat(selection, 'cellSpacing', value);
                break;
            case 'DefaultCellLeftMargin':
                this.editorHistory.initializeHistory('DefaultCellLeftMargin');
                this.updateTableFormat(selection, 'leftMargin', value);
                break;
            case 'DefaultCellRightMargin':
                this.editorHistory.initializeHistory('DefaultCellRightMargin');
                this.updateTableFormat(selection, 'rightMargin', value);
                break;
            case 'DefaultCellTopMargin':
                this.editorHistory.initializeHistory('DefaultCellTopMargin');
                this.updateTableFormat(selection, 'topMargin', value);
                break;
            case 'TablePreferredWidth':
                this.editorHistory.initializeHistory('TablePreferredWidth');
                this.updateTableFormat(selection, 'preferredWidth', value);
                break;
            case 'TablePreferredWidthType':
                this.editorHistory.initializeHistory('TablePreferredWidthType');
                this.updateTableFormat(selection, 'preferredWidthType', value);
                break;
            case 'DefaultCellBottomMargin':
                this.editorHistory.initializeHistory('DefaultCellBottomMargin');
                this.updateTableFormat(selection, 'bottomMargin', value);
                break;
            case 'CellContentVerticalAlignment':
                this.editorHistory.initializeHistory('CellContentVerticalAlignment');
                this.updateCellFormat(selection, 'verticalAlignment', value);
                break;
            case 'CellLeftMargin':
                this.editorHistory.initializeHistory('CellLeftMargin');
                this.updateCellFormat(selection, 'leftMargin', value);
                break;
            case 'CellRightMargin':
                this.editorHistory.initializeHistory('CellRightMargin');
                this.updateCellFormat(selection, 'rightMargin', value);
                break;
            case 'CellTopMargin':
                this.editorHistory.initializeHistory('CellTopMargin');
                this.updateCellFormat(selection, 'topMargin', value);
                break;
            case 'CellBottomMargin':
                this.editorHistory.initializeHistory('CellBottomMargin');
                this.updateCellFormat(selection, 'bottomMargin', value);
                break;
            case 'CellPreferredWidth':
                this.editorHistory.initializeHistory('CellPreferredWidth');
                this.updateCellFormat(selection, 'preferredWidth', value);
                break;
            case 'CellPreferredWidthType':
                this.editorHistory.initializeHistory('CellPreferredWidthType');
                this.updateCellFormat(selection, 'preferredWidthType', value);
                break;
            case 'Shading':
                this.editorHistory.initializeHistory('Shading');
                this.updateCellFormat(selection, 'shading', value);
                break;
            case 'RowHeight':
                this.editorHistory.initializeHistory('RowHeight');
                this.updateRowFormat(selection, 'height', value);
                break;
            case 'RowHeightType':
                this.editorHistory.initializeHistory('RowHeightType');
                this.updateRowFormat(selection, 'heightType', value);
                break;
            case 'RowHeader':
                this.editorHistory.initializeHistory('RowHeader');
                this.updateRowFormat(selection, 'isHeader', value);
                break;
            case 'AllowBreakAcrossPages':
                this.editorHistory.initializeHistory('AllowBreakAcrossPages');
                this.updateRowFormat(selection, 'allowBreakAcrossPages', value);
                break;
            case 'TableBidi':
                this.editorHistory.initializeHistory(action);
                this.updateTableFormat(selection, 'bidi', value);
                break;
        }
    }
    // Update Table Properties
    /**
     * Update Table Format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {object} value
     * @private
     */
    updateTableFormat(selection, property, value) {
        let tableStartPosition = selection.start;
        let tableEndPosition = selection.end;
        if (!selection.isForward) {
            tableStartPosition = selection.end;
            tableEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, tableStartPosition);
        // tslint:disable-next-line:max-line-length
        this.applyTablePropertyValue(selection, property, value, tableStartPosition.paragraph.associatedCell.ownerTable);
        if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            this.viewer.layout.reLayoutTable(tableStartPosition.paragraph.associatedCell.ownerTable);
        }
    }
    /**
     * update cell format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    updateCellFormat(selection, property, value) {
        selection.owner.isShiftingEnabled = true;
        let newStartPosition = selection.start;
        let newEndPosition = selection.end;
        if (!selection.isForward) {
            newStartPosition = selection.end;
            newEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, newStartPosition);
        this.updateFormatForCell(selection, property, value);
    }
    /**
     * update row format on undo
     * @param  {Selection} selection
     * @param  {SelectionRange} selectionRange
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    updateRowFormat(selection, property, value) {
        let rowStartPosition = selection.start;
        let rowEndPosition = selection.end;
        if (!selection.isForward) {
            rowStartPosition = selection.end;
            rowEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, rowStartPosition);
        // tslint:disable-next-line:max-line-length
        this.applyRowFormat(rowStartPosition.paragraph.associatedCell.ownerRow, rowStartPosition, rowEndPosition, property, value);
    }
    initHistoryPosition(selection, position) {
        if (this.viewer.owner.editorHistoryModule && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (!isNullOrUndefined(position)) {
                if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                    this.editorHistory.currentBaseHistoryInfo.insertPosition = position.getHierarchicalIndexInternal();
                }
            }
            else if (isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.start.getHierarchicalIndexInternal();
            }
        }
    }
    startSelectionReLayouting(paragraph, selection, start, end) {
        selection.owner.isLayoutEnabled = true;
        if (start.paragraph.isInsideTable) {
            let table = start.paragraph.associatedCell.ownerTable;
            while (table.isInsideTable) {
                table = table.associatedCell.ownerTable;
            }
            this.reLayoutSelectionOfTable(table, selection, start, end);
        }
        else {
            this.reLayoutSelection(paragraph, selection, start, end);
        }
    }
    reLayoutSelectionOfTable(table, selection, start, end) {
        let isEnded = false;
        this.viewer.layout.layoutBodyWidgetCollection(table.index, table.containerWidget, table, false);
        // If the selection ends in the current table, need to stop relayouting.
        if (!isNullOrUndefined(end.paragraph.associatedCell) && table.contains(end.paragraph.associatedCell)) {
            return true;
        }
        let block = selection.getNextRenderedBlock(table);
        // Relayout the next block.
        if (!isNullOrUndefined(block)) {
            isEnded = this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return isEnded;
    }
    reLayoutSelection(paragraph, selection, start, end) {
        if (start.paragraph === paragraph) {
            let startOffset = start.offset;
            let length = selection.getParagraphLength(paragraph);
            let indexInInline = 0;
            let index = 0;
            let inlineObj = paragraph.getInline(start.offset, indexInInline);
            let inline = inlineObj.element;
            indexInInline = inlineObj.index;
            if (!isNullOrUndefined(inline)) {
                if (indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
                    inline = inline.nextNode;
                }
                index = inline.line.children.indexOf(inline);
            }
            let lineIndex = 0;
            if (start.currentWidget.paragraph === paragraph) {
                lineIndex = paragraph.childWidgets.indexOf(start.currentWidget);
                index = start.currentWidget.children.indexOf(inline);
            }
            // If selection start inline is at new inline, need to relayout from the previous inline.
            if (inline instanceof TextElementBox && !inline.line && index > 0) {
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, index - 1);
            }
            else {
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, index);
            }
        }
        else {
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
        // If the selection ends at the current paragraph, need to stop relayouting.
        if (end.paragraph === paragraph) {
            return true;
        }
        // _Relayout the next block.
        let block = selection.getNextRenderedBlock(paragraph);
        if (!isNullOrUndefined(block)) {
            return this.reLayoutSelectionOfBlock(block, selection, start, end);
        }
        return false;
    }
    //Relayouting Start    
    reLayoutSelectionOfBlock(block, selection, start, end) {
        if (block instanceof ParagraphWidget) {
            return this.reLayoutSelection(block, selection, start, end);
        }
        else {
            return undefined;
            // return this.reLayoutSelectionOfTable(block as TableWidget, selection, start, end);
        }
    }
    /**
     * @private
     */
    layoutItemBlock(block, shiftNextWidget) {
        let section = undefined;
        if (block.containerWidget instanceof BlockContainer) {
            section = block.containerWidget;
            let index = section.childWidgets.indexOf(block);
            if (!isNullOrUndefined(this.viewer.owner)
                && this.viewer.owner.isLayoutEnabled) {
                // tslint:disable-next-line:max-line-length
                this.viewer.layout.layoutBodyWidgetCollection(block.index, section, block, false);
            }
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            let cell = block.containerWidget;
            cell = this.viewer.selection.getContainerCell(cell);
            if (!isNullOrUndefined(this.viewer.owner)
                && this.viewer.owner.isLayoutEnabled) {
                this.viewer.layout.reLayoutTable(block);
            }
        }
    }
    /**
     * @private
     */
    removeSelectedContents(selection) {
        return this.removeSelectedContentInternal(selection, selection.start, selection.end);
    }
    removeSelectedContentInternal(selection, startPosition, endPosition) {
        let startPos = startPosition;
        let endPos = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }
        // tslint:disable-next-line:max-line-length
        if (startPos.paragraph === endPos.paragraph && startPos.paragraph.childWidgets.indexOf(startPos.currentWidget) === startPos.paragraph.childWidgets.length - 1 &&
            startPos.offset === selection.getParagraphLength(startPos.paragraph) && startPos.offset + 1 === endPos.offset) {
            selection.owner.isShiftingEnabled = true;
            selection.selectContent(startPos, true);
            return true;
        }
        let paragraphInfo = this.selection.getParagraphInfo(startPos);
        selection.editPosition = this.selection.getHierarchicalIndex(paragraphInfo.paragraph, paragraphInfo.offset.toString());
        let isRemoved = this.removeSelectedContent(endPos.paragraph, selection, startPos, endPos);
        let textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        return isRemoved;
    }
    removeSelectedContent(paragraph, selection, start, end) {
        //If end is not table end and start is outside the table, then skip removing the contents and move caret to start position.
        if (end.paragraph.isInsideTable
            && end.paragraph !== selection.getLastParagraphInLastCell(end.paragraph.associatedCell.ownerTable)
            && (!start.paragraph.isInsideTable || start.paragraph.associatedCell.ownerTable !== end.paragraph.associatedCell.ownerTable)) {
            return false;
        }
        selection.owner.isShiftingEnabled = true;
        this.deleteSelectedContent(paragraph, selection, start, end, 2);
        return true;
    }
    // tslint:disable-next-line:max-line-length
    deleteSelectedContent(paragraph, selection, start, end, editAction) {
        let indexInInline = 0;
        let inlineObj = start.currentWidget.getInline(start.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldBegin && !isNullOrUndefined((inline as WFieldBegin).fieldEnd)) {
        // tslint:disable-next-line:max-line-length
        //     let fieldEndOffset: number = ((inline as WFieldBegin).fieldEnd.owner as WParagraph).getOffset((inline as WFieldBegin).fieldEnd, 1);
        //     let fieldEndIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldBegin).fieldEnd.owner as WParagraph, fieldEndOffset.toString());
        //     let selectionEndIndex: string = end.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(fieldEndIndex, selectionEndIndex)) {
        //         //If selection end is after field begin, moves selection start to field separator.
        //         start.moveToInline((inline as WFieldBegin).fieldSeparator, 1);
        //         selection.editPosition = start.getHierarchicalIndexInternal();
        //         if (!isNullOrUndefined(selection.currentBaseHistoryInfo)) {
        //             selection.currentBaseHistoryInfo.insertPosition = selection.editPosition;
        //         }
        //     }
        // }
        indexInInline = 0;
        inlineObj = end.currentWidget.getInline(end.offset, indexInInline);
        inline = inlineObj.element;
        indexInInline = inlineObj.index;
        // if (!isNullOrUndefined(inline)) {
        //     inline = selection.getNextRenderedInline(inline, indexInInline);
        // }
        // if (inline instanceof WFieldEnd && !isNullOrUndefined((inline as WFieldEnd).fieldBegin)) {
        // tslint:disable-next-line:max-line-length
        //     let fieldBeginOffset: number = ((inline as WFieldEnd).fieldBegin.owner as WParagraph).getOffset((inline as WFieldEnd).fieldBegin, 0);
        //     let fieldBeginIndex: string = WordDocument.getHierarchicalIndexOf((inline as WFieldEnd).fieldBegin.owner as WParagraph, fieldBeginOffset.toString());
        //     let selectionStartIndex: string = start.getHierarchicalIndexInternal();
        //     if (!TextPosition.isForwardSelection(selectionStartIndex, fieldBeginIndex)) {
        //         //If field begin is before selection start, move selection end to inline item before field end.
        //         let prevInline: WInline = selection.getPreviousTextInline(inline);
        //         if (isNullOrUndefined(prevInline)) {
        //             end.moveBackward();
        //         } else {
        //             end.moveToInline(prevInline, prevInline.length);
        //         }
        //     }
        // }
        if (end.paragraph !== paragraph) {
            this.deleteSelectedContent(end.paragraph, selection, start, end, editAction);
            return;
        }
        //  Selection start in cell.
        if (end.paragraph.isInsideTable && (!start.paragraph.isInsideTable
            || start.paragraph.associatedCell !== end.paragraph.associatedCell
            || selection.isCellSelected(end.paragraph.associatedCell, start, end))) {
            end.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            this.deleteTableCell(end.paragraph.associatedCell, selection, start, end, editAction);
        }
        else {
            this.deletePara(paragraph, start, end, editAction);
            if (this.delBlockContinue && this.delBlock) {
                if (this.delSection) {
                    let bodyWidget = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget : undefined;
                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                    this.delSection = undefined;
                }
                this.deleteBlock(this.delBlock, selection, start, end, editAction);
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
    }
    /**
     * Merge the selected cells.
     */
    mergeCells() {
        if (this.owner.isReadOnlyMode || !this.owner.isDocumentLoaded) {
            return;
        }
        if (!isNullOrUndefined(this.viewer) && !this.selection.isEmpty) {
            this.mergeSelectedCellsInTable();
        }
    }
    /**
     * Deletes the entire table at selection.
     */
    deleteTable() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        if (startPos.paragraph.isInsideTable) {
            let table = this.getOwnerTable(this.selection.isForward).combineWidget(this.viewer);
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteTable');
                //Sets the insert position in history info as current table.    
                this.updateHistoryPosition(startPos, true);
            }
            let paragraph = this.getParagraphForSelection(table);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.editorHistory.currentBaseHistoryInfo.removedNodes.push(table.clone());
            }
            this.removeBlock(table);
            this.selection.selectParagraphInternal(paragraph, true);
            if (this.checkIsNotRedoing() || isNullOrUndefined(this.editorHistory)) {
                this.reLayout(this.selection);
            }
        }
    }
    /**
     * Deletes the selected column(s).
     */
    deleteColumn() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        if (startPos.paragraph.isInsideTable) {
            this.selection.owner.isShiftingEnabled = true;
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteColumn');
            }
            let startCell = this.getOwnerCell(this.selection.isForward);
            let endCell = this.getOwnerCell(!this.selection.isForward);
            let table = startCell.ownerTable.combineWidget(this.viewer);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            let paragraph = undefined;
            if (endCell.nextWidget) {
                let nextCell = endCell.nextWidget;
                paragraph = this.selection.getFirstParagraph(nextCell);
            }
            else if (startCell.previousWidget) {
                let previousCell = startCell.previousWidget;
                paragraph = this.selection.getFirstParagraph(previousCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            //retrieve the cell collection based on start and end cell to remove. 
            let deleteCells = table.getColumnCellsForSelection(startCell, endCell);
            for (let i = 0; i < table.childWidgets.length; i++) {
                let row = table.childWidgets[i];
                if (row.childWidgets.length === 1) {
                    if (deleteCells.indexOf(row.childWidgets[0]) >= 0) {
                        table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                        row.destroy();
                        i--;
                    }
                }
                else {
                    for (let j = 0; j < row.childWidgets.length; j++) {
                        let tableCell = row.childWidgets[j];
                        if (deleteCells.indexOf(tableCell) >= 0) {
                            row.childWidgets.splice(j, 1);
                            tableCell.destroy();
                            j--;
                        }
                    }
                    if (row.childWidgets.length === 0) {
                        table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
                        row.destroy();
                        i--;
                    }
                }
            }
            if (table.childWidgets.length === 0) {
                // Before disposing table reset the paragrph.
                paragraph = this.getParagraphForSelection(table);
                this.removeBlock(table);
                if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                    this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                }
                table.destroy();
            }
            else {
                table.isGridUpdated = false;
                table.buildTableColumns();
                table.isGridUpdated = true;
                this.viewer.layout.reLayoutTable(table);
            }
            this.selection.selectParagraphInternal(paragraph, true);
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
            }
        }
    }
    /**
     * Deletes the selected row(s).
     */
    deleteRow() {
        if (this.owner.isReadOnlyMode) {
            return;
        }
        let startPos = !this.selection.isForward ? this.selection.end : this.selection.start;
        let endPos = !this.selection.isForward ? this.selection.start : this.selection.end;
        if (startPos.paragraph.isInsideTable) {
            let startCell = this.getOwnerCell(this.selection.isForward);
            let endCell = this.getOwnerCell(!this.selection.isForward);
            if (this.checkIsNotRedoing()) {
                this.initHistory('DeleteRow');
            }
            this.selection.owner.isShiftingEnabled = true;
            let table = startCell.ownerTable.combineWidget(this.viewer);
            let row = this.getOwnerRow(true);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.cloneTableToHistoryInfo(table);
            }
            let paragraph = undefined;
            if (row.nextWidget) {
                let nextCell = row.nextWidget.childWidgets[0];
                paragraph = this.selection.getFirstParagraph(nextCell);
            }
            if (isNullOrUndefined(paragraph)) {
                paragraph = this.getParagraphForSelection(table);
            }
            if (!this.selection.isEmpty) {
                //tslint:disable-next-line:max-line-length
                let containerCell = this.selection.getContainerCellOf(startCell, endCell);
                if (containerCell.ownerTable.contains(endCell)) {
                    startCell = this.selection.getSelectedCell(startCell, containerCell);
                    endCell = this.selection.getSelectedCell(endCell, containerCell);
                    if (this.selection.containsCell(containerCell, endCell)) {
                        row = startCell.ownerRow;
                        this.removeRow(row);
                    }
                    else {
                        row = startCell.ownerRow;
                        let endRow = endCell.ownerRow;
                        //Update the selection paragraph.
                        paragraph = undefined;
                        if (endRow.nextWidget) {
                            let nextCell = endRow.nextWidget.childWidgets[0];
                            paragraph = this.selection.getFirstParagraph(nextCell);
                        }
                        if (isNullOrUndefined(paragraph)) {
                            paragraph = this.getParagraphForSelection(table);
                        }
                        for (let i = 0; i < table.childWidgets.length; i++) {
                            let tableRow = table.childWidgets[i];
                            if (tableRow.rowIndex >= row.rowIndex && tableRow.rowIndex <= endRow.rowIndex) {
                                table.childWidgets.splice(i, 1);
                                tableRow.destroy();
                                i--;
                            }
                        }
                        if (table.childWidgets.length === 0) {
                            this.removeBlock(table);
                            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                                this.editorHistory.currentBaseHistoryInfo.action = 'DeleteTable';
                            }
                            table.destroy();
                        }
                        else {
                            this.updateTable(table);
                        }
                    }
                }
            }
            else {
                this.removeRow(row);
            }
            this.selection.selectParagraphInternal(paragraph, true);
            if (isNullOrUndefined(this.editorHistory) || this.checkIsNotRedoing()) {
                this.reLayout(this.selection, true);
            }
        }
    }
    removeRow(row) {
        let table = row.ownerTable;
        if (table.childWidgets.length === 1) {
            this.removeBlock(table);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                this.editorHistory.currentBaseHistoryInfo.action = 'Delete';
            }
            table.destroy();
        }
        else {
            table.childWidgets.splice(table.childWidgets.indexOf(row), 1);
            row.destroy();
            this.updateTable(table);
        }
    }
    updateTable(table) {
        table.updateRowIndex(0);
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.viewer.layout.reLayoutTable(table);
    }
    getParagraphForSelection(table) {
        let paragraph = undefined;
        let nextWidget = table.nextWidget ? table.nextWidget : table.nextRenderedWidget;
        let previousWidget = table.previousWidget ? table.previousWidget : table.previousRenderedWidget;
        if (nextWidget) {
            paragraph = nextWidget instanceof ParagraphWidget ? nextWidget
                : this.selection.getFirstParagraphInFirstCell(nextWidget);
        }
        else if (previousWidget) {
            paragraph = previousWidget instanceof ParagraphWidget ? previousWidget
                : this.selection.getLastParagraphInLastCell(previousWidget);
        }
        return paragraph;
    }
    deletePara(paragraph, start, end, editAction) {
        paragraph = paragraph.combineWidget(this.viewer);
        let selection = this.viewer.selection;
        let paragraphStart = selection.getStartOffset(paragraph);
        let endParagraphStartOffset = selection.getStartOffset(end.paragraph);
        let startOffset = paragraphStart;
        let endOffset = 0;
        let isCombineNextParagraph = false;
        let lastLinelength = this.selection.getLineLength(paragraph.lastChild);
        let currentParagraph = paragraph;
        let section = paragraph.bodyWidget instanceof BodyWidget ? paragraph.bodyWidget : undefined;
        let startLine = undefined;
        let endLineWidget = undefined;
        if (paragraph === start.paragraph) {
            startOffset = start.offset;
            startLine = start.currentWidget;
            if (end.paragraph.isInsideTable) {
                isCombineNextParagraph = this.isEndInAdjacentTable(paragraph, end.paragraph);
            }
        }
        else {
            startLine = paragraph.firstChild;
        }
        if (paragraph !== start.paragraph && selection.isSkipLayouting) {
            selection.isSkipLayouting = false;
        }
        if (paragraph === end.paragraph) {
            endLineWidget = end.currentWidget;
            endOffset = end.offset;
        }
        else {
            endLineWidget = paragraph.lastChild;
            endOffset = this.viewer.selection.getLineLength(paragraph.lastChild);
        }
        let block = paragraph.previousRenderedWidget;
        if (startOffset > paragraphStart && start.currentWidget === paragraph.lastChild &&
            startOffset === lastLinelength && (paragraph === end.paragraph && end.offset === startOffset + 1 ||
            paragraph.nextRenderedWidget === end.paragraph && end.offset === endParagraphStartOffset) ||
            (this.editorHistory && this.editorHistory.isUndoing && this.editorHistory.currentHistoryInfo &&
                this.editorHistory.currentHistoryInfo.action === 'PageBreak' && block && block.isPageBreak()
                && (startOffset === 0 && !start.currentWidget.isFirstLine || startOffset > 0))) {
            isCombineNextParagraph = true;
        }
        if (end.paragraph === paragraph && end.currentWidget !== paragraph.lastChild ||
            (end.currentWidget === paragraph.lastChild && end.offset <= selection.getLineLength(paragraph.lastChild))) {
            let isStartParagraph = start.paragraph === paragraph;
            if (end.currentWidget.isFirstLine() && end.offset > paragraphStart || !end.currentWidget.isFirstLine()) {
                //If selection end with this paragraph and selection doesnot include paragraph mark.               
                this.removeInlines(paragraph, startLine, startOffset, endLineWidget, endOffset, editAction);
                //Removes the splitted paragraph.
            }
            if (!isNullOrUndefined(block) && !isStartParagraph) {
                this.delBlockContinue = true;
                this.delBlock = block;
                let nextSection = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                if (nextSection && !section.equals(nextSection) && section.index !== nextSection.index) {
                    this.delSection = nextSection;
                }
                else {
                    this.delSection = undefined;
                }
            }
            else {
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
        else if (start.paragraph === paragraph && (start.currentWidget !== paragraph.firstChild ||
            (start.currentWidget === paragraph.firstChild && startOffset > paragraphStart))) {
            // If selection start is after paragraph start
            //And selection does not end with this paragraph Or selection include paragraph mark.
            this.delBlockContinue = false;
            this.delBlock = undefined;
            if (editAction === 4) {
                return;
            }
            else {
                currentParagraph = this.splitParagraph(paragraph, paragraph.firstChild, 0, startLine, startOffset, true);
                this.insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction);
                this.addRemovedNodes(paragraph);
                return;
            }
        }
        else {
            let newParagraph = undefined;
            let previousBlock = paragraph.previousWidget;
            let prevParagraph = (previousBlock instanceof ParagraphWidget) ? previousBlock : undefined;
            let nextWidget = paragraph.nextRenderedWidget;
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner text body and previousBlock is not paragraph.
                newParagraph = this.checkAndInsertBlock(paragraph, start, end, editAction, prevParagraph);
                this.removeBlock(paragraph);
                if (this.viewer.blockToShift === paragraph) {
                    this.viewer.blockToShift = undefined;
                }
                this.addRemovedNodes(paragraph);
                if (!isNullOrUndefined(newParagraph)) {
                    selection.editPosition = this.selection.getHierarchicalIndex(newParagraph, '0');
                    let offset = selection.getParagraphLength(newParagraph) + 1;
                    if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        //tslint:disable-next-line:max-line-length
                        this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(newParagraph, offset.toString());
                    }
                }
                else if (paragraph === start.paragraph && isNullOrUndefined(nextWidget) && !isNullOrUndefined(prevParagraph)) {
                    let offset = this.selection.getParagraphLength(prevParagraph);
                    // if (isNullOrUndefined(block)) {
                    selection.editPosition = this.selection.getHierarchicalIndex(prevParagraph, offset.toString());
                    if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                        this.updateHistoryPosition(selection.editPosition, true);
                        this.editorHistory.currentBaseHistoryInfo.endPosition = selection.editPosition;
                    }
                    // } else {
                    //     let offset: number = selection.getParagraphLength(paragraph) + 1;
                    //     if (block instanceof ParagraphWidget) {
                    //         prevParagraph = block as ParagraphWidget;
                    //     }
                    //     // if (block instanceof WTable) {
                    //     //     prevParagraph = (block as WTable).getFirstParagraphInFirstCell();
                    //     // }
                    //     selection.editPosition = prevLineWidget.getHierarchicalIndex('0');
                    // }
                }
            }
            if (start.paragraph !== paragraph && !isNullOrUndefined(block)) {
                this.delBlockContinue = true;
                this.delBlock = block;
            }
            else {
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
        this.insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction);
    }
    deleteSection(selection, section, nextSection, editAction) {
        if (editAction < 4) {
            this.combineSectionInternal(selection, section, nextSection);
        }
        //Copies the section properties, if this is last paragraph of section.
        if (editAction > 2) {
            section.sectionFormat.copyFormat(nextSection.sectionFormat);
        }
    }
    combineSectionInternal(selection, section, nextSection) {
        // if (section.sectionFormat.isEqualFormat(nextSection.sectionFormat)) {
        // } else {
        let bodyWidget = section.getSplitWidgets()[0];
        let currentSection = [];
        this.combineSectionChild(bodyWidget, currentSection);
        bodyWidget = currentSection[0];
        let lastBlockIndex = bodyWidget.lastChild.index;
        this.updateBlockIndex(lastBlockIndex + 1, nextSection.firstChild);
        let insertIndex = 0;
        let containerWidget = nextSection;
        for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
            let block = bodyWidget.childWidgets.splice(i, 1)[0];
            containerWidget.childWidgets.splice(insertIndex, 0, block);
            block.containerWidget = containerWidget;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, block.bodyWidget, block, false);
            block = block.getSplitWidgets().pop();
            containerWidget = block.containerWidget;
            insertIndex = block.indexInOwner + 1;
            i--;
        }
        this.updateSectionIndex(undefined, nextSection, false);
        this.addRemovedNodes(bodyWidget);
        // this.insert
        // }
    }
    //tslint:disable:max-line-length
    /**
     * @private
     */
    checkAndInsertBlock(block, start, end, editAction, previousParagraph) {
        if (block instanceof ParagraphWidget && block === start.paragraph || block instanceof TableWidget) {
            let newParagraph; //Adds an empty paragraph, to ensure minimal content.
            if (isNullOrUndefined(block.nextWidget) && (isNullOrUndefined(previousParagraph) || previousParagraph.nextRenderedWidget instanceof TableWidget)) {
                newParagraph = new ParagraphWidget();
                if (editAction === 1 && block instanceof ParagraphWidget) {
                    newParagraph.characterFormat.copyFormat(block.characterFormat);
                    newParagraph.paragraphFormat.copyFormat(block.paragraphFormat);
                }
                newParagraph.index = block.index + 1;
                newParagraph.containerWidget = block.containerWidget;
                this.viewer.layout.layoutBodyWidgetCollection(newParagraph.index, newParagraph.bodyWidget, newParagraph, false);
                if (block.containerWidget instanceof Widget) {
                    block.containerWidget.childWidgets.push(newParagraph);
                }
            }
            return newParagraph;
        }
        return undefined;
    }
    // tslint:disable-next-line:max-line-length
    splitParagraph(paragraphAdv, startLine, startOffset, endLine, endOffset, removeBlock) {
        let paragraph = new ParagraphWidget();
        paragraph.paragraphFormat = new WParagraphFormat(paragraph);
        paragraph.characterFormat = new WCharacterFormat(paragraph);
        paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
        paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
        let lineWidget = new LineWidget(paragraph);
        paragraph.childWidgets.push(lineWidget);
        let blockIndex = paragraphAdv.index;
        let insertIndex = paragraphAdv.indexInOwner;
        this.moveInlines(paragraphAdv, paragraph, 0, startOffset, startLine, endOffset, endLine);
        //Inserts new paragraph in the current text position.
        paragraphAdv.containerWidget.childWidgets.splice(insertIndex, 0, paragraph);
        paragraph.index = blockIndex;
        paragraph.containerWidget = paragraphAdv.containerWidget;
        this.updateNextBlocksIndex(paragraph, true);
        if (removeBlock) {
            this.removeBlock(paragraphAdv);
        }
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.layoutBodyWidgetCollection(blockIndex, paragraph.containerWidget, paragraph, false);
        return paragraph;
    }
    /**
     * @private
     */
    removeBlock(block, isSkipShifting) {
        let index;
        let blockCollection;
        let containerWidget;
        this.removeFieldInBlock(block);
        this.removeFieldInBlock(block, true);
        if (block.isInsideTable) {
            containerWidget = block.associatedCell;
            index = block.associatedCell.childWidgets.indexOf(block);
            blockCollection = block.associatedCell.childWidgets;
            this.updateNextBlocksIndex(block, false);
            block.associatedCell.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false);
        }
        else {
            containerWidget = block.containerWidget;
            index = containerWidget.childWidgets.indexOf(block);
            blockCollection = containerWidget.childWidgets;
            this.updateNextBlocksIndex(block, false);
            containerWidget.childWidgets.splice(index, 1);
            block.containerWidget = undefined;
            containerWidget.height -= block.height;
            this.viewer.layout.layoutBodyWidgetCollection(block.index, containerWidget, block, false, isSkipShifting);
        }
    }
    removeField(block, isBookmark) {
        let collection = this.viewer.fields;
        if (isBookmark) {
            collection = this.viewer.bookmarks.keys;
        }
        for (let i = 0; i < collection.length; i++) {
            let element = isBookmark ?
                this.viewer.bookmarks.get(collection[i]) : collection[i];
            if (element.line.paragraph === block) {
                if (isBookmark) {
                    this.viewer.bookmarks.remove(collection[i]);
                }
                else {
                    this.viewer.fields.splice(i, 1);
                }
                i--;
            }
        }
    }
    addRemovedNodes(node) {
        if (node instanceof CommentCharacterElementBox && node.commentType === 0 && node.commentMark) {
            node.removeCommentMark();
        }
        if (node instanceof FieldElementBox && node.fieldType === 0) {
            if (this.viewer.fields.indexOf(node) !== -1) {
                this.viewer.fields.splice(this.viewer.fields.indexOf(node), 1);
            }
        }
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(node);
        }
        else if (this.editHyperlinkInternal) {
            this.nodes.push(node);
        }
    }
    deleteBlock(block, selection, start, end, editAction) {
        if (block instanceof ParagraphWidget) {
            this.deletePara(block, start, end, editAction);
            if (this.delBlockContinue && this.delBlock) {
                if (this.delSection) {
                    let bodyWidget = block.bodyWidget instanceof BodyWidget ? block.bodyWidget : undefined;
                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                    this.delSection = undefined;
                }
                this.deleteBlock(this.delBlock, selection, start, end, editAction);
                this.delBlockContinue = false;
                this.delBlock = undefined;
            }
        }
        else {
            this.deleteTableBlock(block, selection, start, end, editAction);
        }
    }
    // tslint:disable-next-line:max-line-length
    deleteTableCell(cellAdv, selection, start, end, editAction) {
        let deletePreviousBlock = !(start.paragraph.isInsideTable && cellAdv.ownerTable.contains(start.paragraph.associatedCell));
        let previousBlock = cellAdv.ownerTable.previousRenderedWidget;
        if (start.paragraph.isInsideTable) {
            let containerCell = selection.getContainerCellOf(cellAdv, start.paragraph.associatedCell);
            if (containerCell.ownerTable.contains(start.paragraph.associatedCell)) {
                let startCell = selection.getSelectedCell(cellAdv, containerCell);
                let endCell = selection.getSelectedCell(start.paragraph.associatedCell, containerCell);
                if (selection.containsCell(containerCell, start.paragraph.associatedCell)) {
                    //Selection end is in container cell.
                    if (selection.isCellSelected(containerCell, start, end)) {
                        //Container cell is completely selected.
                        this.updateEditPosition(containerCell, selection);
                        if (editAction === 1) {
                            //Specifically handled for backspace. Delete selected cell in current table.
                            this.deleteCellsInTable(cellAdv.ownerRow.ownerTable, selection, start, end, editAction);
                        }
                        else {
                            //Delete contents within table cell or Copy contents within table cell to clipboard.
                            let isCellCleared = this.deleteCell(containerCell, selection, editAction, true);
                            if (!isCellCleared && editAction !== 2 && this.editorHistory) {
                                this.editorHistory.currentBaseHistoryInfo = undefined;
                            }
                            else if (isCellCleared) {
                                this.viewer.layout.reLayoutTable(containerCell.ownerRow.ownerTable);
                            }
                        }
                    }
                    else {
                        if (startCell === containerCell) {
                            this.deletePara(end.paragraph, start, end, editAction);
                            if (this.delBlockContinue && this.delBlock) {
                                if (this.delSection) {
                                    let para = end.paragraph;
                                    let bodyWidget = para.bodyWidget instanceof BodyWidget ? para.bodyWidget : undefined;
                                    this.deleteSection(selection, this.delSection, bodyWidget, editAction);
                                    this.delSection = undefined;
                                }
                                this.deleteBlock(this.delBlock, selection, start, end, editAction);
                                this.delBlockContinue = false;
                                this.delBlock = undefined;
                            }
                        }
                        else {
                            this.deleteContainer(startCell, selection, start, end, editAction);
                        }
                    }
                }
                else {
                    if (editAction === 2) {
                        //Delete contents within table cell.
                        this.deleteCell(cellAdv, selection, 2, false);
                    }
                    else {
                        //Delete other selected cells in current table.
                        this.deleteCellsInTable(containerCell.ownerTable, selection, start, end, editAction);
                    }
                }
            }
            else {
                //Selection end is different table.
                this.deleteContainer(containerCell, selection, start, end, editAction);
            }
        }
        else {
            //Selection end is outside table.
            let cell = selection.getContainerCell(cellAdv);
            this.deleteContainer(cell, selection, start, end, editAction);
        }
        if (deletePreviousBlock) {
            let sectionAdv = previousBlock.bodyWidget instanceof BodyWidget ? previousBlock.bodyWidget : undefined;
            // this.deleteContent(cellAdv.ownerTable, selection, editAction);
            if (!isNullOrUndefined(previousBlock)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(previousBlock, selection, start, end, editAction);
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    deleteCellsInTable(table, selection, start, end, editAction) {
        let clonedTable = undefined;
        let isDeleteCells = false;
        let action = 'Delete';
        let startCell = start.paragraph.associatedCell;
        let endCell = end.paragraph.associatedCell;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            action = this.editorHistory.currentBaseHistoryInfo.action;
            //tslint:disable-next-line:max-line-length
            isDeleteCells = this.editorHistory.currentBaseHistoryInfo.action === 'BackSpace' || this.editorHistory.currentBaseHistoryInfo.action === 'DeleteCells'
                || this.editorHistory.currentBaseHistoryInfo.action === 'InsertTable' || (isNullOrUndefined(startCell.ownerRow.previousWidget)
                && isNullOrUndefined(endCell.ownerRow.nextWidget) && this.editorHistory.currentBaseHistoryInfo.action === 'Cut');
            this.editorHistory.currentBaseHistoryInfo.action = isDeleteCells ? 'DeleteCells' : 'ClearCells';
            clonedTable = this.cloneTableToHistoryInfo(table);
            selection.owner.isLayoutEnabled = false;
        }
        let startColumnIndex = startCell.columnIndex;
        let endColumnIndex = endCell.columnIndex + endCell.cellFormat.columnSpan - 1;
        let startRowIndex = startCell.rowIndex;
        let endRowIndex = endCell.rowIndex;
        let isStarted = false;
        let isCellCleared = false;
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row.index >= startRowIndex && row.index <= endRowIndex) {
                for (let j = 0; j < row.childWidgets.length; j++) {
                    let cell = row.childWidgets[j];
                    if (cell.columnIndex >= startColumnIndex && cell.columnIndex <= endColumnIndex) {
                        if (!isStarted) {
                            this.updateEditPosition(cell, selection);
                            isStarted = true;
                        }
                        if (isDeleteCells) {
                            //Specific for Backspace and Cut if selection includes all rows.
                            let cell = row.childWidgets[j];
                            this.updateNextBlocksIndex(cell, false);
                            row.childWidgets.splice(j, 1);
                            j--;
                        }
                        else if (editAction < 4) {
                            isCellCleared = this.deleteCell(cell, selection, editAction, false);
                        }
                    }
                }
                if (row.childWidgets.length === 0) {
                    this.updateNextBlocksIndex(table.childWidgets[i], false);
                    table.childWidgets.splice(i, 1);
                    i--;
                    endRowIndex--;
                }
            }
        }
        //Layouts the table after delete cells.
        selection.owner.isLayoutEnabled = true;
        if (table.childWidgets.length === 0) {
            selection.editPosition = this.selection.getHierarchicalIndex(table, '0');
            this.setActionInternal(selection, action);
            this.removeBlock(table);
        }
        else {
            // Before lay outing need to update table grid.
            table.isGridUpdated = false;
            table.buildTableColumns();
            table.isGridUpdated = true;
            this.viewer.layout.reLayoutTable(table);
        }
    }
    deleteCell(cell, selection, editAction, copyChildToClipboard) {
        //Checks whether this is last paragraph of owner textbody.
        let block = cell.childWidgets[0];
        if (cell.childWidgets.length === 1 && block instanceof ParagraphWidget && block.isEmpty()) {
            return false;
        }
        for (let i = 0; i < cell.childWidgets.length; i++) {
            block = cell.childWidgets[i];
            if (editAction < 4) {
                //Checks whether this is last paragraph of owner textbody.
                if (block instanceof ParagraphWidget && cell.childWidgets.length === 1) {
                    //Preserves empty paragraph, to ensure minimal content.
                    let paragraph = block;
                    //Removes all the inlines in the paragraph.
                    for (let j = 0; j < paragraph.childWidgets.length; j++) {
                        let inline = paragraph.childWidgets[j];
                        for (let k = 0; k < inline.children.length; k++) {
                            let element = inline.children[k];
                            this.unLinkFieldCharacter(element);
                            inline.children.splice(k, 1);
                            // this.layoutInlineCollection(true, paragraph.inlines.indexOf(inline), paragraph.inlines, inline);
                            k--;
                            if (this.checkClearCells(selection)) {
                                this.addRemovedNodes(element);
                            }
                        }
                        if (paragraph.childWidgets.length > 1) {
                            paragraph.childWidgets.splice(j, 1);
                            j--;
                        }
                    }
                    if (this.checkClearCells(selection)) {
                        //Add Index for line Widget
                        selection.editPosition = this.selection.getHierarchicalIndex(paragraph, '0');
                        this.updateHistoryPosition(selection.editPosition, true);
                    }
                    break;
                }
                this.removeBlock(block);
                i--;
                if (this.checkClearCells(selection)) {
                    this.addRemovedNodes(block);
                }
            }
        }
        return true;
    }
    deleteContainer(cell, selection, start, end, editAction) {
        let ownerTable = cell.ownerTable;
        if (selection.containsRow(ownerTable.lastChild, end.paragraph.associatedCell)) {
            this.deleteContent(ownerTable, selection, editAction);
        }
        else {
            for (let i = 0; i < ownerTable.childWidgets.length; i++) {
                let row = ownerTable.childWidgets[i];
                if (editAction < 4) {
                    this.updateNextBlocksIndex(row, false);
                    ownerTable.childWidgets.splice(i, 1);
                    this.addRemovedNodes(row);
                    i--;
                }
                if (end.paragraph.isInsideTable && selection.containsRow(row, end.paragraph.associatedCell)) {
                    this.viewer.layout.reLayoutTable(ownerTable);
                    return;
                }
            }
        }
    }
    deleteTableBlock(table, selection, start, end, editAction) {
        table = table.combineWidget(this.viewer);
        if (start.paragraph.isInsideTable && table.contains(start.paragraph.associatedCell)) {
            let block = table.previousRenderedWidget;
            // tslint:disable-next-line:max-line-length
            let previousBlock = this.checkAndInsertBlock(table, start, end, editAction, block instanceof ParagraphWidget ? block : undefined);
            if (selection.containsRow(table.firstChild, start.paragraph.associatedCell)) {
                this.deleteContent(table, selection, editAction);
            }
            else {
                let newTable = this.splitTable(table, start.paragraph.associatedCell.ownerRow);
                this.deleteContent(table, selection, editAction);
                this.viewer.layout.layoutBodyWidgetCollection(newTable.index, newTable.containerWidget, newTable, false);
            }
            if (!isNullOrUndefined(previousBlock)) {
                selection.editPosition = this.selection.getHierarchicalIndex(previousBlock, '0');
                if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                    this.editorHistory.currentBaseHistoryInfo.endPosition = selection.editPosition;
                }
            }
        }
        else {
            let blockAdv = table.previousRenderedWidget;
            let sectionAdv = table.bodyWidget instanceof BodyWidget ? table.bodyWidget : undefined;
            this.deleteContent(table, selection, editAction);
            if (!isNullOrUndefined(blockAdv)) {
                // let nextSection: WSection = blockAdv.section instanceof WSection ? blockAdv.section as WSection : undefined;
                // if (sectionAdv !== nextSection) {
                //     this.deleteSection(selection, sectionAdv, nextSection, editAction);
                // }
                //Goto the next block.
                this.deleteBlock(blockAdv, selection, start, end, editAction);
            }
        }
    }
    splitTable(table, splitEndRow) {
        let newTable = new TableWidget();
        newTable.tableFormat.copyFormat(table.tableFormat);
        newTable.index = table.index;
        //Moves the rows to new table.
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            if (row === splitEndRow) {
                break;
            }
            newTable.childWidgets.push(row);
            row.containerWidget = newTable;
            table.childWidgets.splice(i, 1);
            i--;
        }
        //Inserts new table in the current text position.
        let insertIndex = table.getIndex();
        table.containerWidget.childWidgets.splice(insertIndex, 0, newTable);
        newTable.containerWidget = table.containerWidget;
        this.updateNextBlocksIndex(newTable, true);
        return newTable;
    }
    updateEditPosition(cell, selection) {
        let firstParagraph = selection.getFirstParagraphInCell(cell);
        selection.editPosition = this.selection.getHierarchicalIndex(firstParagraph, '0');
    }
    /**
     * @private
     */
    deleteContent(table, selection, editAction) {
        if (editAction < 4) {
            this.removeBlock(table);
            this.addRemovedNodes(table);
        }
    }
    setActionInternal(selection, action) {
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.editorHistory.currentBaseHistoryInfo.action = action;
        }
    }
    checkClearCells(selection) {
        // tslint:disable-next-line:max-line-length
        return this.editorHistory && this.editorHistory.currentBaseHistoryInfo && this.editorHistory.currentBaseHistoryInfo.action !== 'ClearCells';
    }
    isEndInAdjacentTable(paragraph, endParagraph) {
        let start = this.selection.getHierarchicalIndex(paragraph, '');
        let end = this.selection.getHierarchicalIndex(endParagraph, '');
        let selectionStart = start.split(';');
        let selectionEnd = end.split(';');
        return selectionStart.length < selectionEnd.length;
    }
    cloneTableToHistoryInfo(table) {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            //Clones the entire table to preserve in history.
            let clonedTable = table.clone();
            //Preserves the cloned table in history info, for future undo operation.
            this.editorHistory.currentBaseHistoryInfo.removedNodes.push(clonedTable);
            //Sets the insert position in history info as current table.
            if (this.viewer.selection.start.paragraph.isInsideTable &&
                this.viewer.selection.start.paragraph.associatedCell.ownerTable === table) {
                this.updateHistoryPosition(this.selection.getHierarchicalIndex(table, '0'), true);
            }
            return clonedTable;
        }
        return undefined;
    }
    // tslint:disable-next-line:max-line-length
    insertParagraphPaste(paragraph, currentParagraph, start, end, isCombineNextParagraph, editAction) {
        if (this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing) && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
            let nextParagraph = this.selection.getNextParagraphBlock(currentParagraph);
            if (nextParagraph) {
                if (start.offset > 0 && nextParagraph === end.paragraph && paragraph === start.paragraph
                    && this.editorHistory.currentBaseHistoryInfo.action === 'Paste') {
                    //Combines the current paragraph with end paragraph specific for undo/redo paste action.
                    let insertIndex = 0;
                    this.removeBlock(currentParagraph);
                    this.viewer.layout.clearListElementBox(nextParagraph);
                    this.viewer.layout.clearListElementBox(currentParagraph);
                    for (let i = 0; i < currentParagraph.childWidgets.length; i++) {
                        let line = currentParagraph.childWidgets[i];
                        nextParagraph.childWidgets.splice(insertIndex, 0, line);
                        currentParagraph.childWidgets.splice(i, 1);
                        i--;
                        insertIndex++;
                        line.paragraph = nextParagraph;
                    }
                    this.viewer.layout.reLayoutParagraph(nextParagraph, 0, 0);
                    isCombineNextParagraph = false;
                    let offset = this.selection.editPosition.substring(this.selection.editPosition.lastIndexOf(';') + 1);
                    this.selection.editPosition = this.selection.getHierarchicalIndex(nextParagraph, offset);
                }
            }
        }
        if (isCombineNextParagraph) {
            this.deleteParagraphMark(currentParagraph, this.selection, editAction);
        }
    }
    // tslint:disable-next-line:max-line-length
    removeInlines(paragraph, startLine, startOffset, endLine, endOffset, editAction) {
        let isRemoved = false;
        this.viewer.layout.clearListElementBox(paragraph);
        let startIndex = paragraph.childWidgets.indexOf(startLine);
        for (let i = paragraph.childWidgets.length - 1; i >= 0; i--) {
            let lineWidget = paragraph.childWidgets[i];
            if (startLine === lineWidget && endLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, endOffset);
                isRemoved = true;
                break;
            }
            if (endLine === lineWidget) {
                isRemoved = true;
                this.removeContent(lineWidget, 0, endOffset);
            }
            else if (startLine === lineWidget) {
                this.removeContent(lineWidget, startOffset, this.viewer.selection.getLineLength(lineWidget));
                break;
            }
            else if (isRemoved) {
                this.removeContent(lineWidget, 0, this.viewer.selection.getLineLength(lineWidget));
            }
        }
        if (isRemoved) {
            this.removeEmptyLine(paragraph);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
        }
    }
    /**
     * @private
     */
    removeContent(lineWidget, startOffset, endOffset) {
        let count = this.selection.getLineLength(lineWidget);
        let isBidi = lineWidget.paragraph.paragraphFormat.bidi;
        let childLength = lineWidget.children.length;
        for (let i = isBidi ? 0 : childLength - 1; isBidi ? i < childLength : i >= 0; isBidi ? i++ : i--) {
            let inline = lineWidget.children[i];
            if (endOffset <= count - inline.length) {
                count -= inline.length;
                continue;
            }
            let endIndex = inline.length;
            if (count > endOffset && (count - endIndex < endOffset)) {
                endIndex = endOffset - (count - inline.length);
            }
            let startIndex = 0;
            if (count - inline.length < startOffset) {
                startIndex = startOffset - (count - inline.length);
            }
            if (count > endOffset) {
                count -= (inline.length - endIndex);
            }
            if (startIndex === 0 && endIndex === inline.length) {
                if (!(this.editorHistory && (this.editorHistory.isUndoing || this.editorHistory.isRedoing))) {
                    if (inline instanceof BookmarkElementBox) {
                        this.removedBookmarkElements.push(inline);
                    }
                }
                if (inline instanceof BookmarkElementBox) {
                    if (this.viewer.bookmarks.containsKey(inline.name)) {
                        this.viewer.bookmarks.remove(inline.name);
                    }
                }
                // if (editAction < 4) {
                this.unLinkFieldCharacter(inline);
                this.addRemovedNodes(lineWidget.children[i]);
                lineWidget.children.splice(i, 1);
                // }
            }
            else if (inline instanceof TextElementBox) {
                // if (editAction < 4) {
                let span = new TextElementBox();
                span.characterFormat.copyFormat(inline.characterFormat);
                span.text = inline.text.substr(startIndex, endIndex - startIndex);
                this.addRemovedNodes(span);
                inline.text = inline.text.slice(0, startIndex) + inline.text.slice(endIndex);
            }
            if (startOffset >= count - (endIndex - startIndex)) {
                break;
            }
            count -= (endIndex - startIndex);
        }
    }
    /**
     * @private
     */
    removeEmptyLine(paragraph) {
        if (paragraph.childWidgets.length > 1) {
            for (let i = 0; i < paragraph.childWidgets.length; i++) {
                let lineWidget = paragraph.childWidgets[i];
                if (lineWidget.children.length === 0 && paragraph.childWidgets.length > 1) {
                    paragraph.childWidgets.splice(i, 1);
                    i--;
                }
            }
        }
    }
    //#endregion
    /**
     * clone the list level
     * @param  {WListLevel} source
     * @private
     */
    cloneListLevel(source) {
        let listLevel = new WListLevel(undefined);
        this.copyListLevel(listLevel, source);
        return listLevel;
    }
    /**
     * Copies the list level
     * @param  {WListLevel} destination
     * @param  {WListLevel} listLevel
     * @private
     */
    copyListLevel(destination, listLevel) {
        if (!isNullOrUndefined(listLevel.paragraphFormat)) {
            destination.paragraphFormat = new WParagraphFormat(destination);
            destination.paragraphFormat.copyFormat(listLevel.paragraphFormat);
        }
        if (!isNullOrUndefined(listLevel.characterFormat)) {
            destination.characterFormat = new WCharacterFormat(destination);
            destination.characterFormat.copyFormat(listLevel.characterFormat);
        }
        if (!isNullOrUndefined(listLevel.followCharacter)) {
            destination.followCharacter = listLevel.followCharacter;
        }
        if (!isNullOrUndefined(listLevel.listLevelPattern)) {
            destination.listLevelPattern = listLevel.listLevelPattern;
        }
        if (!isNullOrUndefined(listLevel.numberFormat)) {
            destination.numberFormat = listLevel.numberFormat;
        }
        if (!isNullOrUndefined(listLevel.restartLevel)) {
            destination.restartLevel = listLevel.restartLevel;
        }
        if (!isNullOrUndefined(listLevel.startAt)) {
            destination.startAt = listLevel.startAt;
        }
    }
    /**
     * Clone level override
     * @param  {WLevelOverride} source
     * @private
     */
    cloneLevelOverride(source) {
        let levelOverride = new WLevelOverride();
        if (!isNullOrUndefined(source.startAt)) {
            levelOverride.startAt = source.startAt;
        }
        if (!isNullOrUndefined(source.overrideListLevel)) {
            levelOverride.overrideListLevel = source.overrideListLevel;
        }
        if (!isNullOrUndefined(source.levelNumber)) {
            levelOverride.levelNumber = source.levelNumber;
        }
        return levelOverride;
    }
    /**
     * Update List Paragraph
     * @private
     */
    updateListParagraphs() {
        this.viewer.listParagraphs = [];
        for (let j = 0; j < this.viewer.pages.length; j++) {
            let bodyWidget = this.viewer.pages[j].bodyWidgets[0];
            for (let i = 0; i < bodyWidget.childWidgets.length; i++) {
                this.updateListParagraphsInBlock(bodyWidget.childWidgets[i]);
            }
        }
    }
    /**
     * @private
     */
    updateListParagraphsInBlock(block) {
        if (block instanceof ParagraphWidget) {
            if (!isNullOrUndefined(block.paragraphFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat)
                && !isNullOrUndefined(block.paragraphFormat.listFormat.listId)) {
                if (isNullOrUndefined(this.viewer.listParagraphs)) {
                    this.viewer.listParagraphs = [];
                }
                this.viewer.listParagraphs.push(block);
            }
        }
        else if (block instanceof TableWidget) {
            for (let i = 0; i < block.childWidgets.length; i++) {
                for (let j = 0; j < block.childWidgets[i].childWidgets.length; j++) {
                    let cell = block.childWidgets[i].childWidgets[j];
                    for (let k = 0; k < cell.childWidgets.length; k++) {
                        this.updateListParagraphsInBlock(cell.childWidgets[k]);
                    }
                }
            }
        }
    }
    /**
     * Applies list format
     * @param  {WList} list
     * @private
     */
    onApplyList(list) {
        let selection = this.viewer.selection;
        this.setOffsetValue(this.viewer.selection);
        this.initHistory('ListFormat');
        let format = new WListFormat();
        if (!isNullOrUndefined(list)) {
            format.listId = list.listId;
        }
        this.viewer.owner.isShiftingEnabled = true;
        if (selection.isEmpty) {
            this.applyParaFormatProperty(selection.start.paragraph, 'listFormat', format, false);
            this.layoutItemBlock(selection.start.paragraph, false);
        }
        else {
            this.updateSelectionParagraphFormatting('listFormat', format, false);
        }
        this.reLayout(selection);
    }
    /**
     * Applies bullets or numbering list
     * @param  {string} format
     * @param  {ListLevelPattern} listLevelPattern
     * @param  {string} fontFamily
     * @private
     */
    applyBulletOrNumbering(format, listLevelPattern, fontFamily) {
        let selection = this.viewer.selection;
        let list = selection.paragraphFormat.getList();
        let isUpdate = false;
        let start = selection.start;
        if (!selection.isForward) {
            start = selection.end;
        }
        let currentParagraph = start.paragraph;
        if (isNullOrUndefined(list)) {
            while (!isNullOrUndefined(currentParagraph.previousWidget) && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.isEmpty() && currentParagraph.previousWidget.paragraphFormat.listFormat.listId === -1) {
                currentParagraph = currentParagraph.previousWidget;
            }
            if (currentParagraph.previousWidget && currentParagraph.previousWidget instanceof ParagraphWidget
                && currentParagraph.previousWidget.paragraphFormat.listFormat.listId !== -1) {
                currentParagraph = currentParagraph.previousWidget;
                list = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
                isUpdate = true;
            }
            if (!isUpdate) {
                while (!isNullOrUndefined(currentParagraph.nextWidget) && currentParagraph.nextWidget instanceof ParagraphWidget
                    && currentParagraph.nextWidget.isEmpty() && currentParagraph.nextWidget.paragraphFormat.listFormat.listId === -1) {
                    currentParagraph = currentParagraph.nextWidget;
                }
                if (currentParagraph.nextWidget && currentParagraph.nextWidget instanceof ParagraphWidget
                    && currentParagraph.nextWidget.paragraphFormat.listFormat.listId !== -1) {
                    currentParagraph = currentParagraph.nextWidget;
                    list = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
                    isUpdate = true;
                }
            }
        }
        let startListLevel = undefined;
        let levelNumber = -1;
        if (!isNullOrUndefined(list)) {
            levelNumber = currentParagraph.paragraphFormat.listFormat.listLevelNumber;
            let tempList = this.viewer.getListById(currentParagraph.paragraphFormat.listFormat.listId);
            startListLevel = this.viewer.layout.getListLevel(tempList, levelNumber);
            let abstractList = tempList.abstractList;
            if (!abstractList) {
                abstractList = this.viewer.getAbstractListById(list.abstractListId);
            }
            if (abstractList.levels.length === 0) {
                startListLevel = this.viewer.layout.getListLevel(tempList, currentParagraph.paragraphFormat.listFormat.listLevelNumber);
            }
            if (isUpdate) {
                if (listLevelPattern !== 'Bullet' && startListLevel.listLevelPattern === listLevelPattern
                    && (startListLevel.numberFormat === format || startListLevel.numberFormat.indexOf(format) !== -1)) {
                    selection.paragraphFormat.listId = list.listId;
                    selection.paragraphFormat.listLevelNumber = levelNumber;
                    selection.paragraphFormat.setList(list);
                    return;
                }
                else {
                    startListLevel = abstractList.levels[0];
                }
            }
        }
        if (isNullOrUndefined(list) || (!isNullOrUndefined(list) && ((startListLevel.listLevelPattern !== listLevelPattern) ||
            startListLevel.numberFormat !== format || (startListLevel.characterFormat.fontFamily !== fontFamily
            && startListLevel.listLevelPattern === 'Bullet')))) {
            isUpdate = false;
            list = new WList();
            if (this.viewer.lists.length > 0) {
                list.listId = this.viewer.lists[this.viewer.lists.length - 1].listId + 1;
            }
            else {
                list.listId = 0;
            }
            let abstractList = new WAbstractList();
            if (this.viewer.abstractLists.length > 0) {
                abstractList.abstractListId = this.viewer.abstractLists[this.viewer.abstractLists.length - 1].abstractListId + 1;
            }
            else {
                abstractList.abstractListId = 0;
            }
            list.abstractListId = abstractList.abstractListId;
            list.abstractList = abstractList;
            this.viewer.abstractLists.push(abstractList);
            if (format === 'bullet' || format === 'multiLevel' || format === 'numbering') {
                this.addListLevels(abstractList, format, selection);
            }
            else {
                let listLevel = new WListLevel(abstractList);
                listLevel.listLevelPattern = listLevelPattern;
                listLevel.numberFormat = format;
                if (listLevelPattern !== 'Bullet') {
                    listLevel.startAt = 1;
                }
                else {
                    listLevel.characterFormat.fontFamily = fontFamily;
                }
                listLevel.paragraphFormat.leftIndent = 36;
                listLevel.paragraphFormat.firstLineIndent = -18;
                abstractList.levels.push(listLevel);
                selection.paragraphFormat.listLevelNumber = 0;
            }
            selection.paragraphFormat.setList(list);
        }
        else if (!isNullOrUndefined(list) && isUpdate) {
            selection.paragraphFormat.setList(list);
        }
        else {
            selection.paragraphFormat.setList(undefined);
        }
    }
    addListLevels(abstractListAdv, listName, selection) {
        let bulletCharacters = ['\uf076', '\uf0d8', '\uf0a7', '\uf0b7', '\uf0a8'];
        for (let i = abstractListAdv.levels.length; i < 9; i++) {
            let listLevel = new WListLevel(abstractListAdv);
            if (listName.match('bullet')) {
                listLevel.listLevelPattern = 'Bullet';
                listLevel.numberFormat = bulletCharacters[i < 5 ? i % 5 : i % 5 + 1];
                listLevel.characterFormat.fontFamily = i < 3 || i === 5 ? 'Wingdings' : 'Symbol';
            }
            else {
                if (listName.match('multiLevel')) {
                    for (let j = 0; j < i + 1; j++) {
                        listLevel.numberFormat += '%' + (j + 1).toString() + '.';
                    }
                    listLevel.listLevelPattern = 'Number';
                }
                else {
                    listLevel.numberFormat = '%' + (i + 1).toString() + ')';
                    listLevel.listLevelPattern = i % 3 === 0 ? 'Number'
                        : i % 3 === 1 ? 'LowLetter' : 'LowRoman';
                }
                listLevel.startAt = 1;
                listLevel.restartLevel = i;
            }
            if (i === 0) {
                listLevel.paragraphFormat.leftIndent = 36;
            }
            else {
                listLevel.paragraphFormat.leftIndent = 36 * i;
            }
            listLevel.paragraphFormat.firstLineIndent = -18;
            abstractListAdv.levels.push(listLevel);
            selection.paragraphFormat.listLevelNumber = i;
        }
    }
    /**
     * Insert page break at cursor position
     */
    insertPageBreak() {
        if (!this.owner.isReadOnlyMode) {
            if (this.viewer.selection.start.paragraph.isInsideTable ||
                this.viewer.selection.start.paragraph.isInHeaderFooter) {
                return;
            }
            this.initComplexHistory('PageBreak');
            this.onEnter(true);
            if (this.editorHistory && this.editorHistory.currentHistoryInfo != null) {
                this.editorHistory.updateComplexHistory();
            }
            this.selection.checkForCursorVisibility();
        }
    }
    /**
     * @private
     */
    onEnter(isInsertPageBreak) {
        let selection = this.viewer.selection;
        if (selection.isEmpty) {
            //ToDo: Need to handle the CTRL + Enter (Page Break) and SHIFT + Enter (Line Break) behavior.
            let hyperlinkField = selection.getHyperlinkField();
            let isSelectionOnHyperlink = !isNullOrUndefined(hyperlinkField);
            if (isSelectionOnHyperlink) {
                selection.fireRequestNavigate(hyperlinkField);
                return;
            }
            let paragraph = selection.start.paragraph;
            if (paragraph.isEmpty() && paragraph.paragraphFormat.listFormat.listId !== -1) {
                // tslint:disable-next-line:max-line-length
                this.onApplyListInternal(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId), paragraph.paragraphFormat.listFormat.listLevelNumber - 1);
                return;
            }
        }
        this.initHistory('Enter');
        let isRemoved = true;
        if (!selection.isEmpty) {
            // this.initHistoryWithSelection(selection, 'Enter');
            isRemoved = this.removeSelectedContents(selection);
        }
        if (isRemoved) {
            selection.owner.isShiftingEnabled = true;
            this.updateInsertPosition();
            let blockInfo = this.selection.getParagraphInfo(selection.start);
            let initialStart = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            this.splitParagraphInternal(selection, selection.start.paragraph, selection.start.currentWidget, selection.start.offset);
            this.setPositionForCurrentIndex(selection.start, initialStart);
            if (isInsertPageBreak) {
                let currentParagraph = selection.start.paragraph;
                let breakParagraph = new ParagraphWidget();
                breakParagraph.characterFormat.copyFormat(currentParagraph.characterFormat);
                breakParagraph.paragraphFormat.copyFormat(currentParagraph.paragraphFormat);
                let pageBreak = new TextElementBox();
                pageBreak.text = '\f';
                let line = new LineWidget(breakParagraph);
                line.children.push(pageBreak);
                pageBreak.line = line;
                breakParagraph.childWidgets.push(line);
                this.insertParagraph(breakParagraph, true);
                selection.selectParagraphInternal(breakParagraph, true);
            }
            let nextNode = selection.start.paragraph.nextWidget;
            if (isNullOrUndefined(nextNode)) {
                nextNode = selection.getNextRenderedBlock(selection.start.paragraph);
            }
            selection.selectParagraphInternal(nextNode, true);
            this.updateEndPosition();
            if (isInsertPageBreak && this.editorHistory) {
                this.owner.editorHistory.updateHistory();
            }
            // if (!isNullOrUndefined(selection.currentHistoryInfo)) {
            //     this.updateComplexHistory();
            // } else {
            this.reLayout(selection);
            // tslint:disable-next-line:max-line-length
            let currentPara = this.selection.start.paragraph.containerWidget.firstChild;
            if (!isNullOrUndefined(currentPara)) {
                currentPara.isChangeDetected = false;
                let nextPara = currentPara.nextRenderedWidget;
                // tslint:disable-next-line:max-line-length
                while (this.owner.enableSpellCheck && !isNullOrUndefined(nextPara)) {
                    currentPara = nextPara;
                    currentPara.isChangeDetected = false;
                    nextPara = currentPara.nextRenderedWidget;
                }
            }
            // }
            let paragraph = selection.start.paragraph.previousWidget;
            if (!isNullOrUndefined(paragraph) && !paragraph.isEmpty() &&
                // tslint:disable-next-line:max-line-length
                paragraph.lastChild.children[paragraph.lastChild.children.length - 1] instanceof TextElementBox) {
                this.checkAndConvertToHyperlink(selection, true, paragraph);
            }
        }
    }
    splitParagraphInternal(selection, paragraphAdv, currentLine, offset) {
        let insertIndex = 0;
        let blockIndex = paragraphAdv.index;
        let currentPara = paragraphAdv;
        currentPara.isChangeDetected = (offset === 0) ? true : false;
        while (this.owner.enableSpellCheck && !isNullOrUndefined(currentPara.nextRenderedWidget)) {
            currentPara = currentPara.nextRenderedWidget;
            currentPara.isChangeDetected = true;
        }
        let paragraph = new ParagraphWidget();
        let lineWidget = new LineWidget(paragraph);
        paragraph.childWidgets.push(lineWidget);
        //Copies the format to new paragraph.
        paragraph.paragraphFormat.ownerBase = paragraph;
        if (currentLine === paragraphAdv.lastChild && offset === selection.getLineLength(currentLine)) {
            // tslint:disable-next-line:max-line-length
            if (paragraphAdv.paragraphFormat.baseStyle
                && paragraphAdv.paragraphFormat.baseStyle.name !== 'Normal' && paragraphAdv.paragraphFormat.baseStyle.next instanceof WParagraphStyle) {
                if (paragraphAdv.paragraphFormat.baseStyle.name === paragraphAdv.paragraphFormat.baseStyle.next.name) {
                    paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                    paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
                }
                else {
                    paragraph.paragraphFormat.baseStyle = paragraphAdv.paragraphFormat.baseStyle.next;
                }
                this.selection.skipFormatRetrieval = false;
            }
            else {
                paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
                paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
            }
            //ToDo in future: Need to skip copying formattings to new paragraph, if the style for following paragraph is same style.
            insertIndex++;
            blockIndex++;
        }
        else {
            paragraph.paragraphFormat.copyFormat(paragraphAdv.paragraphFormat);
            paragraph.characterFormat.copyFormat(paragraphAdv.characterFormat);
            if (offset > 0 || !currentLine.isFirstLine()) {
                paragraphAdv = paragraphAdv.combineWidget(this.viewer);
                this.moveInlines(paragraphAdv, paragraph, 0, 0, paragraphAdv.firstChild, offset, currentLine);
            }
            paragraphAdv = paragraphAdv.getSplitWidgets()[0];
        }
        insertIndex += paragraphAdv.getIndex();
        let container = paragraphAdv.containerWidget;
        let childNodes = container.childWidgets;
        childNodes.splice(insertIndex, 0, paragraph);
        paragraph.containerWidget = container;
        paragraph.index = blockIndex;
        this.updateNextBlocksIndex(paragraph, true);
        // tslint:disable-next-line:max-line-length
        this.viewer.layout.layoutBodyWidgetCollection(blockIndex, container, paragraph, false);
    }
    /**
     * @private
     */
    updateNextBlocksIndex(block, increaseIndex) {
        let nextIndex = block.containerWidget.childWidgets.indexOf(block) + 1;
        if (block.containerWidget instanceof BodyWidget) {
            let currentSectionIndex = block.containerWidget.index;
            for (let j = this.viewer.pages.indexOf(block.containerWidget.page); j < this.viewer.pages.length; j++) {
                let page = this.viewer.pages[j];
                if (page.bodyWidgets[0].index === currentSectionIndex) {
                    for (let k = nextIndex; k < page.bodyWidgets[0].childWidgets.length; k++) {
                        let childWidget = page.bodyWidgets[0].childWidgets[k];
                        this.updateIndex(childWidget, increaseIndex);
                    }
                    nextIndex = 0;
                }
                else {
                    return;
                }
            }
        }
        else if (block.containerWidget instanceof TableCellWidget) {
            let cells = block.containerWidget.getSplitWidgets();
            let currentCellIndex = cells.indexOf(block.containerWidget);
            for (let x = currentCellIndex; x < cells.length; x++) {
                let blocks = cells[x].childWidgets;
                for (let y = nextIndex; y < blocks.length; y++) {
                    this.updateIndex(blocks[y], increaseIndex);
                }
                currentCellIndex = 0;
                nextIndex = 0;
            }
        }
        else if (block.containerWidget instanceof TableRowWidget) {
            for (let i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let cell = block.containerWidget.childWidgets[i];
                if (cell.rowIndex === block.containerWidget.index) {
                    this.updateIndex(cell, increaseIndex);
                }
            }
        }
        else if (block.containerWidget instanceof TableWidget) {
            for (let i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let row = block.containerWidget.childWidgets[i];
                this.updateIndex(row, increaseIndex);
                for (let j = 0; j < row.childWidgets.length; j++) {
                    row.childWidgets[j].rowIndex = row.index;
                }
            }
            //update Row index of all the cell
        }
        else if (block.containerWidget instanceof HeaderFooterWidget) {
            for (let i = nextIndex; i < block.containerWidget.childWidgets.length; i++) {
                let nextBlock = block.containerWidget.childWidgets[i];
                this.updateIndex(nextBlock, increaseIndex);
            }
        }
    }
    updateIndex(widget, increment) {
        if (increment) {
            widget.index++;
        }
        else {
            widget.index--;
        }
    }
    updateEndPosition() {
        let selection = this.viewer.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            this.updateHistoryPosition(selection.start, false);
        }
    }
    /**
     * @private
     */
    onBackSpace() {
        this.removeEditRange = true;
        let selection = this.viewer.selection;
        this.viewer.triggerSpellCheck = true;
        if (selection.isEmpty) {
            this.singleBackspace(selection, false);
        }
        else {
            this.initHistory('BackSpace');
            let skipBackSpace = this.deleteSelectedContents(selection, true);
            if (this.editorHistory && this.editorHistory.currentBaseHistoryInfo) {
                if (skipBackSpace) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                }
                else {
                    if (this.checkEndPosition(selection)) {
                        this.updateHistoryPosition(selection.end, false);
                    }
                    this.reLayout(selection);
                }
            }
            this.viewer.triggerSpellCheck = false;
        }
        this.removeEditRange = false;
    }
    /**
     * @private
     */
    insertRemoveBookMarkElements() {
        let isHandledComplexHistory = false;
        for (let i = 0; i < this.removedBookmarkElements.length; i++) {
            let bookMark = this.removedBookmarkElements[i];
            if (bookMark.bookmarkType === 0) {
                if (!this.viewer.bookmarks.containsKey(bookMark.name)) {
                    this.viewer.bookmarks.add(bookMark.name, bookMark);
                }
                let bookMarkStart = bookMark;
                if (bookMarkStart && bookMarkStart.reference && this.removedBookmarkElements.indexOf(bookMarkStart.reference) !== -1) {
                    let endIndex = this.removedBookmarkElements.indexOf(bookMarkStart.reference);
                    let startIndex = this.removedBookmarkElements.indexOf(bookMarkStart);
                    this.removedBookmarkElements.splice(endIndex, 1);
                    this.removedBookmarkElements.splice(startIndex, 1);
                }
                else {
                    if (this.editorHistory.currentBaseHistoryInfo) {
                        this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                        this.editorHistory.updateHistory();
                    }
                    this.initInsertInline(bookMarkStart.clone());
                    if (this.editorHistory.currentHistoryInfo) {
                        this.editorHistory.updateComplexHistory();
                        isHandledComplexHistory = true;
                    }
                }
            }
            else {
                let bookMarkEnd = bookMark;
                if (bookMarkEnd && bookMarkEnd.reference && this.removedBookmarkElements.indexOf(bookMarkEnd.reference) !== -1) {
                    let endIndex = this.removedBookmarkElements.indexOf(bookMarkEnd.reference);
                    let startIndex = this.removedBookmarkElements.indexOf(bookMarkEnd);
                    this.removedBookmarkElements.splice(endIndex, 1);
                    this.removedBookmarkElements.splice(startIndex, 1);
                }
                else {
                    if (this.editorHistory.currentBaseHistoryInfo) {
                        this.initComplexHistory(this.editorHistory.currentBaseHistoryInfo.action);
                        this.editorHistory.updateHistory();
                    }
                    this.initInsertInline(bookMarkEnd.clone());
                    if (this.editorHistory.currentHistoryInfo) {
                        this.editorHistory.updateComplexHistory();
                        isHandledComplexHistory = true;
                    }
                }
            }
        }
        this.removedBookmarkElements = [];
        return isHandledComplexHistory;
    }
    /**
     * @private
     */
    deleteSelectedContents(selection, isBackSpace) {
        let skipBackSpace = this.deleteSelectedContentInternal(selection, isBackSpace, selection.start, selection.end);
        let textPosition = selection.getTextPosBasedOnLogicalIndex(selection.editPosition);
        selection.selectContent(textPosition, true);
        return skipBackSpace;
    }
    removeWholeElement(selection) {
        this.initHistory('BackSpace');
        this.deleteSelectedContents(selection, true);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.end, false);
        }
        this.reLayout(selection);
    }
    /**
     * @private
     */
    singleBackspace(selection, isRedoing) {
        let history = this.editorHistory;
        // If backspace is pressed after auto format to hyperlink is done, need to undo auto format.
        if (history && !isRedoing && !history.canRedo() && history.canUndo()) {
            let historyInfo = history.undoStack[history.undoStack.length - 1];
            let startBlockInfo = this.selection.getParagraphInfo(selection.start);
            let endBlockInfo = this.selection.getParagraphInfo(selection.end);
            // tslint:disable-next-line:max-line-length
            if (historyInfo.action === 'AutoFormatHyperlink' && historyInfo.insertPosition === this.selection.getHierarchicalIndex(startBlockInfo.paragraph, startBlockInfo.offset.toString()) &&
                historyInfo.endPosition === this.selection.getHierarchicalIndex(endBlockInfo.paragraph, endBlockInfo.offset.toString())) {
                history.undo();
                return;
            }
        }
        let paragraph = selection.start.paragraph;
        let currentLineWidget = selection.start.currentWidget;
        let offset = selection.start.offset;
        let indexInInline = 0;
        let inlineObj = currentLineWidget.getInline(offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (inline instanceof TextElementBox) {
            inline.ignoreOnceItems = [];
        }
        if (inline instanceof TextElementBox) {
            inline.ignoreOnceItems = [];
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 2) {
            if (HelperMethods.isLinkedFieldCharacter(inline)) {
                let begin = inline.fieldBegin;
                let end = inline.fieldEnd;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                selection.fireSelectionChanged(true);
                return;
            }
        }
        if (inline instanceof FieldElementBox && inline.fieldType === 1) {
            let prevInline = selection.getPreviousValidElement(inline);
            if (prevInline instanceof FieldElementBox) {
                inline = prevInline.fieldBegin;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                selection.end.setPositionParagraph(inline.line, offset); //Selects the entire field.
                selection.fireSelectionChanged(true);
                return;
            }
            else if (prevInline !== inline) {
                inline = prevInline; //Updates the offset to delete next content.
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
        }
        if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
            if ((inline.nextNode instanceof EditRangeEndElementBox && inline.editRangeEnd === inline.nextNode)
                || (inline.previousNode instanceof EditRangeStartElementBox
                    && inline.editRangeStart === inline.previousNode)) {
                return;
            }
            if (inline instanceof EditRangeStartElementBox && !(inline.previousNode instanceof EditRangeEndElementBox)) {
                return;
            }
            if (inline instanceof EditRangeEndElementBox) {
                inline = inline.previousNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
            if (inline.length === 1 && inline.nextNode instanceof EditRangeEndElementBox
                && inline.previousNode instanceof EditRangeStartElementBox) {
                let start = inline.previousNode;
                let end = inline.nextNode;
                selection.start.setPositionParagraph(start.line, start.line.getOffset(start, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.removeWholeElement(selection);
                return;
            }
        }
        if (inline && (inline instanceof BookmarkElementBox && inline.bookmarkType === 1
            || inline.previousNode instanceof BookmarkElementBox)) {
            if (inline instanceof BookmarkElementBox) {
                inline = inline.previousNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, inline.length);
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox && inline.previousNode instanceof BookmarkElementBox) {
                let begin = inline.previousNode;
                let end = inline.nextNode;
                selection.start.setPositionParagraph(begin.line, begin.line.getOffset(begin, 0));
                selection.end.setPositionParagraph(end.line, end.line.getOffset(end, 0) + 1);
                this.removeWholeElement(selection);
                return;
            }
        }
        if (!isRedoing) {
            this.initHistory('BackSpace');
        }
        if (offset === selection.getStartOffset(paragraph) && selection.start.currentWidget.isFirstLine()) {
            if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1) {
                this.onApplyList(undefined);
                return;
            }
            if (paragraph.paragraphFormat.firstLineIndent !== 0) {
                this.onApplyParagraphFormat('firstLineIndent', 0, false, false);
                return;
            }
            if (paragraph.paragraphFormat.leftIndent !== 0) {
                this.onApplyParagraphFormat('leftIndent', 0, false, false);
                return;
            }
            if (paragraph.paragraphFormat.textAlignment !== 'Left') {
                this.onApplyParagraphFormat('textAlignment', 'Left', false, true);
                return;
            }
            if (paragraph.previousRenderedWidget instanceof ParagraphWidget) {
                selection.owner.isShiftingEnabled = true;
                let previousParagraph = paragraph.previousRenderedWidget;
                // if (isNullOrUndefined(previousParagraph)) {
                //     previousParagraph = this.viewer.selection.getPreviousBlock(paragraph) as ParagraphWidget;
                // }
                if (previousParagraph.isEmpty()) {
                    this.removeBlock(previousParagraph);
                    this.addRemovedNodes(previousParagraph);
                }
                else {
                    this.removeBlock(paragraph);
                    let endOffset = this.viewer.selection.getLineLength(previousParagraph.lastChild);
                    let previousIndex = previousParagraph.childWidgets.length - 1;
                    let lineWidget;
                    if (!paragraph.isEmpty()) {
                        for (let i = 0; i < paragraph.childWidgets.length; i++) {
                            lineWidget = paragraph.childWidgets[i];
                            previousParagraph.childWidgets.push(lineWidget);
                            paragraph.childWidgets.splice(i, 1);
                            i--;
                            lineWidget.paragraph = previousParagraph;
                        }
                    }
                    this.viewer.layout.reLayoutParagraph(previousParagraph, previousIndex, 0);
                    selection.selects(previousParagraph.childWidgets[previousIndex], endOffset, true);
                    this.addRemovedNodes(paragraph);
                }
                this.setPositionForHistory();
                // if (!isRedoing) {
                this.reLayout(selection);
                // }
            }
            else {
                if (this.editorHistory) {
                    this.editorHistory.currentBaseHistoryInfo = undefined;
                }
            }
        }
        else {
            if (!isRedoing) {
                selection.owner.isShiftingEnabled = true;
            }
            let paragraphInfo = this.selection.getParagraphInfo(selection.start);
            let lineWidget = selection.start.currentWidget;
            let removeOffset = offset - 1;
            if (removeOffset < 0) {
                lineWidget = lineWidget.previousLine;
                removeOffset = this.viewer.selection.getLineLength(lineWidget) + removeOffset;
            }
            this.removeAtOffset(lineWidget, selection, removeOffset);
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset - 1, false);
            this.setPositionForHistory();
            if (!isRedoing) {
                this.reLayout(selection);
            }
            else {
                this.fireContentChange();
            }
        }
    }
    setPositionForHistory(editPosition) {
        let selection = this.viewer.selection;
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            if (isNullOrUndefined(editPosition)) {
                this.updateHistoryPosition(selection.start, true);
                this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
            }
            else {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = editPosition;
                this.editorHistory.currentBaseHistoryInfo.endPosition = editPosition;
            }
        }
    }
    removeAtOffset(lineWidget, selection, offset) {
        let count = 0;
        let lineIndex = lineWidget.paragraph.childWidgets.indexOf(lineWidget);
        for (let i = 0; i < lineWidget.children.length; i++) {
            let inline = lineWidget.children[i];
            if (inline instanceof ListTextElementBox) {
                continue;
            }
            if (offset < count + inline.length) {
                let indexInInline = offset - count;
                inline.ischangeDetected = true;
                if (this.owner.enableSpellCheck) {
                    this.owner.spellChecker.removeErrorsFromCollection({ 'element': inline, 'text': inline.text });
                }
                if (!inline.canTrigger) {
                    this.viewer.triggerSpellCheck = false;
                }
                if (offset === count && inline.length === 1) {
                    this.unLinkFieldCharacter(inline);
                    lineWidget.children.splice(i, 1);
                    this.viewer.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i);
                    this.addRemovedNodes(inline);
                }
                else {
                    let span = new TextElementBox();
                    span.characterFormat.copyFormat(inline.characterFormat);
                    span.text = inline.text.substr(indexInInline, 1);
                    inline.text = HelperMethods.remove(inline.text, indexInInline, 1);
                    this.viewer.layout.reLayoutParagraph(lineWidget.paragraph, lineIndex, i);
                    this.addRemovedNodes(span);
                }
                break;
            }
            count += inline.length;
        }
    }
    /**
     * Remove the current selected content or one character right of cursor.
     */
    delete() {
        this.removeEditRange = true;
        let selection = this.viewer.selection;
        if (selection.isEmpty) {
            this.singleDelete(selection, false);
        }
        else {
            // this.initComplexHistory('MultiSelection');
            // for (let i: number = 0; i < selection.selectionRanges.length; i++) {
            // let selectionRange: SelectionRange = selection.selectionRanges.getRange(i);
            this.initHistory('Delete');
            this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
            let textPosition = new TextPosition(selection.owner);
            this.setPositionForCurrentIndex(textPosition, selection.editPosition);
            selection.selectContent(textPosition, true);
            // if (this.viewer.owner.enableEditorHistory) {
            this.reLayout(selection);
            // }
            // this.updateSelectionRangeOffSet(selection.start, selection.end);
            // }
            // let textPosition: TextPosition = new TextPosition(selection.owner, this.viewer);
            // this.setPositionForCurrentIndex(textPosition,selection.editPosition);
            // selection.selectContent(textPosition, true);
            // if (!isNullOrUndefined(selection.currentHistoryInfo)) {
            //     this.updateComplexHistory();
            // } else {
            //     this.updateComplexWithoutHistory();
            // }
        }
        this.removeEditRange = false;
    }
    deleteEditElement(selection) {
        this.initHistory('Delete');
        this.deleteSelectedContentInternal(selection, false, selection.start, selection.end);
        let textPosition = new TextPosition(selection.owner);
        this.setPositionForCurrentIndex(textPosition, selection.editPosition);
        selection.selectContent(textPosition, true);
        this.reLayout(selection);
    }
    /**
     * Remove single character on right of cursor position
     * @param  {Selection} selection
     * @param  {boolean} isRedoing
     * @private
     */
    singleDelete(selection, isRedoing) {
        // tslint:disable-next-line:max-line-length
        let paragraph = selection.start.paragraph;
        let offset = selection.start.offset;
        let indexInInline = 0;
        let inlineObj = paragraph.getInline(selection.start.offset, indexInInline);
        let inline = inlineObj.element;
        indexInInline = inlineObj.index;
        if (paragraph.paragraphFormat.listFormat && paragraph.paragraphFormat.listFormat.listId !== -1 &&
            this.viewer.isListTextSelected && selection.contextType === 'List') {
            this.onApplyList(undefined);
            return;
        }
        if (!isNullOrUndefined(inline) && indexInInline === inline.length && !isNullOrUndefined(inline.nextNode)) {
            inline = inline.nextNode;
            indexInInline = 0;
        }
        if (!isNullOrUndefined(inline)) {
            let nextRenderedInline = undefined;
            let nextInline = selection.getNextValidElement(inline);
            if (nextInline instanceof ElementBox) {
                nextRenderedInline = nextInline;
            }
            if (!isNullOrUndefined(nextRenderedInline) && nextRenderedInline instanceof FieldElementBox
                && nextRenderedInline.fieldType === 0) { //Selects the entire field.
                inline = nextRenderedInline.fieldEnd;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 1);
                selection.end.setPositionParagraph(inline.line, offset);
                selection.fireSelectionChanged(true);
                return;
            }
            else if (inline !== nextRenderedInline) { //Updates the offset to delete next content.               
                inline = nextRenderedInline;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
                if (inline instanceof FieldElementBox && inline.fieldType === 1) {
                    offset++;
                }
            }
        }
        if (inline instanceof EditRangeStartElementBox || inline instanceof EditRangeEndElementBox) {
            if ((inline.nextNode instanceof EditRangeEndElementBox && inline.editRangeEnd === inline.nextNode)
                || (inline.previousNode instanceof EditRangeStartElementBox
                    && inline.editRangeStart === inline.previousNode)) {
                return;
            }
            if (inline instanceof EditRangeStartElementBox) {
                inline = inline.nextNode;
                offset = inline.line.getOffset(inline, 0);
                paragraph = inline.line.paragraph;
            }
            if (inline.length === 1 && inline.nextNode instanceof EditRangeEndElementBox
                && inline.previousNode instanceof EditRangeStartElementBox) {
                let editStart = inline.previousNode;
                let editEnd = inline.nextNode;
                selection.start.setPositionParagraph(editStart.line, editStart.line.getOffset(editStart, 0));
                selection.end.setPositionParagraph(editEnd.line, editEnd.line.getOffset(editEnd, 0) + 1);
                this.deleteEditElement(selection);
                return;
            }
        }
        if (inline && (inline instanceof BookmarkElementBox && inline.bookmarkType === 0
            || inline.nextNode instanceof BookmarkElementBox)) {
            if (inline instanceof BookmarkElementBox) {
                inline = inline.nextNode;
                paragraph = inline.line.paragraph;
                offset = inline.line.getOffset(inline, 0);
            }
            if (inline.length === 1 && inline.nextNode instanceof BookmarkElementBox
                && inline.previousNode instanceof BookmarkElementBox) {
                let bookMarkBegin = inline.previousNode;
                let bookMarkEnd = inline.nextNode;
                selection.start.setPositionParagraph(bookMarkBegin.line, bookMarkBegin.line.getOffset(bookMarkBegin, 0));
                selection.end.setPositionParagraph(bookMarkEnd.line, bookMarkEnd.line.getOffset(bookMarkEnd, 0) + 1);
                this.deleteEditElement(selection);
                return;
            }
        }
        if (selection.start.currentWidget.isLastLine() && offset === this.viewer.selection.getLineLength(selection.start.currentWidget)) {
            if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget)) {
                return;
            }
            let previousParagraph = undefined;
            let newParagraph = undefined;
            let nextParagraph = selection.getNextParagraphBlock(paragraph);
            if (isNullOrUndefined(nextParagraph)) {
                if (offset > 0) {
                    return;
                }
                else {
                    if (paragraph.previousWidget instanceof ParagraphWidget) {
                        previousParagraph = paragraph.previousWidget;
                    }
                    if (paragraph.previousWidget instanceof TableWidget) {
                        return;
                    }
                    if (isNullOrUndefined(previousParagraph)) {
                        return;
                        //Adds an empty paragraph, to ensure minimal content.
                    }
                }
            }
            if (!isRedoing) {
                this.initHistory('Delete');
            }
            if (paragraph.isEndsWithPageBreak) {
                let lastLine = paragraph.lastChild;
                let lastChild = lastLine.children[lastLine.children.length - 1];
                this.selection.start.setPositionForSelection(lastLine, lastChild, 0, this.selection.start.location);
            }
            let blockInfo = this.selection.getParagraphInfo(selection.start);
            selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            if (this.checkInsertPosition(selection)) {
                this.setPositionForHistory(selection.editPosition);
            }
            selection.owner.isShiftingEnabled = true;
            if (paragraph.isEmpty()) {
                this.removeBlock(paragraph);
                this.addRemovedNodes(paragraph);
                if (isNullOrUndefined(nextParagraph)) {
                    if (isNullOrUndefined(previousParagraph)) {
                        // selection.selectParagraphInternal(newParagraph, true, true);
                        let paraEndOffset = selection.getParagraphLength(newParagraph) + 1;
                        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
                            this.updateHistoryPosition(selection.start, true);
                            //tslint:disable-next-line:max-line-length
                            this.editorHistory.currentBaseHistoryInfo.endPosition = this.selection.getHierarchicalIndex(newParagraph, paraEndOffset.toString());
                        }
                    }
                    else {
                        selection.selectParagraphInternal(previousParagraph, false);
                        this.setPositionForHistory();
                    }
                }
                else {
                    selection.selectParagraphInternal(nextParagraph, true);
                }
            }
            else {
                paragraph = paragraph.combineWidget(this.viewer);
                // tslint:disable-next-line:max-line-length
                let currentParagraph = this.splitParagraph(paragraph, paragraph.firstChild, 0, selection.start.currentWidget, selection.start.offset, true);
                this.deleteParagraphMark(currentParagraph, selection, 0);
                this.addRemovedNodes(paragraph);
                this.setPositionForCurrentIndex(selection.start, selection.editPosition);
                selection.selectContent(selection.start, true);
            }
            // if (!isRedoing) {
            this.reLayout(selection);
            // }
        }
        else {
            this.singleDeleteInternal(selection, isRedoing, paragraph);
        }
    }
    singleDeleteInternal(selection, isRedoing, paragraph) {
        if (!isRedoing) {
            selection.owner.isShiftingEnabled = true;
            this.initHistory('Delete');
        }
        if (this.checkInsertPosition(selection)) {
            this.updateHistoryPosition(selection.start, true);
            this.editorHistory.currentBaseHistoryInfo.endPosition = this.editorHistory.currentBaseHistoryInfo.insertPosition;
        }
        let paragraphInfo = this.selection.getParagraphInfo(selection.start);
        let lineWidget = selection.start.currentWidget;
        let removeOffset = selection.start.offset;
        let lineLength = selection.getLineLength(selection.start.currentWidget);
        if (removeOffset >= lineLength) {
            lineWidget = lineWidget.nextLine;
            removeOffset = removeOffset - lineLength;
        }
        this.removeAtOffset(lineWidget, selection, removeOffset);
        this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset, false);
        if (!isRedoing) {
            this.reLayout(selection);
        }
        else {
            this.fireContentChange();
        }
    }
    deleteParagraphMark(paragraph, selection, editAction) {
        if (isNullOrUndefined(paragraph.containerWidget)) {
            return;
        }
        paragraph = paragraph.combineWidget(this.viewer);
        let nextParagraph = selection.getNextParagraphBlock(paragraph);
        if (paragraph.isInsideTable && isNullOrUndefined(paragraph.nextWidget) || isNullOrUndefined(nextParagraph)) {
            return;
        }
        //BodyWidget
        let section = paragraph.containerWidget instanceof BodyWidget ? paragraph.containerWidget : undefined;
        let table = undefined;
        if (selection.getNextRenderedBlock(paragraph) instanceof TableWidget) {
            table = selection.getNextRenderedBlock(paragraph);
        }
        else {
            table = undefined;
        }
        if (nextParagraph.isInsideTable && !isNullOrUndefined(table) && table.contains(nextParagraph.associatedCell)) {
            if (editAction < 4) {
                // let nextSection: BodyWidget = table.containerWidget instanceof BodyWidget ? table.containerWidget : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }                
                let offset = 0;
                this.removeBlock(paragraph);
                this.viewer.layout.clearListElementBox(nextParagraph);
                this.viewer.layout.clearListElementBox(paragraph);
                for (let i = paragraph.childWidgets.length - 1; i >= 0; i--) {
                    let line = paragraph.childWidgets[i];
                    for (let j = line.children.length - 1; j >= 0; j--) {
                        let element = line.children[j];
                        offset += element.length;
                        nextParagraph.firstChild.children.unshift(element);
                        element.line = nextParagraph.firstChild;
                        // this.layoutInlineCollection(false, 0, nextParagraph.inlines, inline);
                    }
                }
                this.viewer.layout.reLayoutParagraph(nextParagraph, 0, 0);
                if (offset > 0) {
                    selection.editPosition = this.selection.getHierarchicalIndex(nextParagraph, offset.toString());
                }
            }
        }
        else {
            if (editAction < 4) {
                // let nextSection: WSection = nextParagraph.section instanceof WSection ? nextParagraph.section as WSection : undefined;
                // if (section !== nextSection) {
                //     this.combineSection(section, selection, nextSection);
                // }
                let prevLength = paragraph.childWidgets.length - 1;
                let nextPara = nextParagraph.getSplitWidgets();
                nextParagraph = nextParagraph.combineWidget(this.viewer);
                this.viewer.layout.clearListElementBox(nextParagraph);
                this.viewer.layout.clearListElementBox(paragraph);
                this.updateEditPositionOnMerge(paragraph, nextParagraph);
                for (let i = 0; i < nextParagraph.childWidgets.length; i++) {
                    let inline = nextParagraph.childWidgets[i];
                    nextParagraph.childWidgets.splice(i, 1);
                    paragraph.childWidgets.push(inline);
                    inline.paragraph = paragraph;
                    i--;
                }
                if (nextParagraph.childWidgets.length === 0) {
                    nextParagraph.childWidgets.push(new LineWidget(nextParagraph));
                }
                this.removeBlock(nextParagraph);
                this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
                this.addRemovedNodes(nextParagraph);
            }
        }
    }
    updateEditPositionOnMerge(currentParagraph, nextParagraph) {
        if (this.viewer.selection.editPosition === this.selection.getHierarchicalIndex(nextParagraph, '0') &&
            nextParagraph.nextRenderedWidget === undefined) {
            // tslint:disable-next-line:max-line-length
            this.viewer.selection.editPosition = this.selection.getHierarchicalIndex(currentParagraph, this.viewer.selection.getLineLength(currentParagraph.lastChild).toString());
        }
    }
    checkEndPosition(selection) {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.endPosition));
    }
    checkInsertPosition(selection) {
        return (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)
            && isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo.insertPosition));
    }
    checkIsNotRedoing() {
        return this.viewer.owner.enableHistoryMode && !this.editorHistory.isRedoing;
    }
    // tslint:disable-next-line:max-line-length
    deleteSelectedContentInternal(selection, isBackSpace, startPosition, endPosition) {
        let startPos = startPosition;
        let endPos = endPosition;
        if (!startPosition.isExistBefore(endPosition)) {
            startPos = endPosition;
            endPos = startPosition;
        }
        let blockInfo = this.selection.getParagraphInfo(startPos);
        selection.editPosition = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        let skipBackSpace = false;
        if (isBackSpace && startPos.isInSameParagraph(endPos)) {
            //Handled specifically to skip removal of contents, if selection is only paragraph mark and next rendered block is table.
            if (startPos.offset < endPos.offset && startPos.offset === selection.getParagraphLength(endPos.paragraph)) {
                let nextBlock = selection.getNextRenderedBlock(startPos.paragraph);
                skipBackSpace = nextBlock instanceof TableWidget;
            }
            //Handled specifically to remove paragraph completely (Delete behavior), if the selected paragraph is empty.
            if (endPos.offset === 1 && endPos.offset > selection.getParagraphLength(endPos.paragraph)
                && !(endPos.paragraph.isInsideTable && isNullOrUndefined(endPos.paragraph.nextWidget))) {
                isBackSpace = false;
            }
        }
        if (!skipBackSpace) {
            selection.owner.isShiftingEnabled = true;
            if (this.checkInsertPosition(selection)) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = selection.editPosition;
            }
            let editAction = (isBackSpace ? 1 : 0);
            this.deleteSelectedContent(endPos.paragraph, selection, startPos, endPos, editAction);
        }
        return skipBackSpace;
    }
    /**
     * Init EditorHistory
     * @private
     */
    initHistory(action) {
        if (this.viewer.owner.enableHistoryMode) {
            this.editorHistory.initializeHistory(action);
        }
    }
    /**
     * Init Complex EditorHistory
     * @private
     */
    initComplexHistory(action) {
        if (this.viewer.owner.enableHistoryMode) {
            this.editorHistory.initComplexHistory(this.viewer.selection, action);
        }
    }
    //Insert Picture implementation starts
    /**
     * Insert image
     * @param  {string} base64String
     * @param  {number} width
     * @param  {number} height
     * @private
     */
    insertPicture(base64String, width, height) {
        let imageElementBox = new ImageElementBox(true);
        imageElementBox.imageString = base64String;
        imageElementBox.width = width;
        imageElementBox.height = height;
        this.insertPictureInternal(imageElementBox);
    }
    insertPictureInternal(imageElementBox) {
        let selection = this.viewer.selection;
        this.initHistory('InsertInline');
        this.fitImageToPage(selection, imageElementBox);
        this.insertInlineInSelection(selection, imageElementBox);
        this.reLayout(selection);
    }
    fitImageToPage(selection, imageElementBox) {
        let section = selection.start.paragraph.bodyWidget;
        let pageWidth = section.sectionFormat.pageWidth - section.sectionFormat.leftMargin - section.sectionFormat.rightMargin;
        let pageHeight = section.sectionFormat.pageHeight - section.sectionFormat.topMargin - section.sectionFormat.topMargin;
        //Resizes image to page size.
        if (imageElementBox.width > pageWidth) {
            imageElementBox.height = imageElementBox.height * pageWidth / imageElementBox.width;
            imageElementBox.width = pageWidth;
        }
        if (imageElementBox.height > pageHeight) {
            imageElementBox.width = imageElementBox.width * pageHeight / imageElementBox.height;
            imageElementBox.height = pageHeight;
        }
    }
    //Insert Picture implementation ends
    /**
     * @private
     */
    insertInlineInSelection(selection, elementBox) {
        if (this.checkIsNotRedoing()) {
            selection.owner.isShiftingEnabled = true;
        }
        if (!selection.isEmpty) {
            this.removeSelectedContents(selection);
        }
        this.updateInsertPosition();
        this.insertInlineInternal(elementBox);
        if (this.checkEndPosition(selection)) {
            this.updateHistoryPosition(selection.start, false);
        }
        this.fireContentChange();
    }
    /**
     * @private
     */
    onPortrait() {
        let sectionFormat = new WSectionFormat();
        let width = this.viewer.selection.sectionFormat.pageWidth;
        let height = this.viewer.selection.sectionFormat.pageHeight;
        if (width > height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    /**
     * @private
     */
    onLandscape() {
        let sectionFormat = new WSectionFormat();
        let width = this.viewer.selection.sectionFormat.pageWidth;
        let height = this.viewer.selection.sectionFormat.pageHeight;
        if (width < height) {
            sectionFormat.pageWidth = height;
            sectionFormat.pageHeight = width;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    copyValues() {
        let format = new WSectionFormat();
        format.bottomMargin = this.viewer.selection.sectionFormat.bottomMargin;
        format.topMargin = this.viewer.selection.sectionFormat.topMargin;
        format.leftMargin = this.viewer.selection.sectionFormat.leftMargin;
        format.rightMargin = this.viewer.selection.sectionFormat.rightMargin;
        format.pageHeight = this.viewer.selection.sectionFormat.pageHeight;
        format.pageWidth = this.viewer.selection.sectionFormat.pageWidth;
        format.footerDistance = this.viewer.selection.sectionFormat.footerDistance;
        format.headerDistance = this.viewer.selection.sectionFormat.headerDistance;
        return format;
    }
    /**
     * @private
     */
    changeMarginValue(property) {
        let sectionFormat = this.copyValues();
        if (property === 'lastCustomSetting' || property === 'normal') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 72;
            sectionFormat.rightMargin = 72;
        }
        else if (property === 'narrow') {
            sectionFormat.topMargin = 36;
            sectionFormat.bottomMargin = 36;
            sectionFormat.leftMargin = 36;
            sectionFormat.rightMargin = 36;
        }
        else if (property === 'moderate') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 54;
            sectionFormat.rightMargin = 54;
        }
        else if (property === 'wide') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 144;
            sectionFormat.rightMargin = 144;
        }
        else if (property === 'mirrored') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 72;
        }
        else if (property === 'office2003Default') {
            sectionFormat.topMargin = 72;
            sectionFormat.bottomMargin = 72;
            sectionFormat.leftMargin = 90;
            sectionFormat.rightMargin = 90;
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    /**
     * @private
     */
    onPaperSize(property) {
        let sectionFormat = this.copyValues();
        let width = this.viewer.selection.sectionFormat.pageWidth;
        let height = this.viewer.selection.sectionFormat.pageHeight;
        if (property === 'letter') {
            if (width < height) {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 791.9;
            }
            else {
                sectionFormat.pageWidth = 791.9;
                sectionFormat.pageHeight = 611.9;
            }
        }
        else if (property === 'tabloid') {
            if (width < height) {
                sectionFormat.pageWidth = 791.9;
                sectionFormat.pageHeight = 1223.9;
            }
            else {
                sectionFormat.pageWidth = 1223.9;
                sectionFormat.pageHeight = 791.9;
            }
        }
        else if (property === 'legal') {
            if (width < height) {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 1007.9;
            }
            else {
                sectionFormat.pageWidth = 1007.9;
                sectionFormat.pageHeight = 611.9;
            }
        }
        else if (property === 'statement') {
            if (width < height) {
                sectionFormat.pageWidth = 396;
                sectionFormat.pageHeight = 611.9;
            }
            else {
                sectionFormat.pageWidth = 611.9;
                sectionFormat.pageHeight = 396;
            }
        }
        else if (property === 'executive') {
            if (width < height) {
                sectionFormat.pageWidth = 521.9;
                sectionFormat.pageHeight = 755.9;
            }
            else {
                sectionFormat.pageWidth = 755.9;
                sectionFormat.pageHeight = 521.9;
            }
        }
        else if (property === 'a3') {
            if (width < height) {
                sectionFormat.pageWidth = 841.8;
                sectionFormat.pageHeight = 1190.4;
            }
            else {
                sectionFormat.pageWidth = 1190.4;
                sectionFormat.pageHeight = 841.8;
            }
        }
        else if (property === 'a4') {
            if (width < height) {
                sectionFormat.pageWidth = 595.2;
                sectionFormat.pageHeight = 841.8;
            }
            else {
                sectionFormat.pageWidth = 841.8;
                sectionFormat.pageHeight = 595.2;
            }
        }
        else if (property === 'a5') {
            if (width < height) {
                sectionFormat.pageWidth = 419.5;
                sectionFormat.pageHeight = 595.2;
            }
            else {
                sectionFormat.pageWidth = 595.2;
                sectionFormat.pageHeight = 419.5;
            }
        }
        else if (property === 'b4') {
            if (width < height) {
                sectionFormat.pageWidth = 728.4;
                sectionFormat.pageHeight = 1031.7;
            }
            else {
                sectionFormat.pageWidth = 1031.7;
                sectionFormat.pageHeight = 728.4;
            }
        }
        else if (property === 'b5') {
            if (width < height) {
                sectionFormat.pageWidth = 515.8;
                sectionFormat.pageHeight = 728.4;
            }
            else {
                sectionFormat.pageWidth = 728.4;
                sectionFormat.pageHeight = 515.8;
            }
        }
        this.onApplySectionFormat(undefined, sectionFormat);
    }
    //Update List Items
    /**
     * @private
     */
    updateListItemsTillEnd(blockAdv, updateNextBlockList) {
        let block = updateNextBlockList ? this.viewer.selection.getNextRenderedBlock(blockAdv) : blockAdv;
        while (!isNullOrUndefined(block) && !this.viewer.isTextInput) {
            //Updates the list value of the rendered paragraph. 
            this.updateRenderedListItems(block);
            block = block.getSplitWidgets().pop().nextRenderedWidget;
        }
    }
    /**
     * @private
     */
    updateWholeListItems(block) {
        this.viewer.renderedLists.clear();
        let sectionIndex = block.bodyWidget.index;
        let currentBlock;
        for (let j = 0; j < this.viewer.pages.length; j++) {
            let page = this.viewer.pages[j];
            if (page.bodyWidgets[0].index === sectionIndex) {
                currentBlock = page.bodyWidgets[0].firstChild;
                if (!isNullOrUndefined(currentBlock)) {
                    break;
                }
            }
        }
        let isListUpdated = false;
        do {
            isListUpdated = this.updateListItems(currentBlock, block);
            if (isListUpdated) {
                break;
            }
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    }
    updateListItems(blockAdv, block) {
        let isListUpdated = false;
        if (blockAdv instanceof ParagraphWidget) {
            isListUpdated = this.updateListItemsForPara(blockAdv, block);
        }
        else {
            isListUpdated = this.updateListItemsForTable(blockAdv, block);
        }
        return isListUpdated;
    }
    updateListItemsForTable(table, block) {
        if (block instanceof TableWidget && table.equals(block)) {
            return true;
        }
        let row = table.firstChild;
        do {
            let isListUpdated = this.updateListItemsForRow(row, block);
            if (isListUpdated) {
                return true;
            }
            row = row.getSplitWidgets().pop().nextRenderedWidget;
        } while (row);
        return false;
    }
    updateListItemsForRow(row, block) {
        if (block.isInsideTable && row.childWidgets.indexOf(this.viewer.selection.getContainerCell(block.associatedCell)) !== -1) {
            //Returns as list updated, inorder to start list numbering from first list paragraph of this row.
            return true;
        }
        let cell = row.firstChild;
        do {
            this.updateListItemsForCell(cell, block);
            cell = cell.nextRenderedWidget;
        } while (cell);
        return false;
    }
    updateListItemsForCell(cell, block) {
        if (cell.childWidgets.length === 0) {
            return;
        }
        let currentBlock = cell.firstChild;
        do {
            this.updateListItems(currentBlock, block);
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    }
    // public abstract updateListParagraphs(): void;
    /**
     * @private
     */
    updateRenderedListItems(block) {
        if (block instanceof ParagraphWidget) {
            this.updateRenderedListItemsForPara(block);
        }
        else {
            this.updateRenderedListItemsForTable(block);
        }
    }
    updateRenderedListItemsForTable(table) {
        let row = table.firstChild;
        do {
            this.updateRenderedListItemsForRow(row);
            row = row.getSplitWidgets().pop().nextRenderedWidget;
        } while (row);
    }
    updateRenderedListItemsForRow(row) {
        let cell = row.firstChild;
        do {
            this.updateRenderedListItemsForCell(cell);
            cell = cell.nextRenderedWidget;
        } while (cell);
    }
    updateRenderedListItemsForCell(cell) {
        if (cell.childWidgets.length === 0) {
            return;
        }
        let currentBlock = cell.firstChild;
        do {
            this.updateRenderedListItems(currentBlock);
            currentBlock = currentBlock.getSplitWidgets().pop().nextRenderedWidget;
        } while (currentBlock);
    }
    updateListItemsForPara(paragraph, block) {
        if (paragraph.equals(block)) {
            return true;
        }
        else {
            let currentList = undefined;
            let listLevelNumber = 0;
            if (!isNullOrUndefined(paragraph.paragraphFormat) && !isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
                currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
                listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
            }
            // tslint:disable-next-line:max-line-length
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
                // tslint:disable-next-line:max-line-length
                && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels[listLevelNumber])) {
                let currentListLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
                //Updates the list numbering from document start for reLayouting.
                if (currentListLevel.listLevelPattern !== 'Bullet') {
                    this.viewer.layout.getListNumber(paragraph.paragraphFormat.listFormat);
                }
            }
        }
        return false;
    }
    updateRenderedListItemsForPara(paragraph) {
        if (!isNullOrUndefined(this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId))) {
            let currentList = this.viewer.getListById(paragraph.paragraphFormat.listFormat.listId);
            let listLevelNumber = paragraph.paragraphFormat.listFormat.listLevelNumber;
            if (!isNullOrUndefined(currentList) && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId))
                // tslint:disable-next-line:max-line-length
                && !isNullOrUndefined(this.viewer.getAbstractListById(currentList.abstractListId).levels[paragraph.paragraphFormat.listFormat.listLevelNumber])) {
                let currentListLevel = this.viewer.layout.getListLevel(currentList, listLevelNumber);
                //Updates the list numbering from document start for reLayouting.
                if (currentListLevel.listLevelPattern !== 'Bullet') {
                    let element = undefined;
                    if (paragraph.childWidgets.length > 0) {
                        let lineWidget = paragraph.childWidgets[0];
                        if (lineWidget.children.length > 0) {
                            if (paragraph.paragraphFormat.bidi) {
                                element = lineWidget.children[lineWidget.children.length - 1];
                            }
                            else {
                                element = lineWidget.children[0];
                            }
                        }
                    }
                    if (!isNullOrUndefined(element)) {
                        element.text = this.viewer.layout.getListNumber(paragraph.paragraphFormat.listFormat);
                    }
                }
            }
        }
    }
    /**
     * Get offset value to update in selection
     * @private
     */
    getOffsetValue(selection) {
        if (this.startParagraph) {
            let lineInfo = selection.getLineInfoBasedOnParagraph(this.startParagraph, this.startOffset);
            selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        }
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            if (this.endParagraph) {
                let lineInfo = selection.getLineInfoBasedOnParagraph(this.endParagraph, this.endOffset);
                selection.end.setPositionFromLine(lineInfo.line, lineInfo.offset);
            }
            selection.end.updatePhysicalPosition(true);
        }
    }
    /**
     * @private
     */
    setPositionParagraph(paragraph, offset, skipSelectionChange) {
        let selection = this.viewer.selection;
        let lineInfo = selection.getLineInfoBasedOnParagraph(paragraph, offset);
        selection.start.setPositionFromLine(lineInfo.line, lineInfo.offset);
        selection.end.setPositionInternal(selection.start);
        if (!skipSelectionChange) {
            selection.fireSelectionChanged(true);
        }
    }
    /**
     * @private
     */
    setPositionForCurrentIndex(textPosition, editPosition) {
        let blockInfo = this.selection.getParagraph({ index: editPosition });
        let lineInfo = this.selection.getLineInfoBasedOnParagraph(blockInfo.paragraph, blockInfo.offset);
        textPosition.setPositionForLineWidget(lineInfo.line, lineInfo.offset);
    }
    /**
     * @private
     */
    insertPageNumber(numberFormat) {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        }
        else {
            numberFormat = ' \\*' + numberFormat;
        }
        let fieldCode = 'PAGE ' + numberFormat + ' \\* MERGEFORMAT';
        this.createFields(fieldCode);
    }
    /**
     * @private
     */
    insertPageCount(numberFormat) {
        if (isNullOrUndefined(numberFormat)) {
            numberFormat = '';
        }
        else {
            numberFormat = ' \*' + numberFormat;
        }
        let fieldCode = 'NUMPAGES ' + numberFormat + ' \* MERGEFORMAT';
        this.createFields(fieldCode);
    }
    createFields(fieldCode) {
        let paragraph = new ParagraphWidget();
        let line = new LineWidget(paragraph);
        let fieldBegin = new FieldElementBox(0);
        line.children.push(fieldBegin);
        let fieldtext = new FieldTextElementBox();
        fieldtext.fieldBegin = fieldBegin;
        fieldtext.text = '1';
        let text = new TextElementBox();
        text.text = fieldCode;
        line.children.push(text);
        let fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldBegin.fieldSeparator = fieldSeparator;
        line.children.push(fieldSeparator);
        line.children.push(fieldtext);
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldSeparator = fieldSeparator;
        fieldSeparator.fieldEnd = fieldEnd;
        fieldBegin.fieldEnd = fieldEnd;
        line.children.push(fieldEnd);
        fieldBegin.line = line;
        paragraph.childWidgets.push(line);
        let widgets = [];
        widgets.push(paragraph);
        this.viewer.fields.push(fieldBegin);
        this.pasteContentsInternal(widgets);
    }
    /**
     * Insert Bookmark at current selection range
     * @param  {string} name - Name of bookmark
     */
    insertBookmark(name) {
        let bookmark = new BookmarkElementBox(0);
        bookmark.name = name;
        let bookmarkEnd = new BookmarkElementBox(1);
        bookmarkEnd.name = name;
        bookmark.reference = bookmarkEnd;
        bookmarkEnd.reference = bookmark;
        this.viewer.bookmarks.add(name, bookmark);
        this.initComplexHistory('InsertBookmark');
        this.insertElements([bookmarkEnd], [bookmark]);
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        this.selection.start.setPositionForSelection(bookmark.line, bookmark, 1, this.selection.start.location);
        this.selection.end.setPositionForSelection(bookmarkEnd.line, bookmarkEnd, 0, this.selection.end.location);
        this.selection.fireSelectionChanged(true);
        this.fireContentChange();
    }
    /**
     * @private
     */
    deleteBookmark(bookmarkName) {
        let bookmarks = this.viewer.bookmarks;
        let bookmark = bookmarks.get(bookmarkName);
        if (bookmark instanceof BookmarkElementBox) {
            let bookmarkEnd = bookmark.reference;
            this.initHistory('DeleteBookmark');
            if (this.editorHistory) {
                this.editorHistory.currentBaseHistoryInfo.setBookmarkInfo(bookmark);
                this.editorHistory.updateHistory();
            }
            this.deleteBookmarkInternal(bookmark);
        }
        this.fireContentChange();
    }
    /**
     * @private
     */
    deleteBookmarkInternal(bookmark) {
        this.viewer.bookmarks.remove(bookmark.name);
        bookmark.line.children.splice(bookmark.indexInOwner, 1);
        bookmark.reference.line.children.splice(bookmark.reference.indexInOwner, 1);
    }
    /**
     * @private
     */
    getSelectionInfo() {
        let start = this.selection.start;
        let end = this.selection.end;
        let isEmpty = this.selection.isEmpty;
        if (!this.selection.isForward) {
            start = this.selection.end;
            end = this.selection.start;
        }
        let startElementInfo = start.currentWidget.getInline(start.offset, 0);
        let endElementInfo = end.currentWidget.getInline(end.offset, 0);
        if (!(end.offset === this.selection.getLineLength(end.currentWidget) + 1
            && this.selection.isParagraphLastLine(end.currentWidget))) {
            end.offset += 1;
        }
        // tslint:disable-next-line:max-line-length
        return { 'start': start.clone(), 'end': end.clone(), 'startElementInfo': startElementInfo, 'endElementInfo': endElementInfo, 'isEmpty': isEmpty };
    }
    /**
     * @private
     */
    insertElements(endElements, startElements) {
        let info = this.getSelectionInfo();
        if (!isNullOrUndefined(startElements)) {
            this.insertElementsInternal(info.start, startElements);
        }
        if (!isNullOrUndefined(endElements)) {
            this.insertElementsInternal(info.end, endElements);
        }
    }
    /**
     * @private
     */
    insertElementsInternal(position, elements) {
        this.selection.selectPosition(position, position);
        this.initHistory('InsertElements');
        this.updateInsertPosition();
        let indexInInline = 0;
        let paragraphInfo = this.selection.getParagraphInfo(this.selection.start);
        if (this.selection.start.paragraph.isEmpty()) {
            let paragraph = this.selection.start.paragraph;
            paragraph.childWidgets[0].children.push(elements[0]);
            elements[0].line = paragraph.childWidgets[0];
            elements[0].linkFieldCharacter(this.viewer);
            this.viewer.layout.reLayoutParagraph(paragraph, 0, 0);
            this.setPositionParagraph(paragraphInfo.paragraph, paragraphInfo.offset + length, true);
            position.setPositionForSelection(elements[0].line, elements[0], elements[0].length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        }
        else {
            let inlineObj = this.selection.start.currentWidget.getInline(this.viewer.selection.start.offset, indexInInline);
            let curInline = inlineObj.element;
            indexInInline = inlineObj.index;
            let firstElement = elements[0];
            this.insertElementInternal(curInline, firstElement, indexInInline, true);
            let index = firstElement.indexInOwner;
            let lastElement = firstElement;
            for (let i = 1; i < elements.length; i++) {
                lastElement = elements[i];
                firstElement.line.children.splice(index + i, 0, lastElement);
            }
            position.setPositionForSelection(lastElement.line, lastElement, lastElement.length, this.selection.start.location);
            this.selection.selectPosition(position, position);
        }
        if (this.editorHistory) {
            if (this.checkEndPosition()) {
                this.updateHistoryPosition(this.selection.start, false);
            }
            this.editorHistory.updateHistory();
        }
    }
    /**
     * @private
     */
    getCommentElementBox(index) {
        let position = index.split(';');
        let comment = this.viewer.comments[parseInt(position[1], 10)];
        if (position.length > 2 && position[2] !== '') {
            return comment.replyComments[parseInt(position[2], 10)];
        }
        return comment;
    }
    /**
     * @private
     */
    getBlock(position) {
        let bodyWidget = this.selection.getBodyWidget(position);
        return this.getBlockInternal(bodyWidget, position);
    }
    /**
     * Return Block relative to position
     * @private
     */
    getBlockInternal(widget, position) {
        if (position.index === '' || isNullOrUndefined(position)) {
            return undefined;
        }
        let index = position.index.indexOf(';');
        let value = position.index.substring(0, index);
        position.index = position.index.substring(index).replace(';', '');
        let node = widget;
        // if (node instanceof WSection && value === 'HF') {
        //     //Gets the block in Header footers.
        //     let blockObj: BlockInfo = this.getBlock((node as WSection).headerFooters, position);
        // tslint:disable-next-line:max-line-length
        //     return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
        // }
        index = parseInt(value, 10);
        let childWidget = this.selection.getBlockByIndex(widget, index);
        if (childWidget) {
            let child = childWidget;
            if (position.index.indexOf(';') >= 0) {
                if (child instanceof ParagraphWidget) {
                    if (position.index.indexOf(';') >= 0) {
                        position.index = '0';
                    }
                    return { 'node': child, 'position': position };
                }
                if (child instanceof Widget) {
                    let blockObj = this.getBlockInternal(child, position);
                    // tslint:disable-next-line:max-line-length
                    return { 'node': (!isNullOrUndefined(blockObj)) ? blockObj.node : undefined, 'position': (!isNullOrUndefined(blockObj)) ? blockObj.position : undefined };
                }
            }
            else {
                return { 'node': child, 'position': position };
            }
        }
        else {
            return { 'node': node, 'position': position };
        }
        return { 'node': node, 'position': position };
    }
    /**
     * @private
     */
    updateHistoryPosition(position, isInsertPosition) {
        if (this.editorHistory && !isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            let hierarchicalIndex;
            if (position instanceof TextPosition) {
                let blockInfo = this.selection.getParagraphInfo(position);
                hierarchicalIndex = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
            }
            else {
                hierarchicalIndex = position;
            }
            if (isInsertPosition) {
                this.editorHistory.currentBaseHistoryInfo.insertPosition = hierarchicalIndex;
            }
            else {
                this.editorHistory.currentBaseHistoryInfo.endPosition = hierarchicalIndex;
            }
        }
    }
    /**
     * Applies the borders based on given settings.
     * @param {BorderSettings} settings
     */
    applyBorders(settings) {
        this.initHistory('Borders');
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        let table = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        if (this.editorHistory) {
            let clonedTable = this.cloneTableToHistoryInfo(table);
        }
        let startCell = startPos.paragraph.associatedCell;
        let endCell = endPos.paragraph.associatedCell;
        let cells;
        let border = this.getBorder(settings.borderColor, settings.lineWidth, settings.borderStyle);
        if (this.selection.isEmpty) {
            //Apply borders for current selected cell initially.                    
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'LeftBorder') {
                endCell.cellFormat.borders.left.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'TopBorder') {
                endCell.cellFormat.borders.top.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'RightBorder') {
                endCell.cellFormat.borders.right.copyFormat(border);
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'AllBorders' ||
                settings.type === 'BottomBorder') {
                endCell.cellFormat.borders.bottom.copyFormat(border);
            }
            if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                || settings.type === 'InsideVerticalBorder') {
                endCell.cellFormat.borders.vertical.copyFormat(border);
            }
            if (settings.type === 'AllBorders' || settings.type === 'InsideBorders'
                || settings.type === 'InsideHorizontalBorder') {
                endCell.cellFormat.borders.horizontal.copyFormat(border);
            }
            if (settings.type === 'NoBorder') {
                this.clearAllBorderValues(endCell.cellFormat.borders);
            }
        }
        else {
            if (settings.type === 'OutsideBorders' || settings.type === 'TopBorder') {
                let selectedCell = this.getTopBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.top.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'LeftBorder') {
                let selectedCell = this.getLeftBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.left.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'RightBorder') {
                let selectedCell = this.getRightBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.right.copyFormat(border);
                }
            }
            if (settings.type === 'OutsideBorders' || settings.type === 'BottomBorder') {
                let selectedCell = this.getBottomBorderCellsOnSelection();
                for (let i = 0; i < selectedCell.length; i++) {
                    selectedCell[i].cellFormat.borders.bottom.copyFormat(border);
                }
            }
        }
        //Apply Only borders property to selected cells      
        if (settings.type === 'BottomBorder' || settings.type === 'AllBorders' || settings.type === 'OutsideBorders'
            || settings.type === 'NoBorder') {
            cells = this.getAdjacentCellToApplyBottomBorder();
            for (let i = 0; i < cells.length; i++) {
                let cell = cells[i];
                if (settings.type === 'NoBorder') {
                    cell.cellFormat.borders.top.copyFormat(this.clearBorder());
                }
                else {
                    cell.cellFormat.borders.top.copyFormat(border);
                }
            }
        }
        if (settings.type === 'AllBorders' || settings.type === 'OutsideBorders' || settings.type === 'RightBorder'
            || settings.type === 'NoBorder') {
            cells = this.getAdjacentCellToApplyRightBorder();
            for (let i = 0; i < cells.length; i++) {
                let cell = cells[i];
                if (settings.type === 'NoBorder') {
                    cell.cellFormat.borders.left.copyFormat(this.clearBorder());
                }
                else {
                    cell.cellFormat.borders.left.copyFormat(border);
                }
            }
        }
        if (settings.type === 'AllBorders' || settings.type === 'NoBorder') {
            this.applyAllBorders(border, settings.type);
        }
        if (settings.type === 'InsideBorders' || settings.type === 'InsideVerticalBorder'
            || settings.type === 'InsideHorizontalBorder' || settings.type === 'NoBorder') {
            this.applyInsideBorders(border, settings.type, table);
        }
        this.updateGridForTableDialog(table, false);
        this.reLayout(this.selection, false);
        this.editorHistory.updateHistory();
    }
    applyAllBorders(border, borderType) {
        let cells = this.selection.getSelectedCells();
        for (let i = 0; i < cells.length; i++) {
            if (borderType === 'NoBorder') {
                cells[i].cellFormat.borders.left.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.right.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.top.copyFormat(this.clearBorder());
                cells[i].cellFormat.borders.bottom.copyFormat(this.clearBorder());
            }
            else {
                cells[i].cellFormat.borders.left.copyFormat(border);
                cells[i].cellFormat.borders.right.copyFormat(border);
                cells[i].cellFormat.borders.top.copyFormat(border);
                cells[i].cellFormat.borders.bottom.copyFormat(border);
            }
        }
    }
    applyInsideBorders(border, borderType, table) {
        let cells = this.selection.getSelectedCells();
        for (let i = 0; i < cells.length; i++) {
            let cell = cells[i];
            let isLastSelectedRow = cell.ownerRow === cells[cells.length - 1].ownerRow;
            let isLastRightCell = (cell.columnIndex + cell.cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex;
            if (borderType === 'NoBorder') {
                cell.cellFormat.borders.right.copyFormat(this.clearBorder());
                cell.cellFormat.borders.bottom.copyFormat(this.clearBorder());
            }
            else {
                if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                    cell.cellFormat.borders.right.copyFormat(border);
                }
                if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                    cell.cellFormat.borders.bottom.copyFormat(border);
                }
            }
            if (!isLastSelectedRow && borderType !== 'InsideVerticalBorder') {
                // Apply adjacent bottom borders.
                let nextRowIndex = cell.ownerRow.rowIndex + cell.cellFormat.rowSpan;
                let nextRow = table.childWidgets[nextRowIndex];
                if (nextRow) {
                    let selectedCells = this.getAdjacentBottomBorderOnEmptyCells(nextRow, cell, true);
                    for (let j = 0; j < selectedCells.length; j++) {
                        if (borderType === 'NoBorder') {
                            selectedCells[j].cellFormat.borders.top.copyFormat(this.clearBorder());
                        }
                        else {
                            selectedCells[j].cellFormat.borders.top.copyFormat(border);
                        }
                    }
                }
            }
            if (!isLastRightCell && borderType !== 'InsideHorizontalBorder') {
                // Apply adjacent right borders.
                let rightBorderCells = this.getSelectedCellsNextWidgets(cell, table);
                for (let k = 0; k < rightBorderCells.length; k++) {
                    if (borderType === 'NoBorder') {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(this.clearBorder());
                    }
                    else {
                        rightBorderCells[k].cellFormat.borders.left.copyFormat(border);
                    }
                }
            }
        }
    }
    /**
     * @private
     */
    getTopBorderCellsOnSelection() {
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let startCell = startPos.paragraph.associatedCell;
        let topBorderCells = [];
        let cells = this.selection.getSelectedCells();
        for (let i = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === startCell.ownerRow) {
                topBorderCells.push(cells[i]);
            }
        }
        return topBorderCells;
    }
    /**
     * @private
     */
    getLeftBorderCellsOnSelection() {
        let startPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let startCell = startPos.paragraph.associatedCell;
        let cells = this.selection.getSelectedCells();
        let leftBorderCells = [];
        for (let i = 0; i < cells.length; i++) {
            if (cells[i].columnIndex === startCell.columnIndex) {
                leftBorderCells.push(cells[i]);
            }
        }
        return leftBorderCells;
    }
    /**
     * @private
     */
    getRightBorderCellsOnSelection() {
        let cells = this.selection.getSelectedCells();
        let rightBorderCells = [];
        for (let i = 0; i < cells.length; i++) {
            if ((cells[i].columnIndex + cells[i].cellFormat.columnSpan - 1) === cells[cells.length - 1].columnIndex) {
                rightBorderCells.push(cells[i]);
            }
        }
        return rightBorderCells;
    }
    /**
     * @private
     */
    getBottomBorderCellsOnSelection() {
        let endPos = this.selection.isForward ? this.selection.end : this.selection.start;
        let endCell = endPos.paragraph.associatedCell;
        let cells = this.selection.getSelectedCells();
        let bottomBorderCells = [];
        for (let i = 0; i < cells.length; i++) {
            if (cells[i].ownerRow === endCell.ownerRow) {
                bottomBorderCells.push(cells[i]);
            }
        }
        return bottomBorderCells;
    }
    /**
     * @private
     */
    clearAllBorderValues(borders) {
        let border = this.clearBorder();
        borders.bottom.copyFormat(border);
        borders.left.copyFormat(border);
        borders.right.copyFormat(border);
        borders.top.copyFormat(border);
        borders.vertical.copyFormat(border);
        borders.horizontal.copyFormat(border);
    }
    clearBorder() {
        let border = new WBorder();
        border.lineStyle = 'Cleared';
        return border;
    }
    /**
     * @private
     */
    getAdjacentCellToApplyBottomBorder() {
        let cells = [];
        let startPos = this.selection.start;
        let endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        let table = startPos.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        let startCell = startPos.paragraph.associatedCell;
        let endCell = endPos.paragraph.associatedCell;
        let nextRowIndex = endCell.ownerRow.rowIndex + endCell.cellFormat.rowSpan;
        let nextRow = table.childWidgets[nextRowIndex];
        if (nextRow) {
            if (endCell.cellFormat.columnSpan > 1) {
                for (let i = endCell.columnIndex; i < endCell.columnIndex + endCell.cellFormat.columnSpan; i++) {
                    cells.push(nextRow.childWidgets[i]);
                }
            }
            else {
                cells = this.getAdjacentBottomBorderOnEmptyCells(nextRow, endCell);
                if (!this.selection.isEmpty) {
                    for (let i = 0; i < nextRow.childWidgets.length; i++) {
                        let nextCellColIndex = nextRow.childWidgets[i].columnIndex;
                        if (nextCellColIndex >= startCell.columnIndex && nextCellColIndex <= endCell.columnIndex) {
                            cells.push(nextRow.childWidgets[i]);
                        }
                    }
                }
            }
        }
        return cells;
    }
    getAdjacentBottomBorderOnEmptyCells(nextRow, cell, isSingleCell) {
        let cells = [];
        if (cell.cellFormat.columnSpan > 1) {
            for (let i = cell.columnIndex; i < cell.columnIndex + cell.cellFormat.columnSpan; i++) {
                cells.push(nextRow.childWidgets[i]);
            }
        }
        else {
            if (this.selection.isEmpty || isSingleCell) {
                for (let i = 0; i < nextRow.childWidgets.length; i++) {
                    if (nextRow.childWidgets[i].columnIndex === cell.columnIndex) {
                        cells.push(nextRow.childWidgets[i]);
                    }
                }
            }
        }
        return cells;
    }
    /**
     * @private
     */
    getAdjacentCellToApplyRightBorder() {
        let cells = [];
        let startPosIn = this.selection.start;
        let endPosIn = this.selection.end;
        if (!this.selection.isForward) {
            startPosIn = this.selection.end;
            endPosIn = this.selection.start;
        }
        let table = startPosIn.paragraph.associatedCell.ownerTable;
        table = table.combineWidget(this.viewer);
        let startCell = startPosIn.paragraph.associatedCell;
        let endCell = endPosIn.paragraph.associatedCell;
        if (this.selection.isEmpty) {
            let selectedCell = startPosIn.paragraph.associatedCell;
            cells = this.getSelectedCellsNextWidgets(selectedCell, table);
        }
        else {
            // tslint:disable-next-line:max-line-length
            let selectedCells = this.getRightBorderCellsOnSelection();
            for (let i = 0; i < selectedCells.length; i++) {
                let cell = selectedCells[i];
                cells = cells.concat(this.getSelectedCellsNextWidgets(cell, table));
            }
        }
        return cells;
    }
    getSelectedCellsNextWidgets(selectedCell, table) {
        let cells = [];
        if (selectedCell.nextWidget) {
            cells.push(selectedCell.nextWidget);
        }
        if (selectedCell.cellFormat.rowSpan > 1) {
            let nextRowIndex = selectedCell.ownerRow.rowIndex + selectedCell.cellFormat.rowSpan;
            for (let i = selectedCell.ownerRow.rowIndex + 1; i < nextRowIndex; i++) {
                let nextRow = table.childWidgets[i];
                if (nextRow) {
                    for (let j = 0; j < nextRow.childWidgets.length; j++) {
                        if (nextRow.childWidgets[j].columnIndex ===
                            selectedCell.nextWidget.columnIndex) {
                            cells.push(nextRow.childWidgets[j]);
                        }
                    }
                }
            }
        }
        return cells;
    }
    /**
     * @private
     */
    getBorder(borderColor, lineWidth, borderStyle) {
        let border = new WBorder();
        border.color = borderColor || '#000000';
        border.lineWidth = lineWidth || 1;
        border.lineStyle = borderStyle || 'Single';
        return border;
    }
    /**
     * Applies borders
     * @param  {WBorders} sourceBorders
     * @param  {WBorders} applyBorders
     * @private
     */
    applyBordersInternal(sourceBorders, applyBorders) {
        if (!isNullOrUndefined(sourceBorders) && !isNullOrUndefined(sourceBorders)) {
            if (!isNullOrUndefined(sourceBorders.top)) {
                this.applyBorder(sourceBorders.top, applyBorders.top);
            }
            if (!isNullOrUndefined(sourceBorders.bottom)) {
                this.applyBorder(sourceBorders.bottom, applyBorders.bottom);
            }
            if (!isNullOrUndefined(sourceBorders.left)) {
                this.applyBorder(sourceBorders.left, applyBorders.left);
            }
            if (!isNullOrUndefined(sourceBorders.right)) {
                this.applyBorder(sourceBorders.right, applyBorders.right);
            }
            if (!isNullOrUndefined(sourceBorders.horizontal)) {
                this.applyBorder(sourceBorders.horizontal, applyBorders.horizontal);
            }
            if (!isNullOrUndefined(sourceBorders.vertical)) {
                this.applyBorder(sourceBorders.vertical, applyBorders.vertical);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalUp)) {
                this.applyBorder(sourceBorders.diagonalUp, applyBorders.diagonalUp);
            }
            if (!isNullOrUndefined(sourceBorders.diagonalDown)) {
                this.applyBorder(sourceBorders.diagonalDown, applyBorders.diagonalDown);
            }
        }
    }
    /**
     * Apply shading to table
     * @param  {WShading} sourceShading
     * @param  {WShading} applyShading
     * @private
     */
    applyShading(sourceShading, applyShading) {
        if (!isNullOrUndefined(applyShading) && !isNullOrUndefined(sourceShading)) {
            if (!isNullOrUndefined(applyShading.backgroundColor)
                && sourceShading.backgroundColor !== applyShading.backgroundColor) {
                sourceShading.backgroundColor = applyShading.backgroundColor;
            }
            if (!isNullOrUndefined(applyShading.foregroundColor)
                && sourceShading.foregroundColor !== applyShading.foregroundColor) {
                sourceShading.foregroundColor = applyShading.foregroundColor;
            }
            if (!isNullOrUndefined(applyShading.textureStyle)
                && sourceShading.textureStyle !== applyShading.textureStyle) {
                sourceShading.textureStyle = applyShading.textureStyle;
            }
        }
    }
    applyBorder(sourceBorder, applyBorder) {
        if (!isNullOrUndefined(sourceBorder) && !isNullOrUndefined(applyBorder)) {
            if (!isNullOrUndefined(applyBorder.color)
                && sourceBorder.color !== applyBorder.color) {
                sourceBorder.color = applyBorder.color;
            }
            if (!isNullOrUndefined(applyBorder.lineStyle)
                && sourceBorder.lineStyle !== applyBorder.lineStyle) {
                sourceBorder.lineStyle = applyBorder.lineStyle;
            }
            if (!isNullOrUndefined(applyBorder.lineWidth)
                && sourceBorder.lineWidth !== applyBorder.lineWidth) {
                sourceBorder.lineWidth = applyBorder.lineWidth;
            }
            if (!isNullOrUndefined(applyBorder.shadow)
                && sourceBorder.shadow !== applyBorder.shadow) {
                sourceBorder.shadow = applyBorder.shadow;
            }
            if (!isNullOrUndefined(applyBorder.space)
                && sourceBorder.space !== applyBorder.space) {
                sourceBorder.space = applyBorder.space;
            }
        }
    }
    /**
     * Apply Table Format changes
     * @param  {Selection} selection
     * @param  {WTableFormat} format
     * @private
     */
    onTableFormat(format, isShading) {
        if (!isNullOrUndefined(this.selection.tableFormat)) {
            if (isNullOrUndefined(isShading)) {
                isShading = false;
            }
            this.viewer.owner.isShiftingEnabled = true;
            this.editorHistory.initializeHistory('TableFormat');
            let table = this.selection.start.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
            if (isShading) {
                for (let i = 0; i < table.childWidgets.length; i++) {
                    let rowWidget = table.childWidgets[i];
                    for (let j = 0; j < rowWidget.childWidgets.length; j++) {
                        let cellWidget = rowWidget.childWidgets[j];
                        cellWidget.cellFormat.shading.copyFormat(format.shading);
                    }
                }
            }
            this.applyTableFormat(table, undefined, format);
            this.reLayout(this.selection, false);
        }
    }
    /**
     * @private
     */
    applyTableFormat(table, property, value) {
        this.applyTablePropertyValue(this.viewer.selection, undefined, value, table);
    }
    // tslint:disable-next-line:max-line-length
    applyTablePropertyValue(selection, property, value, table) {
        let sourceFormat = table.tableFormat;
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedTableProperties(sourceFormat, property, value);
        }
        if (value instanceof WTableFormat) {
            if (isNullOrUndefined(property)) {
                this.handleTableFormat(sourceFormat, value);
            }
            return;
        }
        if (property === 'preferredWidth') {
            sourceFormat.preferredWidth = value;
        }
        else if (property === 'leftIndent') {
            sourceFormat.leftIndent = value;
        }
        else if (property === 'tableAlignment') {
            sourceFormat.tableAlignment = value;
        }
        else if (property === 'cellSpacing') {
            sourceFormat.cellSpacing = value;
        }
        else if (property === 'leftMargin') {
            sourceFormat.leftMargin = value;
        }
        else if (property === 'rightMargin') {
            sourceFormat.rightMargin = value;
        }
        else if (property === 'topMargin') {
            sourceFormat.topMargin = value;
        }
        else if (property === 'bottomMargin') {
            sourceFormat.bottomMargin = value;
        }
        else if (property === 'preferredWidthType') {
            sourceFormat.preferredWidthType = value;
        }
        else if (property === 'bidi') {
            sourceFormat.bidi = value;
        }
        if (property === 'shading') {
            sourceFormat.shading = value;
        }
        else if (property === 'borders') {
            sourceFormat.borders = value;
        }
        // if (!isNullOrUndefined(table)) {
        //     this.layoutItemBlock(table, true);
        // }
    }
    handleTableFormat(tableFormat, applyFormat) {
        if (this.isBordersAndShadingDialog || this.editorHistory.isUndoing
            || this.editorHistory.isRedoing) {
            if (!isNullOrUndefined(tableFormat.borders)) {
                this.applyBordersInternal(tableFormat.borders, applyFormat.borders);
            }
            if (!isNullOrUndefined(tableFormat.shading)) {
                this.applyShading(tableFormat.shading, applyFormat.shading);
            }
        }
        if (!this.isBordersAndShadingDialog) {
            if (applyFormat.hasValue('bidi') && applyFormat.bidi !== tableFormat.bidi) {
                tableFormat.bidi = applyFormat.bidi;
            }
            if (applyFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== tableFormat.preferredWidth) {
                tableFormat.preferredWidth = applyFormat.preferredWidth;
            }
            if (applyFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== tableFormat.preferredWidthType) {
                tableFormat.preferredWidthType = applyFormat.preferredWidthType;
            }
            if (applyFormat.hasValue('tableAlignment') && applyFormat.tableAlignment !== tableFormat.tableAlignment) {
                tableFormat.tableAlignment = applyFormat.tableAlignment;
            }
            if (applyFormat.hasValue('leftIndent') && applyFormat.leftIndent !== tableFormat.leftIndent) {
                tableFormat.leftIndent = applyFormat.leftIndent;
            }
        }
        this.updateGridForTableDialog(tableFormat.ownerBase, false);
    }
    updateGridForTableDialog(table, shiftNextItem) {
        if (table.tableHolder) {
            table.updateRowIndex(0);
            table.calculateGrid();
            table.isGridUpdated = false;
        }
        this.viewer.layout.reLayoutTable(table);
    }
    /**
     * Applies Row Format Changes
     * @param  {Selection} selection
     * @param  {WRowFormat} format
     * @param  {WRow} row
     * @private
     */
    onRowFormat(format) {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('RowFormat');
        this.viewer.owner.isShiftingEnabled = true;
        let rowStartPos = this.selection.isForward ? this.selection.start : this.selection.end;
        let rowEndPos = this.selection.isForward ? this.selection.end : this.selection.start;
        let table = rowStartPos.paragraph.associatedCell.ownerTable.combineWidget(this.viewer);
        this.applyRowFormat(rowStartPos.paragraph.associatedCell.ownerRow, rowStartPos, rowEndPos, undefined, format);
        this.reLayout(this.selection, false);
    }
    applyRowFormat(row, start, end, property, value) {
        this.applyRowPropertyValue(this.viewer.selection, property, value, row);
        if (end.paragraph.associatedCell.ownerRow === row) {
            return;
        }
        let newRow = row.nextWidget;
        if (!isNullOrUndefined(newRow)) {
            this.applyRowFormat(newRow, start, end, property, value);
        }
    }
    applyRowPropertyValue(selection, property, value, row) {
        let applyFormat = row.rowFormat;
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedRowProperties(applyFormat, property, value);
        }
        if (value instanceof WRowFormat) {
            if (isNullOrUndefined(property)) {
                this.handleRowFormat(value, applyFormat);
            }
            return;
        }
        if (property === 'heightType') {
            applyFormat.heightType = value;
        }
        else if (property === 'height') {
            applyFormat.height = value;
        }
        else if (property === 'isHeader') {
            applyFormat.isHeader = value;
        }
        else if (property === 'allowBreakAcrossPages') {
            applyFormat.allowBreakAcrossPages = value;
        }
        if (!isNullOrUndefined(row.ownerTable)) {
            this.layoutItemBlock(row.ownerTable, true);
        }
    }
    handleRowFormat(format, applyFormat) {
        if (format.hasValue('allowBreakAcrossPages') && format.allowBreakAcrossPages !== applyFormat.allowBreakAcrossPages) {
            applyFormat.allowBreakAcrossPages = format.allowBreakAcrossPages;
        }
        if (format.hasValue('isHeader') && format.isHeader !== applyFormat.isHeader) {
            applyFormat.isHeader = format.isHeader;
        }
        if (format.hasValue('heightType') && format.heightType !== applyFormat.heightType) {
            applyFormat.heightType = format.heightType;
        }
        if (format.hasValue('height') && format.height !== applyFormat.height) {
            applyFormat.height = format.height;
        }
        this.updateGridForTableDialog(applyFormat.ownerBase.ownerTable, true);
    }
    /**
     * Applies Cell Format changes
     * @param  {Selection} selection
     * @param  {WCellFormat} format
     * @param  {WCell} cell
     * @private
     */
    onCellFormat(format) {
        if (isNullOrUndefined(this.selection) || isNullOrUndefined(format)) {
            return;
        }
        this.editorHistory.initializeHistory('CellFormat');
        this.updateFormatForCell(this.selection, undefined, format);
        this.reLayout(this.selection, false);
    }
    /**
     * @private
     */
    updateCellMargins(selection, value) {
        let cellStartPosition = selection.start;
        let cellEndPosition = selection.end;
        if (!selection.isForward) {
            cellStartPosition = selection.end;
            cellEndPosition = selection.start;
        }
        this.initHistoryPosition(selection, cellStartPosition);
        // tslint:disable-next-line:max-line-length
        this.viewer.owner.cellOptionsDialogModule.applyCellmarginsValue(cellStartPosition.paragraph.associatedCell.ownerRow, cellStartPosition, cellEndPosition, value);
    }
    /**
     * @private
     */
    updateFormatForCell(selection, property, value) {
        let start = selection.start;
        let end = selection.end;
        if (!selection.isForward) {
            start = selection.end;
            end = selection.start;
        }
        let startCell = start.paragraph.associatedCell;
        let endCell = end.paragraph.associatedCell;
        let cells;
        let table = startCell.ownerTable.combineWidget(this.viewer);
        let appliedFormat;
        for (let k = startCell.columnIndex; k <= endCell.columnIndex; k++) {
            cells = this.getSelectedCellInColumn(startCell.ownerTable, startCell.ownerRow.rowIndex, k, endCell.ownerRow.rowIndex);
            for (let i = 0; i < cells.length; i++) {
                appliedFormat = this.applyCellPropertyValue(this.viewer.selection, property, value, cells[i].cellFormat);
            }
        }
        this.updateGridForTableDialog(table, false);
    }
    /**
     * @private
     */
    getSelectedCellInColumn(table, rowStartIndex, columnIndex, rowEndIndex) {
        let cells = [];
        for (let i = rowStartIndex; i <= rowEndIndex; i++) {
            let row = table.childWidgets[i];
            for (let j = 0; j < row.childWidgets.length; j++) {
                if (row.childWidgets[j].columnIndex === columnIndex) {
                    cells.push(row.childWidgets[j]);
                }
            }
        }
        return cells;
    }
    getColumnCells(table, columnIndex, isLeftSideCollection) {
        let cells = [];
        for (let k = 0; k < table.childWidgets.length; k++) {
            let row = table.childWidgets[k];
            for (let i = 0; i < row.childWidgets.length; i++) {
                let cell = row.childWidgets[i];
                if (isLeftSideCollection) {
                    if (cell.columnIndex + cell.cellFormat.columnSpan === columnIndex) {
                        cells.push(cell);
                    }
                }
                else {
                    if (cell.columnIndex === columnIndex) {
                        cells.push(cell);
                    }
                }
            }
        }
        return cells;
    }
    /**
     * @private
     */
    getTableWidth(table) {
        if (table.tableFormat.preferredWidth !== 0 || table.tableFormat.preferredWidthType === 'Percent') {
            if (table.tableFormat.preferredWidthType === 'Auto' || table.tableFormat.preferredWidthType === 'Point') {
                return table.tableFormat.preferredWidth;
            }
            else {
                if (table.tableFormat.preferredWidth === 0) {
                    return 0;
                }
                else {
                    return HelperMethods.convertPixelToPoint(this.viewer.clientArea.width) / 100 * table.tableFormat.preferredWidth;
                }
            }
        }
        return HelperMethods.convertPixelToPoint(this.viewer.layout.getTableWidth(table));
    }
    applyCellPropertyValue(selection, property, value, applyFormat) {
        if (!isNullOrUndefined(this.editorHistory.currentBaseHistoryInfo)) {
            value = this.editorHistory.currentBaseHistoryInfo.addModifiedCellProperties(applyFormat, property, value);
        }
        if (value instanceof WCellFormat) {
            if (isNullOrUndefined(property)) {
                this.handleCellFormat(value, applyFormat);
            }
            return value;
        }
        if (property === 'leftMargin') {
            applyFormat.leftMargin = value;
        }
        else if (property === 'topMargin') {
            applyFormat.topMargin = value;
        }
        else if (property === 'rightMargin') {
            applyFormat.rightMargin = value;
        }
        else if (property === 'bottomMargin') {
            applyFormat.bottomMargin = value;
        }
        else if (property === 'preferredWidth') {
            applyFormat.preferredWidth = value;
            applyFormat.cellWidth = value;
        }
        else if (property === 'cellWidth') {
            applyFormat.cellWidth = value;
        }
        else if (property === 'columnSpan') {
            applyFormat.columnSpan = value;
        }
        else if (property === 'rowSpan') {
            applyFormat.rowSpan = value;
        }
        else if (property === 'preferredWidthType') {
            applyFormat.preferredWidthType = value;
        }
        else if (property === 'verticalAlignment') {
            applyFormat.verticalAlignment = value;
        }
        if (property === 'shading') {
            applyFormat.shading = value;
        }
        else if (property === 'borders') {
            applyFormat.borders = value;
        }
        return undefined;
    }
    handleCellFormat(cellFormat, applyFormat) {
        if (!isNullOrUndefined(cellFormat) && !isNullOrUndefined(applyFormat)) {
            if (this.isBordersAndShadingDialog) {
                if (!isNullOrUndefined(cellFormat.borders)) {
                    this.applyBordersInternal(applyFormat.borders, cellFormat.borders);
                }
                if (!isNullOrUndefined(cellFormat.shading)) {
                    this.applyShading(applyFormat.shading, cellFormat.shading);
                }
                // this.layoutRow((applyFormat.ownerBase as TableCellWidget).ownerRow, this.viewer, false);
            }
            else {
                if (cellFormat.hasValue('preferredWidth') && applyFormat.preferredWidth !== cellFormat.preferredWidth) {
                    applyFormat.preferredWidth = cellFormat.preferredWidth;
                }
                if (cellFormat.hasValue('preferredWidthType') && applyFormat.preferredWidthType !== cellFormat.preferredWidthType) {
                    applyFormat.preferredWidthType = cellFormat.preferredWidthType;
                }
                if (cellFormat.hasValue('verticalAlignment') && applyFormat.verticalAlignment !== cellFormat.verticalAlignment) {
                    applyFormat.verticalAlignment = cellFormat.verticalAlignment;
                }
            }
        }
    }
    /**
     * @private
     */
    destroy() {
        this.viewer = undefined;
        this.nodes = [];
    }
    isTocField(element) {
        if (element instanceof FieldElementBox) {
            let nextElement = element.nextNode;
            if (element instanceof FieldElementBox && element.fieldType === 0 && nextElement instanceof TextElementBox
                && nextElement.text.trim().toLowerCase().indexOf('toc') === 0) {
                return true;
            }
        }
        return false;
    }
    /**
     * Updates the table of contents.
     * @private
     */
    updateToc(tocField) {
        if (isNullOrUndefined(tocField)) {
            tocField = this.selection.getTocFieldInternal();
        }
        if (!this.isTocField(tocField)) {
            return;
        }
        // Decode field code to get parameters
        let code = this.selection.getFieldCode(tocField);
        if (code.toLocaleLowerCase().indexOf('toc') !== -1) {
            this.insertTableOfContents(this.validateTocSettings(this.getTocSettings(code, tocField)));
        }
    }
    getTocSettings(code, tocField) {
        let tocSettings = {};
        tocSettings.includePageNumber = true;
        tocSettings.rightAlign = true;
        // Decode field code to get parameters
        if (code.toLowerCase() === 'toc \\mergeformat') {
            tocSettings.startLevel = 1;
            tocSettings.endLevel = 3;
        }
        else {
            let swtiches = code.split('\\');
            for (let i = 0; i < swtiches.length; i++) {
                let swtch = swtiches[i];
                if (swtch.length === 0) {
                    continue;
                }
                switch (swtch[0]) {
                    case 'o':
                        if (!isNullOrUndefined(swtch.match(/\d+/g))) {
                            let levels = swtch.match(/\d+/g).map(Number);
                            tocSettings.startLevel = levels[0];
                            tocSettings.endLevel = levels[1];
                        }
                        else {
                            tocSettings.startLevel = 1;
                            tocSettings.endLevel = 9;
                        }
                        break;
                    case 'h':
                        tocSettings.includeHyperlink = true;
                        break;
                    case 'n':
                        tocSettings.includePageNumber = false;
                        break;
                    case 'p':
                        tocSettings.rightAlign = false;
                        break;
                    case 'u':
                        tocSettings.includeOutlineLevels = true;
                        break;
                    case 't':
                        this.decodeTSwitch(tocSettings, swtch);
                        break;
                }
            }
        }
        //assigns tab leader.
        let tabs = tocField.paragraph.paragraphFormat.getUpdatedTabs();
        if (tabs.length > 0) {
            tocSettings.tabLeader = tabs[tabs.length - 1].tabLeader;
        }
        if (tocSettings.rightAlign && isNullOrUndefined(tocSettings.tabLeader)) {
            tocSettings.tabLeader = 'Dot';
        }
        return tocSettings;
    }
    decodeTSwitch(tocSettings, tSwitch) {
        tocSettings.levelSettings = {};
        tSwitch = tSwitch.replace('t', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.replace('"', '');
        tSwitch = tSwitch.trim();
        let levels = tSwitch.split(',');
        for (let index = 0; index < levels.length; index++) {
            tocSettings.levelSettings[levels[index]] = parseInt(levels[index + 1], 10);
            index++;
        }
    }
    /**
     * Inserts, modifies or updates the table of contents based on given settings.
     * @param {TableOfContentsSettings} tableOfContentsSettings
     */
    insertTableOfContents(tableOfContentsSettings) {
        this.isInsertingTOC = true;
        this.initComplexHistory('TOC');
        if (isNullOrUndefined(tableOfContentsSettings)) {
            //Initializes with default value.
            tableOfContentsSettings = {};
            tableOfContentsSettings.startLevel = 1;
            tableOfContentsSettings.endLevel = 3;
            tableOfContentsSettings.includeHyperlink = true;
            tableOfContentsSettings.includeOutlineLevels = true;
            tableOfContentsSettings.includePageNumber = true;
            tableOfContentsSettings.rightAlign = true;
            tableOfContentsSettings.tabLeader = 'Dot';
        }
        let tocField = undefined;
        let code = undefined;
        if (this.selection.contextType === 'TableOfContents') {
            tocField = this.selection.getTocFieldInternal();
        }
        if (tocField instanceof FieldElementBox) {
            this.selection.start.setPositionForSelection(tocField.line, tocField, 0, this.selection.start.location);
            this.selection.end.setPositionForSelection(tocField.fieldEnd.line, tocField.fieldEnd, 2, this.selection.end.location);
            this.delete();
        }
        // Build TOC field code based on parameter
        code = this.constructTocFieldCode(tableOfContentsSettings);
        let isStartParagraph = this.selection.start.isAtParagraphStart;
        let blockInfo = this.selection.getParagraphInfo(this.selection.start);
        let initialStart = this.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        // Build TOC fields
        // tslint:disable-next-line:max-line-length
        let widgets = this.buildToc(this.validateTocSettings(tableOfContentsSettings), code, true, isStartParagraph);
        if (widgets.length > 0) {
            let tocLastPara = new ParagraphWidget();
            let tocLastLine = new LineWidget(tocLastPara);
            tocLastPara.childWidgets.push(tocLastLine);
            let index = 0;
            if (!isStartParagraph) {
                index = 1;
            }
            let line = widgets[index].childWidgets[0];
            let fieldBegin = line.children[0];
            this.appendEndField(fieldBegin, tocLastLine);
            widgets.push(tocLastPara);
            this.appendEmptyPara(widgets);
        }
        this.setPositionForCurrentIndex(this.selection.start, initialStart);
        this.selection.end.setPositionInternal(this.selection.start);
        this.pasteContentsInternal(widgets);
        this.isInsertingTOC = false;
        this.updatePageRef();
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
    }
    appendEmptyPara(widgets) {
        let emptyPara = new ParagraphWidget();
        let emptyLine = new LineWidget(emptyPara);
        emptyPara.childWidgets.push(emptyLine);
        widgets.push(emptyPara);
    }
    constructTocFieldCode(tocSettings) {
        let tocFieldCode = 'TOC';
        //appends styles level
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(tocSettings.startLevel) && tocSettings.startLevel !== 0 && !isNullOrUndefined(tocSettings.endLevel) && tocSettings.endLevel !== 0) {
            tocFieldCode = tocFieldCode + ' \\o "' + tocSettings.startLevel + '-' + tocSettings.endLevel + '"';
        }
        if (tocSettings.includePageNumber && !tocSettings.rightAlign) {
            tocFieldCode = tocFieldCode + ' \\p " "';
        }
        if (!tocSettings.includePageNumber) {
            tocFieldCode = tocFieldCode + ' \\n';
        }
        if (tocSettings.includeHyperlink) {
            tocFieldCode = tocFieldCode + ' \\h \\z';
        }
        if (tocSettings.includeOutlineLevels) {
            tocFieldCode = tocFieldCode + ' \\u';
        }
        let tSwitch = this.constructTSwitch(tocSettings);
        if (tSwitch.length > 6) {
            tocFieldCode = tocFieldCode + tSwitch;
        }
        return tocFieldCode;
    }
    constructTSwitch(tocSettings) {
        let tSwitch = '';
        let prefix = ' \\t ';
        if (!isNullOrUndefined(tocSettings.levelSettings)) {
            for (let key of Object.keys(tocSettings.levelSettings)) {
                tSwitch = tSwitch + key + ',' + tocSettings.levelSettings[key].toString() + ',';
            }
        }
        tSwitch = tSwitch.slice(0, -1);
        tSwitch = prefix + '"' + tSwitch + '"';
        return tSwitch;
    }
    /**
     * Appends the end filed to the given line.
     */
    appendEndField(fieldBegin, lineWidget) {
        let fieldEnd = new FieldElementBox(1);
        fieldEnd.fieldSeparator = fieldBegin.fieldSeparator;
        fieldBegin.fieldSeparator.fieldEnd = fieldEnd;
        fieldEnd.fieldBegin = fieldBegin;
        fieldEnd.fieldBegin.fieldEnd = fieldEnd;
        fieldEnd.line = lineWidget;
        lineWidget.children.push(fieldEnd);
    }
    validateTocSettings(tocSettings) {
        if (isNullOrUndefined(tocSettings.startLevel) || tocSettings.startLevel < 1) {
            tocSettings.startLevel = 1;
        }
        if (isNullOrUndefined(tocSettings.endLevel) || tocSettings.endLevel < tocSettings.endLevel) {
            tocSettings.endLevel = tocSettings.startLevel > 3 ? tocSettings.startLevel : 3;
        }
        if (isNullOrUndefined(tocSettings.includeHyperlink)) {
            tocSettings.includeHyperlink = false;
        }
        if (isNullOrUndefined(tocSettings.includePageNumber)) {
            tocSettings.includePageNumber = false;
        }
        if (isNullOrUndefined(tocSettings.rightAlign)) {
            tocSettings.rightAlign = false;
        }
        if (isNullOrUndefined(tocSettings.levelSettings)) {
            tocSettings.levelSettings = {};
        }
        return tocSettings;
    }
    /**
     * Builds the TOC
     * @private
     */
    // tslint:disable-next-line:max-line-length
    buildToc(tocSettings, fieldCode, isFirstPara, isStartParagraph) {
        let tocDomBody = this.viewer.pages[0].bodyWidgets[0];
        let widgets = [];
        this.createHeadingLevels(tocSettings);
        if (tocSettings.includeOutlineLevels) {
            this.createOutlineLevels(tocSettings);
        }
        let sectionFormat = this.selection.start.paragraph.bodyWidget.sectionFormat;
        let widget = tocDomBody.childWidgets[0];
        while (widget !== undefined) {
            // tslint:disable-next-line:max-line-length
            if (widget instanceof ParagraphWidget && (this.isHeadingStyle(widget) || (tocSettings.includeOutlineLevels && this.isOutlineLevelStyle(widget)))) {
                let bookmarkName = this.insertTocBookmark(widget);
                // tslint:disable-next-line:max-line-length
                this.createTOCWidgets(widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara, isStartParagraph, sectionFormat);
                isFirstPara = false;
            }
            widget = this.selection.getNextParagraphBlock(widget.getSplitWidgets().pop());
        }
        this.tocStyles = {};
        return widgets;
    }
    createOutlineLevels(settings) {
        for (let i = settings.startLevel; i <= settings.endLevel; i++) {
            let levelStyle = 'Level' + i.toString();
            if (isNullOrUndefined(this.tocStyles[levelStyle])) {
                this.tocStyles[levelStyle] = i;
            }
        }
    }
    /**
     * Creates TOC heading styles
     * @param start - lower heading level
     * @param end - higher heading level
     */
    createHeadingLevels(settings) {
        for (let i = settings.startLevel; i <= settings.endLevel; i++) {
            let headingStyle = 'Heading ' + i.toString();
            if (isNullOrUndefined(this.tocStyles[headingStyle])) {
                this.tocStyles[headingStyle] = i;
            }
        }
        if (!isNullOrUndefined(settings.levelSettings)) {
            for (let key of Object.keys(settings.levelSettings)) {
                this.tocStyles[key] = settings.levelSettings[key];
            }
        }
    }
    /**
     * Checks the current style is heading style.
     */
    isHeadingStyle(para) {
        let style = para.paragraphFormat.baseStyle;
        if (style !== undefined) {
            return isNullOrUndefined(this.tocStyles[style.name]) ? false : true;
        }
        return false;
    }
    isOutlineLevelStyle(para) {
        let styleName = para.paragraphFormat.outlineLevel;
        return isNullOrUndefined(this.tocStyles[styleName]) ? false : true;
    }
    /**
     * Creates TOC field element.
     */
    createTocFieldElement(lineWidget, fieldCode) {
        //begin
        let fieldBegin = new FieldElementBox(0);
        fieldBegin.hasFieldEnd = true;
        fieldBegin.line = lineWidget;
        lineWidget.children.push(fieldBegin);
        //format toc
        let textElement = new TextElementBox();
        textElement.text = fieldCode;
        textElement.line = lineWidget;
        lineWidget.children.push(textElement);
        //field separator
        let fieldSeparator = new FieldElementBox(2);
        fieldSeparator.fieldBegin = fieldBegin;
        fieldSeparator.fieldBegin.fieldSeparator = fieldSeparator;
        fieldSeparator.line = lineWidget;
        lineWidget.children.push(fieldSeparator);
        return fieldBegin;
    }
    /**
     * Updates TOC para
     */
    // tslint:disable-next-line:max-line-length
    createTOCWidgets(widget, widgets, fieldCode, bookmarkName, tocSettings, isFirstPara, isStartParagraph, sectionFormat) {
        let fieldBegin = undefined;
        let tocPara = undefined;
        let tocLine = undefined;
        // tslint:disable-next-line:max-line-length
        if (widgets.length === 1 && widgets[0].childWidgets[0].children.length === 3 && !isNullOrUndefined(isFirstPara) && !isFirstPara) {
            tocLine = widgets[0].childWidgets[0];
        }
        else {
            tocPara = new ParagraphWidget();
            let styleName = undefined;
            //Adds toc syles into paragraph
            let headingStyleName = widget.paragraphFormat.baseStyle.name;
            if (tocSettings.includeOutlineLevels && isNullOrUndefined(this.tocStyles[headingStyleName])) {
                styleName = widget.paragraphFormat.outlineLevel;
            }
            else {
                styleName = headingStyleName;
            }
            let tocStyleName = 'Toc' + this.tocStyles[styleName];
            let paraStyle = this.viewer.styles.findByName(tocStyleName, 'Paragraph');
            if (isNullOrUndefined(paraStyle)) {
                // tslint:disable-next-line:max-line-length
                this.viewer.owner.parser.parseStyle(JSON.parse(this.getCompleteStyles()), JSON.parse(this.viewer.preDefinedStyles.get(tocStyleName)), this.viewer.styles);
                paraStyle = this.viewer.styles.findByName(tocStyleName, 'Paragraph');
            }
            tocPara.paragraphFormat.ApplyStyle(paraStyle);
            //Creates right tab for page number.
            if (tocSettings.rightAlign && tocSettings.includePageNumber) {
                let tabStop = new WTabStop();
                tabStop.position = sectionFormat.pageWidth - (sectionFormat.leftMargin + sectionFormat.rightMargin);
                tabStop.tabLeader = tocSettings.tabLeader;
                tabStop.deletePosition = 0;
                tabStop.tabJustification = 'Right';
                tocPara.paragraphFormat.tabs.push(tabStop);
            }
            tocLine = new LineWidget(tocPara);
            tocPara.childWidgets.push(tocLine);
        }
        //creates toc field element if it is insert
        if ((isFirstPara !== undefined) && isFirstPara) {
            if (!isNullOrUndefined(isStartParagraph) && !isStartParagraph) {
                this.appendEmptyPara(widgets);
            }
            this.createTocFieldElement(tocLine, fieldCode);
        }
        let text = '';
        let isFieldCode = false;
        let paragraph = widget;
        while (paragraph instanceof ParagraphWidget) {
            for (let lineIndex = 0; lineIndex < paragraph.childWidgets.length; lineIndex++) {
                let lineWidget = paragraph.childWidgets[lineIndex];
                for (let elementIndex = 0; elementIndex < lineWidget.children.length; elementIndex++) {
                    let element = lineWidget.children[elementIndex];
                    if (element.isPageBreak) {
                        continue;
                    }
                    if ((element instanceof FieldElementBox) || (element instanceof BookmarkElementBox) || isFieldCode) {
                        if (element instanceof FieldElementBox) {
                            if (element.fieldType === 0) {
                                isFieldCode = true;
                            }
                            else if (element.fieldType === 2) {
                                isFieldCode = false;
                            }
                        }
                    }
                    else if (element instanceof TextElementBox || element instanceof ListTextElementBox) {
                        let temp = element.text;
                        let tabChar = '\t';
                        if (temp.indexOf(tabChar) !== -1) {
                            temp = temp.replace(new RegExp(tabChar, 'g'), ' ');
                        }
                        text = text + temp;
                    }
                }
            }
            paragraph = paragraph.nextSplitWidget;
        }
        if (text !== '') {
            // inserts hyperlink
            if (tocSettings.includeHyperlink && (bookmarkName !== undefined)) {
                fieldBegin = this.insertTocHyperlink(tocLine, bookmarkName, text);
            }
            else {
                let span = new TextElementBox();
                span.text = text;
                span.line = tocLine;
                tocLine.children.push(span);
            }
            //inserts page number
            if (tocSettings.includePageNumber && (bookmarkName !== undefined)) {
                if (tocSettings.rightAlign) {
                    let tabText = new TabElementBox();
                    tabText.text = '\t';
                    tabText.line = tocLine;
                    tocLine.children.push(tabText);
                }
                let pageField = this.insertTocPageNumber(bookmarkName, tocLine, tocSettings.rightAlign, widget);
                this.appendEndField(pageField, tocLine);
            }
            if (tocSettings.includeHyperlink && fieldBegin !== undefined) {
                this.appendEndField(fieldBegin, tocLine);
            }
        }
        if (!isNullOrUndefined(tocPara) && (text !== '' || isFirstPara)) {
            widgets.push(tocPara);
        }
    }
    /**
     * Inserts toc hyperlink.
     */
    insertTocHyperlink(lineWidget, bookmarkName, text) {
        let fieldCode = ' HYPERLINK \\l \"' + bookmarkName + '\" ';
        let fieldBegin = this.createTocFieldElement(lineWidget, fieldCode);
        //text element.
        let span = new TextElementBox();
        span.text = text;
        span.line = lineWidget;
        lineWidget.children.push(span);
        return fieldBegin;
    }
    /**
     * Inserts toc page number.
     */
    // tslint:disable-next-line:max-line-length
    insertTocPageNumber(bookMarkname, lineWidget, isRightAlign, widget) {
        let fieldCode = ' PAGEREF' + bookMarkname + ' \\h ';
        let fieldBegin = this.createTocFieldElement(lineWidget, fieldCode);
        let text = (this.viewer.pages.indexOf(widget.bodyWidget.page) + 1).toString();
        //text element.
        let span = new FieldTextElementBox();
        span.fieldBegin = fieldBegin;
        if (!isRightAlign) {
            text = ' ' + text;
        }
        span.text = text;
        span.line = lineWidget;
        lineWidget.children.push(span);
        this.pageRefFields[bookMarkname] = span;
        return fieldBegin;
    }
    updatePageRef() {
        for (let key of Object.keys(this.pageRefFields)) {
            let bookmark = this.viewer.bookmarks.get(key);
            let pageRef = (bookmark.paragraph.bodyWidget.page.index + 1).toString();
            let span = this.pageRefFields[key];
            if (pageRef !== span.text) {
                span.text = pageRef;
                let paragraph = span.paragraph;
                let lineIndex = paragraph.childWidgets.indexOf(span.line);
                let elementIndex = span.line.children.indexOf(span);
                this.viewer.layout.reLayoutParagraph(paragraph, lineIndex, elementIndex);
            }
        }
    }
    /**
     * Inserts toc bookmark.
     */
    insertTocBookmark(widget) {
        let bookmarkName = undefined;
        let lineLength = widget.childWidgets.length;
        if (lineLength > 0) {
            let splitParagraph = widget.getSplitWidgets();
            let firstParagraph = splitParagraph[0];
            let lastParagraph = splitParagraph.pop();
            let startLine = firstParagraph.childWidgets[0];
            let endLine = lastParagraph.childWidgets[lastParagraph.childWidgets.length - 1];
            if ((startLine !== undefined) && (endLine !== undefined)) {
                let startElement = startLine.children[0];
                if (startElement instanceof ListTextElementBox) {
                    do {
                        startElement = startElement.nextNode;
                    } while (startElement instanceof ListTextElementBox);
                }
                //Returns the bookmark if already present for paragraph.
                // tslint:disable-next-line:max-line-length
                if (!isNullOrUndefined(startElement) && startElement instanceof BookmarkElementBox && startElement.bookmarkType === 0 && (startElement.name.toLowerCase().match('^_toc'))) {
                    return startElement.name;
                }
                let endElement = endLine.children[endLine.children.length - 1];
                if ((startElement !== undefined) && (endElement !== undefined)) {
                    this.selection.start.setPositionForSelection(startLine, startElement, 0, this.selection.start.location);
                    this.selection.end.setPositionForSelection(endLine, endElement, endElement.length, this.selection.end.location);
                    bookmarkName = this.generateBookmarkName();
                    this.insertBookmark(bookmarkName);
                }
            }
        }
        return bookmarkName;
    }
    /**
     * Generates bookmark id.
     */
    generateBookmarkName() {
        this.tocBookmarkId++;
        let count = 10 - this.tocBookmarkId.toString().length;
        let formatString = '';
        while (count - 1 > 0) {
            formatString = '0' + formatString;
            count--;
        }
        let bookmarkName = '_Toc' + formatString + this.tocBookmarkId;
        return bookmarkName;
    }
    /**
     * Change cell content alignment
     * @private
     */
    onCellContentAlignment(verticalAlignment, textAlignment) {
        this.owner.isShiftingEnabled = true;
        let selection = this.owner.selection;
        if (selection.isEmpty && selection.start.paragraph.isInsideTable) {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.initComplexHistory(selection, 'MultiSelection');
            }
            //Selecting the table cell to update the all the paragraph format.
            selection.selectTableCell();
            this.initHistory('CellContentVerticalAlignment');
            let cellFormat = selection.start.paragraph.associatedCell.cellFormat;
            this.applyCellPropertyValue(selection, 'verticalAlignment', verticalAlignment, cellFormat);
            this.reLayout(selection, false);
            this.initHistory('TextAlignment');
            this.updateParagraphFormat('textAlignment', textAlignment, false);
            this.reLayout(this.owner.selection, false);
            if (this.owner.editorHistory) {
                this.owner.editorHistory.updateComplexHistory();
            }
        }
        else {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.initComplexHistory(selection, 'MultiSelection');
            }
            if (!isNullOrUndefined(selection.getTable(selection.start, selection.end))) {
                //Table cell vertical alignment.
                this.updateSelectionTableFormat(selection, 'CellContentVerticalAlignment', verticalAlignment);
                this.reLayout(this.owner.selection, false);
                this.initHistory('TextAlignment');
                //Paragraph text alignment.
                this.updateSelectionParagraphFormatting('textAlignment', textAlignment, false);
                this.reLayout(selection, false);
            }
            if (this.owner.editorHistory) {
                this.owner.editorHistory.updateComplexHistory();
            }
        }
    }
    //Restrict editing implementation starts
    /**
     * @private
     */
    insertEditRangeElement(user) {
        if (this.viewer.isDocumentProtected || this.viewer.selection.isEmpty) {
            return;
        }
        this.initComplexHistory('RestrictEditing');
        this.selection.skipEditRangeRetrieval = true;
        let selection = this.viewer.selection;
        let startPos = this.selection.start;
        let endPos = this.selection.end;
        if (!this.selection.isForward) {
            startPos = this.selection.end;
            endPos = this.selection.start;
        }
        if (selection.start.paragraph.isInsideTable && selection.end.paragraph.isInsideTable
            && selection.start.paragraph.associatedCell.ownerTable.contains(selection.end.paragraph.associatedCell)) {
            let startCell = this.getOwnerCell(this.selection.isForward);
            let endCell = this.getOwnerCell(!this.selection.isForward);
            if (startCell.rowIndex === endCell.rowIndex) {
                let startIndex = startCell.ownerRow.childWidgets.indexOf(startCell);
                let endIndex = startCell.ownerRow.childWidgets.indexOf(endCell);
                let startElement = [];
                let endElement = [];
                for (let i = startIndex; i <= endIndex; i++) {
                    let editStart = this.addEditElement(user);
                    editStart.columnFirst = i;
                    editStart.columnLast = i;
                    editStart.line = selection.start.currentWidget;
                    let editEnd = editStart.editRangeEnd;
                    editEnd.line = selection.end.currentWidget;
                    startElement.push(editStart);
                    endElement.push(editEnd);
                }
                this.insertElements(endElement, startElement);
                let offset = startElement[0].line.getOffset(startElement[0], 1);
                this.selection.start.setPositionParagraph(startElement[0].line, offset);
                offset = endElement[0].line.getOffset(endElement[0], 1);
                this.selection.end.setPositionParagraph(endElement[0].line, offset);
                this.selection.fireSelectionChanged(true);
                this.fireContentChange();
            }
            else {
                this.insertEditRangeInsideTable(startCell, endCell, user);
                let startLine = this.selection.getFirstParagraphInCell(startCell).childWidgets[0];
                let endLine = this.selection.getLastParagraph(endCell).childWidgets[0];
                let offset = startLine.getOffset(startLine.children[0], 1);
                this.selection.start.setPositionParagraph(startLine, offset);
                offset = endLine.getOffset(endLine.children[0], 1);
                this.selection.end.setPositionParagraph(endLine, offset);
                this.selection.fireSelectionChanged(true);
                this.fireContentChange();
            }
        }
        else {
            this.addRestrictEditingForSelectedArea(user);
        }
        this.selection.skipEditRangeRetrieval = false;
    }
    /**
     * @private
     */
    insertEditRangeInsideTable(startCell, endCell, user) {
        let table = startCell.ownerTable;
        let count = table.childWidgets.indexOf(endCell.ownerRow);
        let rowStartIndex = table.childWidgets.indexOf(startCell.ownerRow);
        let startLeft = this.selection.getCellLeft(startCell.ownerRow, startCell);
        let endLeft = startLeft + startCell.cellFormat.cellWidth;
        let endCellLeft = this.selection.getCellLeft(endCell.ownerRow, endCell);
        let endCellRight = endCellLeft + endCell.cellFormat.cellWidth;
        let cellInfo = this.updateSelectedCellsInTable(startLeft, endLeft, endCellLeft, endCellRight);
        startLeft = cellInfo.start;
        endLeft = cellInfo.end;
        let endElement = [];
        for (let i = rowStartIndex; i <= count; i++) {
            let row = table.childWidgets[i];
            let cellSelectionStartIndex = -1;
            let cellSelectionEndIndex = -1;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellStart = this.selection.getCellLeft(row, cell);
                if (this.checkCellWithInSelection(startLeft, endLeft, cellStart)) {
                    if (cellSelectionStartIndex === -1) {
                        cellSelectionStartIndex = j;
                    }
                    cellSelectionEndIndex = j;
                }
            }
            let newEndElement = [];
            for (let z = cellSelectionStartIndex; z <= cellSelectionEndIndex; z++) {
                let index = 0;
                let startCell;
                let startParagraph;
                if (z === cellSelectionStartIndex) {
                    startCell = row.childWidgets[cellSelectionStartIndex];
                    startParagraph = this.selection.getFirstParagraphInCell(startCell).childWidgets[0];
                }
                let editStart = this.addEditElement(user);
                editStart.columnFirst = z;
                editStart.columnLast = z;
                editStart.line = startParagraph;
                editStart.line.children.splice(index, 0, editStart);
                index++;
                let editEnd = editStart.editRangeEnd;
                newEndElement.push(editEnd);
                if (endElement.length > 0 && z === cellSelectionEndIndex) {
                    for (let l = 0; l < endElement.length; l++) {
                        endElement[l].line = editStart.line;
                        editStart.line.children.splice(index, 0, endElement[l]);
                        index++;
                    }
                    endElement = [];
                }
            }
            endElement = newEndElement;
            if (i === count && endElement.length > 0) {
                let cellWidget = row.childWidgets[cellSelectionEndIndex];
                let lastLine = this.selection.getLastParagraph(cellWidget).lastChild;
                let index = lastLine.children.length - 1;
                for (let l = 0; l < endElement.length; l++) {
                    endElement[l].line = lastLine;
                    lastLine.children.splice(index, 0, endElement[l]);
                    index++;
                }
            }
        }
    }
    /**
     * @private
     */
    addRestrictEditingForSelectedArea(user) {
        let editStart = this.addEditElement(user);
        let editEnd = editStart.editRangeEnd;
        if (this.editorHistory && this.editorHistory.currentHistoryInfo) {
            this.editorHistory.currentHistoryInfo.editRangeStart = editStart;
        }
        this.insertElements([editEnd], [editStart]);
        if (this.editorHistory) {
            this.editorHistory.updateComplexHistoryInternal();
        }
        let offset = editStart.line.getOffset(editStart, 1);
        this.selection.start.setPositionParagraph(editStart.line, offset);
        offset = editEnd.line.getOffset(editEnd, 1);
        this.selection.end.setPositionParagraph(editEnd.line, offset);
        this.selection.fireSelectionChanged(true);
        this.fireContentChange();
    }
    /**
     * @private
     */
    addEditElement(user) {
        let editStart = new EditRangeStartElementBox();
        if (user.toLocaleLowerCase() === 'everyone') {
            editStart.group = user;
        }
        else {
            editStart.user = user;
        }
        let editEnd = new EditRangeEndElementBox();
        editEnd.editRangeStart = editStart;
        editStart.editRangeEnd = editEnd;
        this.editStartRangeCollection.push(editStart);
        this.addEditCollectionToDocument();
        this.editStartRangeCollection = [];
        return editStart;
    }
    /**
     * @private
     */
    protect(protectionType) {
        this.viewer.isDocumentProtected = true;
        this.viewer.protectionType = protectionType;
        this.selection.highlightEditRegion();
    }
    /**
     * @private
     */
    addEditCollectionToDocument() {
        for (let i = 0; i < this.editStartRangeCollection.length; i++) {
            let editStart = this.editStartRangeCollection[i];
            let user = editStart.user === '' ? editStart.group : editStart.user;
            if (this.viewer.editRanges.length > 0 && this.viewer.editRanges.containsKey(user)) {
                this.viewer.editRanges.get(user).push(editStart);
            }
            else {
                let collection = [];
                collection.push(editStart);
                this.viewer.editRanges.add(user, collection);
            }
        }
        this.selection.updateEditRangeCollection();
    }
    /**
     * @private
     */
    updateRangeCollection(editStart, user) {
        if (this.viewer.editRanges.length > 0 && this.viewer.editRanges.containsKey(user)) {
            this.viewer.editRanges.get(user).push(editStart);
        }
        else {
            let collection = [];
            collection.push(editStart);
            this.viewer.editRanges.add(user, collection);
        }
    }
    /**
     * @private
     */
    removeUserRestrictions(user) {
        if (!this.selection.checkSelectionIsAtEditRegion()) {
            return;
        }
        this.selection.skipEditRangeRetrieval = true;
        let editStart = this.selection.getEditRangeStartElement();
        this.initHistory('RemoveEditRange');
        if (this.editorHistory) {
            this.editorHistory.currentBaseHistoryInfo.setEditRangeInfo(editStart);
            this.editorHistory.updateHistory();
        }
        if (editStart.user === user || editStart.group === user) {
            this.removeUserRestrictionsInternal(editStart, user);
        }
        this.selection.updateEditRangeCollection();
        this.fireContentChange();
        this.selection.skipEditRangeRetrieval = false;
    }
    /**
     * @private
     */
    removeUserRestrictionsInternal(editStart, currentUser) {
        let user = currentUser;
        if (isNullOrUndefined(currentUser)) {
            user = editStart.user === '' ? editStart.group : editStart.user;
        }
        let index = this.viewer.editRanges.get(user).indexOf(editStart);
        this.viewer.editRanges.get(user).splice(index, 1);
        editStart.editRangeEnd.line.children.splice(editStart.editRangeEnd.indexInOwner, 1);
        editStart.line.children.splice(editStart.indexInOwner, 1);
    }
    /**
     * @private
     */
    removeAllEditRestrictions() {
        this.selection.skipEditRangeRetrieval = true;
        let startPosition = this.selection.start;
        let endPosition = this.selection.end;
        let editStart = [];
        let keys = this.viewer.editRanges.keys;
        for (let j = 0; j < keys.length; j++) {
            editStart = this.viewer.editRanges.get(keys[j]);
            for (let i = 0; i < editStart.length; i++) {
                editStart[i].editRangeEnd.line.children.splice(editStart[i].editRangeEnd.indexInOwner, 1);
                editStart[i].line.children.splice(editStart[i].indexInOwner, 1);
            }
        }
        this.viewer.editRanges.clear();
        this.selection.updateEditRangeCollection();
        this.selection.start.setPositionInternal(startPosition);
        this.selection.end.setPositionInternal(endPosition);
        this.selection.editRegionHighlighters.clear();
        this.viewer.updateScrollBars();
        this.selection.fireSelectionChanged(false);
        this.selection.skipEditRangeRetrieval = false;
    }
}

/**
 * @private
 */
class ModifiedLevel {
    constructor(owner, modified) {
        this.ownerListLevelIn = undefined;
        this.modifiedListLevelIn = undefined;
        this.ownerListLevel = owner;
        this.modifiedListLevel = modified;
    }
    /**
     * @private
     */
    get ownerListLevel() {
        return this.ownerListLevelIn;
    }
    /**
     * @private
     */
    set ownerListLevel(value) {
        this.ownerListLevelIn = value;
    }
    /**
     * @private
     */
    get modifiedListLevel() {
        return this.modifiedListLevelIn;
    }
    /**
     * @private
     */
    set modifiedListLevel(value) {
        this.modifiedListLevelIn = value;
    }
    /**
     * @private
     */
    destroy() {
        this.ownerListLevel = undefined;
        this.modifiedListLevel = undefined;
    }
}
/**
 * @private
 */
class ModifiedParagraphFormat {
    constructor(ownerFormat, modifiedFormat) {
        this.ownerFormatIn = undefined;
        this.modifiedFormatIn = undefined;
        this.ownerFormat = ownerFormat;
        this.modifiedFormat = modifiedFormat;
    }
    /**
     * @private
     */
    get ownerFormat() {
        return this.ownerFormatIn;
    }
    /**
     * @private
     */
    set ownerFormat(value) {
        this.ownerFormatIn = value;
    }
    /**
     * hidden
     */
    get modifiedFormat() {
        return this.modifiedFormatIn;
    }
    /**
     * @private
     */
    set modifiedFormat(value) {
        this.modifiedFormatIn = value;
    }
    /**
     * @private
     */
    destroy() {
        this.ownerFormat = undefined;
        this.modifiedFormat.destroy();
        this.modifiedFormat = undefined;
    }
}
/**
 * @private
 */
class RowHistoryFormat {
    constructor(startingPoint, rowFormat) {
        this.startingPoint = startingPoint;
        this.rowFormat = rowFormat;
        this.rowHeightType = rowFormat.heightType;
    }
    revertChanges(isRedo, owner) {
        //backup current format values.
        let currentRowHeightType = this.rowFormat.heightType;
        //Restore old values.
        owner.editorModule.tableResize.updateRowHeight(this.rowFormat.ownerBase, isRedo ? this.displacement : (-this.displacement));
        owner.viewer.layout.reLayoutTable(this.rowFormat.ownerBase.ownerTable);
        if (this.rowFormat.heightType !== this.rowHeightType) {
            this.rowFormat.heightType = this.rowHeightType;
        }
        //backup the current format values for redo.
        this.rowHeightType = currentRowHeightType;
    }
}
/**
 * @private
 */
class TableHistoryInfo {
    constructor(table, owner) {
        this.tableHolder = new WTableHolder();
        this.tableFormat = new TableFormatHistoryInfo();
        this.rows = [];
        this.owner = owner;
        this.copyProperties(table);
    }
    copyProperties(table) {
        if (table.tableHolder) {
            this.tableHolder = table.tableHolder.clone();
        }
        if (table.tableFormat) {
            this.tableFormat.leftIndent = table.tableFormat.leftIndent;
            this.tableFormat.preferredWidth = table.tableFormat.preferredWidth;
            this.tableFormat.preferredWidthType = table.tableFormat.preferredWidthType;
            this.tableFormat.allowAutoFit = table.tableFormat.allowAutoFit;
        }
        for (let i = 0; i < table.childWidgets.length; i++) {
            let row = table.childWidgets[i];
            let rowFormat = new RowFormatHistoryInfo();
            rowFormat.gridBefore = row.rowFormat.gridBefore;
            rowFormat.gridBeforeWidth = row.rowFormat.gridBeforeWidth;
            rowFormat.gridBeforeWidthType = row.rowFormat.gridBeforeWidthType;
            rowFormat.gridAfter = row.rowFormat.gridAfter;
            rowFormat.gridAfterWidth = row.rowFormat.gridAfterWidth;
            rowFormat.gridAfterWidthType = row.rowFormat.gridAfterWidthType;
            for (let j = 0; j < row.childWidgets.length; j++) {
                let cell = row.childWidgets[j];
                let cellFormat = new CellFormatHistoryInfo();
                cellFormat.columnIndex = cell.columnIndex;
                cellFormat.columnSpan = cell.cellFormat.columnSpan;
                cellFormat.preferredWidth = cell.cellFormat.preferredWidth;
                cellFormat.preferredWidthType = cell.cellFormat.preferredWidthType;
                rowFormat.cells.push(cellFormat);
            }
            this.rows.push(rowFormat);
        }
        this.tableHierarchicalIndex = this.owner.selection.getHierarchicalIndex(table, '0');
    }
    destroy() {
        this.tableHierarchicalIndex = undefined;
        if (this.tableHolder) {
            this.tableHolder.destroy();
            this.tableHolder = undefined;
        }
        if (this.tableFormat) {
            this.tableFormat = null;
        }
        if (this.rows) {
            this.rows = [];
            this.rows = undefined;
        }
    }
}
/**
 * @private
 */
class TableFormatHistoryInfo {
    constructor() {
        /* tslint:disable:no-empty */
    }
}
/**
 * @private
 */
class RowFormatHistoryInfo {
    constructor() {
        this.cells = [];
    }
}
/**
 * @private
 */
class CellFormatHistoryInfo {
    constructor() {
        /* tslint:disable:no-empty */
    }
}
/**
 * @private
 */
class CellHistoryFormat {
    constructor(point) {
        this.startingPoint = point; // starting point preserved to calculate the displacement on after cell resizing finished.
    }
}

/**
 * @private
 */
class BaseHistoryInfo {
    //Properties
    //gets owner control
    /**
     * gets the owner control
     * @private
     */
    get owner() { return this.ownerIn; }
    /**
     * gets or sets action
     * @private
     */
    get editorHistory() {
        return this.owner.editorHistory;
    }
    /**
     * gets or sets action
     * @private
     */
    get action() { return this.actionIn; }
    set action(value) { this.actionIn = value; }
    /**
     * gets modified properties
     * @returns Object
     * @private
     */
    get modifiedProperties() { return this.modifiedPropertiesIn; }
    /**
     * @private
     */
    get removedNodes() {
        return this.removedNodesIn;
    }
    /**
     * Gets or Sets the selection start
     * @private
     */
    //gets or sets selection start
    get selectionStart() { return this.selectionStartIn; }
    set selectionStart(value) { this.selectionStartIn = value; }
    /**
     * Gets or Sets the selection end
     * @private
     */
    get selectionEnd() { return this.selectionEndIn; }
    set selectionEnd(value) { this.selectionEndIn = value; }
    /**
     * Gets or sets the insert position
     * @private
     */
    get insertPosition() { return this.insertPositionIn; }
    set insertPosition(value) { this.insertPositionIn = value; }
    /**
     * Gets or sets end position
     * @private
     */
    get endPosition() { return this.endPositionIn; }
    set endPosition(value) { this.endPositionIn = value; }
    constructor(node) {
        this.ownerIn = node;
        this.viewer = node.viewer;
        this.modifiedPropertiesIn = [];
        this.modifiedNodeLength = [];
        this.removedNodesIn = [];
    }
    /**
     * Update the selection
     * @param selection
     * @private
     */
    updateSelection() {
        let blockInfo = this.owner.selection.getParagraphInfo(this.owner.selection.start);
        this.selectionStart = this.owner.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
        blockInfo = this.owner.selection.getParagraphInfo(this.owner.selection.end);
        this.selectionEnd = this.owner.selection.getHierarchicalIndex(blockInfo.paragraph, blockInfo.offset.toString());
    }
    setBookmarkInfo(bookmark) {
        this.removedNodes.push({ 'bookmark': bookmark, 'startIndex': bookmark.indexInOwner, 'endIndex': bookmark.reference.indexInOwner });
    }
    setEditRangeInfo(editStart) {
        // tslint:disable-next-line:max-line-length
        this.removedNodes.push({ 'editStart': editStart, 'startIndex': editStart.indexInOwner, 'endIndex': editStart.editRangeEnd.indexInOwner });
    }
    revertBookmark() {
        let bookmarkInfo = this.removedNodes[0];
        let bookmark = bookmarkInfo.bookmark;
        if (this.editorHistory.isUndoing) {
            this.viewer.bookmarks.add(bookmark.name, bookmark);
            bookmark.line.children.splice(bookmarkInfo.startIndex, 0, bookmark);
            bookmark.reference.line.children.splice(bookmarkInfo.endIndex, 0, bookmark.reference);
            this.editorHistory.recordChanges(this);
        }
        else {
            this.owner.editorModule.deleteBookmarkInternal(bookmark);
            this.editorHistory.undoStack.push(this);
        }
    }
    revertComment() {
        let editPosition = this.insertPosition;
        let comment = this.removedNodes[0];
        let insert = false;
        if (this.action === 'InsertCommentWidget') {
            insert = (this.editorHistory.isRedoing);
        }
        else if (this.action === 'DeleteCommentWidget') {
            insert = (this.editorHistory.isUndoing);
        }
        if (insert) {
            if (comment) {
                if (comment.isReply) {
                    this.owner.editor.addReplyComment(comment, this.insertPosition);
                }
                else {
                    this.owner.editor.addCommentWidget(comment, false);
                }
            }
        }
        else {
            let commentElement = this.owner.editor.getCommentElementBox(editPosition);
            this.owner.editor.deleteCommentWidget(commentElement);
        }
    }
    revertEditRangeRegion() {
        let editRangeInfo = this.removedNodes[0];
        let editStart = editRangeInfo.editStart;
        if (this.editorHistory.isUndoing) {
            let user = editStart.user === '' ? editStart.group : editStart.user;
            this.owner.editor.updateRangeCollection(editStart, user);
            editStart.line.children.splice(editRangeInfo.startIndex, 0, editStart);
            editStart.editRangeEnd.line.children.splice(editRangeInfo.endIndex, 0, editStart.editRangeEnd);
            this.editorHistory.recordChanges(this);
        }
        else {
            this.owner.editorModule.removeUserRestrictionsInternal(editStart);
            this.editorHistory.undoStack.push(this);
        }
        this.owner.editor.fireContentChange();
    }
    /**
     * Reverts this instance
     * @private
     */
    // tslint:disable: max-func-body-length
    revert() {
        if (this.action === 'DeleteBookmark') {
            this.revertBookmark();
            return;
        }
        if (this.action === 'RemoveEditRange') {
            this.revertEditRangeRegion();
            return;
        }
        if (this.action === 'InsertCommentWidget' || this.action === 'DeleteCommentWidget') {
            this.revertComment();
            return;
        }
        this.owner.isShiftingEnabled = true;
        let selectionStartTextPosition = undefined;
        let selectionEndTextPosition = undefined;
        let start = this.selectionStart;
        let end = this.selectionEnd;
        let isForwardSelection = TextPosition.isForwardSelection(start, end);
        if (this.modifiedProperties.length > 0 || this.action === 'Selection' || this.action === 'ClearCharacterFormat'
            || this.action === 'ClearParagraphFormat') {
            selectionStartTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(start);
            selectionEndTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(end);
            this.revertModifiedProperties(selectionStartTextPosition, selectionEndTextPosition);
        }
        else {
            let sel = this.owner.selection;
            let deletedNodes = this.removedNodes;
            this.removedNodesIn = [];
            let isForward = TextPosition.isForwardSelection(this.insertPosition, this.endPosition);
            let insertTextPosition = sel.getTextPosBasedOnLogicalIndex(isForward ? this.insertPosition : this.endPosition);
            let endTextPosition = sel.getTextPosBasedOnLogicalIndex(isForward ? this.endPosition : this.insertPosition);
            if (insertTextPosition.isAtSamePosition(endTextPosition)) {
                sel.selectContent(insertTextPosition, true);
            }
            else {
                sel.selectPosition(insertTextPosition, endTextPosition);
            }
            if (this.action === 'InsertHyperlink' && this.editorHistory.isRedoing) {
                let fieldBegin = this.owner.selection.getHyperlinkField();
                if (!isNullOrUndefined(fieldBegin)) {
                    let offset = (fieldBegin.line).getOffset(fieldBegin, 0);
                    insertTextPosition.setPositionParagraph(fieldBegin.line, offset);
                    this.owner.selection.start.setPositionInternal(insertTextPosition);
                    offset = fieldBegin.fieldEnd.line.getOffset(fieldBegin.fieldEnd, 1);
                    endTextPosition.setPositionParagraph(fieldBegin.fieldEnd.line, offset);
                }
            }
            this.editorHistory.currentBaseHistoryInfo = this;
            this.selectionStart = this.insertPosition;
            this.insertPosition = undefined;
            this.selectionEnd = this.endPosition;
            this.endPosition = undefined;
            let isRemoveContent = false;
            if (!insertTextPosition.isAtSamePosition(endTextPosition)) {
                isRemoveContent = this.action === 'BackSpace' || this.action === 'Delete' || this.action === 'ClearCells'
                    || this.action === 'DeleteCells';
                if (!(isRemoveContent) && this.action !== 'MergeCells' && this.action !== 'InsertRowAbove'
                    && this.action !== 'InsertRowBelow' && this.action !== 'InsertColumnLeft'
                    && this.action !== 'InsertColumnRight' && this.action !== 'Borders'
                    && this.action !== 'DeleteTable' && this.action !== 'DeleteColumn' && this.action !== 'DeleteRow') {
                    sel.end.setPositionInternal(endTextPosition);
                    if (!this.owner.selection.isEmpty) {
                        if (this.editorHistory.isRedoing) {
                            this.owner.editorModule.removeSelectedContents(sel);
                        }
                        else {
                            this.owner.editorModule.deleteSelectedContents(sel, true);
                        }
                        if (!isNullOrUndefined(this.editorHistory.currentHistoryInfo) &&
                            this.editorHistory.currentHistoryInfo.action === 'PageBreak' && this.viewer.blockToShift) {
                            this.viewer.layout.shiftLayoutedItems();
                        }
                    }
                }
            }
            let isRedoAction = this.editorHistory.isRedoing && !isRemoveContent;
            this.revertModifiedNodes(deletedNodes, isRedoAction, isForwardSelection ? start : end, start === end);
            if (isRemoveContent) {
                this.removeContent(insertTextPosition, endTextPosition);
            }
            //this.owner.editorModule.reLayout(this.viewer.selection);
        }
        let isSelectionChanged = false;
        if ((this.editorHistory.isUndoing && isNullOrUndefined(this.editorHistory.currentHistoryInfo)) ||
            ((this.action === 'InsertRowAbove' || this.action === 'Borders' || this.action === 'InsertRowBelow'
                || this.action === 'InsertColumnLeft'
                || this.action === 'InsertColumnRight') && (this.editorHistory.isRedoing
                || this.editorHistory.currentHistoryInfo.action === 'Paste'))) {
            selectionStartTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(start);
            selectionEndTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(end);
            this.owner.selection.selectRange(selectionStartTextPosition, selectionEndTextPosition);
            isSelectionChanged = true;
        }
        // Updates insert position of history info instance.
        this.insertPosition = start;
        this.endPosition = end;
        this.owner.editorModule.reLayout(this.owner.selection, this.owner.selection.isEmpty);
        if (isSelectionChanged) {
            this.viewer.scrollToPosition(this.owner.selection.start, this.owner.selection.end);
        }
        this.highlightListText();
    }
    highlightListText() {
        if (!isNullOrUndefined(this.editorHistory.currentHistoryInfo)) {
            // tslint:disable-next-line:max-line-length
            if (this.action === 'ListCharacterFormat' || (this.editorHistory.currentHistoryInfo.action === 'ListSelect' && this.action === 'ListFormat')) {
                let selectionStartTextPosition = this.owner.selection.getTextPosBasedOnLogicalIndex(this.selectionStart);
                let widget = selectionStartTextPosition.currentWidget;
                this.viewer.selection.highlightListText(widget);
            }
        }
    }
    removeContent(insertTextPosition, endTextPosition) {
        //If the base parent of the insert text position and end text position is null 
        //then the paragraphs already removed.
        //Example scenario: In table editing that is delete cells operation 
        // we will backed up the entire table ad it will be replaced on undo operation.
        //At that time if the positions are in table 
        //which is already replaced in undo (revert modified nodes method) then the base parent of the paragraph will be null.
        //So again, selecting the content and deleting is unnecessary
        // and it will cause improper position updates and null reference exceptions. 
        if ((!isNullOrUndefined(insertTextPosition.paragraph.containerWidget) &&
            insertTextPosition.paragraph.containerWidget instanceof BodyWidget &&
            (!isNullOrUndefined(endTextPosition.paragraph.containerWidget)
                && endTextPosition.paragraph.containerWidget instanceof BodyWidget))
            || (!isNullOrUndefined(insertTextPosition.paragraph.containerWidget)
                && !isNullOrUndefined(endTextPosition.paragraph.containerWidget)
                && insertTextPosition.paragraph.containerWidget instanceof TableCellWidget
                && endTextPosition.paragraph.containerWidget instanceof TableCellWidget
                && !isNullOrUndefined(insertTextPosition.paragraph.bodyWidget))) {
            //Removes if any empty paragraph is added while delete.
            this.owner.selection.selectRange(insertTextPosition, endTextPosition);
            let isDelete = (this.action === 'BackSpace') ? true : false;
            this.owner.editorModule.deleteSelectedContents(this.owner.selection, isDelete);
        }
    }
    revertModifiedProperties(start, end) {
        if (this.action === 'CellFormat' || this.action === 'CellOptions' || this.action === 'TableOptions') {
            this.owner.isShiftingEnabled = false;
        }
        this.owner.selection.selectRange(start, end);
        if (this.action === 'RowResizing' || this.action === 'CellResizing') {
            this.revertResizing();
        }
        else if (this.action === 'CellOptions' || this.action === 'TableOptions') {
            this.revertTableDialogProperties(this.action);
        }
        else if (this.action !== 'Selection') {
            this.revertProperties();
        }
    }
    // Redoes the Action
    redoAction() {
        let editor = this.owner.editorModule;
        switch (this.action) {
            case 'BackSpace':
                editor.singleBackspace(this.owner.selection, true);
                break;
            case 'Delete':
                editor.singleDelete(this.owner.selection, true);
                break;
            case 'DeleteTable':
                editor.deleteTable();
                break;
            case 'DeleteColumn':
                editor.deleteColumn();
                break;
            case 'DeleteRow':
                editor.deleteRow();
                break;
            case 'MergeCells':
                editor.mergeSelectedCellsInTable();
                break;
            case 'InsertRowAbove':
                editor.insertRow(true);
                break;
            case 'InsertRowBelow':
                editor.insertRow(false);
                break;
            case 'InsertColumnLeft':
                editor.insertColumn(true);
                break;
            case 'InsertColumnRight':
                editor.insertColumn(true);
                break;
            case 'SectionBreak':
                editor.insertSection(this.owner.selection, true);
                break;
            case 'TableAutoFitToContents':
                editor.autoFitTable('FitToContents');
                break;
            case 'TableAutoFitToWindow':
                editor.autoFitTable('FitToWindow');
                break;
            case 'TableFixedColumnWidth':
                editor.autoFitTable('FixedColumnWidth');
                break;
        }
    }
    /**
     * Revert the modified nodes
     * @param  {WNode[]} deletedNodes
     * @param  {boolean} isRedoAction
     * @param  {string} start
     * @param  {boolean} isEmptySelection
     */
    revertModifiedNodes(deletedNodes, isRedoAction, start, isEmptySelection) {
        if (isRedoAction && (this.action === 'BackSpace' || this.action === 'Delete' || this.action === 'DeleteTable'
            || this.action === 'DeleteColumn' || this.action === 'DeleteRow' || this.action === 'InsertRowAbove' ||
            this.action === 'InsertRowBelow' || this.action === 'InsertColumnLeft' || this.action === 'InsertColumnRight'
            || this.action === 'MergeCells' || this.action === 'SectionBreak' || this.action === 'TableAutoFitToContents' ||
            this.action === 'TableAutoFitToWindow' || this.action === 'TableFixedColumnWidth')) {
            this.redoAction();
            if (this.action === 'SectionBreak') {
                return;
            }
        }
        if (deletedNodes.length > 0) {
            if ((this.editorHistory.isUndoing && (this.action === 'DeleteCells' || this.action === 'DeleteColumn'
                || this.action === 'DeleteRow' || this.action === 'MergeCells'))
                || (this.action === 'InsertRowAbove' || this.action === 'InsertRowBelow' || this.action === 'InsertColumnLeft'
                    || this.action === 'ClearCells' || this.action === 'InsertColumnRight' || this.action === 'Borders' ||
                    this.action === 'TableAutoFitToContents' || this.action === 'TableAutoFitToWindow' ||
                    this.action === 'TableFixedColumnWidth')) {
                let insertIndex = this.selectionStart;
                let block = this.owner.editorModule.getBlock({ index: insertIndex }).node;
                let lastNode = deletedNodes[deletedNodes.length - 1];
                if ((block instanceof TableWidget || block.previousRenderedWidget instanceof TableWidget || block.isInsideTable)
                    && lastNode instanceof TableWidget) {
                    if (block instanceof ParagraphWidget && !block.isInsideTable) {
                        block = block.previousRenderedWidget;
                    }
                    block = block.combineWidget(this.viewer);
                    this.owner.editorModule.insertTableInternal(block, lastNode, false);
                    deletedNodes.splice(deletedNodes.indexOf(lastNode), 1);
                }
                else if (lastNode instanceof TableWidget) {
                    this.owner.editorModule.insertBlock(lastNode);
                }
            }
            else {
                let initialStart = start;
                let block = this.owner.editorModule.getBlock({ index: initialStart }).node;
                // initialStart = blockObj.position;
                if (deletedNodes.length > 0 && (this.action === 'BackSpace' && isEmptySelection
                    || (!(block instanceof TableWidget) && !(block instanceof HeaderFooterWidget)))) {
                    let lastNode = deletedNodes[0];
                    if (this.action === 'SectionBreak' && lastNode instanceof BodyWidget ||
                        !isNullOrUndefined(this.editorHistory.currentHistoryInfo) &&
                            this.editorHistory.currentHistoryInfo.action === 'PageBreak') {
                        lastNode = deletedNodes[1];
                    }
                    if (lastNode instanceof ParagraphWidget && this.owner.selection.start.offset > 0) {
                        this.owner.editorModule.insertNewParagraphWidget(lastNode, true);
                        deletedNodes.splice(deletedNodes.indexOf(lastNode), 1);
                        if (isNullOrUndefined(block)) {
                            // tslint:disable-next-line:max-line-length
                            let nextBlock = this.viewer.selection.getNextParagraphBlock(lastNode.getSplitWidgets().pop());
                            this.owner.selection.getNextRenderedBlock(lastNode);
                            if (isNullOrUndefined(nextBlock)) {
                                //Sets the selection as starting of last paragraph.
                                this.owner.selection.selectParagraphInternal(lastNode, true);
                            }
                        }
                    }
                    if (lastNode instanceof TableWidget && this.owner.selection.start.offset > 0) {
                        let firstBlock = deletedNodes[deletedNodes.length - 1];
                        if (firstBlock instanceof ParagraphWidget) {
                            this.owner.editorModule.insertNewParagraphWidget(firstBlock, true);
                            deletedNodes.splice(deletedNodes.indexOf(firstBlock), 1);
                            if (isNullOrUndefined(block)) {
                                // tslint:disable-next-line:max-line-length
                                let nextBlock = this.viewer.selection.getNextParagraphBlock(firstBlock.getSplitWidgets().pop());
                                if (isNullOrUndefined(nextBlock)) {
                                    //Sets the selection as starting of last paragraph.
                                    this.owner.selection.selectParagraphInternal(firstBlock, true);
                                }
                            }
                        }
                    }
                }
                if (deletedNodes.length > 0) {
                    let firstNode = deletedNodes[deletedNodes.length - 1];
                    if (block instanceof TableWidget) {
                        block = block.combineWidget(this.viewer);
                        if (firstNode instanceof TableWidget) {
                            this.owner.editorModule.insertTableInternal(block, firstNode, true);
                            deletedNodes.splice(deletedNodes.indexOf(firstNode), 1);
                            this.insertPosition = start;
                            let nextWidget = firstNode.getSplitWidgets().pop();
                            if (nextWidget.nextRenderedWidget instanceof TableWidget) {
                                block = nextWidget.nextRenderedWidget;
                            }
                            else {
                                initialStart = start;
                                block = this.owner.editorModule.getBlock({ index: initialStart }).node;
                            }
                        }
                    }
                    //Checks if first node is paragraph and current insert position is paragraph end.
                    // tslint:disable-next-line:max-line-length
                    if (firstNode instanceof ParagraphWidget && this.owner.selection.start.offset > 0
                        && this.owner.selection.start.offset === this.owner.selection.getLineLength(this.owner.selection.start.paragraph.lastChild)) {
                        let editor = this.owner.editorModule;
                        editor.insertNewParagraphWidget(firstNode, false);
                        deletedNodes.splice(deletedNodes.indexOf(firstNode), 1);
                        //Removes the intermediate empty paragraph instance.
                        if (this.action !== 'Paste') {
                            editor.removeBlock(this.owner.selection.start.paragraph);
                        }
                        // tslint:disable-next-line:max-line-length
                        let paragraph = this.viewer.selection.getNextParagraphBlock(firstNode.getSplitWidgets().pop());
                        if (!isNullOrUndefined(paragraph)) {
                            this.owner.selection.selectParagraphInternal(paragraph, true);
                        }
                    }
                    else if (deletedNodes[0] instanceof TableWidget && deletedNodes.length !== 1) {
                        let nextNode = deletedNodes[1];
                        if (nextNode instanceof ParagraphWidget && nextNode.isEmpty()) {
                            deletedNodes.splice(deletedNodes.indexOf(nextNode), 1);
                        }
                    }
                }
                if (deletedNodes.length > 0) {
                    if (block instanceof TableWidget) {
                        block = block.combineWidget(this.viewer);
                    }
                    this.insertRemovedNodes(deletedNodes, block);
                }
            }
        }
    }
    insertRemovedNodes(deletedNodes, block) {
        for (let i = deletedNodes.length - 1, index = 0; i > -1; i--) {
            let node = deletedNodes[i];
            if (node instanceof ElementBox) {
                this.owner.editorModule.insertInlineInSelection(this.owner.selection, node);
            }
            else if (node instanceof BlockWidget) {
                if (node instanceof TableRowWidget) {
                    if (block instanceof TableWidget) {
                        block.childWidgets.splice(index, 0, node);
                        this.owner.editorModule.updateNextBlocksIndex(node, true);
                        if (i === 0 || !(deletedNodes[i - 1] instanceof TableRowWidget)) {
                            // tslint:disable-next-line:max-line-length
                            this.viewer.layout.layoutBodyWidgetCollection(block.index, block.containerWidget, block, false);
                        }
                    }
                }
                else if (block instanceof TableWidget) {
                    this.owner.editorModule.insertBlockTable(this.owner.selection, node, block);
                }
                else {
                    this.owner.editorModule.insertBlock(node);
                }
            }
            else if (node instanceof BodyWidget) {
                this.owner.editorModule.insertSection(this.owner.selection, false);
            }
        }
        deletedNodes = [];
    }
    revertResizing() {
        this.editorHistory.currentBaseHistoryInfo = this;
        if (this.action === 'RowResizing') {
            if (this.modifiedProperties[0] instanceof RowHistoryFormat) {
                // tslint:disable-next-line:max-line-length
                this.modifiedProperties[0].revertChanges(this.editorHistory.isRedoing, this.owner);
            }
        }
        else {
            if (this.modifiedProperties[0] instanceof TableHistoryInfo) {
                //selected cell resizing the condition checks done based on the selected widgets only. so need to highlight the selection.
                if (this.owner.selection.selectedWidgets.length === 0) {
                    this.owner.selection.highlightSelection(true);
                }
                let prevTableHistoryInfo = this.modifiedProperties[0];
                let position = prevTableHistoryInfo.tableHierarchicalIndex;
                let block = this.owner.editorModule.getBlock({ index: position }).node;
                if (block instanceof TableWidget) {
                    let tableResize = this.owner.editorModule.tableResize;
                    this.owner.editor.setOffsetValue(this.owner.selection);
                    block = block.combineWidget(this.owner.viewer);
                    tableResize.currentResizingTable = block;
                    this.modifiedProperties.splice(0, 1);
                    if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
                        let tableHistoryInfoCurrent = new TableHistoryInfo(block, this.owner);
                        this.modifiedProperties.splice(0, 0, tableHistoryInfoCurrent);
                        this.owner.isLayoutEnabled = false;
                        tableResize.applyProperties(tableResize.currentResizingTable, prevTableHistoryInfo);
                        tableResize.currentResizingTable.isGridUpdated = true;
                        this.owner.isLayoutEnabled = true;
                        tableResize.updateGridValue(tableResize.currentResizingTable, false);
                        prevTableHistoryInfo.destroy();
                        prevTableHistoryInfo = undefined;
                    }
                }
            }
        }
    }
    revertTableDialogProperties(action) {
        this.owner.isShiftingEnabled = false;
        this.editorHistory.currentBaseHistoryInfo = this;
        this.currentPropertyIndex = 0;
        if (action === 'CellOptions') {
            let selection = this.owner.selection;
            let cellFormat = this.modifiedProperties[0];
            this.owner.editorModule.updateCellMargins(selection, cellFormat);
        }
        else if (action === 'TableOptions') {
            this.owner.tableOptionsDialogModule.applyTableOptionsHelper(this.modifiedProperties[0]);
        }
        this.currentPropertyIndex = 0;
        this.owner.isShiftingEnabled = true;
    }
    /**
     * Add modified properties for section format
     * @param  {WSectionFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedPropertiesForSection(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            let modifiedProperties = this.modifiedProperties;
            let previousFormat = (this.currentPropertyIndex < modifiedProperties.length ?
                modifiedProperties[this.currentPropertyIndex] : modifiedProperties[modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
            }
            else {
                value = previousFormat.getPropertyValue(property);
                previousFormat.copyFormat(format);
            }
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                let currentFormat = new WSectionFormat();
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
        }
        return value;
    }
    /**
     * Add the modified properties for character format
     * @param  {WCharacterFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedProperties(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length           
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            let skipRemove = false;
            if (format.ownerBase instanceof ElementBox) {
                let prevLength = this.modifiedNodeLength[this.currentPropertyIndex];
                if (format.ownerBase.length < prevLength) {
                    skipRemove = true;
                    this.modifiedNodeLength[this.currentPropertyIndex] = format.ownerBase.length;
                    this.modifiedNodeLength.splice(this.currentPropertyIndex + 1, 0, prevLength - format.ownerBase.length);
                    //Adds a copy of character format at next position for splitted inline.
                    let nextFormat = new WCharacterFormat(undefined);
                    nextFormat.copyFormat(previousFormat);
                    this.modifiedProperties.splice(this.currentPropertyIndex + 1, 0, nextFormat);
                }
            }
            if (this.action === 'ClearCharacterFormat') {
                if (this.editorHistory.isUndoing) {
                    value = previousFormat;
                    if (!skipRemove) {
                        this.modifiedProperties.splice(this.currentPropertyIndex, 1);
                        this.currentPropertyIndex--;
                    }
                }
                else {
                    this.modifiedProperties.push(format.cloneFormat());
                }
            }
            else {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
            }
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                let currentFormat = new WCharacterFormat(undefined);
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
            if (format.ownerBase instanceof ElementBox) {
                this.modifiedNodeLength.push(format.ownerBase.length);
            }
            else {
                this.modifiedNodeLength.push(0);
            }
        }
        return value;
    }
    /**
     * Add the modified properties for paragraph format
     * @param  {WParagraphFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedPropertiesForParagraphFormat(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (this.action === 'ClearParagraphFormat') {
                if (this.editorHistory.isUndoing) {
                    value = previousFormat;
                    this.modifiedProperties.splice(this.currentPropertyIndex, 1);
                    this.currentPropertyIndex--;
                }
                else {
                    this.modifiedProperties.push(format.cloneFormat());
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'listFormat') {
                value = new WParagraphFormat(undefined);
                value.copyFormat(previousFormat);
                previousFormat.listFormat = new WListFormat();
                previousFormat.listFormat.copyFormat(format.listFormat);
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'styleName') {
                if (!isNullOrUndefined(previousFormat.baseStyle)) {
                    value = new WParagraphStyle();
                    value.copyStyle(previousFormat.baseStyle);
                    this.currentPropertyIndex++;
                    if (!isNullOrUndefined(format.baseStyle)) {
                        previousFormat.baseStyle = new WParagraphStyle();
                        previousFormat.baseStyle.copyStyle(format.baseStyle);
                    }
                    return value;
                }
                else {
                    if (!isNullOrUndefined(format.baseStyle)) {
                        previousFormat.baseStyle = new WParagraphStyle();
                        previousFormat.baseStyle.copyStyle(format.baseStyle);
                    }
                    return undefined;
                }
            }
            value = previousFormat.getPropertyValue(property);
            previousFormat.copyFormat(format);
            this.currentPropertyIndex++;
        }
        else {
            if (isNullOrUndefined(property)) {
                this.modifiedProperties.push(format.cloneFormat());
            }
            else {
                let currentFormat = new WParagraphFormat(undefined);
                currentFormat.copyFormat(format);
                this.modifiedProperties.push(currentFormat);
            }
        }
        return value;
    }
    /**
     * @private
     */
    addModifiedPropertiesForContinueNumbering(paragraphFormat, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = previousFormat;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = paragraphFormat.cloneFormat();
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = paragraphFormat.cloneFormat();
            }
            this.currentPropertyIndex++;
            return value;
        }
        else {
            let currentFormat = new WParagraphFormat();
            currentFormat.copyFormat(paragraphFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * @param listFormat
     * @param value
     * @private
     */
    addModifiedPropertiesForRestartNumbering(listFormat, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let listId = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = listId;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = listFormat.listId;
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = listFormat.listId;
            }
            this.currentPropertyIndex++;
            return value;
        }
        else {
            this.modifiedProperties.push(listFormat.listId);
        }
        return value;
    }
    /**
     * Add modified properties for list format
     * @param  {WListLevel} listLevel
     * @private
     */
    addModifiedPropertiesForList(listLevel) {
        let value;
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousLevel = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            value = previousLevel;
            previousLevel = new ModifiedLevel(listLevel, this.owner.editorModule.cloneListLevel(listLevel));
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = previousLevel;
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = previousLevel;
            }
            this.currentPropertyIndex++;
        }
        else {
            this.modifiedProperties.push(new ModifiedLevel(listLevel, this.owner.editorModule.cloneListLevel(listLevel)));
            value = listLevel;
        }
        return value;
    }
    /**
     * Revert the properties
     * @param  {SelectionRange} selectionRange
     */
    revertProperties() {
        this.editorHistory.currentBaseHistoryInfo = this;
        this.currentPropertyIndex = 0;
        let property = this.getProperty();
        this.viewer.owner.editorModule.setOffsetValue(this.viewer.selection);
        if (this.action === 'ClearCharacterFormat' || this.modifiedProperties[0] instanceof WCharacterFormat) {
            if (this.action === 'ListCharacterFormat') {
                this.owner.editorModule.updateListCharacterFormat(this.viewer.selection, property, undefined);
                return;
            }
            this.owner.editorModule.updateSelectionCharacterFormatting(property, undefined, false);
        }
        else if (this.action === 'ClearParagraphFormat' || this.modifiedProperties[0] instanceof WParagraphFormat) {
            if (this.action === 'ContinueNumbering') {
                // tslint:disable-next-line:max-line-length
                this.owner.editorModule.revertContinueNumbering(this.owner.selection, this.modifiedProperties[0]);
                return;
            }
            if (this.action === 'StyleName' && this.modifiedProperties[0] instanceof WParagraphFormat) {
                // tslint:disable-next-line:max-line-length
                this.owner.editorModule.updateSelectionParagraphFormatting(property, this.modifiedProperties[0].baseStyle, false);
                return;
            }
            let selection = this.owner.viewer.selection;
            let isBidiList = (selection.paragraphFormat.bidi ||
                (this.modifiedProperties[0] instanceof WParagraphFormat && this.modifiedProperties[0]).bidi) && (selection.paragraphFormat.listId !== -1 || property === 'listFormat');
            if (!isBidiList) {
                this.owner.viewer.layout.isBidiReLayout = true;
            }
            this.owner.editorModule.updateSelectionParagraphFormatting(property, undefined, false);
            if (!isBidiList) {
                this.owner.viewer.layout.isBidiReLayout = false;
            }
        }
        else if (this.modifiedProperties[0] instanceof WSectionFormat) {
            this.owner.editorModule.updateSectionFormat(property, undefined);
        }
        else if (this.action === 'RestartNumbering') {
            this.owner.editorModule.restartListAtInternal(this.owner.selection, this.modifiedProperties[0]);
            return;
        }
        else if (this.modifiedProperties[0] instanceof ImageFormat) {
            this.owner.selection.updateImageSize(this.modifiedProperties[0]);
        }
        else if (this.modifiedProperties[0] instanceof ModifiedLevel) {
            let modified = new Dictionary();
            for (let i = 0; i < this.modifiedProperties.length; i++) {
                let modifiedLevel = this.modifiedProperties[i];
                // modified.modifiedLevels.add(modifiedLevel.ownerListLevel.levelNumber, modifiedLevel);
                modified.add(i, modifiedLevel);
            }
            this.editorHistory.updateListChanges(modified);
            modified.destroy();
            modified = undefined;
        }
        else if (this.modifiedProperties[0] instanceof WTableFormat) {
            this.owner.editorModule.updateTableFormat(this.owner.selection, property, undefined);
        }
        else if (this.modifiedProperties[0] instanceof WCellFormat) {
            this.owner.isShiftingEnabled = true;
            this.owner.editorModule.updateCellFormat(this.owner.selection, property, undefined);
        }
        else if (this.modifiedProperties[0] instanceof WRowFormat) {
            this.owner.editorModule.updateRowFormat(this.owner.selection, property, undefined);
        }
        this.currentPropertyIndex = 0;
        if (this.action === 'ClearCharacterFormat' || this.action === 'ClearParagraphFormat') {
            this.owner.editorModule.getOffsetValue(this.viewer.selection);
        }
    }
    /**
     * Add modified properties for cell options dialog
     * @param  {WCellFormat} format
     * @param  {WTable} table
     * @private
     */
    addModifiedCellOptions(applyFormat, format, table) {
        let currentFormat;
        if (isNullOrUndefined(applyFormat.bottomMargin) && isNullOrUndefined(applyFormat.topMargin)
            && isNullOrUndefined(applyFormat.rightMargin) && isNullOrUndefined(applyFormat.leftMargin)) {
            currentFormat = this.copyCellOptions(table.tableFormat);
        }
        else {
            currentFormat = this.copyCellOptions(applyFormat);
        }
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            format = previousFormat;
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties[this.currentPropertyIndex] = this.copyCellOptions(applyFormat);
            }
            else {
                this.modifiedProperties[this.modifiedProperties.length - 1] = this.copyCellOptions(applyFormat);
            }
            this.currentPropertyIndex++;
            return format;
        }
        else {
            this.modifiedProperties.push(currentFormat);
        }
        return format;
    }
    copyCellOptions(format) {
        let cellFormat = new WCellFormat();
        cellFormat.topMargin = format.topMargin;
        cellFormat.rightMargin = format.rightMargin;
        cellFormat.bottomMargin = format.bottomMargin;
        cellFormat.leftMargin = format.leftMargin;
        return cellFormat;
    }
    /**
     * Add modified properties for cell options dialog
     * @param  {WTableFormat} format
     * @private
     */
    addModifiedTableOptions(format) {
        let currentFormat = this.copyTableOptions(format);
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length           
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (this.currentPropertyIndex < this.modifiedProperties.length) {
                this.modifiedProperties.splice(this.currentPropertyIndex, 1, currentFormat);
            }
            else {
                this.modifiedProperties.splice(this.modifiedProperties.length - 1, 1, currentFormat);
            }
            this.currentPropertyIndex++;
        }
        else {
            this.modifiedProperties.push(currentFormat);
        }
    }
    copyTableOptions(format) {
        let tableFormat = new WTableFormat();
        tableFormat.topMargin = format.topMargin;
        tableFormat.rightMargin = format.rightMargin;
        tableFormat.bottomMargin = format.bottomMargin;
        tableFormat.leftMargin = format.leftMargin;
        tableFormat.cellSpacing = format.cellSpacing;
        return tableFormat;
    }
    getProperty() {
        switch (this.action) {
            case 'Bold':
                return 'bold';
            case 'Italic':
                return 'italic';
            case 'FontColor':
                return 'fontColor';
            case 'FontFamily':
                return 'fontFamily';
            case 'FontSize':
                return 'fontSize';
            case 'HighlightColor':
                return 'highlightColor';
            case 'BaselineAlignment':
                return 'baselineAlignment';
            case 'Strikethrough':
                return 'strikethrough';
            case 'Underline':
                return 'underline';
            case 'AfterSpacing':
                return 'afterSpacing';
            case 'BeforeSpacing':
                return 'beforeSpacing';
            case 'LeftIndent':
                return 'leftIndent';
            case 'RightIndent':
                return 'rightIndent';
            case 'FirstLineIndent':
                return 'firstLineIndent';
            case 'LineSpacingType':
                return 'lineSpacingType';
            case 'LineSpacing':
                return 'lineSpacing';
            case 'TextAlignment':
                return 'textAlignment';
            case 'ListFormat':
                return 'listFormat';
            case 'PageHeight':
                return 'pageHeight';
            case 'PageWidth':
                return 'pageWidth';
            case 'TableAlignment':
                return 'tableAlignment';
            case 'TableLeftIndent':
                return 'leftIndent';
            case 'DefaultCellSpacing':
                return 'cellSpacing';
            case 'LeftMargin':
            case 'CellLeftMargin':
            case 'DefaultCellLeftMargin':
                return 'leftMargin';
            case 'RightMargin':
            case 'CellRightMargin':
            case 'DefaultCellRightMargin':
                return 'rightMargin';
            case 'TopMargin':
            case 'CellTopMargin':
            case 'DefaultCellTopMargin':
                return 'topMargin';
            case 'BottomMargin':
            case 'CellBottomMargin':
            case 'DefaultCellBottomMargin':
                return 'bottomMargin';
            case 'CellContentVerticalAlignment':
                return 'verticalAlignment';
            case 'RowHeight':
                return 'height';
            case 'RowHeightType':
                return 'heightType';
            case 'RowHeader':
                return 'isHeader';
            case 'AllowBreakAcrossPages':
                return 'allowBreakAcrossPages';
            case 'TablePreferredWidth':
            case 'CellPreferredWidth':
                return 'preferredWidth';
            case 'TablePreferredWidthType':
            case 'CellPreferredWidthType':
                return 'preferredWidthType';
            case 'Shading':
                return 'shading';
            case 'StyleName':
                return 'styleName';
            case 'ParagraphBidi':
            case 'TableBidi':
                return 'bidi';
            case 'ContextualSpacing':
                return 'contextualSpacing';
        }
        return undefined;
    }
    getCharacterPropertyValue(property, modifiedProperty) {
        let value;
        if (property === 'bold') {
            value = modifiedProperty.bold;
        }
        else if (property === 'italic') {
            value = modifiedProperty.italic;
        }
        else if (property === 'fontColor') {
            value = modifiedProperty.fontColor;
        }
        else if (property === 'fontFamily') {
            value = modifiedProperty.fontFamily;
        }
        else if (property === 'fontSize') {
            value = modifiedProperty.fontSize;
        }
        else if (property === 'highlightColor') {
            value = modifiedProperty.highlightColor;
        }
        else if (property === 'baselineAlignment') {
            value = modifiedProperty.baselineAlignment;
        }
        else if (property === 'strikethrough') {
            value = modifiedProperty.strikethrough;
        }
        else if (property === 'underline') {
            value = modifiedProperty.underline;
        }
        return value;
    }
    /**
     * Add modified properties for table format
     * @param  {WTableFormat} format
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedTableProperties(format, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousTableFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousTableFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = format.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = format.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'shading') {
                value = previousTableFormat.shading;
            }
            else {
                value = previousTableFormat.getPropertyValue(property);
            }
            previousTableFormat.copyFormat(format);
            this.currentPropertyIndex++;
        }
        else {
            let currentFormat = new WTableFormat();
            currentFormat.copyFormat(format);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * Add modified properties for row format
     * @param  {WRowFormat} rowFormat
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedRowProperties(rowFormat, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = rowFormat.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = rowFormat.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            value = previousFormat.getPropertyValue(property);
            previousFormat.copyFormat(rowFormat);
            this.currentPropertyIndex++;
        }
        else {
            let currentFormat = new WRowFormat();
            currentFormat.copyFormat(rowFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * Add modified properties for cell format
     * @param  {WCellFormat} cellFormat
     * @param  {string} property
     * @param  {Object} value
     * @private
     */
    addModifiedCellProperties(cellFormat, property, value) {
        if (this.editorHistory.isUndoing || this.editorHistory.isRedoing) {
            // tslint:disable-next-line:max-line-length
            let previousFormat = (this.currentPropertyIndex < this.modifiedProperties.length ? this.modifiedProperties[this.currentPropertyIndex] : this.modifiedProperties[this.modifiedProperties.length - 1]);
            if (isNullOrUndefined(property)) {
                value = previousFormat;
                if (this.currentPropertyIndex < this.modifiedProperties.length) {
                    this.modifiedProperties[this.currentPropertyIndex] = cellFormat.cloneFormat();
                }
                else {
                    this.modifiedProperties[this.modifiedProperties.length - 1] = cellFormat.cloneFormat();
                }
                this.currentPropertyIndex++;
                return value;
            }
            if (property === 'shading') {
                value = previousFormat.shading;
            }
            else {
                value = previousFormat.getPropertyValue(property);
            }
            previousFormat.copyFormat(cellFormat);
            this.currentPropertyIndex++;
        }
        else {
            let currentFormat = new WCellFormat();
            currentFormat.copyFormat(cellFormat);
            this.modifiedProperties.push(currentFormat);
        }
        return value;
    }
    /**
     * @private
     */
    destroy() {
        this.selectionStart = undefined;
        this.selectionEnd = undefined;
        this.insertPosition = undefined;
        this.endPosition = undefined;
        if (!isNullOrUndefined(this.modifiedNodeLength)) {
            this.modifiedNodeLength = [];
            this.modifiedNodeLength = undefined;
        }
        if (!isNullOrUndefined(this.modifiedProperties)) {
            for (let i = 0; i < this.modifiedProperties.length; i++) {
                let property = this.modifiedProperties[i];
                if (property instanceof WCharacterFormat) {
                    property.destroy();
                }
                else if (property instanceof WParagraphFormat) {
                    property.destroy();
                }
                else if (property instanceof WSectionFormat) {
                    property.destroy();
                }
                else if (property instanceof ModifiedLevel) {
                    property.destroy();
                }
                this.modifiedProperties.splice(this.modifiedProperties.indexOf(property), 1);
                i--;
            }
            this.modifiedPropertiesIn = undefined;
        }
        if (!isNullOrUndefined(this.removedNodes)) {
            for (let i = 0; i < this.removedNodes.length; i++) {
                let node = this.removedNodes[i];
                if (node instanceof ParagraphWidget) {
                    node.destroyInternal(this.viewer);
                }
                else if (node instanceof ElementBox) {
                    node.destroy();
                }
                this.removedNodes.splice(this.removedNodes.indexOf(node), 1);
                i--;
            }
            this.removedNodesIn = undefined;
        }
        this.ownerIn = undefined;
    }
}

/**
 * Image resizer implementation.
 */
class ImageResizer {
    /**
     * Constructor for image resizer module.
     * @param {DocumentEditor} node
     * @param {LayoutViewer} viewer
     * @private
     */
    constructor(node, viewer) {
        /**
         * @private
         */
        this.resizeContainerDiv = undefined;
        /**
         * @private
         */
        this.topLeftRect = undefined;
        /**
         * @private
         */
        this.topMiddleRect = undefined;
        /**
         * @private
         */
        this.topRightRect = undefined;
        /**
         * @private
         */
        this.bottomLeftRect = undefined;
        /**
         * @private
         */
        this.bottomMiddleRect = undefined;
        /**
         * @private
         */
        this.bottomRightRect = undefined;
        /**
         * @private
         */
        this.leftMiddleRect = undefined;
        /**
         * @private
         */
        this.rightMiddleRect = undefined;
        /**
         * @private
         */
        this.topLeftRectParent = undefined;
        /**
         * @private
         */
        this.topMiddleRectParent = undefined;
        /**
         * @private
         */
        this.topRightRectParent = undefined;
        /**
         * @private
         */
        this.bottomLeftRectParent = undefined;
        /**
         * @private
         */
        this.bottomMiddleRectParent = undefined;
        /**
         * @private
         */
        this.bottomRightRectParent = undefined;
        /**
         * @private
         */
        this.leftMiddleRectParent = undefined;
        /**
         * @private
         */
        this.rightMiddleRectParent = undefined;
        /**
         * @private
         */
        this.resizeMarkSizeIn = 7;
        /**
         * @private
         */
        this.selectedImageWidget = undefined;
        /**
         * @private
         */
        this.baseHistoryInfo = undefined;
        /**
         * @private
         */
        this.isImageResizing = false;
        /**
         * @private
         */
        this.isImageResizerVisible = false;
        /**
         * @private
         */
        this.isImageMoveToNextPage = false;
        /**
         * @private
         */
        this.selectedResizeElement = undefined;
        /**
         * @private
         */
        this.topValue = undefined;
        /**
         * @private
         */
        this.leftValue = undefined;
        this.owner = node;
        this.selectedImageWidget = new Dictionary();
        this.viewer = viewer;
        this.imageResizerPoints = new ImageResizingPoints();
        if (isNullOrUndefined(this.imageResizerDiv) && this.viewer && this.viewer.pageContainer) {
            this.initializeImageResizer();
        }
    }
    /**
     * Gets or Sets the current image element box.
     * @private
     */
    get currentImageElementBox() {
        return this.currentImageElementBoxIn;
    }
    /**
     * @private
     */
    set currentImageElementBox(value) {
        this.currentImageElementBoxIn = value;
    }
    /**
     * Gets or Sets the resize mark size.
     * @private
     */
    get resizeMarkSize() {
        return this.resizeMarkSizeIn;
    }
    /**
     * @private
     */
    set resizeMarkSize(value) {
        this.resizeMarkSizeIn = value;
    }
    /**
     * Gets module name.
     */
    getModuleName() {
        return 'ImageResizer';
    }
    //Image Resizing Methods
    /**
     * Sets image resizer position.
     * @param {number} x - Specifies for image resizer left value.
     * @param {number} y - Specifies for image resizer top value.
     * @param {number} width - Specifies for image resizer width value.
     * @param {number} height - Specifies for image resizer height value.
     * @private
     */
    setImageResizerPositions(x, y, width, height) {
        this.imageResizerDivElement.style.top = y.toString() + 'px';
        this.imageResizerDivElement.style.left = x.toString() + 'px';
        this.imageResizerDivElement.style.borderWidth = '0px';
        this.imageResizerDivElement.style.height = height + 'px';
        this.imageResizerDivElement.style.width = width + 'px';
        this.imageResizerDivElement.style.backgroundColor = 'transparent';
        this.imageResizerDivElement.style.overflow = 'hidden';
        this.imageResizerDivElement.style.position = 'absolute';
    }
    /**
     * Creates image resizer DOM element.
     * @private
     */
    initializeImageResizer() {
        this.imageResizerDivElement = document.createElement('div');
        this.imageResizerDivElement.style.zIndex = '1';
        this.imageResizerDivElement.style.display = 'none';
        this.viewer.pageContainer.appendChild(this.imageResizerDivElement);
    }
    /**
     * Position an image resizer
     * @param {ImageElementBox} elementBox - Specifies the image position.
     * @private
     */
    positionImageResizer(elementBox) {
        this.selectedImageWidget.clear();
        // Initializes the image resizer on demand, i.e at the time of selecting an image for the first time.
        let resizeDiv;
        if (!isNullOrUndefined(this.viewer.currentPage)) {
            resizeDiv = this.imageResizerDivElement;
        }
        if (!isNullOrUndefined(resizeDiv) && !resizeDiv.contains(this.imageResizerDiv)) {
            this.imageResizerDiv = this.initResizeMarks(resizeDiv, this);
        }
        this.imageResizerDiv.style.width = (elementBox.width) + 'px';
        this.imageResizerDiv.style.height = (elementBox.height) + 'px';
        this.currentImageElementBox = elementBox;
        let lineWidget = elementBox.line;
        let top = this.viewer.selection.getTop(lineWidget) + elementBox.margin.top;
        let left = this.viewer.selection.getLeftInternal(lineWidget, elementBox, 0);
        let page = this.viewer.selection.getPage(lineWidget.paragraph);
        this.currentPage = page;
        let x = 0;
        let y = 0;
        if (!isNullOrUndefined(resizeDiv)) {
            this.imageResizerDivElement.style.display = 'block';
            resizeDiv.style.width = page.boundingRectangle.width + 'px';
            resizeDiv.style.height = page.boundingRectangle.height + 'px';
            resizeDiv.style.left = page.boundingRectangle.x + 'px';
            resizeDiv.style.top = page.boundingRectangle.y + 'px';
            resizeDiv.style.borderWidth = '0px';
            resizeDiv.style.backgroundColor = 'transparent';
            resizeDiv.style.overflow = 'hidden';
            resizeDiv.style.position = 'absolute';
        }
        let horizontalWidth = 0;
        let pageWidth = this.viewer.getPageWidth(page);
        let pagelayout = this.viewer;
        // tslint:disable-next-line:max-line-length
        horizontalWidth = parseFloat(this.imageResizerDivElement.style.width);
        x = (this.viewer.visibleBounds.width - horizontalWidth * this.viewer.zoomFactor) / 2;
        if (x < 30) {
            x = 30;
        }
        if (pageWidth < horizontalWidth) {
            x += (horizontalWidth - pageWidth) * this.viewer.zoomFactor / 2;
        }
        // tslint:disable-next-line:max-line-length           
        y = page.boundingRectangle.y * this.viewer.zoomFactor + (this.viewer.pages.indexOf(page) + 1) * 20 * (1 - this.viewer.zoomFactor);
        let currentPageDiv = this.imageResizerDivElement;
        let currentPageDivWidth = parseFloat(currentPageDiv.style.width);
        let currentPageDivHeight = parseFloat(currentPageDiv.style.height);
        let imageResizerDivWidth = parseFloat(this.imageResizerDiv.style.width);
        let imageResizerDivHeight = parseFloat(this.imageResizerDiv.style.height);
        let margin = (this.resizeMarkSize - 1) / 2;
        let width = imageResizerDivWidth + 2 * margin;
        let height = imageResizerDivHeight + 2 * margin;
        if (width > (currentPageDivWidth - left) * this.viewer.zoomFactor + margin) {
            width = (currentPageDivWidth - left) * this.viewer.zoomFactor;
        }
        if (height > (currentPageDivHeight - top) * this.viewer.zoomFactor + margin) {
            height = (currentPageDivHeight - top) * this.viewer.zoomFactor;
        }
        // if (width < imageResizerDivHeight + margin || height < imageResizerDivHeight + margin) {
        // }
        // tslint:disable-next-line:max-line-length
        this.imageResizerDivElement.style.width = parseInt(this.imageResizerDivElement.style.width.replace('px', ''), 10) * this.viewer.zoomFactor + 'px';
        this.imageResizerDivElement.style.height = parseInt(this.imageResizerDivElement.style.height.replace('px', ''), 10) * this.viewer.zoomFactor + 'px';
        height = this.viewer.render.getScaledValue(elementBox.height);
        width = this.viewer.render.getScaledValue(elementBox.width);
        left = this.viewer.render.getScaledValue(left);
        top = this.viewer.render.getScaledValue(top);
        this.setImageResizerPosition(left, top, width, height, this);
        if (!this.selectedImageWidget.containsKey(lineWidget)) {
            let selectedImageInfo = new SelectedImageInfo(elementBox.height, elementBox.width);
            this.selectedImageWidget.add(lineWidget, selectedImageInfo);
        }
    }
    /**
     * Shows the image resizer.
     * @private
     */
    showImageResizer() {
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.style.display = '';
        }
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.style.display = '';
            this.bottomLeftRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.style.display = '';
            this.bottomRightRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.style.display = '';
            this.bottomMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.style.display = '';
            this.rightMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.style.display = '';
            this.topRightRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.style.display = '';
            this.topLeftRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.style.display = '';
            this.leftMiddleRectParent.style.display = '';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.style.display = '';
            this.topMiddleRectParent.style.display = '';
        }
        this.isImageResizerVisible = true;
    }
    /**
     * Hides the image resizer.
     * @private
     */
    hideImageResizer() {
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.style.display = 'none';
        }
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.style.display = 'none';
            this.bottomLeftRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.style.display = 'none';
            this.bottomRightRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.style.display = 'none';
            this.bottomMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.style.display = 'none';
            this.rightMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.style.display = 'none';
            this.topRightRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.style.display = 'none';
            this.topLeftRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.style.display = 'none';
            this.leftMiddleRectParent.style.display = 'none';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.style.display = 'none';
            this.topMiddleRectParent.style.display = 'none';
        }
        this.isImageResizerVisible = false;
        this.currentPage = undefined;
    }
    /**
     * Initialize the resize marks.
     * @param {HTMLElement} resizeDiv - Specifies to appending resizer container div element.
     * @param {ImageResizer} imageResizer - Specifies to creating div element of each position.
     * @private
     */
    // tslint:disable:max-func-body-length
    initResizeMarks(resizeDiv, imageResizer) {
        this.initResizeContainerDiv(imageResizer);
        resizeDiv.appendChild(imageResizer.resizeContainerDiv);
        imageResizer.topRightRectParent = document.createElement('div');
        imageResizer.topRightRectParent.style.cursor = 'ne-resize';
        imageResizer.topRightRectParent.id = this.viewer.owner.containerId + '_TopRightRectParent';
        this.applyProperties(imageResizer.topRightRectParent);
        imageResizer.topRightRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topRightRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topRightRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topRightRectParent);
        imageResizer.topRightRect = document.createElement('div');
        imageResizer.topRightRect.id = this.viewer.owner.containerId + '_TopRightRect';
        imageResizer.topRightRect.style.cursor = 'ne-resize';
        this.applyProperties(imageResizer.topRightRect);
        resizeDiv.appendChild(imageResizer.topRightRect);
        imageResizer.topLeftRectParent = document.createElement('div');
        imageResizer.topLeftRectParent.style.cursor = 'nw-resize';
        imageResizer.topLeftRectParent.id = this.viewer.owner.containerId + '_TopLeftRectParent';
        this.applyProperties(imageResizer.topLeftRectParent);
        imageResizer.topLeftRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topLeftRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topLeftRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topLeftRectParent);
        imageResizer.topLeftRect = document.createElement('div');
        imageResizer.topLeftRect.id = this.viewer.owner.containerId + '_TopLeftRect';
        imageResizer.topLeftRect.style.cursor = 'nw-resize';
        this.applyProperties(imageResizer.topLeftRect);
        resizeDiv.appendChild(imageResizer.topLeftRect);
        imageResizer.topMiddleRectParent = document.createElement('div');
        imageResizer.topMiddleRectParent.style.cursor = 'n-resize';
        imageResizer.topMiddleRectParent.id = this.viewer.owner.containerId + '_TopMiddleRectParent';
        this.applyProperties(imageResizer.topMiddleRectParent);
        imageResizer.topMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.topMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.topMiddleRectParent);
        imageResizer.topMiddleRect = document.createElement('div');
        imageResizer.topMiddleRect.id = this.viewer.owner.containerId + '_TopMiddleRect';
        imageResizer.topMiddleRect.style.cursor = 'n-resize';
        this.applyProperties(imageResizer.topMiddleRect);
        resizeDiv.appendChild(imageResizer.topMiddleRect);
        imageResizer.bottomRightRectParent = document.createElement('div');
        imageResizer.bottomRightRectParent.style.cursor = 'se-resize';
        imageResizer.bottomRightRectParent.id = this.viewer.owner.containerId + '_BottomRightRectParent';
        this.applyProperties(imageResizer.bottomRightRectParent);
        imageResizer.bottomRightRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomRightRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomRightRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomRightRectParent);
        imageResizer.bottomRightRect = document.createElement('div');
        imageResizer.bottomRightRect.id = this.viewer.owner.containerId + '_BottomRightRect';
        imageResizer.bottomRightRect.style.cursor = 'se-resize';
        this.applyProperties(imageResizer.bottomRightRect);
        resizeDiv.appendChild(imageResizer.bottomRightRect);
        imageResizer.bottomLeftRectParent = document.createElement('div');
        imageResizer.bottomLeftRectParent.style.cursor = 'sw-resize';
        imageResizer.bottomLeftRectParent.id = this.viewer.owner.containerId + '_BottomLeftRectParent';
        this.applyProperties(imageResizer.bottomLeftRectParent);
        imageResizer.bottomLeftRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomLeftRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomLeftRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomLeftRectParent);
        imageResizer.bottomLeftRect = document.createElement('div');
        imageResizer.bottomLeftRect.id = this.viewer.owner.containerId + '_BottomLeftRect';
        imageResizer.bottomLeftRect.style.cursor = 'sw-resize';
        this.applyProperties(imageResizer.bottomLeftRect);
        resizeDiv.appendChild(imageResizer.bottomLeftRect);
        imageResizer.bottomMiddleRectParent = document.createElement('div');
        imageResizer.bottomMiddleRectParent.style.cursor = 's-resize';
        imageResizer.bottomMiddleRectParent.id = this.viewer.owner.containerId + '_BottomMiddleRectParent';
        this.applyProperties(imageResizer.bottomMiddleRectParent);
        imageResizer.bottomMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.bottomMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.bottomMiddleRectParent);
        imageResizer.bottomMiddleRect = document.createElement('div');
        imageResizer.bottomMiddleRect.id = this.viewer.owner.containerId + '_BottomMiddleRect';
        imageResizer.bottomMiddleRect.style.cursor = 's-resize';
        this.applyProperties(imageResizer.bottomMiddleRect);
        resizeDiv.appendChild(imageResizer.bottomMiddleRect);
        imageResizer.rightMiddleRectParent = document.createElement('div');
        imageResizer.rightMiddleRectParent.style.cursor = 'e-resize';
        imageResizer.rightMiddleRectParent.id = this.viewer.owner.containerId + '_RightMiddleRectParent';
        this.applyProperties(imageResizer.rightMiddleRectParent);
        imageResizer.rightMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.rightMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.rightMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.rightMiddleRectParent);
        imageResizer.rightMiddleRect = document.createElement('div');
        imageResizer.rightMiddleRect.id = this.viewer.owner.containerId + '_RightMiddleRect';
        imageResizer.rightMiddleRect.style.cursor = 'e-resize';
        this.applyProperties(imageResizer.rightMiddleRect);
        resizeDiv.appendChild(imageResizer.rightMiddleRect);
        imageResizer.leftMiddleRectParent = document.createElement('div');
        imageResizer.leftMiddleRectParent.style.cursor = 'w-resize';
        imageResizer.leftMiddleRectParent.id = this.viewer.owner.containerId + '_LeftMiddleRectParent';
        this.applyProperties(imageResizer.leftMiddleRectParent);
        imageResizer.leftMiddleRectParent.style.width = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.leftMiddleRectParent.style.height = !this.viewer.isTouchInput ? '14px' : '30px';
        imageResizer.leftMiddleRectParent.style.opacity = '-1';
        resizeDiv.appendChild(imageResizer.leftMiddleRectParent);
        imageResizer.leftMiddleRect = document.createElement('div');
        imageResizer.leftMiddleRect.id = this.viewer.owner.containerId + '_LeftMiddleRect';
        imageResizer.leftMiddleRect.style.cursor = 'w-resize';
        this.applyProperties(imageResizer.leftMiddleRect);
        resizeDiv.appendChild(imageResizer.leftMiddleRect);
        return imageResizer.resizeContainerDiv;
    }
    /**
     * Sets the image resizer position.
     * @param {number} left - Specifies for image resizer left value.
     * @param {number} top - Specifies for image resizer top value.
     * @param {number} width - Specifies for image resizer width value.
     * @param {number} height - Specifies for image resizer height value.
     * @param {ImageResizer} imageResizer - Specifies for image resizer.
     * @private
     */
    setImageResizerPosition(left, top, width, height, imageResizer) {
        //Positions Updating For Image Resize Div
        imageResizer.resizeContainerDiv.style.width = width + 'px';
        imageResizer.resizeContainerDiv.style.height = height + 'px';
        imageResizer.resizeContainerDiv.style.left = left - 1 + 'px';
        imageResizer.resizeContainerDiv.style.top = top + 'px';
        //Positions Updating For Image Resizing Points
        imageResizer.topRightRect.style.left = ((left + width) - 5) + 'px';
        imageResizer.topRightRect.style.top = (top - 4) + 'px';
        imageResizer.topLeftRect.style.left = (left - 5) + 'px';
        imageResizer.topLeftRect.style.top = (top - 4) + 'px';
        imageResizer.topMiddleRect.style.left = ((parseFloat(imageResizer.topLeftRect.style.left) + (width / 2)) - 4) + 'px';
        imageResizer.topMiddleRect.style.top = (top - 4) + 'px';
        imageResizer.bottomRightRect.style.left = imageResizer.topRightRect.style.left;
        imageResizer.bottomRightRect.style.top = (parseFloat(imageResizer.topRightRect.style.top) + height) + 'px';
        imageResizer.bottomLeftRect.style.left = imageResizer.topLeftRect.style.left;
        imageResizer.bottomLeftRect.style.top = (parseFloat(imageResizer.topLeftRect.style.top) + height) + 'px';
        imageResizer.bottomMiddleRect.style.left = imageResizer.topMiddleRect.style.left;
        imageResizer.bottomMiddleRect.style.top = (parseFloat(imageResizer.topMiddleRect.style.top) + height) + 'px';
        imageResizer.rightMiddleRect.style.left = ((left + width) - 4) + 'px';
        imageResizer.rightMiddleRect.style.top = (parseFloat(imageResizer.topRightRect.style.top) + (height / 2)) + 'px';
        imageResizer.leftMiddleRect.style.left = imageResizer.topLeftRect.style.left;
        imageResizer.leftMiddleRect.style.top = (parseFloat(imageResizer.topLeftRect.style.top) + (height / 2)) + 'px';
        imageResizer.topRightRectParent.style.left = !this.viewer.isTouchInput ? ((left + width) - 8) + 'px' : ((left + width) - 15) + 'px';
        imageResizer.topRightRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.topLeftRectParent.style.left = !this.viewer.isTouchInput ? (left - 8) + 'px' : (left - 15) + 'px';
        imageResizer.topLeftRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.topMiddleRectParent.style.left = ((parseFloat(imageResizer.topLeftRectParent.style.left) + (width / 2)) - 4) + 'px';
        imageResizer.topMiddleRectParent.style.top = !this.viewer.isTouchInput ? (top - 7) + 'px' : (top - 15) + 'px';
        imageResizer.bottomRightRectParent.style.left = imageResizer.topRightRectParent.style.left;
        imageResizer.bottomRightRectParent.style.top = (parseFloat(imageResizer.topRightRectParent.style.top) + height) + 'px';
        imageResizer.bottomLeftRectParent.style.left = imageResizer.topLeftRectParent.style.left;
        imageResizer.bottomLeftRectParent.style.top = (parseFloat(imageResizer.topLeftRectParent.style.top) + height) + 'px';
        imageResizer.bottomMiddleRectParent.style.left = imageResizer.topMiddleRectParent.style.left;
        imageResizer.bottomMiddleRectParent.style.top = (parseFloat(imageResizer.topMiddleRectParent.style.top) + height) + 'px';
        // tslint:disable-next-line:max-line-length 
        imageResizer.rightMiddleRectParent.style.left = !this.viewer.isTouchInput ? ((left + width) - 7) + 'px' : ((left + width) - 15) + 'px';
        imageResizer.rightMiddleRectParent.style.top = (parseFloat(imageResizer.topRightRectParent.style.top) + (height / 2)) + 'px';
        imageResizer.leftMiddleRectParent.style.left = imageResizer.topLeftRectParent.style.left;
        imageResizer.leftMiddleRectParent.style.top = (parseFloat(imageResizer.topLeftRectParent.style.top) + (height / 2)) + 'px';
        this.setImageResizingPoints(imageResizer);
        if (this.viewer.isTouchInput) {
            this.applyPropertiesForTouch();
        }
        else {
            this.applyPropertiesForMouse();
        }
    }
    /**
     * Sets the image resizing points.
     * @param {ImageResizer} imageResizer - Specifies for position of each resizing elements.
     * @private
     */
    setImageResizingPoints(imageResizer) {
        this.imageResizerPoints.resizeContainerDiv.x = parseFloat(imageResizer.resizeContainerDiv.style.left);
        this.imageResizerPoints.resizeContainerDiv.y = parseFloat(imageResizer.resizeContainerDiv.style.top);
        this.imageResizerPoints.bottomLeftRectParent.x = parseFloat(imageResizer.bottomLeftRectParent.style.left);
        this.imageResizerPoints.bottomLeftRectParent.y = parseFloat(imageResizer.bottomLeftRectParent.style.top);
        this.imageResizerPoints.bottomRightRectParent.x = parseFloat(imageResizer.bottomRightRectParent.style.left);
        this.imageResizerPoints.bottomRightRectParent.y = parseFloat(imageResizer.bottomRightRectParent.style.top);
        this.imageResizerPoints.bottomMiddleRectParent.x = parseFloat(imageResizer.bottomMiddleRectParent.style.left);
        this.imageResizerPoints.bottomMiddleRectParent.y = parseFloat(imageResizer.bottomMiddleRectParent.style.top);
        this.imageResizerPoints.topLeftRectParent.x = parseFloat(imageResizer.topLeftRectParent.style.left);
        this.imageResizerPoints.topLeftRectParent.y = parseFloat(imageResizer.topLeftRectParent.style.top);
        this.imageResizerPoints.topRightRectParent.x = parseFloat(imageResizer.topRightRectParent.style.left);
        this.imageResizerPoints.topRightRectParent.y = parseFloat(imageResizer.topRightRectParent.style.top);
        this.imageResizerPoints.topMiddleRectParent.x = parseFloat(imageResizer.topMiddleRectParent.style.left);
        this.imageResizerPoints.topMiddleRectParent.y = parseFloat(imageResizer.topMiddleRectParent.style.top);
        this.imageResizerPoints.leftMiddleRectParent.x = parseFloat(imageResizer.leftMiddleRectParent.style.left);
        this.imageResizerPoints.leftMiddleRectParent.y = parseFloat(imageResizer.leftMiddleRectParent.style.top);
        this.imageResizerPoints.rightMiddleRectParent.x = parseFloat(imageResizer.rightMiddleRectParent.style.left);
        this.imageResizerPoints.rightMiddleRectParent.y = parseFloat(imageResizer.rightMiddleRectParent.style.top);
    }
    /**
     * Initialize the resize container div element.
     * @param {ImageResizer} imageResizer - Specifies for creating resize container div element.
     * @private
     */
    initResizeContainerDiv(imageResizer) {
        imageResizer.resizeContainerDiv = document.createElement('div');
        imageResizer.resizeContainerDiv.id = this.viewer.owner.containerId + '_ResizeDivElement';
        imageResizer.resizeContainerDiv.style.position = 'absolute';
        imageResizer.resizeContainerDiv.style.border = '1px solid #bfbfbf';
        imageResizer.resizeContainerDiv.style.zIndex = '30';
        imageResizer.resizeContainerDiv.style.backgroundColor = 'transparent';
        imageResizer.resizeContainerDiv.style.display = 'block';
    }
    /**
     * Apply the properties of each resize rectangle element.
     * @param {HTMLDivElement} resizeRectElement - Specifies for applying properties to resize rectangle element.
     * @private
     */
    applyProperties(resizeRectElement) {
        resizeRectElement.style.position = 'absolute';
        resizeRectElement.style.width = '8px';
        resizeRectElement.style.height = '8px';
        resizeRectElement.style.fontSize = '0px';
        resizeRectElement.style.zIndex = ' 551';
        resizeRectElement.style.backgroundColor = '#ffffff';
        resizeRectElement.style.border = '1px solid #bfbfbf';
        resizeRectElement.style.boxShadow = '0 1px 2px 0 #bfbfbf 0.35';
        resizeRectElement.style.color = '#000000';
    }
    /**
     * Handles an image resizing.
     * @param {number} x  - Specifies for left value while resizing.
     * @param {number} y - Specifies for top value while resizing.
     */
    handleImageResizing(touchPoint, prevX, prevY) {
        prevX = prevX / this.viewer.zoomFactor;
        prevY = prevY / this.viewer.zoomFactor;
        this.leftValue = isNullOrUndefined(this.leftValue) ? prevX : this.leftValue;
        this.topValue = isNullOrUndefined(this.topValue) ? prevY : this.topValue;
        let points;
        let id = this.selectedResizeElement.id.split('_');
        let currentElementId = id[id.length - 1];
        switch (currentElementId) {
            case 'TopRightRectParent':
                points = this.topRightResizing(touchPoint);
                prevX = points.left;
                prevY = points.top;
                break;
            case 'TopLeftRectParent':
                points = this.topLeftResizing(touchPoint);
                prevX = -points.left;
                prevY = -points.top;
                break;
            case 'TopMiddleRectParent':
                prevX = 0;
                prevY = this.topMiddleResizing(touchPoint);
                break;
            case 'BottomRightRectParent':
                points = this.bottomRightResizing(touchPoint);
                prevX = points.left;
                prevY = points.top;
                break;
            case 'BottomLeftRectParent':
                points = this.bottomLeftResizing(touchPoint);
                prevX = -points.left;
                prevY = -points.top;
                break;
            case 'BottomMiddleRectParent':
                prevY = touchPoint.y - prevY;
                prevX = 0;
                break;
            case 'RightMiddleRectParent':
                prevX = touchPoint.x - prevX;
                prevY = 0;
                break;
            case 'LeftMiddleRectParent':
                prevX = this.leftMiddleResizing(touchPoint);
                prevY = 0;
                break;
            default:
                break;
        }
        if (prevX !== 0 || prevY !== 0) {
            let widget = this.currentImageElementBox.line.paragraph;
            let image = this.currentImageElementBox;
            if (!isNullOrUndefined(widget) && widget.isInsideTable) {
                let cellWidget = widget.containerWidget;
                if (!isNullOrUndefined(cellWidget)) {
                    let rowWidget = cellWidget.containerWidget;
                    let imageHeight = HelperMethods.convertPointToPixel(image.height);
                    let widgetHeight = rowWidget.height - imageHeight;
                    if (prevY > 0 && rowWidget.y + widgetHeight + imageHeight + prevY > this.viewer.clientArea.bottom) {
                        this.isImageMoveToNextPage = true;
                    }
                }
            }
            // tslint:disable-next-line:max-line-length 
            if (this.owner.enableHistoryMode) {
                this.initHistoryForImageResizer(this.currentImageElementBox);
            }
            if (!isNullOrUndefined(this.currentImageElementBox)) {
                // tslint:disable-next-line:max-line-length   
                let width = this.currentImageElementBox.width + prevX > 10 ? this.currentImageElementBox.width + prevX : 10;
                // tslint:disable-next-line:max-line-length 
                let height = this.currentImageElementBox.height + prevY > 10 ? this.currentImageElementBox.height + prevY : 10;
                if (currentElementId === 'BottomRightRectParent'
                    || currentElementId === 'TopRightRectParent'
                    || currentElementId === 'BottomLeftRectParent'
                    || currentElementId === 'TopLeftRectParent') {
                    height = this.currentImageElementBox.height / this.currentImageElementBox.width * width;
                    width = this.currentImageElementBox.width / this.currentImageElementBox.height * height;
                }
                this.currentImageElementBox.width = width;
                this.currentImageElementBox.height = height;
                let owner = this.currentImageElementBox.line.paragraph;
                this.positionImageResizer(this.currentImageElementBox);
            }
            this.isImageResizing = true;
        }
    }
    /**
     * Handles image resizing on mouse.
     * @param {MouseEvent} event - Specifies for image resizing using mouse event.
     * @private
     */
    handleImageResizingOnMouse(event) {
        if (!isNullOrUndefined(this.selectedResizeElement)) {
            let prevX = parseFloat(this.selectedResizeElement.style.left);
            let prevY = parseFloat(this.selectedResizeElement.style.top);
            let cursorPoint = new Point(event.offsetX, event.offsetY);
            let touchPoint = this.viewer.findFocusedPage(cursorPoint, true);
            this.handleImageResizing(touchPoint, prevX, prevY);
        }
    }
    topMiddleResizing(touchPoint) {
        let prevY;
        if (this.topValue >= touchPoint.y) {
            prevY = this.topValue / touchPoint.y;
            this.topValue = touchPoint.y;
            if (this.viewer instanceof PageLayoutViewer) {
                if (this.topValue <= this.viewer.pageGap) {
                    prevY = 1;
                }
            }
        }
        else {
            prevY = -(touchPoint.y / this.topValue);
            this.topValue = touchPoint.y;
            if (this.topValue === 0) {
                prevY = -1;
            }
        }
        return prevY;
    }
    leftMiddleResizing(touchPoint) {
        let prevX;
        if (this.leftValue >= touchPoint.x) {
            prevX = this.leftValue / touchPoint.x;
            this.leftValue = touchPoint.x;
            if (this.leftValue === 0) {
                prevX = 1;
                this.leftValue = parseFloat(this.selectedResizeElement.style.left);
            }
        }
        else {
            prevX = -(touchPoint.x / this.leftValue);
            this.leftValue = touchPoint.x;
        }
        return prevX;
    }
    topRightResizing(touchPoint) {
        let points;
        if (this.leftValue <= touchPoint.x && this.topValue >= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    topLeftResizing(touchPoint) {
        let points;
        if (this.leftValue >= touchPoint.x && this.topValue >= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    bottomRightResizing(touchPoint) {
        let points;
        if (this.leftValue <= touchPoint.x && this.topValue <= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    bottomLeftResizing(touchPoint) {
        let points;
        if (this.leftValue >= touchPoint.x && this.topValue <= touchPoint.y) {
            points = this.getOuterResizingPoint(touchPoint);
        }
        else {
            points = this.getInnerResizingPoint(touchPoint);
        }
        return points;
    }
    getOuterResizingPoint(touchPoint) {
        let prevX;
        let prevY;
        prevX = touchPoint.x - this.leftValue;
        this.leftValue = touchPoint.x;
        prevY = touchPoint.y - this.topValue;
        this.topValue = touchPoint.y;
        return { left: prevX, top: prevY };
    }
    getInnerResizingPoint(touchPoint) {
        let prevX;
        let prevY;
        prevX = -(this.leftValue - touchPoint.x);
        this.leftValue = touchPoint.x;
        prevY = -(this.topValue - touchPoint.y);
        this.topValue = touchPoint.y;
        return { left: prevX, top: prevY };
    }
    /**
     * Handles image resizing on touch.
     * @param {TouchEvent} touchEvent - Specifies for image resizing using touch event.
     * @private
     */
    handleImageResizingOnTouch(touchEvent) {
        if (!isNullOrUndefined(this.selectedResizeElement)) {
            let prevX = parseFloat(this.selectedResizeElement.style.left) + 24;
            let prevY = parseFloat(this.selectedResizeElement.style.top) + 24;
            let touch = touchEvent.touches;
            let cursorPoint = new Point(touch[0].clientX, touch[0].clientY);
            let touchPoint = this.viewer.findFocusedPage(cursorPoint, true);
            if (isNullOrUndefined(this.currentImageElementBox) || isNullOrUndefined(this.currentImageElementBox)) {
                return;
            }
            this.handleImageResizing(touchPoint, prevX, prevY);
        }
    }
    /**
     * Gets the image point of mouse.
     * @param {Point} touchPoint - Specifies for resizer cursor position.
     * @private
     */
    getImagePoint(touchPoint) {
        let x = this.viewer.render.getScaledValue(touchPoint.x, 1);
        let y = this.viewer.render.getScaledValue(touchPoint.y, 2);
        touchPoint = new Point(x, y);
        let imageResizingPoints = this.imageResizerPoints;
        let resizePosition = '';
        let selectedElement = undefined;
        let bottomMiddle = imageResizingPoints.bottomMiddleRectParent;
        let bottomRight = imageResizingPoints.bottomRightRectParent;
        let bottomLeft = imageResizingPoints.bottomLeftRectParent;
        let topMiddle = imageResizingPoints.topMiddleRectParent;
        let topRight = imageResizingPoints.topRightRectParent;
        let topLeft = imageResizingPoints.topLeftRectParent;
        let rightMiddle = imageResizingPoints.rightMiddleRectParent;
        let leftMiddle = imageResizingPoints.leftMiddleRectParent;
        if (!isNullOrUndefined(this.bottomMiddleRectParent) && this.bottomMiddleRectParent.style.display !== 'none') {
            // tslint:disable-next-line:max-line-length   
            if ((touchPoint.x > bottomMiddle.x && touchPoint.x <= bottomMiddle.x + 15) && (touchPoint.y > bottomMiddle.y && touchPoint.y <= bottomMiddle.y + 15)) {
                selectedElement = this.bottomMiddleRectParent;
                resizePosition = 's-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > bottomRight.x && touchPoint.x <= bottomRight.x + 15) && (touchPoint.y > bottomRight.y && touchPoint.y <= bottomRight.y + 15)) {
                selectedElement = this.bottomRightRectParent;
                resizePosition = 'se-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > bottomLeft.x && touchPoint.x <= bottomLeft.x + 15) && (touchPoint.y > bottomLeft.y && touchPoint.y <= bottomLeft.y + 15)) {
                selectedElement = this.bottomLeftRectParent;
                resizePosition = 'sw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topMiddle.x && touchPoint.x <= topMiddle.x + 15) && (touchPoint.y > topMiddle.y && touchPoint.y <= topMiddle.y + 15)) {
                selectedElement = this.topMiddleRectParent;
                resizePosition = 'n-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topRight.x && touchPoint.x <= topRight.x + 15) && (touchPoint.y > topRight.y && touchPoint.y <= topRight.y + 15)) {
                selectedElement = this.topRightRectParent;
                resizePosition = 'ne-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > topLeft.x && touchPoint.x <= topLeft.x + 15) && (touchPoint.y > topLeft.y && touchPoint.y <= topLeft.y + 15)) {
                selectedElement = this.topLeftRectParent;
                resizePosition = 'nw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > leftMiddle.x && touchPoint.x <= leftMiddle.x + 15) && (touchPoint.y > leftMiddle.y && touchPoint.y <= leftMiddle.y + 15)) {
                selectedElement = this.leftMiddleRectParent;
                resizePosition = 'w-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoint.x > rightMiddle.x && touchPoint.x <= rightMiddle.x + 15) && (touchPoint.y > rightMiddle.y && touchPoint.y <= rightMiddle.y + 15)) {
                selectedElement = this.rightMiddleRectParent;
                resizePosition = 'e-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if (!isNullOrUndefined(this.resizeContainerDiv) && (touchPoint.x > parseFloat(this.resizeContainerDiv.style.left)
                && touchPoint.x <= (parseFloat(this.resizeContainerDiv.style.left) + parseFloat(this.resizeContainerDiv.style.width)))
                && (touchPoint.y > parseFloat(this.resizeContainerDiv.style.top)
                    // tslint:disable-next-line:max-line-length 
                    && touchPoint.y <= (parseFloat(this.resizeContainerDiv.style.top) + parseFloat(this.resizeContainerDiv.style.height)))) {
                resizePosition = 'move';
            }
        }
        return { 'selectedElement': selectedElement, 'resizePosition': resizePosition };
    }
    applyPropertiesForMouse() {
        if (!isNullOrUndefined(this.bottomLeftRectParent)) {
            this.bottomMiddleRectParent.style.width = '14px';
            this.bottomMiddleRectParent.style.height = '14px';
            this.bottomRightRectParent.style.width = '14px';
            this.bottomRightRectParent.style.height = '14px';
            this.bottomLeftRectParent.style.width = '14px';
            this.bottomLeftRectParent.style.height = '14px';
            this.topMiddleRectParent.style.width = '14px';
            this.topMiddleRectParent.style.height = '14px';
            this.topRightRectParent.style.width = '14px';
            this.topRightRectParent.style.height = '14px';
            this.topLeftRectParent.style.width = '14px';
            this.topLeftRectParent.style.height = '14px';
            this.leftMiddleRectParent.style.width = '14px';
            this.leftMiddleRectParent.style.height = '14px';
            this.rightMiddleRectParent.style.width = '14px';
            this.rightMiddleRectParent.style.height = '14px';
        }
    }
    /**
     * Gets the image point of touch.
     * @param {Point} touchPoints - Specifies for resizer cursor position.
     * @private
     */
    getImagePointOnTouch(touchPoints) {
        let x = this.viewer.render.getScaledValue(touchPoints.x, 1);
        let y = this.viewer.render.getScaledValue(touchPoints.y, 2);
        touchPoints = new Point(x, y);
        let imageResizingPointsOnTouch = this.imageResizerPoints;
        let resizePosition = '';
        let selectedElements = undefined;
        let bottomMiddle = imageResizingPointsOnTouch.bottomMiddleRectParent;
        let bottomRight = imageResizingPointsOnTouch.bottomRightRectParent;
        let bottomLeft = imageResizingPointsOnTouch.bottomLeftRectParent;
        let topMiddle = imageResizingPointsOnTouch.topMiddleRectParent;
        let topRight = imageResizingPointsOnTouch.topRightRectParent;
        let topLeft = imageResizingPointsOnTouch.topLeftRectParent;
        let rightMiddle = imageResizingPointsOnTouch.rightMiddleRectParent;
        let leftMiddle = imageResizingPointsOnTouch.leftMiddleRectParent;
        if (!isNullOrUndefined(this.bottomMiddleRectParent) && this.bottomMiddleRectParent.style.display !== 'none') {
            // tslint:disable-next-line:max-line-length   
            if ((touchPoints.x > bottomMiddle.x && touchPoints.x <= bottomMiddle.x + 25) && (touchPoints.y > bottomMiddle.y && touchPoints.y <= bottomMiddle.y + 25)) {
                selectedElements = this.bottomMiddleRectParent;
                resizePosition = 's-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > bottomRight.x && touchPoints.x <= bottomRight.x + 25) && (touchPoints.y > bottomRight.y && touchPoints.y <= bottomRight.y + 25)) {
                selectedElements = this.bottomRightRectParent;
                resizePosition = 'se-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > bottomLeft.x && touchPoints.x <= bottomLeft.x + 25) && (touchPoints.y > bottomLeft.y && touchPoints.y <= bottomLeft.y + 25)) {
                selectedElements = this.bottomLeftRectParent;
                resizePosition = 'sw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topMiddle.x && touchPoints.x <= topMiddle.x + 25) && (touchPoints.y > topMiddle.y && touchPoints.y <= topMiddle.y + 25)) {
                selectedElements = this.topMiddleRectParent;
                resizePosition = 'n-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topRight.x && touchPoints.x <= topRight.x + 25) && (touchPoints.y > topRight.y && touchPoints.y <= topRight.y + 25)) {
                selectedElements = this.topRightRectParent;
                resizePosition = 'ne-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > topLeft.x && touchPoints.x <= topLeft.x + 25) && (touchPoints.y > topLeft.y && touchPoints.y <= topLeft.y + 25)) {
                selectedElements = this.topLeftRectParent;
                resizePosition = 'nw-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > leftMiddle.x && touchPoints.x <= leftMiddle.x + 25) && (touchPoints.y > leftMiddle.y && touchPoints.y <= leftMiddle.y + 25)) {
                selectedElements = this.leftMiddleRectParent;
                resizePosition = 'w-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if ((touchPoints.x > rightMiddle.x && touchPoints.x <= rightMiddle.x + 25) && (touchPoints.y > rightMiddle.y && touchPoints.y <= rightMiddle.y + 25)) {
                selectedElements = this.rightMiddleRectParent;
                resizePosition = 'e-resize';
                // tslint:disable-next-line:max-line-length   
            }
            else if (!isNullOrUndefined(this.resizeContainerDiv) && (touchPoints.x > parseFloat(this.resizeContainerDiv.style.left)
                && touchPoints.x <= (parseFloat(this.resizeContainerDiv.style.left) + parseFloat(this.resizeContainerDiv.style.width)))
                && (touchPoints.y > parseFloat(this.resizeContainerDiv.style.top)
                    // tslint:disable-next-line:max-line-length 
                    && touchPoints.y <= (parseFloat(this.resizeContainerDiv.style.top) + parseFloat(this.resizeContainerDiv.style.height)))) {
                resizePosition = 'move';
            }
        }
        return { 'selectedElement': selectedElements, 'resizePosition': resizePosition };
    }
    applyPropertiesForTouch() {
        if (!isNullOrUndefined(this.bottomLeftRectParent)) {
            this.bottomMiddleRectParent.style.width = '30px';
            this.bottomMiddleRectParent.style.height = '30px';
            this.bottomRightRectParent.style.width = '30px';
            this.bottomRightRectParent.style.height = '30px';
            this.bottomLeftRectParent.style.width = '30px';
            this.bottomLeftRectParent.style.height = '30px';
            this.topMiddleRectParent.style.width = '30px';
            this.topMiddleRectParent.style.height = '30px';
            this.topRightRectParent.style.width = '30px';
            this.topRightRectParent.style.height = '30px';
            this.topLeftRectParent.style.width = '30px';
            this.topLeftRectParent.style.height = '30px';
            this.leftMiddleRectParent.style.width = '30px';
            this.leftMiddleRectParent.style.height = '30px';
            this.rightMiddleRectParent.style.width = '30px';
            this.rightMiddleRectParent.style.height = '30px';
        }
    }
    /**
     * @private
     */
    mouseUpInternal() {
        this.currentImageElementBox.width = parseFloat(this.imageResizerDiv.style.width) / this.viewer.zoomFactor;
        this.currentImageElementBox.height = parseFloat(this.imageResizerDiv.style.height) / this.viewer.zoomFactor;
        this.owner.isShiftingEnabled = true;
        this.owner.editorModule.setOffsetValue(this.owner.selection);
        this.viewer.layout.reLayoutParagraph(this.currentImageElementBox.line.paragraph, 0, 0);
        this.owner.editorModule.reLayout(this.owner.selection, true);
        this.viewer.updateScrollBars();
    }
    /**
     * Initialize history for image resizer.
     * @param {ImageResizer} imageResizer - Specifies for image resizer.
     * @param {WImage} imageContainer - Specifies for an image.
     * @private
     */
    initHistoryForImageResizer(imageContainer) {
        if (!isNullOrUndefined(this.owner) && isNullOrUndefined(this.baseHistoryInfo)) {
            this.baseHistoryInfo = new BaseHistoryInfo(this.owner);
            this.baseHistoryInfo.action = 'ImageResizing';
            this.baseHistoryInfo.updateSelection();
            this.baseHistoryInfo.modifiedProperties.push(new ImageFormat(imageContainer));
        }
    }
    /**
     * Updates histroy for image resizer.
     * @private
     */
    updateHistoryForImageResizer() {
        if (!isNullOrUndefined(this.owner) && !isNullOrUndefined(this.baseHistoryInfo)) {
            let imageFormat = this.baseHistoryInfo.modifiedProperties[0];
            if (this.currentImageElementBox.width === imageFormat.width
                && this.currentImageElementBox.height === imageFormat.height) {
                this.baseHistoryInfo.modifiedProperties.pop();
            }
            else {
                //Records the image size modifications
                this.owner.editorHistory.recordChanges(this.baseHistoryInfo);
            }
            //Fires the content changed event for the image size modifications
            this.baseHistoryInfo = undefined;
        }
    }
    /**
     * Updates image resize container when applying zooming
     * @private
     */
    updateImageResizerPosition() {
        if (!isNullOrUndefined(this.currentImageElementBox)) {
            let elementBox = this.currentImageElementBox;
            let lineWidget = elementBox.line;
            let top = this.viewer.selection.getTop(lineWidget) + elementBox.margin.top;
            let left = this.viewer.selection.getLeftInternal(lineWidget, elementBox, 0);
            let topValue = top * this.viewer.zoomFactor;
            let leftValue = left * this.viewer.zoomFactor;
            let height = this.viewer.render.getScaledValue(elementBox.height, 2);
            let width = this.viewer.render.getScaledValue(elementBox.width, 1);
            this.setImageResizerPosition(leftValue, topValue, width, height, this);
        }
    }
    /**
     * Dispose the internal objects which are maintained.
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.resizeContainerDiv)) {
            this.resizeContainerDiv.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topLeftRect)) {
            this.topLeftRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topMiddleRect)) {
            this.topMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.topRightRect)) {
            this.topRightRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomLeftRect)) {
            this.bottomLeftRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomMiddleRect)) {
            this.bottomMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.bottomRightRect)) {
            this.bottomRightRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.leftMiddleRect)) {
            this.leftMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.rightMiddleRect)) {
            this.rightMiddleRect.innerHTML = '';
        }
        if (!isNullOrUndefined(this.imageResizerDiv)) {
            this.imageResizerDiv.innerHTML = '';
        }
        if (!isNullOrUndefined(this.selectedImageWidget)) {
            this.selectedImageWidget.destroy();
        }
        if (!isNullOrUndefined(this.imageResizerDivElement)) {
            this.imageResizerDivElement.innerHTML = '';
        }
        this.imageResizerDivElement = undefined;
        this.resizeContainerDiv = undefined;
        this.topLeftRect = undefined;
        this.topMiddleRect = undefined;
        this.topRightRect = undefined;
        this.bottomLeftRect = undefined;
        this.bottomMiddleRect = undefined;
        this.bottomRightRect = undefined;
        this.leftMiddleRect = undefined;
        this.rightMiddleRect = undefined;
        this.imageResizerDiv = undefined;
        this.selectedImageWidget = undefined;
        this.isImageResizing = false;
        this.isImageResizerVisible = false;
        this.currentImageElementBoxIn = undefined;
        //this.baseHistoryInfo = undefined;
        this.resizeMarkSizeIn = undefined;
        this.viewer = undefined;
        this.owner = undefined;
    }
}
/**
 * @private
 */
class ImageResizingPoints {
    /**
     * Constructor for image resizing points class.
     */
    constructor() {
        /**
         * @private
         */ this.resizeContainerDiv = new Point(0, 0);
        /**
         * @private
         */
        this.topLeftRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.topMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.topRightRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomLeftRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.bottomRightRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.leftMiddleRectParent = new Point(0, 0);
        /**
         * @private
         */
        this.rightMiddleRectParent = new Point(0, 0);
        
    }
}
/**
 * @private
 */
class SelectedImageInfo {
    /**
     * Constructor for selected image info class.
     * @param {number} height - Specifies for height value.
     * @param {number} width - Specifies for width value.
     */
    constructor(height, width) {
        this.heightIn = 0;
        this.widthIn = 0;
        this.heightIn = height;
        this.widthIn = width;
    }
    /**
     * Gets or Sets the height value.
     * @private
     */
    get height() {
        return this.heightIn;
    }
    /**
     * @private
     */
    set height(value) {
        this.heightIn = value;
    }
    /**
     * Gets or Sets the width value.
     * @private
     */
    get width() {
        return this.widthIn;
    }
    /**
     * @private
     */
    set width(value) {
        this.widthIn = value;
    }
}

/**
 * Editor Export
 */

/**
 * EditorHistory preservation class
 */
/**
 * @private
 */
class HistoryInfo extends BaseHistoryInfo {
    constructor(node, isChild) {
        super(node);
        this.isChildHistoryInfo = false;
        this.editRangeStart = undefined;
        this.isChildHistoryInfo = isChild;
    }
    /**
     * @private
     */
    get hasAction() {
        return !isNullOrUndefined(this.modifiedActions);
    }
    /**
     * Adds the modified actions
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @private
     */
    addModifiedAction(baseHistoryInfo) {
        // For complex actions such as Replace text, Insert/Remove Hyperlink etc.
        if (!(this.editorHistory.isUndoing || this.editorHistory.isRedoing)) {
            if (isNullOrUndefined(this.modifiedActions)) {
                this.modifiedActions = [];
            }
            this.modifiedActions.push(baseHistoryInfo);
        }
    }
    /**
     * Reverts this instance
     * @private
     */
    revert() {
        this.editorHistory.currentHistoryInfo = this;
        if (this.action === 'BordersAndShading') {
            this.owner.editorModule.isBordersAndShadingDialog = true;
        }
        if (!isNullOrUndefined(this.modifiedActions)) {
            if (this.editorHistory.isUndoing) {
                let i = this.modifiedActions.length;
                while (i > 0) {
                    let baseHistoryInfo = this.modifiedActions[i - 1];
                    baseHistoryInfo.revert();
                    i = i - 1;
                }
            }
            else {
                let i = 0;
                while (i < this.modifiedActions.length) {
                    let baseHistoryInfo = this.modifiedActions[i];
                    baseHistoryInfo.revert();
                    i = i + 1;
                }
            }
        }
        if (this.action === 'RestrictEditing') {
            let user = this.editRangeStart.user !== '' ? this.editRangeStart.user : this.editRangeStart.group;
            if (this.editorHistory.isUndoing) {
                let index = this.owner.viewer.editRanges.get(user).indexOf(this.editRangeStart);
                if (index !== -1) {
                    this.owner.viewer.editRanges.get(user).splice(index, 1);
                }
            }
            else {
                this.owner.editor.updateRangeCollection(this.editRangeStart, user);
            }
            this.owner.selection.updateEditRangeCollection();
        }
        if (!this.isChildHistoryInfo) {
            this.editorHistory.updateComplexHistory();
        }
        else {
            this.editorHistory.updateComplexHistoryInternal();
        }
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.modifiedActions)) {
            while (this.modifiedActions.length > 0) {
                let baseHistoryInfo = this.modifiedActions[this.modifiedActions.length - 1];
                baseHistoryInfo.destroy();
                this.modifiedActions.splice(this.modifiedActions.indexOf(baseHistoryInfo), 1);
            }
            this.modifiedActions = undefined;
        }
        super.destroy();
    }
}

/**
 *  `EditorHistory` Module class is used to handle history preservation
 */
class EditorHistory {
    /**
     * @private
     */
    constructor(node) {
        //Fields
        this.undoStackIn = [];
        this.redoStackIn = [];
        this.historyInfoStack = [];
        /**
         * @private
         */
        this.isUndoing = false;
        /**
         * @private
         */
        this.isRedoing = false;
        this.owner = node;
        this.viewer = node.viewer;
        this.modifiedParaFormats = new Dictionary();
        this.undoLimitIn = 500;
        this.redoLimitIn = 500;
    }
    /**
     * @private
     */
    get currentHistoryInfo() {
        return this.historyInfoStack && this.historyInfoStack.length > 0 ?
            this.historyInfoStack[this.historyInfoStack.length - 1] : undefined;
    }
    set currentHistoryInfo(value) {
        if (value instanceof HistoryInfo) {
            this.historyInfoStack.push(value);
        }
        else {
            this.historyInfoStack.pop();
        }
    }
    //Properties
    /**
     * gets undo stack
     * @private
     */
    get undoStack() { return this.undoStackIn; }
    /**
     * gets redo stack
     * @private
     */
    get redoStack() { return this.redoStackIn; }
    /**
     * Gets or Sets the limit of undo operations can be done.
     * @aspType int
     * @blazorType int
     */
    get undoLimit() {
        return isNullOrUndefined(this.undoLimitIn) ? 0 : this.undoLimitIn;
    }
    /**
     * Sets the limit of undo operations can be done.
     * @aspType int
     * @blazorType int
     */
    set undoLimit(value) {
        if (value < 0) {
            throw new Error('The limit should be greater than or equal to zero.');
        }
        this.undoLimitIn = value;
    }
    /**
     * Gets or Sets the limit of redo operations can be done.
     * @aspType int
     * @blazorType int
     */
    get redoLimit() {
        return isNullOrUndefined(this.redoLimitIn) ? 0 : this.redoLimitIn;
    }
    /**
     * Gets or Sets the limit of redo operations can be done.
     * @aspType int
     * @blazorType int
     */
    set redoLimit(value) {
        if (value < 0) {
            throw new Error('The limit should be greater than or equal to zero.');
        }
        this.redoLimitIn = value;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'EditorHistory';
    }
    /**
     * Determines whether undo operation can be done.
     * @returns boolean
     */
    canUndo() {
        return !isNullOrUndefined(this.undoStack) && this.undoStack.length > 0;
    }
    /**
     * Determines whether redo operation can be done.
     * @returns boolean
     */
    canRedo() {
        return !isNullOrUndefined(this.redoStack) && this.redoStack.length > 0;
    }
    //EditorHistory Initialization    
    /**
     * initialize EditorHistory
     * @param  {Selection} selection
     * @param  {Action} action
     * @param  {SelectionRange} selectionRange
     * @private
     */
    initializeHistory(action) {
        this.currentBaseHistoryInfo = new BaseHistoryInfo(this.owner);
        this.currentBaseHistoryInfo.action = action;
        this.currentBaseHistoryInfo.updateSelection();
    }
    /**
     * Initialize complex history
     * @param  {Selection} selection
     * @param  {Action} action
     * @private
     */
    initComplexHistory(selection, action) {
        this.currentHistoryInfo = new HistoryInfo(selection.owner, !isNullOrUndefined(this.currentHistoryInfo));
        this.currentHistoryInfo.action = action;
        this.currentHistoryInfo.updateSelection();
    }
    /**
     * @private
     */
    initResizingHistory(startingPoint, tableResize) {
        if (tableResize.resizeNode === 1) {
            this.initializeHistory('RowResizing');
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                // tslint:disable-next-line:max-line-length
                this.currentBaseHistoryInfo.modifiedProperties.push(new RowHistoryFormat(startingPoint, tableResize.currentResizingTable.childWidgets[tableResize.resizerPosition].rowFormat));
            }
        }
        else {
            this.initializeHistory('CellResizing');
            if (this.currentBaseHistoryInfo) {
                tableResize.currentResizingTable = tableResize.currentResizingTable.combineWidget(this.viewer);
                let tableHistoryInfo = new TableHistoryInfo(tableResize.currentResizingTable, this.owner);
                tableHistoryInfo.startingPoint = startingPoint;
                this.currentBaseHistoryInfo.modifiedProperties.push(tableHistoryInfo);
            }
        }
    }
    /**
     * Update resizing history
     * @param  {Point} point
     * @param  {Selection} selection
     * @private
     */
    updateResizingHistory(point, tableResize) {
        if (tableResize.resizeNode === 1) {
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                let rowHistoryFormat = this.currentBaseHistoryInfo.modifiedProperties[0];
                if (rowHistoryFormat.startingPoint.y === point.y) {
                    this.currentBaseHistoryInfo.modifiedProperties.length = 0;
                }
                else {
                    rowHistoryFormat.displacement = HelperMethods.convertPixelToPoint(point.y - rowHistoryFormat.startingPoint.y);
                    this.recordChanges(this.currentBaseHistoryInfo);
                    this.currentBaseHistoryInfo = undefined;
                }
            }
        }
        else {
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                let cellHistoryFormat = this.currentBaseHistoryInfo.modifiedProperties[0];
                if (cellHistoryFormat.startingPoint.x === point.x) {
                    this.currentBaseHistoryInfo.modifiedProperties.length = 0;
                }
                else {
                    cellHistoryFormat.displacement = HelperMethods.convertPixelToPoint(point.x - cellHistoryFormat.startingPoint.x);
                    cellHistoryFormat.endIndex = tableResize.getCellReSizerPosition(point);
                    this.owner.editorHistory.recordChanges(this.currentBaseHistoryInfo);
                    this.currentBaseHistoryInfo = undefined;
                }
            }
        }
    }
    /**
     * Record the changes
     * @param  {BaseHistoryInfo} baseHistoryInfo
     * @private
     */
    recordChanges(baseHistoryInfo) {
        if (!this.owner.enableHistoryMode) {
            return;
        }
        if (this.isUndoing) {
            if (isNullOrUndefined(this.redoStack)) {
                this.redoStackIn = [];
            }
            if (this.redoStack.length === this.redoLimit && this.redoLimit > 0) {
                let count = this.undoLimit > 20 ? 10 : 1;
                this.redoStackIn.splice(0, count);
            }
            if (this.redoStack.length < this.redoLimit) {
                this.redoStack.push(baseHistoryInfo);
            }
        }
        else {
            if (!this.isRedoing) {
                this.clearRedoStack();
            }
            if (isNullOrUndefined(this.undoStack)) {
                this.undoStackIn = [];
            }
            if (this.undoStack.length === this.undoLimit && this.undoLimit > 0) {
                let count = this.undoLimit > 20 ? 10 : 1;
                this.undoStackIn.splice(0, count);
            }
            if (this.undoStack.length < this.undoLimit) {
                this.undoStackIn.push(baseHistoryInfo);
            }
        }
    }
    /**
     * update EditorHistory
     * @private
     */
    updateHistory() {
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.currentBaseHistoryInfo)) {
            //Updates the current end position
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)
                && isNullOrUndefined(this.currentBaseHistoryInfo.endPosition)) {
                this.currentBaseHistoryInfo.endPosition = this.currentBaseHistoryInfo.insertPosition;
            }
            if (!isNullOrUndefined(this.currentHistoryInfo)) {
                this.currentHistoryInfo.addModifiedAction(this.currentBaseHistoryInfo);
            }
            else {
                this.recordChanges(this.currentBaseHistoryInfo);
            }
            this.currentBaseHistoryInfo = undefined;
        }
    }
    /**
     * @private
     */
    isHandledComplexHistory() {
        let isHandledComplexHistory = false;
        if (!(this.isUndoing || this.isRedoing)) {
            isHandledComplexHistory = this.owner.editorModule.insertRemoveBookMarkElements();
        }
        if (this.viewer.owner.enableHistoryMode && !isNullOrUndefined(this.currentHistoryInfo)) {
            this.updateHistory();
            isHandledComplexHistory = true;
        }
        else if (this.owner.editorModule.isHandledComplex) {
            isHandledComplexHistory = true;
        }
        return isHandledComplexHistory;
    }
    /**
     * Update complex history
     * @private
     */
    updateComplexHistory() {
        let selection = this.viewer.selection;
        if (this.currentHistoryInfo.hasAction) {
            if (this.currentHistoryInfo.action === 'AutoFormatHyperlink') {
                let startPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(startPosition, this.currentHistoryInfo.insertPosition);
                // this.reLayoutParagraph(startPosition.paragraph, 0);
                if (selection.owner.editorHistory.isUndoing) {
                    this.owner.editorModule.setPositionForCurrentIndex(selection.start, this.currentHistoryInfo.selectionStart);
                    this.owner.editorModule.setPositionForCurrentIndex(selection.end, this.currentHistoryInfo.selectionEnd);
                }
                else {
                    this.owner.editorModule.setPositionForCurrentIndex(selection.start, this.currentHistoryInfo.endPosition);
                    this.owner.editorModule.setPositionForCurrentIndex(selection.end, this.currentHistoryInfo.endPosition);
                }
            }
            if (this.currentHistoryInfo.action === 'InsertHyperlink') {
                let startPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(startPosition, this.currentHistoryInfo.insertPosition);
                let endPosition = new TextPosition(selection.owner);
                this.owner.editorModule.setPositionForCurrentIndex(endPosition, this.currentHistoryInfo.endPosition);
                this.viewer.layout.reLayoutParagraph(startPosition.paragraph, 0, 0);
                if (endPosition.paragraph !== startPosition.paragraph) {
                    this.viewer.layout.reLayoutParagraph(endPosition.paragraph, 0, 0);
                }
            }
            if (this.currentHistoryInfo.action === 'ReplaceAll') {
                this.owner.editorModule.layoutWholeDocument();
            }
            else if (selection.owner.isShiftingEnabled) {
                this.viewer.layout.shiftLayoutedItems();
                if (this.owner.enableHeaderAndFooter) {
                    this.owner.editorModule.updateHeaderFooterWidget();
                }
                this.viewer.removeEmptyPages();
            }
        }
        selection.owner.isShiftingEnabled = false;
        selection.owner.isLayoutEnabled = true;
        // // selection.addMultipleSelectionRanges();
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        this.viewer.isScrollHandler = true;
        this.viewer.updateScrollBars();
        selection.fireSelectionChanged(true);
        this.viewer.isScrollHandler = false;
        this.viewer.updateFocus();
        this.updateComplexHistoryInternal();
        this.owner.editorModule.fireContentChange();
    }
    /**
     * @private
     */
    updateComplexHistoryInternal() {
        if (!isNullOrUndefined(this.currentHistoryInfo)) {
            //Updates the current end position
            if (isNullOrUndefined(this.currentHistoryInfo.endPosition)) {
                this.currentHistoryInfo.endPosition = this.currentHistoryInfo.insertPosition;
            }
            if (this.historyInfoStack.length > 1) {
                let historyInfo = this.historyInfoStack[this.historyInfoStack.length - 2];
                historyInfo.addModifiedAction(this.currentHistoryInfo);
            }
            else {
                this.recordChanges(this.currentHistoryInfo);
            }
            this.currentHistoryInfo = undefined;
        }
    }
    //List history preservation undo API
    /**
     * update list changes for history preservation
     * @param  {Selection} selection
     * @param  {WAbstractList} currentAbstractList
     * @param  {WList} list
     * @private
     */
    updateListChangesInHistory(currentAbstractList, list) {
        this.currentBaseHistoryInfo = new BaseHistoryInfo(this.viewer.owner);
        this.currentBaseHistoryInfo.action = 'List';
        this.currentBaseHistoryInfo.updateSelection();
        let collection = new Dictionary();
        for (let i = 0; i < currentAbstractList.levels.length; i++) {
            let levels = this.viewer.getAbstractListById(list.abstractListId).levels[i];
            let value = this.currentBaseHistoryInfo.addModifiedPropertiesForList(levels);
            let modifiedLevel = new ModifiedLevel(levels, currentAbstractList.levels[i]);
            if (!isNullOrUndefined(levels)) {
                this.viewer.owner.editorModule.copyListLevel(levels, currentAbstractList.levels[i]);
            }
            collection.add(i, modifiedLevel);
        }
        return collection;
    }
    /**
     * Apply list changes
     * @param  {Selection} selection
     * @param  {Dictionary<number, ModifiedLevel>} modifiedLevelsInternal
     * @private
     */
    applyListChanges(selection, modifiedLevelsInternal) {
        if (isNullOrUndefined(this.modifiedParaFormats)) {
            this.modifiedParaFormats = new Dictionary();
        }
        let collection = [];
        for (let i = 0; i < this.viewer.listParagraphs.length; i++) {
            let paragraph = this.viewer.listParagraphs[i];
            let paraFormat = paragraph.paragraphFormat;
            let currentList = this.viewer.getListById(paraFormat.listFormat.listId);
            let listLevel = this.viewer.layout.getListLevel(currentList, paraFormat.listFormat.listLevelNumber);
            // tslint:disable-next-line:max-line-length
            if (modifiedLevelsInternal.containsKey(paraFormat.listFormat.listLevelNumber)
                && modifiedLevelsInternal.get(paraFormat.listFormat.listLevelNumber).ownerListLevel === listLevel) {
                let modifiedFormat = new WParagraphFormat(null);
                modifiedFormat.leftIndent = paraFormat.leftIndent;
                modifiedFormat.firstLineIndent = paraFormat.firstLineIndent;
                let modified = new ModifiedParagraphFormat(paraFormat, modifiedFormat);
                collection.push(modified);
                this.owner.editorModule.copyFromListLevelParagraphFormat(paraFormat, listLevel.paragraphFormat);
            }
        }
        this.modifiedParaFormats.add(this.currentBaseHistoryInfo, collection);
    }
    /**
     * Update list changes
     * @param  {Dictionary<number, ModifiedLevel>} modifiedCollection
     * @param  {Selection} selection
     * @private
     */
    updateListChanges(modifiedCollection) {
        this.viewer.owner.isLayoutEnabled = false;
        this.owner.editorModule.updateListParagraphs();
        for (let i = 0; i < modifiedCollection.keys.length; i++) {
            let levelNumber = modifiedCollection.keys[0];
            let modifiedLevel = modifiedCollection.get(levelNumber);
            if (!isNullOrUndefined(this.currentBaseHistoryInfo)) {
                // tslint:disable-next-line:max-line-length
                modifiedLevel = this.currentBaseHistoryInfo.addModifiedPropertiesForList(modifiedLevel.ownerListLevel);
            }
            this.owner.editorModule.copyListLevel(modifiedLevel.ownerListLevel, modifiedLevel.modifiedListLevel);
        }
        this.revertListChanges();
        this.viewer.owner.isLayoutEnabled = true;
        this.viewer.renderedLists.clear();
        this.viewer.pages = [];
        this.viewer.layout.layout();
        let selection = this.viewer.selection;
        selection.start.updatePhysicalPosition(true);
        if (selection.isEmpty) {
            selection.end.setPositionInternal(selection.start);
        }
        else {
            selection.end.updatePhysicalPosition(true);
        }
        selection.upDownSelectionLength = selection.end.location.x;
        selection.fireSelectionChanged(false);
        this.updateHistory();
    }
    /**
     * Revert list changes
     * @param  {Selection} selection
     */
    revertListChanges() {
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(this.currentBaseHistoryInfo)
            && this.viewer.owner.editorHistory.modifiedParaFormats.containsKey(this.currentBaseHistoryInfo)) {
            // tslint:disable-next-line:max-line-length
            let collection = this.modifiedParaFormats.get(this.currentBaseHistoryInfo);
            for (let i = 0; i < collection.length; i++) {
                let modified = new WParagraphFormat(null);
                modified.leftIndent = collection[i].ownerFormat.leftIndent;
                modified.firstLineIndent = collection[i].ownerFormat.firstLineIndent;
                collection[i].ownerFormat.copyFormat(collection[i].modifiedFormat);
                collection[i].modifiedFormat.leftIndent = modified.leftIndent;
                collection[i].modifiedFormat.firstLineIndent = modified.firstLineIndent;
            }
        }
    }
    /**
     * Reverts the last editing action.
     */
    undo() {
        if (this.owner.isReadOnlyMode || !this.canUndo() || !this.owner.enableHistoryMode) {
            return;
        }
        //this.owner.ClearTextSearchResults();
        let historyInfo = this.undoStack.pop();
        this.isUndoing = true;
        historyInfo.revert();
        this.isUndoing = false;
        this.owner.selection.checkForCursorVisibility();
        this.owner.editorModule.isBordersAndShadingDialog = false;
    }
    /**
     * Performs the last reverted action.
     */
    redo() {
        if (this.owner.isReadOnlyMode || !this.canRedo() || !this.owner.enableHistoryMode) {
            return;
        }
        //this.owner.ClearTextSearchResults();
        let historyInfo = this.redoStack.pop();
        if (historyInfo.action === 'BordersAndShading') {
            this.owner.editorModule.isBordersAndShadingDialog = true;
        }
        this.isRedoing = true;
        historyInfo.revert();
        this.isRedoing = false;
        this.owner.selection.checkForCursorVisibility();
        this.owner.editorModule.isBordersAndShadingDialog = false;
    }
    /**
     * @private
     */
    destroy() {
        this.clearHistory();
        this.undoStackIn = undefined;
        this.redoStackIn = undefined;
    }
    clearHistory() {
        this.clearUndoStack();
        this.clearRedoStack();
    }
    clearUndoStack() {
        if (this.canUndo()) {
            while (this.undoStack.length > 0) {
                let historyInfo = this.undoStack.pop();
                historyInfo.destroy();
                historyInfo = undefined;
            }
        }
    }
    clearRedoStack() {
        if (this.canRedo()) {
            while (this.redoStack.length > 0) {
                let historyInfo = this.redoStack.pop();
                historyInfo.destroy();
                historyInfo = undefined;
            }
        }
    }
}

/**
 * EditorHistory implementation
 */

/**
 * Exports the document to Word format.
 */
class WordExport {
    constructor() {
        //Part path
        this.documentPath = 'word/document.xml';
        this.stylePath = 'word/styles.xml';
        this.chartPath = 'word/charts';
        this.numberingPath = 'word/numbering.xml';
        this.settingsPath = 'word/settings.xml';
        this.headerPath = 'word/header';
        this.footerPath = 'word/footer';
        //private commentsPath: string = 'word/comments.xml';
        this.imagePath = 'word/media/image';
        // private footnotesPath: string = 'word/footnotes.xml';
        // private endnotesPath: string = 'word/endnotes.xml';
        this.appPath = 'docProps/app.xml';
        this.corePath = 'docProps/core.xml';
        // private CustomPath: string = 'docProps/custom.xml';
        // private FontTablePath: string = 'word/fontTable.xml';
        this.contentTypesPath = '[Content_Types].xml';
        // private ChartsPath: string = 'word/charts/';
        this.defaultEmbeddingPath = 'word/embeddings/';
        this.commentsPath = 'word/comments.xml';
        this.commentsExtendedPath = 'word/commentsExtended.xml';
        // private EmbeddingPath:string = 'word\embeddings\';
        // private DrawingPath:string = 'word\drawings\';
        // private ThemePath: string = 'word/theme/theme1.xml';
        // private FontsPath:string = 'word\fonts\';
        // private DiagramPath:string = "word/diagrams/';
        // private ControlPath:string = "word/activeX/';
        // private VbaProject: string = 'vbaProject.bin';
        // private VbaData: string = 'vbaData.xml';
        // private VbaProjectPath: string = 'word/vbaProject.bin';
        // private VbaDataPath: string = 'word/vbaData.xml';
        // private CustomXMLPath:string = 'customXml\';
        //Relationship path
        this.generalRelationPath = '_rels/.rels';
        this.wordRelationPath = 'word/_rels/document.xml.rels';
        this.excelRelationPath = 'xl/_rels/workbook.xml.rels';
        // private FontRelationPath: string = 'word/_rels/fontTable.xml.rels';
        // private CommentsRelationPath: string = 'word/_rels/comments.xml.rels';
        // private FootnotesRelationPath: string = 'word/_rels/footnotes.xml.rels';
        // private EndnotesRelationPath: string = 'word/_rels/endnotes.xml.rels';
        // private NumberingRelationPath: string = 'word/_rels/numbering.xml.rels';
        this.headerRelationPath = 'word/_rels/header';
        this.footerRelationPath = 'word/_rels/footer';
        // private SettingsRelationpath: string = 'word/_rels/settings.xml.rels';
        // private VbaProjectRelsPath: string = 'word/_rels/vbaProject.bin.rels';
        //Content type of the parts
        this.xmlContentType = 'application/xml';
        this.fontContentType = 'application/vnd.openxmlformats-officedocument.obfuscatedFont';
        this.documentContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml';
        // private TemplateContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml';
        // private CommentsContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml';
        this.settingsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml';
        this.commentsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml';
        this.commentsExContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml';
        // private EndnoteContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml';
        // private FontTableContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml';
        this.footerContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml';
        // private FootnoteContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml';
        // private GlossaryDocumentContentType: string = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml';
        this.headerContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml';
        this.numberingContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml';
        this.stylesContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml';
        this.webSettingsContentType = 'application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml';
        this.appContentType = 'application/vnd.openxmlformats-officedocument.extended-properties+xml';
        this.coreContentType = 'application/vnd.openxmlformats-package.core-properties+xml';
        this.customContentType = 'application/vnd.openxmlformats-officedocument.custom-properties+xml';
        this.customXmlContentType = 'application/vnd.openxmlformats-officedocument.customXmlProperties+xml';
        this.relationContentType = 'application/vnd.openxmlformats-package.relationships+xml';
        // private DiagramColor: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml';
        // private DiagramData: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml';
        // private DiagramLayout: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml';
        // private DiagramStyle: string = 'application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml';
        this.chartsContentType = 'application/vnd.openxmlformats-officedocument.drawingml.chart+xml';
        // private ThemeContentType: string = 'application/vnd.openxmlformats-officedocument.theme+xml';
        // private ChartDrawingContentType: string = 'application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml';
        // private ActiveXContentType: string = 'application/vnd.ms-office.activeX+xml';
        // private ActiveXBinContentType: string = 'application/vnd.ms-office.activeX';
        this.tableStyleContentType = 'application/vnd.openxmlformats-officedocument.presentationml.tableStyles+xml';
        // private ChartStyleContentType: string = 'application/vnd.ms-office.chartstyle+xml';
        this.chartColorStyleContentType = 'application/vnd.ms-office.chartcolorstyle+xml';
        // private VbaProjectContentType: string = 'application/vnd.ms-office.vbaProject';
        // private VbaDataContentType: string = 'application/vnd.ms-word.vbaData+xml';
        // private MacroDocumentContentType: string = 'application/vnd.ms-word.document.macroEnabled.main+xml';
        // private MacroTemplateContentType: string = 'application/vnd.ms-word.template.macroEnabledTemplate.main+xml';
        // private OleObjectContentType: string = 'application/vnd.openxmlformats-officedocument.oleObject';
        // Relationship types of document parts
        // private AltChunkRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/aFChunk';
        this.commentsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments';
        this.commentsExRelType = 'http://schemas.microsoft.com/office/2011/relationships/commentsExtended';
        this.settingsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings';
        // private EndnoteRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/endnotes';
        // private FontTableRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable';
        this.footerRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer';
        // private FootnoteRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes';
        this.headerRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/header';
        this.documentRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument';
        this.numberingRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/numbering';
        this.stylesRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles';
        // private OleObjectRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/oleObject';
        this.chartRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart';
        // private ThemeRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme';
        this.fontRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/font';
        this.tableStyleRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/tableStyles';
        this.coreRelType = 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties';
        this.appRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties';
        this.customRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties';
        this.imageRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/image';
        this.hyperlinkRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';
        this.controlRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/control';
        this.packageRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/package';
        // private VbaProjectRelType: string = 'http://schemas.microsoft.com/office/2006/relationships/vbaProject';
        // private VbaDataRelType: string = 'http://schemas.microsoft.com/office/2006/relationships/wordVbaData';
        this.customXmlRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml';
        this.customUIRelType = 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility';
        this.attachedTemplateRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate';
        this.chartColorStyleRelType = 'http://schemas.microsoft.com/office/2011/relationships/chartColorStyle';
        // private ChartStyleRelType: string = 'http://schemas.microsoft.com/office/2011/relationships/chartStyle';
        // private ChartUserShapesRelType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartUserShapes';
        // private ChartContentType: string = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/package';
        // Namespaces
        // private PKG_namespace: string = 'http://schemas.microsoft.com/office/2006/xmlPackage';
        this.wNamespace = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
        this.wpNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing';
        this.pictureNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/picture';
        this.aNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/main';
        this.a14Namespace = 'http://schemas.microsoft.com/office/drawing/2010/main';
        // private SVG_namespace: string = 'http://schemas.microsoft.com/office/drawing/2016/SVG/main';
        this.rNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships';
        this.rpNamespace = 'http://schemas.openxmlformats.org/package/2006/relationships';
        this.vNamespace = 'urn:schemas-microsoft-com:vml';
        this.oNamespace = 'urn:schemas-microsoft-com:office:office';
        this.xmlNamespace = 'http://www.w3.org/XML/1998/namespace';
        this.w10Namespace = 'urn:schemas-microsoft-com:office:word';
        this.cpNamespace = 'http://schemas.openxmlformats.org/package/2006/metadata/core-properties';
        this.dcNamespace = 'http://purl.org/dc/elements/1.1/';
        // private DCTERMS_namespace: string = 'http://purl.org/dc/terms/';
        // private XSI_namespace: string = 'http://www.w3.org/2001/XMLSchema-instance';
        this.docPropsNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/extended-properties';
        this.veNamespace = 'http://schemas.openxmlformats.org/markup-compatibility/2006';
        this.mNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/math';
        this.wneNamespace = 'http://schemas.microsoft.com/office/word/2006/wordml';
        // private DCMI_namespace: string = 'http://purl.org/dc/dcmitype/';
        this.customPropsNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/custom-properties';
        this.vtNamespace = 'http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes';
        this.chartNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/chart';
        this.slNamespace = 'http://schemas.openxmlformats.org/schemaLibrary/2006/main';
        //2003WML namespace
        // private amlNamespace: string = 'http://schemas.microsoft.com/aml/2001/core';
        this.dtNamespace = 'uuid:C2F41010-65B3-11d1-A29F-00AA00C14882';
        this.wmlNamespace = 'http://schemas.microsoft.com/office/word/2003/wordml';
        //2010 namespaces
        this.w14Namespace = 'http://schemas.microsoft.com/office/word/2010/wordml';
        this.wpCanvasNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas';
        this.wpDrawingNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing';
        this.wpGroupNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingGroup';
        this.wpInkNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingInk';
        this.wpShapeNamespace = 'http://schemas.microsoft.com/office/word/2010/wordprocessingShape';
        //2013 namespaces
        this.w15Namespace = 'http://schemas.microsoft.com/office/word/2012/wordml';
        this.diagramNamespace = 'http://schemas.openxmlformats.org/drawingml/2006/diagram';
        //Encryption namespaces
        this.eNamespace = 'http://schemas.microsoft.com/office/2006/encryption';
        this.pNamespace = 'http://schemas.microsoft.com/office/2006/keyEncryptor/password';
        this.certNamespace = 'http://schemas.microsoft.com/office/2006/keyEncryptor/certificate';
        this.cxNamespace = 'http://schemas.microsoft.com/office/drawing/2014/chartex';
        // chart
        this.c15Namespace = 'http://schemas.microsoft.com/office/drawing/2015/06/chart';
        this.c7Namespace = 'http://schemas.microsoft.com/office/drawing/2007/8/2/chart';
        this.csNamespace = 'http://schemas.microsoft.com/office/drawing/2012/chartStyle';
        // worksheet
        this.spreadSheetNamespace = 'http://schemas.openxmlformats.org/spreadsheetml/2006/main';
        this.spreadSheet9 = 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/main';
        // Dls xml tags
        this.cRelationshipsTag = 'Relationships';
        this.cRelationshipTag = 'Relationship';
        this.cIdTag = 'Id';
        this.cTypeTag = 'Type';
        this.cTargetTag = 'Target';
        this.cUserShapesTag = 'userShapes';
        this.cExternalData = 'externalData';
        this.twipsInOnePoint = 20;
        this.twentiethOfPoint = 20;
        this.borderMultiplier = 8;
        this.percentageFactor = 50;
        this.emusPerPoint = 12700;
        // private const TOC_SYMBOL:string = (char)0x01;
        // private const FOOTNOTE_SYMBOL:string = (char)0x02;
        // private const PAGENUMBER_SYMBOL:string = (char)0xB;
        // private DEF_FIT_TEXT_TO_SHAPE: string = 'mso-fit-shape-to-text:t';
        // Document tags
        this.cConditionalTableStyleTag = 'tblStylePr';
        this.cTableFormatTag = 'tblPr';
        this.cTowFormatTag = 'trPr';
        this.cCellFormatTag = 'tcPr';
        this.cParagraphFormatTag = 'pPr';
        this.cCharacterFormatTag = 'rPr';
        this.packageType = 'http://schemas.microsoft.com/office/2006/xmlPackage';
        this.relsPartPath = '/_rels/.rels';
        this.documentRelsPartPath = '/word/_rels/document.xml.rels';
        this.webSettingsPath = '/word/webSettings.xml';
        this.wordMLDocumentPath = '/word/document.xml';
        this.wordMLStylePath = '/word/styles.xml';
        this.wordMLNumberingPath = '/word/numbering.xml';
        this.wordMLSettingsPath = '/word/settings.xml';
        this.wordMLHeaderPath = '/word/header';
        this.wordMLFooterPath = '/word/footer';
        this.wordMLCommentsPath = '/word/comments.xml';
        this.wordMLImagePath = '/word/media/image';
        this.wordMLFootnotesPath = '/word/footnotes.xml';
        this.wordMLEndnotesPath = '/word/endnotes.xml';
        this.wordMLAppPath = '/docProps/app.xml';
        this.wordMLCorePath = '/docProps/core.xml';
        this.wordMLCustomPath = '/docProps/custom.xml';
        this.wordMLFontTablePath = '/word/fontTable.xml';
        this.wordMLChartsPath = '/word/charts/';
        this.wordMLDefaultEmbeddingPath = '/word/embeddings/';
        this.wordMLEmbeddingPath = '/word/embeddings/';
        this.wordMLDrawingPath = '/word/drawings/';
        this.wordMLThemePath = '/word/theme/theme1.xml';
        this.wordMLFontsPath = '/word/fonts/';
        this.wordMLDiagramPath = '/word/diagrams/';
        this.wordMLControlPath = '/word/activeX/';
        this.wordMLVbaProject = '/vbaProject.bin';
        this.wordMLVbaData = '/vbaData.xml';
        this.wordMLVbaProjectPath = '/word/vbaProject.bin';
        this.wordMLVbaDataPath = '/word/vbaData.xml';
        // private WordMLCustomXMLPath: string = '/customXml/';
        this.wordMLWebSettingsPath = '/word/webSettings.xml';
        this.wordMLCustomItemProp1Path = '/customXml/itemProps1.xml';
        // private WordMLCustomXMLRelPath: string = '/customXml/_rels/item1.xml.rels';
        this.wordMLFootnoteRelPath = '/word/_rels/footnotes.xml.rels';
        this.wordMLEndnoteRelPath = '/word/_rels/endnotes.xml.rels';
        this.wordMLSettingsRelPath = '/word/_rels/settings.xml.rels';
        this.wordMLNumberingRelPath = '/word/_rels/numbering.xml.rels';
        this.wordMLFontTableRelPath = '/word/_rels/fontTable.xml.rels';
        this.wordMLCustomXmlPropsRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps';
        this.wordMLControlRelType = 'http://schemas.microsoft.com/office/2006/relationships/activeXControlBinary';
        this.wordMLDiagramContentType = 'application/vnd.ms-office.drawingml.diagramDrawing+xml';
        this.lastSection = false;
        this.mRelationShipID = 0;
        this.cRelationShipId = 0;
        this.eRelationShipId = 0;
        this.mDocPrID = 0;
        this.chartCount = 0;
        this.seriesCount = 0;
        this.chartStringCount = 0;
        this.mDifferentFirstPage = false;
        this.mBookmarks = undefined;
        this.mComments = [];
        this.paraID = 0;
        this.commentParaID = 0;
        this.commentParaIDInfo = {};
        this.isInsideComment = false;
        this.commentId = {};
        this.currentCommentId = 0;
        /* tslint:enable:no-any */
    }
    getModuleName() {
        return 'WordExport';
    }
    // Gets the bookmark name
    get bookmarks() {
        if (isNullOrUndefined(this.mBookmarks)) {
            this.mBookmarks = [];
        }
        return this.mBookmarks;
    }
    // Gets the collection of images present in the document body
    get documentImages() {
        if (this.mDocumentImages === undefined) {
            this.mDocumentImages = new Dictionary();
        }
        return this.mDocumentImages;
    }
    // Gets the collection of images present in the document body
    get externalImages() {
        if (this.mExternalLinkImages === undefined) {
            this.mExternalLinkImages = new Dictionary();
        }
        return this.mExternalLinkImages;
    }
    // Gets the collections of images present in the HeaderFooters
    get headerFooterImages() {
        if (this.mHeaderFooterImages === undefined) {
            this.mHeaderFooterImages = new Dictionary();
        }
        return this.mHeaderFooterImages;
    }
    // Gets the collection of charts present in the document body
    get documentCharts() {
        if (this.mDocumentCharts === undefined) {
            this.mDocumentCharts = new Dictionary();
        }
        return this.mDocumentCharts;
    }
    /// Gets the HeaderFooter Collection
    get headersFooters() {
        if (this.mHeaderFooterColl === undefined) {
            this.mHeaderFooterColl = new Dictionary();
        }
        return this.mHeaderFooterColl;
    }
    /**
     * @private
     */
    save(viewer, fileName) {
        this.fileName = fileName;
        this.serialize(viewer);
        this.mArchive.save(fileName + '.docx').then((mArchive) => {
            mArchive.destroy();
        });
        this.close();
    }
    /**
     * @private
     */
    saveAsBlob(viewer) {
        this.serialize(viewer);
        return new Promise((resolve, reject) => {
            this.mArchive.saveAsBlob().then((blob) => {
                this.mArchive.destroy();
                blob = new Blob([blob], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                resolve(blob);
            });
        });
    }
    /**
     * @private
     */
    saveExcel() {
        let xlsxPath = this.defaultEmbeddingPath + 'Microsoft_Excel_Worksheet' + this.chartCount + '.xlsx';
        let promise;
        let blobData;
        return promise = new Promise((resolve, reject) => {
            this.mArchiveExcel.saveAsBlob().then((blob) => {
                blobData = blob;
                let zipArchiveItem = new ZipArchiveItem(blob, xlsxPath);
                this.mArchive.addItem(zipArchiveItem);
                this.mArchive.save(this.fileName + '.docx').then((mArchive) => {
                    mArchive.destroy();
                });
            });
            resolve(blobData);
            this.mArchiveExcel = undefined;
        });
    }
    /**
     * @private
     */
    destroy() {
        this.clearDocument();
        this.mRelationShipID = undefined;
        this.mDocPrID = undefined;
        this.mDifferentFirstPage = undefined;
        this.fileName = undefined;
        if (this.mArchive) {
            this.mArchive.destroy();
            this.mArchive = undefined;
        }
        if (this.mArchiveExcel) {
            this.mArchiveExcel.destroy();
            this.mArchiveExcel = undefined;
        }
    }
    // Saves the word document in the stream
    serialize(viewer) {
        /* tslint:disable:no-any */
        let document = viewer.owner.sfdtExportModule.write();
        this.setDocument(document);
        this.mComments = viewer.comments;
        this.mArchive = new ZipArchive();
        this.mArchive.compressionLevel = 'Normal';
        this.commentParaIDInfo = {};
        this.commentParaID = 0;
        this.currentCommentId = 0;
        this.commentId = {};
        this.mVerticalMerge = new Dictionary();
        this.mGridSpans = new Dictionary();
        let contenttype;
        //document.xml
        this.serializeDocument();
        //Styles.xml
        this.serializeStyles();
        //numbering.xml
        this.serializeNumberings();
        //comments.xml
        this.serializeComments();
        //commentsExtended.xml
        this.serializeCommentsExtended();
        //theme.xml
        // if (m_document.DocHasThemes && !isNullOrUndefined(m_document.Themes))
        //     SerializeThemes();
        // else
        // this.serializeDefaultThemes();
        //settings.xml
        this.serializeSettings();
        //core.xml
        this.serializeCoreProperties();
        //app.xml
        this.serializeAppProperties();
        //fontTable.xml
        this.serializeFontTable(contenttype);
        //custom.xml
        // if (!isNullOrUndefined(this.wordDocument.CustomDocumentProperties) && m_document.CustomDocumentProperties.length > 0) {
        //     SerializeCustomProperties();
        // }
        //Settings Relations
        this.serializeSettingsRelation();
        //Numbering relation if the document has picture bullet
        // if (PictureBullets.length > 0) {
        //     SerializeNumberingsRelation();
        // }
        this.serializeHeaderFooters();
        //document relations
        this.serializeDocumentRelations();
        // // Add controls to archieve.
        // if (ControlsPathNames.length > 0) {
        //     AddControlsToZip(m_document.DocxPackage);
        // }
        // if (!isNullOrUndefined(m_document.CustomUIPartContainer))
        //     AddPartContainerToArchive(m_document.CustomUIPartContainer);
        // if (!isNullOrUndefined(m_document.CustomXMLContainer))
        //     AddPartContainerToArchive(m_document.CustomXMLContainer);
        //general relations
        this.serializeGeneralRelations();
        //[ContentTypes].xml
        this.serializeContentTypes(contenttype);
        // Clears the internal fields maintained for serializing.
        this.clearDocument();
    }
    // Sets the document
    setDocument(document) {
        this.document = document;
        this.mSections = document.sections;
        this.mLists = document.lists;
        this.mAbstractLists = document.abstractLists;
        this.defCharacterFormat = document.characterFormat;
        this.defParagraphFormat = document.paragraphFormat;
        this.defaultTabWidthValue = document.defaultTabWidth;
        this.mStyles = document.styles;
        this.formatting = document.formatting;
        this.enforcement = document.enforcement;
        this.hashValue = document.hashValue;
        this.saltValue = document.saltValue;
        this.protectionType = document.protectionType;
    }
    // Clears the document
    clearDocument() {
        // Owner Nodes
        this.section = undefined;
        this.lastSection = undefined;
        this.blockOwner = undefined;
        this.paragraph = undefined;
        this.table = undefined;
        this.row = undefined;
        this.headerFooter = undefined;
        this.commentParaIDInfo = {};
        this.commentParaID = 0;
        this.currentCommentId = 0;
        this.commentId = {};
        this.document = undefined;
        this.mSections = undefined;
        this.mLists = undefined;
        this.mAbstractLists = undefined;
        this.defCharacterFormat = undefined;
        this.defParagraphFormat = undefined;
        this.defaultTabWidthValue = undefined;
        this.mRelationShipID = 0;
        this.eRelationShipId = 0;
        this.cRelationShipId = 0;
        this.mDocPrID = 0;
        this.chartCount = 0;
        this.mDifferentFirstPage = false;
        if (this.mHeaderFooterColl) {
            this.mHeaderFooterColl.destroy();
            this.mHeaderFooterColl = undefined;
        }
        if (this.mVerticalMerge) {
            this.mVerticalMerge.destroy();
            this.mVerticalMerge = undefined;
        }
        if (this.mGridSpans) {
            this.mGridSpans.destroy();
            this.mGridSpans = undefined;
        }
        if (this.mDocumentImages) {
            this.mDocumentImages.destroy();
            this.mDocumentImages = undefined;
        }
        if (this.mExternalLinkImages) {
            this.mExternalLinkImages.destroy();
            this.mExternalLinkImages = undefined;
        }
        if (this.mHeaderFooterImages) {
            this.mHeaderFooterImages.destroy();
            this.mHeaderFooterImages = undefined;
        }
        if (this.mDocumentCharts) {
            this.mDocumentCharts.destroy();
            this.mDocumentCharts = undefined;
        }
    }
    // Serializes the document elements (document.xml)
    serializeDocument() {
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'document', this.wNamespace);
        this.writeCommonAttributeStrings(writer);
        this.serializeDocumentBody(writer);
        writer.writeEndElement(); //end of document tag
        let archiveItem = new ZipArchiveItem(writer.buffer, this.documentPath);
        this.mArchive.addItem(archiveItem);
    }
    writeCommonAttributeStrings(writer) {
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        this.writeCustom(writer);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        this.writeDup(writer);
        writer.writeAttributeString('xmlns', 'wne', undefined, this.wneNamespace);
        writer.writeAttributeString('xmlns', 'wps', undefined, this.wpShapeNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15 wp14');
    }
    writeDup(writer) {
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('xmlns', 'wpg', undefined, this.wpGroupNamespace);
        writer.writeAttributeString('xmlns', 'wpi', undefined, this.wpInkNamespace);
    }
    writeCustom(writer) {
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
    }
    // Serializes the document body
    serializeDocumentBody(writer) {
        writer.writeStartElement(undefined, 'body', this.wNamespace);
        let count = this.document.sections.length;
        for (let i = 0; i < count; i++) {
            this.section = this.document.sections[i];
            this.lastSection = i === count - 1;
            this.serializeSection(writer, this.section, i === count - 1);
            this.section = undefined;
        }
        writer.writeEndElement();
    }
    // Serializes the Section.
    serializeSection(writer, section, last) {
        this.blockOwner = section;
        this.serializeBodyItems(writer, section.blocks, last);
        if (last) {
            this.serializeSectionProperties(writer, section);
        }
        this.blockOwner = undefined;
    }
    // Serialize the comments (comments.xml)
    serializeComments() {
        if (this.mComments.length === 0) {
            return;
        }
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'comments', this.wNamespace);
        this.serializeCommentCommonAttribute(writer);
        this.serializeCommentInternal(writer, this.mComments, false);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.commentsPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    serializeCommentCommonAttribute(writer) {
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        writer.writeAttributeString('xmlns', 'cx', undefined, this.cxNamespace);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
    }
    serializeCommentInternal(writer, comments, isreplay) {
        for (let i = 0; i < comments.length; i++) {
            let comment = comments[i];
            writer.writeStartElement('w', 'comment', this.wNamespace);
            writer.writeAttributeString('w', 'id', this.wNamespace, this.commentId[comment.commentId].toString());
            if (comment.author && comment.author !== ' ') {
                writer.writeAttributeString('w', 'author', this.wNamespace, comment.author);
            }
            if (comment.date) {
                writer.writeAttributeString('w', 'date', this.wNamespace, comment.date);
            }
            if (comment.initial && comment.initial !== '') {
                writer.writeAttributeString('w', 'initials', this.wNamespace, comment.initial);
            }
            let blocks = this.retrieveCommentText(comment.text);
            for (let k = 0; k < blocks.length; k++) {
                this.isInsideComment = true;
                this.commentParaID++;
                this.serializeBodyItem(writer, blocks[k], true);
                this.isInsideComment = false;
            }
            //if (blocks.length > 0) {
            this.commentParaIDInfo[comment.commentId] = this.commentParaID;
            //}
            //}
            this.isInsideComment = false;
            //}
            writer.writeEndElement();
            if (comment.replyComments.length > 0) {
                this.serializeCommentInternal(writer, comment.replyComments, true);
            }
        }
    }
    retrieveCommentText(text) {
        let blocks = [];
        let multiText = text.split('\n');
        multiText = multiText.filter((x) => x !== '');
        while (multiText.length > 0) {
            let block = {};
            block.inlines = [{ text: multiText[0] }];
            blocks.push(block);
            multiText.splice(0, 1);
        }
        return blocks;
    }
    // Serialize the comments (commentsExtended.xml)
    serializeCommentsExtended() {
        if (this.mComments.length === 0) {
            return;
        }
        let writer = new XmlWriter();
        writer.writeStartElement('w15', 'commentsEx', this.wNamespace);
        this.serializeCommentCommonAttribute(writer);
        this.serializeCommentsExInternal(writer, this.mComments, false);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.commentsExtendedPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    serializeCommentsExInternal(writer, comments, isReply) {
        for (let i = 0; i < comments.length; i++) {
            let comment = comments[i];
            writer.writeStartElement('w15', 'commentEx', this.wNamespace);
            //if (comment.blocks.length > 0) {
            let syncParaID = this.commentParaIDInfo[comment.commentId];
            if (isReply) {
                let paraID = this.commentParaIDInfo[comment.ownerComment.commentId];
                writer.writeAttributeString('w15', 'paraIdParent', this.wNamespace, paraID.toString());
            }
            writer.writeAttributeString('w15', 'paraId', this.wNamespace, syncParaID.toString());
            //}
            let val = comment.done ? 1 : 0;
            writer.writeAttributeString('w15', 'done', this.wNamespace, val.toString());
            writer.writeEndElement();
            if (comment.replyComments.length > 0) {
                this.serializeCommentsExInternal(writer, comment.replyComments, true);
            }
        }
    }
    // Serialize the section properties.
    serializeSectionProperties(writer, section) {
        writer.writeStartElement('w', 'sectPr', this.wNamespace);
        if (section.headersFooters) {
            this.serializeHFReference(writer, section.headersFooters);
        }
        // if (IsNeedToSerializeSectionFootNoteProperties(section))
        //     SerializeFootnoteProperties(section);
        // if (IsNeedToSerializeSectionEndNoteProperties(section))
        //     SerializeEndnoteProperties(section);      
        this.serializeSectionType(writer, 'nextPage');
        this.serializePageSetup(writer, section.sectionFormat);
        this.serializeColumns(writer, section);
        // this.serializeSectionProtection(section);
        // if (section.PageSetup.VerticalAlignment !== PageAlignment.Top) {
        //     writer.writeStartElement('vAlign', this.wNamespace);
        //     switch (section.PageSetup.VerticalAlignment) {
        //         case PageAlignment.Top:
        //             writer.WriteAttributeString('val', this.wNamespace, 'top');
        //             break;
        //         case PageAlignment.Middle:
        //             writer.WriteAttributeString('val', this.wNamespace, 'center');
        //             break;
        //         case PageAlignment.Justified:
        //             writer.WriteAttributeString('val', this.wNamespace, 'both');
        //             break;
        //         case PageAlignment.Bottom:
        //             writer.WriteAttributeString('val', this.wNamespace, 'bottom');
        //             break;
        //     }
        //     writer.WriteEndElement();
        // }
        if (section.sectionFormat !== undefined && section.sectionFormat.differentFirstPage) {
            writer.writeStartElement(undefined, 'titlePg', this.wNamespace);
            writer.writeEndElement();
        }
        // SerializeTextDirection(section);
        if (!isNullOrUndefined(section.sectionFormat) && section.sectionFormat.bidi) {
            writer.writeStartElement(undefined, 'bidi', this.wNamespace);
            writer.writeEndElement();
        }
        //rtlGutter
        // SerializeDocGrid(section);
        //printerSettings
        writer.writeEndElement(); //end of sectPr tag
    }
    // Serialize the column properties of section.
    serializeColumns(writer, section) {
        writer.writeStartElement(undefined, 'cols', this.wNamespace);
        writer.writeAttributeString(undefined, 'equalWidth', this.wNamespace, '1');
        writer.writeAttributeString(undefined, 'space', this.wNamespace, '0');
        writer.writeEndElement();
        // ColumnCollection columns = section.Columns;
        // writer.WriteStartElement('cols', this.wNamespace);
        // if (columns.length > 0)
        // {
        //     writer.WriteAttributeString('num', this.wNamespace, columns.length.ToString());
        // }
        // if (section.PageSetup.DrawLinesBetweenCols)
        //     writer.WriteAttributeString('sep', this.wNamespace, '1');
        // if (columns.OwnerSection.PageSetup.EqualColumnWidth)
        // {
        //     writer.WriteAttributeString('equalWidth', this.wNamespace, '1');
        //     //When the column count is negative, MS word just reset the column's count to zero
        //     //To avoid index out of exception, checked the columns count
        // tslint:disable-next-line:max-line-length
        //     writer.WriteAttributeString('space', this.wNamespace, ToString(columns.length > 0 ? columns[0].Space * this.TwentiethOfPoint : 0));
        // }
        // else if (columns.length > 0)
        // {
        //     writer.WriteAttributeString('equalWidth', this.wNamespace, '0');
        //     foreach (Column column in columns)
        //     {
        //         writer.WriteStartElement('col', this.wNamespace);
        //         writer.WriteAttributeString('w', this.wNamespace, ToString(column.Width * this.TwentiethOfPoint));
        // tslint:disable-next-line:max-line-length
        //         writer.WriteAttributeString('space', this.wNamespace, ToString(column.Space * this.TwentiethOfPoint));
        //         writer.WriteEndElement();
        //     }
        // }
        // writer.WriteEndElement();
    }
    // Serialize the page setup properties.
    serializePageSetup(writer, pageSetup) {
        if (pageSetup !== undefined) {
            this.serializePageSize(writer, pageSetup);
            this.serializePageMargins(writer, pageSetup);
        }
        // // StartElement paperSrc (if any)
        // if (pageSetup.FirstPageTray > 0 || pageSetup.OtherPagesTray > 0) {
        //     writer.WriteStartElement('paperSrc', this.wNamespace);
        //     if (pageSetup.FirstPageTray > 0) {
        //         writer.WriteAttributeString('first', this.wNamespace, pageSetup.FirstPageTray.ToString());
        //     }
        //     if (pageSetup.OtherPagesTray > 0) {
        //         writer.WriteAttributeString('other', this.wNamespace, pageSetup.OtherPagesTray.ToString());
        //     }
        //     writer.WriteEndElement();
        // }
        writer.writeStartElement(undefined, 'pgBorders', this.wNamespace);
        // //zOrder
        // if (pageSetup.PageBordersApplyType === PageBordersApplyType.FirstPage)
        //     writer.WriteAttributeString('display', this.wNamespace, 'firstPage');
        // else if (pageSetup.PageBordersApplyType === PageBordersApplyType.AllExceptFirstPage)
        //     writer.WriteAttributeString('display', this.wNamespace, 'notFirstPage');
        // if (pageSetup.PageBorderOffsetFrom === PageBorderOffsetFrom.PageEdge) {
        //     writer.WriteAttributeString('offsetFrom', this.wNamespace, 'page');
        // }
        // //Serializing zOrder of the front page border
        // if (!pageSetup.IsFrontPageBorder) {
        //     writer.WriteAttributeString('zOrder', this.wNamespace, 'back');
        // }
        // SerializePageBorders(pageSetup.Borders);
        writer.writeEndElement();
        // this.serializeLineNumberType(writer, pageSetup);
        //this.serializePageNumberType(writer, pageSetup);
    }
    // serialize the page size
    serializePageSize(writer, pageSetup) {
        writer.writeStartElement(undefined, 'pgSz', this.wNamespace);
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(pageSetup.pageWidth * this.twentiethOfPoint).toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'h', this.wNamespace, this.roundToTwoDecimal(pageSetup.pageHeight * this.twentiethOfPoint).toString());
        // if (pageSetup.Orientation === PageOrientation.Landscape)
        // {
        //     writer.WriteAttributeString('orient', this.wNamespace, 'landscape');
        // }
        writer.writeEndElement();
    }
    // Serialize the border.
    serializePageMargins(writer, pageSetup) {
        writer.writeStartElement(undefined, 'pgMar', this.wNamespace);
        let marginValue = Math.round(pageSetup.topMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'top', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.rightMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'right', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.bottomMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'bottom', this.wNamespace, marginValue.toString());
        marginValue = Math.round(pageSetup.leftMargin * this.twentiethOfPoint);
        writer.writeAttributeString(undefined, 'left', this.wNamespace, marginValue.toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'header', this.wNamespace, this.roundToTwoDecimal(pageSetup.headerDistance * this.twentiethOfPoint).toString());
        // tslint:disable-next-line:max-line-length
        writer.writeAttributeString(undefined, 'footer', this.wNamespace, this.roundToTwoDecimal(pageSetup.footerDistance * this.twentiethOfPoint).toString());
        writer.writeAttributeString(undefined, 'gutter', this.wNamespace, '0');
        writer.writeEndElement();
    }
    // Serialize the section type.
    serializeSectionType(writer, sectionBreakCode) {
        writer.writeStartElement('w', 'type', this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, sectionBreakCode); //GetSectionBreakCode(sectionBreakCode));
        writer.writeEndElement();
    }
    // Serialize the heeader/footer reference.
    serializeHFReference(writer, headersFooters) {
        let hfId = '';
        if (headersFooters !== undefined) {
            this.mDifferentFirstPage = this.section.sectionFormat.differentOddAndEvenPages;
            let hf = headersFooters.firstPageHeader;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'first');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'FirstPageHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.firstPageFooter;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'first');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'FirstPageFooter', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.evenHeader;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'even');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'EvenHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.evenFooter;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'even');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'EvenFooter', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.header;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'headerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'default');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'OddHeader', hfId);
                writer.writeEndElement();
            }
            hf = headersFooters.footer;
            if (hf && hf.blocks && hf.blocks.length > 0) {
                writer.writeStartElement(undefined, 'footerReference', this.wNamespace);
                writer.writeAttributeString(undefined, 'type', this.wNamespace, 'default');
                hfId = this.getNextRelationShipID();
                writer.writeAttributeString(undefined, 'id', this.rNamespace, hfId);
                this.addHeaderFooter(hf, 'OddFooter', hfId);
                writer.writeEndElement();
            }
        }
    }
    // Adds the header footer details to the collection.
    addHeaderFooter(hf, hfType, id) {
        let hfColl = new Dictionary();
        this.headersFooters.add(hfType, hfColl);
        this.headersFooters.get(hfType).add(id, hf);
    }
    // Serializes the bodyItems
    serializeBodyItems(writer, blockCollection, isLastSection) {
        for (let i = 0; i < blockCollection.length; i++) {
            this.serializeBodyItem(writer, blockCollection[i], isLastSection);
        }
    }
    // Serialize the TextBody item
    serializeBodyItem(writer, item, isLastSection) {
        if (isNullOrUndefined(item)) {
            throw new Error('BodyItem should not be undefined');
        }
        if (item.hasOwnProperty('inlines')) {
            this.paragraph = item;
            this.serializeParagraph(writer, item, isLastSection);
            this.paragraph = undefined;
        }
        else {
            let table = item;
            for (let i = 0; i < table.rows.length; i++) {
                if (table.rows[i].cells.length > 0) {
                    this.serializeTable(writer, table);
                    break;
                }
            }
        }
    }
    // Serialize the paragraph
    serializeParagraph(writer, paragraph, isLastSection) {
        if (isNullOrUndefined(paragraph)) {
            throw new Error('Paragraph should not be undefined');
        }
        let sec = this.blockOwner;
        // if (paragraph.ParagraphFormat.PageBreakAfter && !IsPageBreakNeedToBeSkipped(paragraph as Entity))
        //     paragraph.InsertBreak(BreakType.PageBreak);
        // if (paragraph.ParagraphFormat.ColumnBreakAfter && !IsPageBreakNeedToBeSkipped(paragraph as Entity))
        //     paragraph.InsertBreak(BreakType.ColumnBreak);
        //Splits the paragraph based on the newline character
        // paragraph.SplitTextRange();
        writer.writeStartElement('w', 'p', this.wNamespace);
        if (this.isInsideComment) {
            writer.writeAttributeString('w14', 'paraId', undefined, this.commentParaID.toString());
        }
        writer.writeStartElement(undefined, 'pPr', this.wNamespace);
        if (!isNullOrUndefined(paragraph.paragraphFormat)) {
            this.serializeParagraphFormat(writer, paragraph.paragraphFormat, paragraph);
        }
        if (!isNullOrUndefined(paragraph.characterFormat)) {
            this.serializeCharacterFormat(writer, paragraph.characterFormat);
        }
        writer.writeEndElement(); //end of pPr
        // Serialize watermark if paragraph is the first item of Header document.
        // EnsureWatermark(paragraph);
        this.serializeParagraphItems(writer, paragraph.inlines);
        writer.writeEndElement(); //end of paragraph tag.
        //Need to write the Section Properties if the Paragraph is last item in the section
        if (!isLastSection && sec.hasOwnProperty('sectionFormat')
            && sec.blocks.indexOf(paragraph) === sec.blocks.length - 1) {
            writer.writeStartElement('w', 'p', this.wNamespace);
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            this.serializeSectionProperties(writer, sec);
            writer.writeEndElement();
            writer.writeEndElement();
        }
    }
    // Serialize the paragraph items
    serializeParagraphItems(writer, paraItems) {
        let previousNode = undefined;
        let isContinueOverride = false;
        for (let i = 0; i < paraItems.length; i++) {
            let item = paraItems[i];
            let isBdo = false;
            if (item.characterFormat) {
                isBdo = !isNullOrUndefined(item.characterFormat.bdo) && item.characterFormat.bdo !== 'None';
                if (isBdo && !isContinueOverride) {
                    this.serializeBiDirectionalOverride(writer, item.characterFormat);
                    isContinueOverride = true;
                }
            }
            if (isContinueOverride && !isBdo) {
                writer.writeEndElement();
                isContinueOverride = false;
            }
            if (item.hasOwnProperty('fieldType')) {
                this.serializeFieldCharacter(writer, item);
            }
            else if (item.hasOwnProperty('imageString')) {
                this.serializePicture(writer, item);
            }
            else if (item.hasOwnProperty('bookmarkType')) {
                this.serializeBookMark(writer, item);
            }
            else if (item.hasOwnProperty('editRangeId')) {
                this.serializeEditRange(writer, item);
            }
            else if (item.hasOwnProperty('chartType')) {
                this.chart = item;
                this.serializeChart(writer, item);
                // chart.xml
                this.serializeChartStructure();
            }
            else if (item.hasOwnProperty('commentCharacterType')) {
                this.serializeComment(writer, item);
            }
            else {
                this.serializeTextRange(writer, item, previousNode);
            }
            previousNode = item;
        }
        if (isContinueOverride) {
            writer.writeEndElement();
        }
    }
    // Serialize the comment
    serializeComment(writer, comment) {
        if (comment.commentCharacterType === 0) {
            writer.writeStartElement('w', 'commentRangeStart', this.wNamespace);
        }
        else if (comment.commentCharacterType === 1) {
            writer.writeStartElement('w', 'commentRangeEnd', this.wNamespace);
        }
        let commentId = this.commentId[comment.commentId];
        if (isNullOrUndefined(commentId)) {
            commentId = this.commentId[comment.commentId] = this.currentCommentId++;
        }
        writer.writeAttributeString('w', 'id', this.wNamespace, commentId.toString());
        writer.writeEndElement();
        if (comment.commentCharacterType === 1) {
            this.serializeCommentItems(writer, commentId);
        }
    }
    serializeCommentItems(writer, commentId) {
        writer.writeStartElement('w', 'r', this.wNamespace);
        writer.writeStartElement('w', 'commentReference', this.wNamespace);
        writer.writeAttributeString('w', 'id', this.wNamespace, commentId.toString());
        writer.writeEndElement();
        writer.writeEndElement();
    }
    serializeBiDirectionalOverride(writer, characterFormat) {
        writer.writeStartElement(undefined, 'bdo', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, characterFormat.bdo.toLowerCase());
    }
    // Serialize Document Protection
    //<w:permStart w:id="627587516" w:edGrp="everyone" />
    serializeEditRange(writer, editElement) {
        if (editElement.hasOwnProperty('editableRangeStart')) {
            writer.writeStartElement('w', 'permEnd', this.wNamespace);
        }
        else {
            writer.writeStartElement('w', 'permStart', this.wNamespace);
            if (editElement.user && editElement.user !== '') {
                writer.writeAttributeString('w', 'ed', this.wNamespace, editElement.user);
            }
            if (editElement.group && editElement.group !== '') {
                writer.writeAttributeString('w', 'edGrp', this.wNamespace, editElement.group.toLowerCase());
            }
            if (editElement.columnFirst && editElement.columnFirst !== -1) {
                writer.writeAttributeString('w', 'colFirst', this.wNamespace, editElement.columnFirst.toString());
            }
            if (editElement.columnLast && editElement.columnLast !== -1) {
                writer.writeAttributeString('w', 'colLast', this.wNamespace, editElement.columnLast.toString());
            }
        }
        writer.writeAttributeString('w', 'id', this.wNamespace, editElement.editRangeId);
        writer.writeEndElement();
    }
    // Serialize the book mark
    serializeBookMark(writer, bookmark) {
        let bookmarkId = this.getBookmarkId(bookmark.name);
        let bookmarkName = bookmark.name;
        if (bookmark.bookmarkType === 0) {
            writer.writeStartElement('w', 'bookmarkStart', this.wNamespace);
            writer.writeAttributeString('w', 'name', this.wNamespace, bookmarkName);
        }
        else if (bookmark.bookmarkType === 1) {
            writer.writeStartElement('w', 'bookmarkEnd', this.wNamespace);
        }
        writer.writeAttributeString('w', 'id', this.wNamespace, bookmarkId.toString());
        writer.writeEndElement();
    }
    getBookmarkId(name) {
        let index = this.bookmarks.indexOf(name);
        if (index < 0) {
            index = this.bookmarks.length;
            this.bookmarks.push(name);
        }
        return index;
    }
    // Serialize the picture.
    serializePicture(writer, image) {
        if (image.width >= 0 && image.height >= 0) {
            writer.writeStartElement(undefined, 'r', this.wNamespace);
            this.serializeCharacterFormat(writer, image.characterFormat);
            this.serializeDrawing(writer, image);
            writer.writeEndElement(); //end of run element
        }
    }
    // Serialize the drawing element.
    serializeDrawing(writer, draw) {
        writer.writeStartElement(undefined, 'drawing', this.wNamespace);
        if (draw.hasOwnProperty('chartType')) {
            this.serializeInlineCharts(writer, draw);
        }
        else {
            this.serializeInlinePicture(writer, draw);
        }
        writer.writeEndElement();
    }
    // Serialize the inline picture.
    serializeInlinePicture(writer, image) {
        writer.writeStartElement(undefined, 'inline', this.wpNamespace);
        writer.writeStartElement(undefined, 'extent', this.wpNamespace);
        let cx = Math.round(image.width * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        let cy = Math.round(image.height * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement();
        // double borderWidth = (double)picture.PictureShape.PictureDescriptor.BorderLeft.LineWidth / DLSConstants.BorderLineFactor;
        // if (borderWidth > 0 && picture.DocxProps.length === 0) {
        //     long leftTop = 0, rightBottom = 0;
        //     picture.PictureShape.GetEffectExtent(borderWidth, ref leftTop, ref rightBottom);
        //     m_writer.WriteStartElement('effectExtent', WP_namespace);
        //     m_writer.WriteAttributeString('l', leftTop.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('t', leftTop.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('r', rightBottom.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteAttributeString('b', rightBottom.ToString(CultureInfo.InvariantCulture));
        //     m_writer.WriteEndElement();
        // }
        //this.serializePicProperties(writer, image);
        this.serializeDrawingGraphics(writer, image);
        writer.writeEndElement();
    }
    // serialize inline chart
    serializeInlineCharts(writer, item) {
        writer.writeStartElement(undefined, 'inline', this.wpNamespace);
        writer.writeAttributeString(undefined, 'distT', undefined, '0');
        writer.writeAttributeString(undefined, 'distB', undefined, '0');
        writer.writeAttributeString(undefined, 'distL', undefined, '0');
        writer.writeAttributeString(undefined, 'distR', undefined, '0');
        writer.writeStartElement(undefined, 'extent', this.wpNamespace);
        let cx = Math.round(item.width * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        let cy = Math.round(item.height * this.emusPerPoint);
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement(); // end of wp:extend
        writer.writeStartElement(undefined, 'effectExtent', this.wpNamespace);
        writer.writeAttributeString(undefined, 'l', undefined, '0');
        writer.writeAttributeString(undefined, 't', undefined, '0');
        writer.writeAttributeString(undefined, 'r', undefined, '0');
        writer.writeAttributeString(undefined, 'b', undefined, '0');
        writer.writeEndElement(); // end of wp: effectExtent
        this.serializeDrawingGraphicsChart(writer, item);
        writer.writeEndElement(); // end of inline
    }
    // Serialize the graphics element for chart.
    serializeDrawingGraphicsChart(writer, chart) {
        let id = '';
        id = this.updatechartId(chart);
        // Processing chart
        writer.writeStartElement('wp', 'docPr', this.wpNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, (this.mDocPrID++).toString());
        writer.writeAttributeString(undefined, 'name', undefined, this.getNextChartName());
        writer.writeEndElement(); // end of wp docPr
        writer.writeStartElement('wp', 'cNvGraphicFramePr', this.wpNamespace);
        writer.writeEndElement(); // end of cNvGraphicFramePr
        writer.writeStartElement('a', 'graphic', this.aNamespace);
        writer.writeStartElement('a', 'graphicData', this.aNamespace);
        writer.writeAttributeString(undefined, 'uri', undefined, this.chartNamespace);
        writer.writeStartElement('c', 'chart', this.chartNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('r', 'id', undefined, id);
        writer.writeEndElement(); // end of chart
        writer.writeEndElement(); // end of graphic data
        writer.writeEndElement(); // end of graphic
    }
    getNextChartName() {
        return 'Chart' + (++this.chartCount);
    }
    // serialize chart
    serializeChart(writer, chart) {
        writer.writeStartElement('w', 'r', this.wNamespace);
        this.serializeCharacterFormat(writer, chart.characterFormat);
        this.serializeDrawing(writer, chart);
        writer.writeEndElement();
    }
    serializeChartStructure() {
        this.serializeChartXML();
        this.serializeChartColors();
        this.serializeChartExcelData();
        this.serializeChartRelations();
        this.chart = undefined;
        this.saveExcel();
    }
    // serialize Chart.xml
    serializeChartXML() {
        let chartPath = '';
        let writer = new XmlWriter();
        writer.writeStartElement('c', 'chartSpace', this.chartNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'c16r2', undefined, this.c15Namespace);
        this.serializeChartData(writer, this.chart);
        writer.writeStartElement('c', 'externalData', this.chartNamespace);
        writer.writeAttributeString('r', 'id', undefined, 'rId1');
        writer.writeStartElement('c', 'autoUpdate', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of autoUpdate
        writer.writeEndElement(); // end of externalData
        writer.writeEndElement(); // end of chartSpace
        chartPath = this.chartPath + '/chart' + this.chartCount + '.xml';
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, chartPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    // serialize chart colors.xml
    serializeChartColors() {
        let writer = new XmlWriter();
        let colorPath = '';
        writer.writeStartElement('cs', 'colorStyle', this.csNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeAttributeString(undefined, 'meth', undefined, 'cycle');
        writer.writeAttributeString(undefined, 'id', undefined, '10');
        this.serializeChartColor(writer, this.chart);
        colorPath = this.chartPath + '/colors' + this.chartCount + '.xml';
        writer.writeEndElement(); // end of cs:colorStyle chart color
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, colorPath);
        this.mArchive.addItem(zipArchiveItem);
        colorPath = '';
    }
    serializeChartColor(writer, chart) {
        for (let i = 1; i <= 6; i++) {
            writer.writeStartElement('a', 'schemeClr', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'accent' + i);
            writer.writeEndElement(); // end of a:schemeClr
        }
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '60000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '80000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '20000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '80000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '60000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '40000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '50000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '70000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '30000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '70000');
        writer.writeEndElement(); // end of lumMod
        writer.writeEndElement(); // end of cs:variation
        writer.writeStartElement('cs', 'variation', this.csNamespace);
        writer.writeStartElement('a', 'lumMod', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '50000');
        writer.writeEndElement(); // end of lumMod
        writer.writeStartElement('a', 'lumOff', this.aNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '50000');
        writer.writeEndElement(); // end of lumoff
        writer.writeEndElement(); // end of cs:variation
    }
    // serialize chart Excel Data
    serializeChartExcelData() {
        this.mArchiveExcel = new ZipArchive();
        this.mArchiveExcel.compressionLevel = 'Normal';
        let type = this.chart.chartType;
        let isScatterType = (type === 'Scatter_Markers' || type === 'Bubble');
        this.serializeWorkBook();
        this.serializeSharedString(isScatterType);
        this.serializeExcelContentTypes();
        this.serializeExcelData(isScatterType);
        this.serializeExcelStyles();
        this.serializeExcelRelation();
        this.serializeExcelGeneralRelations();
        this.chartStringCount = 0;
    }
    serializeWorkBook() {
        let writer = new XmlWriter();
        let workbookPath = 'xl/workbook.xml';
        this.resetExcelRelationShipId();
        writer.writeStartElement(undefined, 'workbook', undefined);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        writer.writeStartElement(undefined, 'sheets', undefined);
        writer.writeStartElement(undefined, 'sheet', undefined);
        writer.writeAttributeString(undefined, 'name', undefined, 'Sheet1');
        writer.writeAttributeString(undefined, 'sheetId', undefined, '1');
        writer.writeAttributeString('r', 'id', undefined, this.getNextExcelRelationShipID());
        writer.writeEndElement(); // end of sheet
        writer.writeEndElement(); // end of sheets
        writer.writeEndElement(); // end of workbook
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, workbookPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    }
    serializeExcelStyles() {
        let writer = new XmlWriter();
        let stylePath = 'xl/styles.xml';
        writer.writeStartElement(undefined, 'styleSheet', undefined);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'x14ac');
        writer.writeAttributeString('xmlns', 'x14ac', undefined, 'http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac');
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        writer.writeEndElement(); // end of styleSheet
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, stylePath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    }
    serializeExcelData(isScatterType) {
        // excel data
        let sheetPath = '';
        let writer = new XmlWriter();
        writer.writeStartElement(undefined, 'worksheet', undefined);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'x14', undefined, this.spreadSheet9);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        this.serializeExcelSheet(writer, isScatterType);
        writer.writeEndElement(); // end of worksheet
        sheetPath = 'xl/worksheets' + '/sheet1.xml';
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, sheetPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    }
    serializeSharedString(isScatterType) {
        let chart = this.chart;
        let writer = new XmlWriter();
        let sharedStringPath = '';
        let chartSharedString = [];
        let type = this.chart.chartType;
        let seriesLength = chart.chartSeries.length;
        for (let column = 0; column < seriesLength; column++) {
            let series = chart.chartSeries[column];
            let seriesName = series.seriesName;
            let isString = seriesName.match(/[a-z]/i);
            if (isScatterType && column === 0) {
                chartSharedString.push('X-Values');
            }
            if (isString) {
                chartSharedString.push(series.seriesName);
                this.chartStringCount++;
            }
        }
        if (type === 'Bubble') {
            chartSharedString.push('Size');
        }
        for (let row = 0; row < chart.chartCategory.length; row++) {
            let category = chart.chartCategory[row];
            let format = chart.chartPrimaryCategoryAxis.numberFormat;
            let categoryName = category.categoryXName;
            let isString = categoryName.match(/[a-z]/i);
            if (isString || format === 'm/d/yyyy') {
                chartSharedString.push(category.categoryXName);
                this.chartStringCount++;
            }
        }
        let uniqueCount = this.chartStringCount + 1;
        writer.writeStartElement(undefined, 'sst', undefined);
        writer.writeAttributeString('xmlns', undefined, undefined, this.spreadSheetNamespace);
        writer.writeAttributeString(undefined, 'count', undefined, uniqueCount.toString());
        writer.writeAttributeString(undefined, 'uniqueCount', undefined, uniqueCount.toString());
        for (let i = 0; i <= chartSharedString.length; i++) {
            writer.writeStartElement(undefined, 'si', undefined);
            writer.writeStartElement(undefined, 't', undefined);
            if (i !== chartSharedString.length) {
                writer.writeString(chartSharedString[i]);
            }
            else if (!isScatterType) {
                writer.writeAttributeString('xml', 'space', this.xmlNamespace, 'preserve');
                writer.writeString(' ');
            }
            writer.writeEndElement(); // end of t
            writer.writeEndElement(); // end of si
        }
        writer.writeEndElement(); // end of sst
        sharedStringPath = 'xl/sharedStrings' + '.xml';
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, sharedStringPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    }
    // excel sheet data
    serializeExcelSheet(writer, isScatterType) {
        let chart = this.chart;
        let type = 's';
        let isBubbleType = (chart.chartType === 'Bubble');
        let bubbleLength;
        let categoryLength = chart.chartCategory.length + 1;
        let format = chart.chartPrimaryCategoryAxis.numberFormat;
        let seriesLength = chart.chartSeries.length + 1;
        if (isBubbleType) {
            bubbleLength = seriesLength;
            seriesLength = seriesLength + 1;
        }
        let category = undefined;
        let series = undefined;
        let count = 0;
        writer.writeStartElement(undefined, 'sheetData', undefined);
        for (let row = 0; row < categoryLength; row++) {
            writer.writeStartElement(undefined, 'row', undefined);
            writer.writeAttributeString(undefined, 'r', undefined, (row + 1).toString());
            for (let column = 0; column < seriesLength; column++) {
                let alphaNumeric = String.fromCharCode('A'.charCodeAt(0) + column) + (row + 1).toString();
                writer.writeStartElement(undefined, 'c', undefined);
                writer.writeAttributeString(undefined, 'r', undefined, alphaNumeric);
                if (row !== 0 && column === 0) {
                    category = chart.chartCategory[row - 1];
                    let categoryName = category.categoryXName;
                    let isString = categoryName.match(/[a-z]/i);
                    if (isNullOrUndefined(isString) && format === 'm/d/yyyy') {
                        type = 's';
                    }
                    else if ((!isString && !isNullOrUndefined(isString)) || isScatterType) {
                        type = 'n';
                    }
                    else {
                        type = 's';
                    }
                }
                else if (row === 0 && column !== 0 && column !== (bubbleLength)) {
                    series = chart.chartSeries[column - 1];
                    let seriesName = series.seriesName;
                    let isString = seriesName.match(/[a-z]/i);
                    if (!isString) {
                        type = 'n';
                    }
                    else {
                        type = 's';
                    }
                }
                else if (row === 0 && isBubbleType && column === (bubbleLength)) {
                    type = 's';
                }
                else if (row === 0 && column === 0) {
                    type = 's';
                }
                else {
                    type = 'n';
                }
                writer.writeAttributeString(undefined, 't', undefined, type);
                writer.writeStartElement(undefined, 'v', undefined);
                if (row === 0 && column === 0 && !isScatterType) {
                    writer.writeString(this.chartStringCount.toString());
                }
                else if (type === 's') {
                    writer.writeString(count.toString());
                    count++;
                }
                else if (row !== 0 && type !== 's' && column === 0 && column !== (bubbleLength)) {
                    writer.writeString(category.categoryXName);
                }
                else if (column !== 0 && type !== 's' && row === 0 && column !== (bubbleLength)) {
                    writer.writeString(series.seriesName);
                }
                else if (column !== 0 && column !== (bubbleLength)) {
                    let data = category.chartData[column - 1];
                    let yValue = data.yValue;
                    writer.writeString(yValue.toString());
                }
                else if (isBubbleType && column === (bubbleLength)) {
                    let data = category.chartData[column - 2];
                    let size = data.size;
                    writer.writeString(size.toString());
                }
                writer.writeEndElement(); // end of v[value]
                writer.writeEndElement(); // end of c[column]
                type = '';
            }
            writer.writeEndElement(); // end of row
        }
        writer.writeEndElement(); // end of sheetData
    }
    // excel content types
    serializeExcelContentTypes() {
        let writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Types', 'http://schemas.openxmlformats.org/package/2006/content-types');
        this.serializeDefaultContentType(writer, 'xml', this.xmlContentType);
        this.serializeDefaultContentType(writer, 'rels', this.relationContentType);
        // tslint:disable-next-line:max-line-length
        this.serializeOverrideContentType(writer, 'xl/styles.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml');
        this.serializeOverrideContentType(writer, 'xl/workbook.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml');
        // tslint:disable-next-line:max-line-length
        // this.serializeOverrideContentType(writer, '/docProps/app.xml', 'application/vnd.openxmlformats-officedocument.extended-properties+xml');
        // this.serializeOverrideContentType(writer, '/docProps/core.xml', 'application/vnd.openxmlformats-package.core-properties+xml');
        // tslint:disable-next-line:max-line-length
        this.serializeOverrideContentType(writer, 'xl/sharedStrings.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml');
        this.serializeOverrideContentType(writer, 'xl/worksheets/sheet1.xml', 'application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml');
        writer.writeEndElement(); // end of types tag
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.contentTypesPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    }
    serializeExcelRelation() {
        let writer = new XmlWriter();
        this.resetExcelRelationShipId();
        let worksheetType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet';
        let sharedStringType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings';
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), worksheetType, 'worksheets/sheet1.xml');
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), this.stylesRelType, 'styles.xml');
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), sharedStringType, 'sharedStrings.xml');
        writer.writeEndElement(); // end of relationships
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.excelRelationPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    }
    serializeExcelGeneralRelations() {
        let writer = new XmlWriter();
        this.resetExcelRelationShipId();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextExcelRelationShipID(), this.documentRelType, 'xl/workbook.xml');
        writer.writeEndElement(); // end of relationships
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.generalRelationPath);
        this.mArchiveExcel.addItem(zipArchiveItem);
    }
    // get the next Excel relationship ID
    getNextExcelRelationShipID() {
        return 'rId' + (++this.eRelationShipId);
    }
    // get the next Chart relationship ID
    getNextChartRelationShipID() {
        return 'rId' + (++this.cRelationShipId);
    }
    //  chart data
    serializeChartData(writer, chart) {
        writer.writeStartElement('c', 'date1904', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement();
        writer.writeStartElement('c', 'lang', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'en-US');
        writer.writeEndElement();
        writer.writeStartElement('c', 'roundedCorners', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement();
        writer.writeStartElement('mc', 'AlternateContent', this.veNamespace);
        writer.writeStartElement('mc', 'Choice', this.veNamespace);
        writer.writeAttributeString('xmlns', 'c14', undefined, this.c7Namespace);
        writer.writeAttributeString(undefined, 'Requires', undefined, 'c14');
        writer.writeStartElement('c14', 'style', undefined);
        writer.writeAttributeString(undefined, 'val', undefined, '102');
        writer.writeEndElement(); // c14 style end
        writer.writeEndElement(); // mc:choice ened
        writer.writeStartElement('mc', 'Fallback', this.veNamespace);
        writer.writeStartElement('c', 'style', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '2');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement(); // end tag of mc alternate content
        writer.writeStartElement('c', 'chart', this.chartNamespace);
        if (!isNullOrUndefined(this.chart.chartTitle)) {
            writer.writeStartElement('c', 'title', this.chartNamespace);
            this.serializeTextProperties(writer, this.chart.chartTitleArea, this.chart.chartTitle);
            writer.writeEndElement(); // end tag of title
        }
        // serialize plot area
        this.serializeChartPlotArea(writer, chart);
        writer.writeEndElement(); // end tag of chart
        this.serializeShapeProperties(writer, 'D9D9D9', true);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeAttributeString('xmlns', 'c', undefined, this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeEndElement(); // end tag of bodyPr
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeEndElement(); // end of a:lstStyle
        writer.writeStartElement('a', 'p', this.aNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeStartElement('a', 'pPr', this.aNamespace);
        writer.writeStartElement('a', 'defRPr', this.aNamespace);
        writer.writeEndElement(); // end tag of defRPr
        writer.writeEndElement(); // end tag of pPr
        writer.writeStartElement('a', 'endParaRPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'lang', undefined, 'en-US');
        writer.writeEndElement(); // end of a:endParaRPr
        writer.writeEndElement(); // end tag of p
        writer.writeEndElement(); // end tag of txPr
    }
    //  chart plot area
    // tslint:disable:max-func-body-length
    serializeChartPlotArea(writer, chart) {
        writer.writeStartElement('c', 'autoTitleDeleted', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of autoTitleDeleted
        writer.writeStartElement('c', 'plotArea', this.chartNamespace);
        writer.writeStartElement('c', 'layout', this.chartNamespace);
        writer.writeEndElement();
        // chart Type
        let serializationChartType = this.chartType(chart);
        let isPieTypeSerialization = (serializationChartType === 'pieChart' || serializationChartType === 'doughnutChart');
        let isScatterType = (serializationChartType === 'scatterChart' || serializationChartType === 'bubbleChart');
        writer.writeStartElement('c', serializationChartType, this.chartNamespace);
        if (serializationChartType === 'barChart') {
            let barDiv = '';
            if (chart.chartType === 'Column_Clustered' || chart.chartType === 'Column_Stacked'
                || chart.chartType === 'Column_Stacked_100') {
                barDiv = 'col';
            }
            else {
                barDiv = 'bar';
            }
            writer.writeStartElement('c', 'barDir', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, barDiv);
            writer.writeEndElement(); // end of barDir
        }
        if (!isPieTypeSerialization && !isScatterType) {
            let grouping = this.chartGrouping(chart.chartType);
            writer.writeStartElement('c', 'grouping', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, grouping);
            writer.writeEndElement(); // end of grouping
        }
        if (serializationChartType === 'scatterChart') {
            writer.writeStartElement('c', 'scatterStyle', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'marker');
            writer.writeEndElement(); // end of scatterStyle
        }
        writer.writeStartElement('c', 'varyColors', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c:varyColors
        let valueSheet = '';
        for (let i = 0; i < chart.chartSeries.length; i++) {
            let series = chart.chartSeries[i];
            this.seriesCount = i;
            writer.writeStartElement('c', 'ser', this.chartNamespace);
            writer.writeStartElement('c', 'idx', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, i.toString());
            writer.writeEndElement(); // end of c:idx
            writer.writeStartElement('c', 'order', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, i.toString());
            writer.writeEndElement(); // end of c:order
            writer.writeStartElement('c', 'tx', this.chartNamespace);
            writer.writeStartElement('c', 'strRef', this.chartNamespace);
            writer.writeStartElement('c', 'f', this.chartNamespace);
            let alphaNumeric = String.fromCharCode('B'.charCodeAt(0) + i);
            valueSheet = 'Sheet1!$' + alphaNumeric;
            writer.writeString(valueSheet + '$1');
            valueSheet = valueSheet + '$2:$' + alphaNumeric + '$';
            writer.writeEndElement(); // end of c:f
            writer.writeStartElement('c', 'strCache', this.chartNamespace);
            writer.writeStartElement('c', 'ptCount', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '1');
            writer.writeEndElement(); // end of ptCount
            writer.writeStartElement('c', 'pt', this.chartNamespace);
            writer.writeAttributeString(undefined, 'idx', undefined, '0');
            writer.writeStartElement('c', 'v', this.chartNamespace);
            writer.writeString(series.seriesName);
            writer.writeEndElement(); // end of c:v
            writer.writeEndElement(); // end of pt
            writer.writeEndElement(); // end of strCache
            writer.writeEndElement(); // end of strRef
            writer.writeEndElement(); // end of tx
            if (chart.chartType === 'Pie' || chart.chartType === 'Doughnut') {
                this.parseChartDataPoint(writer, series);
                writer.writeStartElement('c', 'explosion', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, '0');
                writer.writeEndElement(); // end of explosion
            }
            else if (!isScatterType) {
                this.parseChartSeriesColor(writer, series.dataPoints, serializationChartType);
            }
            if (serializationChartType === 'scatterChart') {
                let fillColor = series.dataPoints[0].fill.foreColor;
                writer.writeStartElement('c', 'marker', this.chartNamespace);
                writer.writeStartElement('c', 'symbol', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, 'circle');
                writer.writeEndElement(); // end of a: symbol
                writer.writeStartElement('c', 'size', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, '5');
                writer.writeEndElement(); // end of a: size
                this.serializeShapeProperties(writer, fillColor, false);
                writer.writeEndElement(); // end of a: marker
            }
            if (series.dataLabel) {
                this.parseChartDataLabels(writer, series.dataLabel);
            }
            if (series.trendLines) {
                this.parseChartTrendLines(writer, series);
            }
            if (series.errorBar) {
                this.serializeChartErrorBar(writer, series);
            }
            if (serializationChartType === 'scatterChart') {
                this.serializeDefaultShapeProperties(writer);
            }
            else if (serializationChartType === 'bubbleChart') {
                this.serializeShapeProperties(writer, series.dataPoints[i].fill.foreColor, false);
            }
            let categoryType = 'cat';
            let categoryRef = 'strRef';
            let cacheType = 'strCache';
            if (isScatterType) {
                categoryType = 'xVal';
                categoryRef = 'numRef';
                cacheType = 'numCache';
            }
            writer.writeStartElement('c', categoryType, this.chartNamespace);
            writer.writeStartElement('c', categoryRef, this.chartNamespace);
            this.serializeChartCategory(writer, chart, cacheType); // serialize chart yvalue
            writer.writeEndElement(); // end of categoryRef
            writer.writeEndElement(); // end of cat
            this.serializeChartValue(writer, valueSheet, serializationChartType);
            writer.writeEndElement(); // end of c:ser
        }
        writer.writeStartElement('c', 'dLbls', this.chartNamespace);
        if (isPieTypeSerialization) {
            writer.writeStartElement('c', 'dLblPos', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'bestFit');
            writer.writeEndElement(); // end of dLblPos
        }
        writer.writeStartElement('c', 'showLegendKey', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showLegendKey
        writer.writeStartElement('c', 'showVal', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showVal
        writer.writeStartElement('c', 'showCatName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showCatName
        writer.writeStartElement('c', 'showSerName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showSerName
        writer.writeStartElement('c', 'showPercent', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showPercent
        writer.writeStartElement('c', 'showBubbleSize', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: showBubbleSize
        writer.writeStartElement('c', 'showLeaderLines', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '1');
        writer.writeEndElement(); // end of c: showLeaderLines
        writer.writeEndElement(); // end of c: dLbls
        if (isPieTypeSerialization) {
            let series = this.chart.chartSeries[0];
            let sliceAngle = 0;
            let holeSize = 0;
            if (series.hasOwnProperty('firstSliceAngle')) {
                sliceAngle = series.firstSliceAngle;
            }
            writer.writeStartElement('c', 'firstSliceAng', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, sliceAngle.toString());
            writer.writeEndElement(); // end of c: firstSliceAng
            if (chart.chartType === 'Doughnut') {
                holeSize = series.holeSize;
                writer.writeStartElement('c', 'holeSize', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, holeSize.toString());
                writer.writeEndElement(); // end of c: holeSize
            }
        }
        if (serializationChartType !== 'lineChart' && !isScatterType) {
            writer.writeStartElement('c', 'gapWidth', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, this.chart.gapWidth.toString());
            writer.writeEndElement(); // end of gapWidth
            writer.writeStartElement('c', 'overlap', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, this.chart.overlap.toString());
            writer.writeEndElement(); // end of overlap
        }
        else if (serializationChartType !== 'bubbleChart') {
            writer.writeStartElement('c', 'smooth', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of smooth
        }
        if (serializationChartType === 'bubbleChart') {
            writer.writeStartElement('c', 'sizeRepresents', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'area');
            writer.writeEndElement(); // end of smooth
        }
        let type = this.chart.chartType;
        if (!isPieTypeSerialization) {
            writer.writeStartElement('c', 'axId', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '335265000');
            writer.writeEndElement(); // end of axId
            writer.writeStartElement('c', 'axId', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '335263360');
            writer.writeEndElement(); // end of axId
        }
        writer.writeEndElement(); // end of chart type
        let isStackedPercentage = (type === 'Column_Stacked_100' || type === 'Area_Stacked_100' ||
            type === 'Bar_Stacked_100' || type === 'Line_Stacked_100' || type === 'Line_Markers_Stacked_100');
        let format = this.chart.chartPrimaryCategoryAxis.categoryType;
        if (!isPieTypeSerialization) {
            this.serializeCategoryAxis(writer, format, isStackedPercentage);
            this.serializeValueAxis(writer, format, isStackedPercentage);
        }
        if (this.chart.hasOwnProperty('chartDataTable')) {
            let dataTable = this.chart.chartDataTable;
            let showHorzBorder = 0;
            let showVertBorder = 0;
            let showOutline = 0;
            let showKeys = 0;
            if (dataTable.showSeriesKeys) {
                showKeys = 1;
            }
            if (dataTable.hasHorzBorder) {
                showHorzBorder = 1;
            }
            if (dataTable.hasVertBorder) {
                showVertBorder = 1;
            }
            if (dataTable.hasBorders) {
                showOutline = 1;
            }
            writer.writeStartElement('c', 'dTable', this.chartNamespace);
            writer.writeStartElement('c', 'showHorzBorder', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showHorzBorder.toString());
            writer.writeEndElement(); // end of showHorzBorder
            writer.writeStartElement('c', 'showVertBorder', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showVertBorder.toString());
            writer.writeEndElement(); // end of showVertBorder
            writer.writeStartElement('c', 'showOutline', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showOutline.toString());
            writer.writeEndElement(); // end of showOutline
            writer.writeStartElement('c', 'showKeys', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, showKeys.toString());
            writer.writeEndElement(); // end of showKeys
            writer.writeEndElement(); // end of dTable
        }
        this.serializeDefaultShapeProperties(writer);
        writer.writeEndElement(); // end of plot area
        // legend
        if (!isNullOrUndefined(this.chart.chartLegend.position)) {
            this.serializeChartLegend(writer);
        }
        writer.writeStartElement('c', 'plotVisOnly', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '1');
        writer.writeEndElement(); // end of c: plotVisOnly
        writer.writeStartElement('c', 'dispBlanksAs', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'gap');
        writer.writeEndElement(); // end of c: dispBlanksAs
    }
    serializeChartLegend(writer) {
        let legendPosition = this.chartLegendPosition(this.chart.chartLegend);
        let title = this.chart.chartLegend.chartTitleArea;
        let fill = title.dataFormat.fill.foreColor;
        writer.writeStartElement('c', 'legend', this.chartNamespace);
        writer.writeStartElement('c', 'legendPos', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, legendPosition);
        writer.writeEndElement();
        writer.writeStartElement('c', 'overlay', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement();
        this.serializeDefaultShapeProperties(writer);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement();
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement();
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, title.fontSize, fill, title.fontName);
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
    }
    serializeChartErrorBar(writer, series) {
        let errorBar = series.errorBar;
        let errorBarValueType = this.errorBarValueType(errorBar.type);
        let endStyle = 0;
        if (errorBar.endStyle !== 'Cap') {
            endStyle = 1;
        }
        writer.writeStartElement('c', 'errBars', this.chartNamespace);
        writer.writeStartElement('c', 'errBarType', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, errorBar.direction.toLowerCase());
        writer.writeEndElement(); // end of c: errBarType
        writer.writeStartElement('c', 'errValType', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, errorBarValueType);
        writer.writeEndElement(); // end of c: errValType
        writer.writeStartElement('c', 'noEndCap', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, endStyle.toString());
        writer.writeEndElement(); // end of c: noEndCap
        writer.writeStartElement('c', 'val', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, errorBar.numberValue.toString());
        writer.writeEndElement(); // end of c: val
        this.serializeShapeProperties(writer, '595959', true);
        writer.writeEndElement(); // end of c: errBars
    }
    errorBarValueType(type) {
        let valueType = '';
        switch (type) {
            case 'StandardError':
                valueType = 'stdErr';
                break;
            case 'StandardDeviation':
                valueType = 'stdDev';
                break;
            case 'Percentage':
                valueType = 'percentage';
                break;
            case 'Fixed':
                valueType = 'fixedVal';
                break;
            default:
                valueType = 'stdErr';
                break;
        }
        return valueType;
    }
    serializeCategoryAxis(writer, format, isStackedPercentage) {
        // serialize category axis
        let axisType = 'catAx';
        let formatCode = this.chart.chartPrimaryCategoryAxis.numberFormat;
        let type = this.chart.chartType;
        let isScatterType = (type === 'Scatter_Markers' || type === 'Bubble');
        if (format === 'Time') {
            axisType = 'dateAx';
        }
        if (isScatterType) {
            axisType = 'valAx';
        }
        writer.writeStartElement('c', axisType, this.chartNamespace);
        writer.writeStartElement('c', 'axId', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '335265000');
        writer.writeEndElement(); // end of axId
        this.serializeAxis(writer, '335263360', this.chart.chartPrimaryCategoryAxis, formatCode, isStackedPercentage);
        if (!isScatterType) {
            writer.writeStartElement('c', 'auto', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '1');
            writer.writeEndElement(); // end of auto
            writer.writeStartElement('c', 'lblAlgn', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'ctr');
            writer.writeEndElement(); // end of lblAlgn
            writer.writeStartElement('c', 'lblOffset', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '100');
            writer.writeEndElement(); // end of lblOffset
        }
        if (format === 'Time') {
            writer.writeStartElement('c', 'baseTimeUnit', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'days');
            writer.writeEndElement(); // end of baseTimeUnit
        }
        else if (this.chart.chartType !== 'Bubble') {
            writer.writeStartElement('c', 'noMultiLvlLbl', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of noMultiLvlLbl
        }
        writer.writeEndElement(); // end of catAx
    }
    serializeValueAxis(writer, format, isStackedPercentage) {
        // serialize category axis
        let valueAxis = this.chart.chartPrimaryValueAxis;
        let crossBetween = 'between';
        if (format === 'Time') {
            crossBetween = 'midCat';
        }
        writer.writeStartElement('c', 'valAx', this.chartNamespace);
        writer.writeStartElement('c', 'axId', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '335263360');
        writer.writeEndElement(); // end of axId
        this.serializeAxis(writer, '335265000', valueAxis, 'General', isStackedPercentage);
        writer.writeStartElement('c', 'crossBetween', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, crossBetween);
        writer.writeEndElement(); // end of crossBetween
        if (valueAxis.majorUnit !== 0 && !isStackedPercentage) {
            writer.writeStartElement('c', 'majorUnit', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, valueAxis.majorUnit.toString());
            writer.writeEndElement(); // end of majorUnit
        }
        writer.writeEndElement(); // end of valAx
    }
    serializeAxis(writer, axisID, axis, formatCode, isStackedPercentage) {
        let majorTickMark = 'none';
        let minorTickMark = 'none';
        let tickLabelPosition = 'nextTo';
        writer.writeStartElement('c', 'scaling', this.chartNamespace);
        writer.writeStartElement('c', 'orientation', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'minMax');
        writer.writeEndElement(); // end of orientation
        if (axis.maximumValue !== 0 && !isStackedPercentage) {
            writer.writeStartElement('c', 'max', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, axis.maximumValue.toString());
            writer.writeEndElement(); // end of max
            writer.writeStartElement('c', 'min', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, axis.minimumValue.toString());
            writer.writeEndElement(); // end of min
        }
        writer.writeEndElement(); // end of scaling
        writer.writeStartElement('c', 'delete', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of delete
        writer.writeStartElement('c', 'axPos', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'l');
        writer.writeEndElement(); // end of axPos
        if (axis.hasMajorGridLines) {
            writer.writeStartElement('c', 'majorGridlines', this.chartNamespace);
            this.serializeShapeProperties(writer, 'D9D9D9', true);
            writer.writeEndElement(); // end of majorGridlines
        }
        if (axis.hasMinorGridLines) {
            writer.writeStartElement('c', 'minorGridlines', this.chartNamespace);
            this.serializeShapeProperties(writer, 'F2F2F2', true);
            writer.writeEndElement(); // end of minorGridlines
        }
        if (axis.chartTitle) {
            writer.writeStartElement('c', 'title', this.chartNamespace);
            this.serializeTextProperties(writer, axis.chartTitleArea, axis.chartTitle);
            writer.writeEndElement(); // end tag of title
        }
        writer.writeStartElement('c', 'numFmt', this.chartNamespace);
        writer.writeAttributeString(undefined, 'formatCode', undefined, formatCode);
        writer.writeAttributeString(undefined, 'sourceLinked', undefined, '1');
        writer.writeEndElement(); // end of numFmt
        writer.writeStartElement('c', 'majorTickMark', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, majorTickMark);
        writer.writeEndElement(); // end of majorTickMark
        writer.writeStartElement('c', 'minorTickMark', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, minorTickMark);
        writer.writeEndElement(); // end of minorTickMark
        writer.writeStartElement('c', 'tickLblPos', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, tickLabelPosition);
        writer.writeEndElement(); // end of tickLblPos
        if (this.chart.chartType === 'Bubble') {
            this.serializeShapeProperties(writer, 'BFBFBF', true);
        }
        else {
            this.serializeDefaultShapeProperties(writer);
        }
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement(); // end of bodyPr
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, axis.fontSize, '595959', axis.fontName);
        writer.writeEndElement(); // end of a: p
        writer.writeEndElement(); // end of c: txPr
        writer.writeStartElement('c', 'crossAx', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, axisID);
        writer.writeEndElement(); // end of crossAx
        writer.writeStartElement('c', 'crosses', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, 'autoZero');
        writer.writeEndElement(); // end of crosses
    }
    parseChartTrendLines(writer, series) {
        for (let i = 0; i < series.trendLines.length; i++) {
            let data = series.trendLines[i];
            let type = this.chartTrendLineType(data.type);
            let dispRSqr = 0;
            let dispEq = 0;
            if (data.isDisplayEquation) {
                dispEq = 1;
            }
            else if (data.isDisplayRSquared) {
                dispRSqr = 1;
            }
            let solidFill = series.dataPoints[i];
            writer.writeStartElement('c', 'trendline', this.chartNamespace);
            writer.writeStartElement('c', 'spPr', this.chartNamespace);
            writer.writeStartElement('a', 'ln', this.aNamespace);
            writer.writeAttributeString(undefined, 'w', undefined, '19050');
            this.serializeChartSolidFill(writer, solidFill.fill.foreColor, false);
            writer.writeStartElement('a', 'prstDash', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'sysDot');
            writer.writeEndElement(); // end of a: prstDash
            writer.writeStartElement('a', 'round', this.aNamespace);
            writer.writeEndElement(); // end of a: round
            writer.writeEndElement(); // end of a: ln
            writer.writeEndElement(); // end of c: spPr
            writer.writeStartElement('c', 'trendlineType', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, type);
            writer.writeEndElement(); // end of c: trendlineType
            writer.writeStartElement('c', 'forward', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, data.forward.toString());
            writer.writeEndElement(); // end of c: forward
            writer.writeStartElement('c', 'backward', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, data.backward.toString());
            writer.writeEndElement(); // end of c: backward
            if (data.intercept !== 'NaN') {
                writer.writeStartElement('c', 'intercept', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, data.intercept.toString());
                writer.writeEndElement(); // end of c: intercept
            }
            writer.writeStartElement('c', 'dispRSqr', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, dispRSqr.toString());
            writer.writeEndElement(); // end of c: dispRSqr
            writer.writeStartElement('c', 'dispEq', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, dispEq.toString());
            writer.writeEndElement(); // end of c: dispEq
            writer.writeEndElement(); // end of c: trendline
        }
    }
    chartTrendLineType(type) {
        let trendlineType = '';
        switch (type) {
            case 'Linear':
                trendlineType = 'linear';
                break;
            case 'Exponential':
                trendlineType = 'exp';
                break;
        }
        return trendlineType;
    }
    parseChartDataLabels(writer, dataLabels) {
        let position = '';
        let dataLabelPosition = dataLabels.position;
        let isLegendKey = 0;
        let isBubbleSize = 0;
        let isCategoryName = 0;
        let isSeriesName = 0;
        let isValue = 0;
        let isPercentage = 0;
        let isLeaderLines = 0;
        switch (dataLabelPosition) {
            case 'Center':
                position = 'ctr';
                break;
            case 'Left':
                position = 'l';
                break;
            case 'Right':
                position = 'r';
                break;
            case 'Outside':
                position = 'outEnd';
                break;
            case 'BestFit':
                position = 'bestFit';
                break;
            case 'Bottom':
            case 'OutsideBase':
                position = 'inBase';
                break;
            case 'Inside':
                position = 'inEnd';
                break;
            case 'Above':
                position = 't';
                break;
            case 'Below':
                position = 'b';
                break;
            default:
                position = 'Automatic';
                break;
        }
        writer.writeStartElement('c', 'dLbls', this.chartNamespace);
        this.serializeDefaultShapeProperties(writer);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement(); //end of a:bodyPr.
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement(); //end of a:lstStyle.
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, dataLabels.fontSize, dataLabels.fontColor, dataLabels.fontName);
        writer.writeEndElement(); //end of a:p.
        writer.writeEndElement(); //end of c:txPr.
        if (dataLabels.isLegendKey) {
            isLegendKey = 1;
        }
        else if (dataLabels.isBubbleSize) {
            isBubbleSize = 1;
        }
        else if (dataLabels.isCategoryName) {
            isCategoryName = 1;
        }
        else if (dataLabels.isSeriesName) {
            isSeriesName = 1;
        }
        else if (dataLabels.isValue) {
            isValue = 1;
        }
        else if (dataLabels.isPercentage) {
            isPercentage = 1;
        }
        else if (dataLabels.isLeaderLines) {
            isLeaderLines = 1;
        }
        if (position !== 'Automatic') {
            writer.writeStartElement('c', 'dLblPos', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, position);
            writer.writeEndElement(); // end of dLblPos
        }
        writer.writeStartElement('c', 'showLegendKey', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isLegendKey.toString());
        writer.writeEndElement(); // end of showLegendKey
        writer.writeStartElement('c', 'showVal', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isValue.toString());
        writer.writeEndElement(); // end of showVal
        writer.writeStartElement('c', 'showCatName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isCategoryName.toString());
        writer.writeEndElement(); // end of showCatName
        writer.writeStartElement('c', 'showSerName', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isSeriesName.toString());
        writer.writeEndElement(); // end of showSerName
        writer.writeStartElement('c', 'showPercent', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isPercentage.toString());
        writer.writeEndElement(); // end of showPercent
        writer.writeStartElement('c', 'showBubbleSize', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isBubbleSize.toString());
        writer.writeEndElement(); // end of showBubbleSize
        writer.writeStartElement('c', 'showLeaderLines', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, isLeaderLines.toString());
        writer.writeEndElement(); // end of showBubbleSize
        writer.writeEndElement(); // end of dLbls
    }
    serializeShapeProperties(writer, color, isLine) {
        let chartType = this.chart.chartType;
        let isScatterType = (chartType === 'Scatter_Markers' || chartType === 'Bubble');
        // serialize shape
        writer.writeStartElement('c', 'spPr', this.chartNamespace);
        if (!isScatterType || isLine) {
            writer.writeStartElement('a', 'ln', this.aNamespace);
            writer.writeAttributeString(undefined, 'w', undefined, '9525');
            this.serializeChartSolidFill(writer, color, false);
            writer.writeStartElement('a', 'prstDash', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, 'solid');
            writer.writeEndElement(); // end of prstDash
            writer.writeStartElement('a', 'round', this.aNamespace);
            writer.writeEndElement(); // end tag of round
            writer.writeEndElement(); // end tag of ln
        }
        else if (chartType === 'Scatter_Markers') {
            this.serializeChartSolidFill(writer, color, false);
            this.serializeDefaultLineProperties(writer);
        }
        else if (chartType === 'Bubble') {
            this.serializeChartSolidFill(writer, color, true);
            this.serializeDefaultLineProperties(writer);
        }
        writer.writeStartElement('a', 'effectLst', this.aNamespace);
        writer.writeEndElement(); // end of a: effectLst
        writer.writeEndElement(); // end tag of spPr
    }
    serializeDefaultShapeProperties(writer) {
        writer.writeStartElement('c', 'spPr', this.chartNamespace);
        writer.writeStartElement('a', 'noFill', this.aNamespace);
        writer.writeEndElement(); // end of a: noFill
        this.serializeDefaultLineProperties(writer);
        writer.writeStartElement('a', 'effectLst', this.aNamespace);
        writer.writeEndElement(); // end of a: effectLst
        writer.writeEndElement(); // end of c: spPr
    }
    serializeDefaultLineProperties(writer) {
        writer.writeStartElement('a', 'ln', this.aNamespace);
        writer.writeStartElement('a', 'noFill', this.aNamespace);
        writer.writeEndElement(); // end of a: noFill
        writer.writeStartElement('a', 'round', this.aNamespace);
        writer.writeEndElement(); // end of a: round
        writer.writeEndElement(); // end of a: ln
    }
    serializeTextProperties(writer, title, chartTitleName) {
        let fill = title.dataFormat.fill.foreColor;
        let fontSize = title.fontSize * 100;
        writer.writeStartElement('c', 'tx', this.chartNamespace);
        writer.writeStartElement('c', 'rich', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'rot', undefined, '0');
        writer.writeAttributeString(undefined, 'vert', undefined, 'horz');
        writer.writeEndElement(); // end of a: bodyPr
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement(); // end of a:lstStyle
        writer.writeStartElement('a', 'p', this.aNamespace);
        this.serializeChartTitleFont(writer, title.fontSize, fill, title.fontName);
        writer.writeStartElement('a', 'r', this.aNamespace);
        writer.writeStartElement('a', 'rPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'lang', undefined, 'en-US');
        writer.writeAttributeString(undefined, 'b', undefined, '0');
        writer.writeAttributeString(undefined, 'sz', undefined, fontSize.toString());
        writer.writeAttributeString(undefined, 'baseline', undefined, '0');
        this.serializeChartSolidFill(writer, fill, false);
        this.serializeFont(writer, title.fontName);
        writer.writeEndElement(); // end of a: rPr
        writer.writeStartElement('a', 't', this.aNamespace);
        writer.writeString(chartTitleName);
        writer.writeEndElement(); // end of a:t
        writer.writeEndElement(); // end of a: r
        writer.writeEndElement(); // end of a: p
        writer.writeEndElement(); // end of c: rich
        writer.writeEndElement(); // end of c: tx
        writer.writeStartElement('c', 'layout', this.chartNamespace);
        // writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: layout
        writer.writeStartElement('c', 'overlay', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, '0');
        writer.writeEndElement(); // end of c: overlay
        this.serializeDefaultShapeProperties(writer);
        writer.writeStartElement('c', 'txPr', this.chartNamespace);
        writer.writeStartElement('a', 'bodyPr', this.aNamespace);
        writer.writeEndElement(); // end of a: bodyPr
        writer.writeStartElement('a', 'lstStyle', this.aNamespace);
        writer.writeEndElement(); // end of a: lstStyle
        writer.writeStartElement('a', 'p', this.aNamespace);
        writer.writeEndElement(); // end of a: p
        this.serializeChartTitleFont(writer, title.fontSize, fill, title.fontName);
        writer.writeEndElement(); // end of c: txPr
    }
    serializeChartTitleFont(writer, fontSize, fill, fontName) {
        let fontSizeCalc = fontSize * 100;
        writer.writeStartElement('a', 'pPr', this.aNamespace);
        writer.writeStartElement('a', 'defRPr', this.aNamespace);
        writer.writeAttributeString(undefined, 'lang', undefined, 'en-US');
        writer.writeAttributeString(undefined, 'b', undefined, '0');
        writer.writeAttributeString(undefined, 'sz', undefined, fontSizeCalc.toString());
        writer.writeAttributeString(undefined, 'baseline', undefined, '0');
        this.serializeChartSolidFill(writer, fill, false);
        this.serializeFont(writer, fontName);
        writer.writeEndElement(); // end of defRPr
        writer.writeEndElement(); // end of a: pPr
    }
    serializeChartSolidFill(writer, fill, isSeriesFill) {
        writer.writeStartElement('a', 'solidFill', this.aNamespace);
        writer.writeStartElement('a', 'srgbClr', this.aNamespace);
        if (fill !== '000000') {
            writer.writeAttributeString(undefined, 'val', undefined, fill);
        }
        else {
            writer.writeAttributeString(undefined, 'val', undefined, '595959');
        }
        if (this.chart.chartType === 'Bubble' && isSeriesFill) {
            writer.writeStartElement('a', 'alpha', this.aNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '75000');
            writer.writeEndElement(); // end of alpha
        }
        writer.writeEndElement(); // end of srgbClr
        writer.writeEndElement(); // end of solidFill
    }
    serializeFont(writer, fontName) {
        writer.writeStartElement('a', 'latin', this.aNamespace);
        writer.writeAttributeString(undefined, 'typeface', undefined, fontName);
        writer.writeEndElement(); // end of a:latin
        writer.writeStartElement('a', 'ea', this.aNamespace);
        writer.writeAttributeString(undefined, 'typeface', undefined, fontName);
        writer.writeEndElement(); // end of a:ea
        writer.writeStartElement('a', 'cs', this.aNamespace);
        writer.writeAttributeString(undefined, 'typeface', undefined, fontName);
        writer.writeEndElement(); // end of a:cs
    }
    parseChartSeriesColor(writer, dataPoints, chartType) {
        for (let i = 0; i < dataPoints.length; i++) {
            let data = dataPoints[i];
            writer.writeStartElement('c', 'spPr', this.chartNamespace);
            if (chartType === 'lineChart') {
                writer.writeStartElement('a', 'ln', this.aNamespace);
                writer.writeAttributeString(undefined, 'w', undefined, '28575');
                writer.writeAttributeString(undefined, 'cap', undefined, 'rnd');
            }
            if (chartType !== 'lineChart') {
                this.serializeChartSolidFill(writer, data.fill.foreColor, true);
            }
            else {
                this.serializeChartSolidFill(writer, data.line.color, true);
            }
            if (chartType !== 'lineChart') {
                writer.writeStartElement('a', 'ln', this.aNamespace);
                writer.writeStartElement('a', 'noFill', this.aNamespace);
                writer.writeEndElement(); // end of a: noFill
            }
            writer.writeStartElement('a', 'round', this.aNamespace);
            writer.writeEndElement(); // end of a: round
            writer.writeEndElement(); // end of a: ln
            writer.writeStartElement('a', 'effectLst', this.aNamespace);
            writer.writeEndElement(); // end of a: effectLst
            writer.writeEndElement(); // end of c: spPr
            if (chartType === 'lineChart') {
                let symbolType = 'none';
                let size = 0;
                if (this.chart.chartSeries[i].hasOwnProperty('seriesFormat')) {
                    symbolType = this.chart.chartSeries[i].seriesFormat.markerStyle;
                    size = this.chart.chartSeries[i].seriesFormat.markerSize;
                }
                writer.writeStartElement('c', 'marker', this.chartNamespace);
                writer.writeStartElement('c', 'symbol', this.chartNamespace);
                writer.writeAttributeString(undefined, 'val', undefined, symbolType.toLowerCase());
                writer.writeEndElement(); // end of a: symbol
                if (this.chart.chartSeries[i].hasOwnProperty('seriesFormat')) {
                    writer.writeStartElement('c', 'size', this.chartNamespace);
                    writer.writeAttributeString(undefined, 'val', undefined, size.toString());
                    writer.writeEndElement(); // end of a: size
                }
                writer.writeEndElement(); // end of a: marker
            }
        }
    }
    parseChartDataPoint(writer, series) {
        // data point
        let dataPoints = series.dataPoints;
        let points = [];
        for (let j = 0; j < dataPoints.length; j++) {
            points.push(dataPoints[j]);
            writer.writeStartElement('c', 'dPt', this.chartNamespace);
            writer.writeStartElement('c', 'idx', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, j.toString());
            writer.writeEndElement(); // end of c:idx
            writer.writeStartElement('c', 'bubble3D', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of c:bubble3D
            this.parseChartSeriesColor(writer, points, this.chart.chartType);
            writer.writeEndElement(); // end of c:dPt
            points = [];
        }
    }
    // chart data value
    serializeChartCategory(writer, chart, cacheType) {
        let chartCategory = chart.chartCategory;
        let chartCategoryCount = chartCategory.length;
        writer.writeStartElement('c', 'f', this.chartNamespace);
        writer.writeString('Sheet1!$A$2:$A$' + (chartCategoryCount + 1).toString());
        writer.writeEndElement(); // end of f
        writer.writeStartElement('c', cacheType, this.chartNamespace);
        if (cacheType === 'numCache') {
            writer.writeStartElement('c', 'formatCode', this.chartNamespace);
            writer.writeString('General');
            writer.writeEndElement(); // end of formatCode
        }
        writer.writeStartElement('c', 'ptCount', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, chartCategoryCount.toString());
        writer.writeEndElement(); // end of ptCount
        for (let i = 0; i < chartCategory.length; i++) {
            let category = chartCategory[i];
            writer.writeStartElement('c', 'pt', this.chartNamespace);
            writer.writeAttributeString(undefined, 'idx', undefined, i.toString());
            writer.writeStartElement('c', 'v', this.chartNamespace);
            if (category.categoryXName !== '') {
                writer.writeString(category.categoryXName);
            }
            writer.writeEndElement(); // end of v
            writer.writeEndElement(); // end of pt
        }
        writer.writeEndElement(); // end of cacheType
    }
    // chart value
    serializeChartValue(writer, valueSheet, chartType) {
        let isScatterType = (chartType === 'scatterChart' || chartType === 'bubbleChart');
        let valueType = 'val';
        if (isScatterType) {
            valueType = 'yVal';
        }
        this.serializeChartYValue(writer, valueType, valueSheet);
        if (chartType === 'bubbleChart') {
            valueType = 'bubbleSize';
            valueSheet = 'Sheet1!$C$2:$C$';
            this.serializeChartYValue(writer, valueType, valueSheet);
        }
        if (chartType === 'lineChart' || chartType === 'scatterChart') {
            writer.writeStartElement('c', 'smooth', this.chartNamespace);
            writer.writeAttributeString(undefined, 'val', undefined, '0');
            writer.writeEndElement(); // end of smooth
        }
    }
    serializeChartYValue(writer, valueType, valueSheet) {
        let chart = this.chart;
        let chartCategory = chart.chartCategory;
        let chartCategoryCount = chartCategory.length;
        writer.writeStartElement('c', valueType, this.chartNamespace);
        writer.writeStartElement('c', 'numRef', this.chartNamespace);
        writer.writeStartElement('c', 'f', this.chartNamespace);
        writer.writeString(valueSheet + (chartCategoryCount + 1).toString());
        writer.writeEndElement(); // end of f
        writer.writeStartElement('c', 'numCache', this.chartNamespace);
        writer.writeStartElement('c', 'formatCode', this.chartNamespace);
        writer.writeString('General');
        writer.writeEndElement(); // end of formatCode
        writer.writeStartElement('c', 'ptCount', this.chartNamespace);
        writer.writeAttributeString(undefined, 'val', undefined, chartCategoryCount.toString());
        writer.writeEndElement(); // end of ptCount
        for (let j = 0; j < chartCategoryCount; j++) {
            let category = chartCategory[j];
            for (let k = 0; k < category.chartData.length; k++) {
                if (k === this.seriesCount) {
                    let chartData = category.chartData[this.seriesCount];
                    writer.writeStartElement('c', 'pt', this.chartNamespace);
                    writer.writeAttributeString(undefined, 'idx', undefined, j.toString());
                    writer.writeStartElement('c', 'v', this.chartNamespace);
                    if (valueType !== 'bubbleSize') {
                        writer.writeString(chartData.yValue.toString());
                    }
                    else {
                        writer.writeString(chartData.size.toString());
                    }
                    writer.writeEndElement(); // end of v
                    writer.writeEndElement(); // end of pt
                }
            }
        }
        writer.writeEndElement(); // end of numCache
        writer.writeEndElement(); // end of numRef
        writer.writeEndElement(); // end of val
    }
    // chart type
    chartType(chart) {
        let chartType = chart.chartType;
        switch (chartType) {
            case 'Pie':
                chartType = 'pieChart';
                break;
            case 'Doughnut':
                chartType = 'doughnutChart';
                break;
            case 'Scatter_Markers':
                chartType = 'scatterChart';
                break;
            case 'Bubble':
                chartType = 'bubbleChart';
                break;
        }
        if (chartType === 'Area' || chartType === 'Area_Stacked' || chartType === 'Area_Stacked_100') {
            chartType = 'areaChart';
        }
        if (chartType === 'Bar_Stacked_100' || chartType === 'Bar_Stacked' || chartType === 'Bar_Clustered' ||
            chartType === 'Column_Clustered' || chartType === 'Column_Stacked' || chartType === 'Column_Stacked_100') {
            chartType = 'barChart';
        }
        if (chartType === 'Line' || chartType === 'Line_Markers' || chartType === 'Line_Markers_Stacked' || chartType === 'Line_Stacked'
            || chartType === 'Line_Markers_Stacked_100' || chartType === 'Line_Stacked_100') {
            chartType = 'lineChart';
        }
        return chartType;
    }
    // chart group
    chartGrouping(type) {
        let grouping = 'standard';
        if (type === 'Bar_Stacked' || type === 'Column_Stacked' || type === 'Area_Stacked'
            || type === 'Line_Stacked' || type === 'Line_Markers_Stacked') {
            grouping = 'stacked';
        }
        else if (type === 'Bar_Stacked_100' || type === 'Column_Stacked_100' ||
            type === 'Area_Stacked_100' || type === 'Line_Stacked_100' ||
            type === 'Line_Markers_Stacked_100') {
            grouping = 'percentStacked';
        }
        else if (type === 'Bar_Clustered' || type === 'Column_Clustered') {
            grouping = 'clustered';
        }
        return grouping;
    }
    // chart legend position
    chartLegendPosition(chart) {
        let legendPosition = chart.position;
        switch (legendPosition) {
            case 'Top':
                legendPosition = 't';
                break;
            case 'Bottom':
                legendPosition = 'b';
                break;
            case 'Left':
                legendPosition = 'l';
                break;
            case 'Right':
                legendPosition = 'r';
                break;
            case 'Corner':
                legendPosition = 'tr';
                break;
            default:
                legendPosition = 'b';
                break;
        }
        return legendPosition;
    }
    // update the chard id
    updatechartId(chart) {
        let id = '';
        if (id === '') {
            id = this.addChartRelation(this.documentCharts, chart);
        }
        return id;
    }
    // adds the chart relation.
    addChartRelation(chartCollection, chart) {
        let relationId = '';
        relationId = this.getNextRelationShipID();
        chartCollection.add(relationId, chart);
        return relationId;
    }
    startsWith(sourceString, startString) {
        return startString.length > 0 && sourceString.substring(0, startString.length) === startString;
    }
    // Serialize the graphics element for pictures.
    serializeDrawingGraphics(writer, picture) {
        let id = '';
        id = this.updateShapeId(picture);
        // picture.ShapeId = this.getNextDocPrID();
        // Processing picture
        writer.writeStartElement('wp', 'docPr', this.wpNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, (this.mDocPrID++).toString());
        // if (!isNullOrUndefined(picture.AlternativeText))
        //     m_writer.WriteAttributeString('descr', picture.AlternativeText);
        writer.writeAttributeString(undefined, 'name', undefined, '1'.toString());
        // if (!string.IsNullOrEmpty(picture.Title))
        //     m_writer.WriteAttributeString('title', picture.Title);
        // else
        writer.writeAttributeString(undefined, 'title', undefined, '');
        // if (!picture.Visible)
        //     m_writer.WriteAttributeString('hidden', '1');
        // SerializePictureHyperlink(picture);
        writer.writeEndElement();
        writer.writeStartElement('a', 'graphic', this.aNamespace);
        writer.writeStartElement('a', 'graphicData', this.aNamespace);
        writer.writeAttributeString(undefined, 'uri', undefined, this.pictureNamespace);
        writer.writeStartElement('pic', 'pic', this.pictureNamespace);
        writer.writeStartElement('pic', 'nvPicPr', this.pictureNamespace);
        writer.writeStartElement('pic', 'cNvPr', this.pictureNamespace);
        writer.writeAttributeString(undefined, 'id', undefined, '0');
        writer.writeAttributeString(undefined, 'name', undefined, '');
        writer.writeAttributeString(undefined, 'descr', undefined, '');
        writer.writeEndElement();
        writer.writeStartElement('pic', 'cNvPicPr', this.pictureNamespace);
        writer.writeStartElement('a', 'picLocks', this.aNamespace);
        writer.writeAttributeString(undefined, 'noChangeAspect', undefined, '1');
        writer.writeAttributeString(undefined, 'noChangeArrowheads', undefined, '1');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('pic', 'blipFill', this.pictureNamespace);
        writer.writeStartElement('a', 'blip', this.aNamespace);
        if (this.startsWith(picture.imageString, 'data:image')) {
            writer.writeAttributeString('r', 'embed', this.rNamespace, id);
        }
        else {
            if (this.documentImages.containsKey(id)) {
                //Remove the image document images collection for this particular key
                //If the picture image data has href means MS Word contains the image in media folder as well as 
                //it is having external relationship id
                // if (!this.startsWith(picture.imageString, 'data:image')) {
                this.documentImages.remove(id);
                this.externalImages.add(id, picture.imageString);
                writer.writeAttributeString(undefined, 'link', this.rNamespace, id);
            }
        }
        //End Element Blip
        writer.writeEndElement();
        writer.writeStartElement('a', 'srcRect', this.aNamespace);
        writer.writeEndElement();
        writer.writeStartElement('a', 'stretch', this.aNamespace);
        writer.writeStartElement('a', 'fillRect', this.aNamespace);
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('pic', 'spPr', this.pictureNamespace);
        writer.writeAttributeString(undefined, 'bwMode', undefined, 'auto');
        writer.writeStartElement('a', 'xfrm', this.aNamespace);
        // if (picture.Rotation !== 0)
        //     m_writer.WriteAttributeString('rot', picture.Rotation.ToString());
        writer.writeStartElement('a', 'off', this.aNamespace);
        writer.writeAttributeString(undefined, 'x', undefined, '0');
        writer.writeAttributeString(undefined, 'y', undefined, '0');
        writer.writeEndElement();
        writer.writeStartElement('a', 'ext', this.aNamespace);
        let cx = Math.round((picture.width * this.emusPerPoint));
        writer.writeAttributeString(undefined, 'cx', undefined, cx.toString());
        let cy = Math.round((picture.height * this.emusPerPoint));
        writer.writeAttributeString(undefined, 'cy', undefined, cy.toString());
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeStartElement('a', 'prstGeom', this.aNamespace);
        writer.writeAttributeString(undefined, 'prst', undefined, 'rect');
        writer.writeStartElement('a', 'avLst', this.aNamespace);
        writer.writeEndElement();
        writer.writeEndElement();
        //When the picture border has been added next to effect list
        //if not, Picture border has not been preserved
        // if (picture.HasBorder)
        // {
        //     if (picture.TextWrappingStyle === TextWrappingStyle.Inline && picture.IsShape)
        //         SerializeInlineShapeLine(picture.PictureShape);
        //     else
        //         SerializeShapeLine(picture.PictureShape);
        // }
        // if (picture.DocxProps.length > 0)
        //     SerializeDocxProps(picture.DocxProps, 'effectLst');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
    }
    /// Update the shape id.
    updateShapeId(picture) {
        let id = '';
        let tOwner = this.paragraph;
        // Adding picture byte data to the corresponding picture collection 
        // depending on its owner subdocument
        if (this.headerFooter) {
            id = this.updateHFImageRels(this.headerFooter, picture);
        }
        else {
            if (id === '') {
                if (tOwner.hasOwnProperty('sectionFormat') || tOwner.hasOwnProperty('inlines')) {
                    id = this.addImageRelation(this.documentImages, picture);
                    // if (owner is WFootnote)
                    // {
                    //     if ((owner as WFootnote).FootnoteType === FootnoteType.Footnote)
                    //         id = AddImageRelation(FootnoteImages, picture.ImageRecord);
                    //     else
                    //         id = AddImageRelation(EndnoteImages, picture.ImageRecord);
                    // }
                    // if (owner is WComment)
                    //     id = AddImageRelation(CommentImages, picture.ImageRecord);
                }
            }
        }
        return id;
    }
    // Adds the image relation.
    addImageRelation(imageCollection, image) {
        let relationId = '';
        // if (imageCollection.ContainsValue(imageRecord)) {
        //     foreach(string key in imageCollection.keys)
        //     {
        //         if (imageRecord === imageCollection[key]) {
        //             relationId = key;
        //             break;
        //         }
        //     }
        // }
        // else {
        relationId = this.getNextRelationShipID();
        imageCollection.add(relationId, image);
        // }
        return relationId;
    }
    // Update the HeaderFooter image relations.
    updateHFImageRels(hf, image) {
        let id = '';
        // UpdateImages(image);
        let headerId = '';
        let types = this.headersFooters.keys;
        for (let i = 0; i < types.length; i++) {
            let hfColl = this.headersFooters.get(types[i]);
            let hfKeys = hfColl.keys;
            for (let j = 0; j < hfKeys.length; j++) {
                if (hfColl.get(hfKeys[j]) === hf) {
                    headerId = hfKeys[j];
                    let headerImages;
                    if (this.headerFooterImages.containsKey(headerId)) {
                        headerImages = this.headerFooterImages.get(headerId);
                        id = this.addImageRelation(headerImages, image);
                    }
                    else {
                        headerImages = new Dictionary();
                        id = this.addImageRelation(headerImages, image);
                        this.headerFooterImages.add(headerId, headerImages);
                    }
                }
            }
        }
        return id;
    }
    // Serialize the table
    serializeTable(writer, table) {
        if (table.rows.length <= 0) {
            return;
        }
        let owner = this.table;
        this.table = table;
        writer.writeStartElement(undefined, 'tbl', this.wNamespace);
        let tableFormat = table.rows[0].rowFormat;
        this.serializeTableFormat(writer, tableFormat, table);
        this.serializeTableGrid(writer, table);
        this.serializeTableRows(writer, table.rows);
        writer.writeEndElement();
        this.table = owner;
    }
    // Serialize the table grid
    serializeTableGrid(writer, table) {
        writer.writeStartElement(undefined, 'tblGrid', this.wNamespace);
        if (table.grid.length !== 0) {
            this.serializeGridColumns(writer, table.grid);
        }
        writer.writeEndElement();
    }
    // Serialize the table rows
    serializeTableRows(writer, rows) {
        if (rows.length > 0) {
            for (let i = 0; i < rows.length; i++) {
                let row = rows[i];
                if (row.cells.length > 0) {
                    this.serializeRow(writer, row);
                }
            }
        }
    }
    // Serialize the table row
    serializeRow(writer, row) {
        let owner = this.row;
        this.row = row;
        writer.writeStartElement(undefined, 'tr', this.wNamespace);
        this.serializeRowFormat(writer, row);
        this.serializeCells(writer, row.cells);
        writer.writeEndElement(); //end od table row 'tr'
        this.row = owner;
    }
    // Serialize the row format
    serializeRowFormat(writer, row) {
        this.serializeRowMargins(writer, row.rowFormat);
        writer.writeStartElement(undefined, 'trPr', this.wNamespace);
        //Serialize Row Height
        if (row.rowFormat.height > 0) {
            writer.writeStartElement(undefined, 'trHeight', this.wNamespace);
            if (row.rowFormat.heightType === 'Exactly') {
                writer.writeAttributeString('w', 'hRule', this.wNamespace, 'exact');
            }
            else if (row.rowFormat.heightType === 'AtLeast') {
                writer.writeAttributeString('w', 'hRule', this.wNamespace, 'atLeast');
            }
            let height = this.roundToTwoDecimal(row.rowFormat.height * this.twentiethOfPoint).toString();
            writer.writeAttributeString('w', 'val', this.wNamespace, height);
            writer.writeEndElement();
        }
        let rowFormat = row.rowFormat;
        // //Serialize 'gridBefore' element
        let gridBefore = rowFormat.gridBefore;
        if (gridBefore > 0) {
            writer.writeStartElement(undefined, 'gridBefore', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, gridBefore.toString());
            writer.writeEndElement();
        }
        // //Serialize 'gridAfter' element
        let gridAfter = rowFormat.gridAfter;
        if (gridAfter > 0) {
            writer.writeStartElement(undefined, 'gridAfter', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, gridAfter.toString());
            writer.writeEndElement();
        }
        // //Serialize 'wBefore' element 
        if (gridBefore > 0) {
            writer.writeStartElement(undefined, 'wBefore', this.wNamespace);
            switch (rowFormat.gridBeforeWidthType) {
                case 'Percent':
                    let width = this.roundToTwoDecimal(rowFormat.gridBeforeWidth * this.percentageFactor).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, width);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'pct');
                    break;
                case 'Point':
                    let pointWidth = this.roundToTwoDecimal(rowFormat.gridBeforeWidth * this.twipsInOnePoint).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, pointWidth);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'dxa');
                    break;
            }
            writer.writeEndElement();
        }
        //Serialize 'wAfter' element
        if (gridAfter > 0) {
            writer.writeStartElement(undefined, 'wAfter', this.wNamespace);
            switch (rowFormat.gridAfterWidthType) {
                case 'Percent':
                    let width = this.roundToTwoDecimal(rowFormat.gridAfterWidth * this.percentageFactor).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, width);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'pct');
                    break;
                case 'Point':
                    let pointWidth = this.roundToTwoDecimal(rowFormat.gridAfterWidth * this.twipsInOnePoint).toString();
                    writer.writeAttributeString('w', 'val', this.wNamespace, pointWidth);
                    writer.writeAttributeString('w', 'type', this.wNamespace, 'dxa');
                    break;
            }
            writer.writeEndElement();
        }
        //Serialize 'cantSplit' element 
        if (!rowFormat.allowBreakAcrossPages) {
            writer.writeStartElement(undefined, 'cantSplit', this.wNamespace);
            writer.writeEndElement();
        }
        // //Serialize 'tblHeader' element 
        if (rowFormat.isHeader) {
            writer.writeStartElement(undefined, 'tblHeader', this.wNamespace);
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    // serialize the table cells
    serializeCells(writer, cells) {
        for (let i = 0; i < cells.length; i++) {
            this.serializeCell(writer, cells[i]);
        }
    }
    // Serialize the table cell
    serializeCell(writer, cell) {
        let owner = this.blockOwner;
        this.blockOwner = cell;
        writer.writeStartElement(undefined, 'tc', this.wNamespace);
        this.serializeCellFormat(writer, cell.cellFormat, true, true);
        if (cell.blocks.length > 0) {
            let itemIndex = 0;
            let item = undefined;
            while (itemIndex < cell.blocks.length) {
                item = cell.blocks[itemIndex];
                this.serializeBodyItem(writer, item, false);
                itemIndex += 1;
            }
        }
        else {
            writer.writeStartElement(undefined, 'p', this.wNamespace);
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            writer.writeStartElement(undefined, 'pStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'Normal');
            writer.writeEndElement(); //end of pStyle
            writer.writeEndElement(); //end of pPr
            writer.writeEndElement(); //end of P
        }
        writer.writeEndElement(); //end of table cell 'tc'        
        if (this.mVerticalMerge.containsKey((cell.columnIndex + cell.cellFormat.columnSpan - 1) + 1)
            && (((this.row.cells.indexOf(cell) === this.row.cells.length - 1) || this.row.cells.indexOf(cell) === cell.columnIndex))
            && cell.nextNode === undefined) {
            let collKey = (cell.columnIndex + cell.cellFormat.columnSpan - 1) + 1;
            writer.writeStartElement(undefined, 'tc', this.wNamespace);
            let endProperties = true;
            if (!isNullOrUndefined(this.spanCellFormat)) {
                endProperties = false;
                this.serializeCellFormat(writer, this.spanCellFormat, false, endProperties);
            }
            this.serializeColumnSpan(collKey, writer);
            writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'continue');
            writer.writeEndElement();
            if (!endProperties) {
                writer.writeEndElement();
            }
            this.checkMergeCell(collKey);
            writer.writeStartElement('w', 'p', this.wNamespace);
            writer.writeEndElement(); //end of P
            writer.writeEndElement(); //end of table cell 'tc'  
        }
        this.blockOwner = owner;
    }
    // Serialize the cell formatting
    serializeCellFormat(writer, cellFormat, ensureMerge, endProperties) {
        let cell = this.blockOwner;
        //Get the table fomat
        let tf = this.table.tableFormat;
        //Get the row format
        let rf = this.row.rowFormat;
        writer.writeStartElement(undefined, 'tcPr', this.wNamespace);
        //w:cnfStyle -   Table Cell Conditional Formatting
        // SerializeCnfStyleElement(cell);
        //w:tcW -    Preferred Table Cell Width
        this.serializeCellWidth(writer, cell);
        // serialize cell margins
        this.serializeCellMargins(writer, cellFormat);
        if (ensureMerge) {
            //w:gridSpan -   Grid Columns Spanned by Current Table Cell
            this.serializeGridSpan(writer, cell);
            //w:hMerge -    Horizontally Merged Cell and w:vMerge -    Vertically Merged Cell
            this.serializeCellMerge(writer, cellFormat);
        }
        //w:tcBorders -    Table Cell Borders
        writer.writeStartElement(undefined, 'tcBorders', this.wNamespace);
        this.serializeBorders(writer, cellFormat.borders, 8);
        writer.writeEndElement();
        //w:shd -  Table Cell Shading
        this.serializeShading(writer, cell.cellFormat.shading);
        // //w:noWrap -   Don't Wrap Cell Content
        // if (cellFormat.HasValue(CellFormat.TextWrapKey)) {
        //     m_writer.WriteStartElement('noWrap', W_namespace);
        //     if (cellFormat.TextWrap)
        //         m_writer.WriteAttributeString('w', 'val', W_namespace, 'false');
        //     m_writer.WriteEndElement();
        // }
        // //w:tcMar -  Single Table Cell Margins
        // if (!cellFormat.SamePaddingsAsTable) {
        //     m_writer.WriteStartElement('tcMar', W_namespace);
        //     SerializePaddings(cellFormat.Paddings);
        //     m_writer.WriteEndElement();
        // }
        //w:textDirection -   Table Cell Text Flow Direction
        this.serializeTableCellDirection(writer, cellFormat);
        // //w:tcFitText -  Fit Text Within Cell
        // if (cellFormat.FitText) {
        //     m_writer.WriteStartElement('tcFitText', W_namespace);
        //     m_writer.WriteEndElement();
        // }
        // //w:hideMark 
        // if (cellFormat.HideMark) {
        //     m_writer.WriteStartElement('hideMark', W_namespace);
        //     m_writer.WriteEndElement();
        // }
        //w:vAlign -  Table Cell Vertical Alignment
        // if (cellFormat.HasValue(CellFormat.VrAlignmentKey))
        this.serializeCellVerticalAlign(writer, cellFormat.verticalAlignment);
        // //w:hideMark -   Ignore End Of Cell Marker In Row Height Calculation
        // SerializeDocxProps(tempDocxProps, 'hideMark');
        // //w:cellIns -    Table Cell Insertion
        // SerializeDocxProps(tempDocxProps, 'cellIns');
        // //w:cellDel -    Table Cell Deletion
        // SerializeDocxProps(tempDocxProps, 'cellDel');
        // //w:cellMerge -   Vertically Merged/Split Table Cells
        // SerializeDocxProps(tempDocxProps, 'cellMerge');
        // if (cellFormat.OldPropertiesHash.length > 0 && !m_isAlternativeCellFormat) {
        //     m_isAlternativeCellFormat = true;
        //     SerializeTrackChangeProps('tcPrChange', cellFormat.FormatChangeAuthorName, cellFormat.FormatChangeDateTime);
        //     Dictionary < int, object > oldPropertyHash = new Dictionary<int, object>(cellFormat.OldPropertiesHash);
        //     Dictionary < int, object > propertyHash = new Dictionary<int, object>(cellFormat.PropertiesHash);
        //     cellFormat.PropertiesHash.Clear();
        //     cellFormat.OldPropertiesHash.Clear();
        //     foreach(KeyValuePair < int, object > keyValue in oldPropertyHash)
        //     cellFormat.PropertiesHash[keyValue.Key] = keyValue.Value;
        //     SerializeCellFormat(cellFormat);
        //     cellFormat.PropertiesHash.Clear();
        //     foreach(KeyValuePair < int, object > keyValue in propertyHash)
        //     cellFormat.PropertiesHash[keyValue.Key] = keyValue.Value;
        //     foreach(KeyValuePair < int, object > keyValue in oldPropertyHash)
        //     cellFormat.OldPropertiesHash[keyValue.Key] = keyValue.Value;
        //     m_writer.WriteEndElement();
        //     m_isAlternativeCellFormat = false;
        // }
        if (endProperties) {
            writer.writeEndElement();
        }
    }
    // Serialize the cell width
    serializeCellWidth(writer, cell) {
        let cf = cell.cellFormat;
        writer.writeStartElement(undefined, 'tcW', this.wNamespace);
        if (cf.preferredWidthType === 'Percent') {
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'pct');
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(cf.preferredWidth * this.percentageFactor).toString());
        }
        else if (cf.preferredWidthType === 'Auto') {
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'auto');
            writer.writeAttributeString(undefined, 'w', this.wNamespace, '0');
        }
        else {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(cf.preferredWidth * this.twipsInOnePoint).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        }
        writer.writeEndElement();
    }
    // Serialize cell merge
    serializeCellMerge(writer, cellFormat) {
        let cell = this.blockOwner;
        let isserialized = false;
        let collKey;
        let currentIndex = cell.columnIndex;
        let cellIndex = this.row.cells.indexOf(cell);
        let prevIndex = cellIndex > 0 ? this.row.cells[cellIndex - 1].columnIndex : cell.columnIndex;
        if (cell.columnIndex === cellIndex) {
            collKey = cell.columnIndex;
            isserialized = true;
        }
        else {
            isserialized = false;
        }
        if (!isserialized) {
            if (cellIndex === 0) {
                currentIndex = cell.columnIndex;
                prevIndex = -1;
            }
            for (let i = prevIndex; i < currentIndex; i++) {
                collKey = prevIndex + 1;
                prevIndex += 1;
                if (this.mVerticalMerge.containsKey(collKey)) {
                    this.createMerge(writer, collKey, cell);
                }
            }
        }
        if (cellFormat.rowSpan > 1) {
            writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
            this.spanCellFormat = cellFormat;
            this.mVerticalMerge.add(collKey, cellFormat.rowSpan - 1);
            if (cellFormat.columnSpan > 1) {
                this.mGridSpans.add(collKey, cellFormat.columnSpan);
            }
            writer.writeAttributeString('w', 'val', this.wNamespace, 'restart');
            writer.writeEndElement();
        }
        else if (this.mVerticalMerge.containsKey(collKey) && isserialized) {
            this.createMerge(writer, collKey, cell);
        }
    }
    createMerge(writer, collKey, cell) {
        this.serializeColumnSpan(collKey, writer);
        writer.writeStartElement(undefined, 'vMerge', this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, 'continue');
        writer.writeEndElement();
        writer.writeEndElement(); //end tcPr
        writer.writeStartElement('w', 'p', this.wNamespace);
        writer.writeEndElement();
        writer.writeEndElement(); //end tc
        writer.writeStartElement(undefined, 'tc', this.wNamespace);
        writer.writeStartElement(undefined, 'tcPr', this.wNamespace);
        this.serializeCellWidth(writer, cell);
        this.checkMergeCell(collKey);
    }
    serializeColumnSpan(collKey, writer) {
        if (this.mGridSpans.keys.length > 0 && this.mGridSpans.containsKey(collKey)) {
            writer.writeStartElement(undefined, 'gridSpan', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.mGridSpans.get(collKey).toString());
            writer.writeEndElement();
        }
    }
    checkMergeCell(collKey) {
        if ((this.mVerticalMerge.get(collKey) - 1) === 0) {
            this.mVerticalMerge.remove(collKey);
            this.spanCellFormat = undefined;
            if (this.mGridSpans.keys.length > 0 && this.mGridSpans.containsKey(collKey)) {
                this.mGridSpans.remove(collKey);
            }
        }
        else {
            this.mVerticalMerge.set(collKey, this.mVerticalMerge.get(collKey) - 1);
        }
    }
    // Serialize the grid span element of cell.
    serializeGridSpan(writer, cell) {
        // int gridSpan = cell.cellFormat.GridSpan;
        if (cell.cellFormat.columnSpan > 1) {
            let num = cell.cellFormat.columnSpan;
            writer.writeStartElement(undefined, 'gridSpan', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, num.toString());
            writer.writeEndElement();
        }
    }
    // Serialize the table cell direction
    serializeTableCellDirection(writer, cellFormat) {
        // if (cellFormat..textDirection !== TextDirection.Horizontal)
        // {
        //     m_writer.WriteStartElement('textDirection', W_namespace);
        //     switch (cellFormat.TextDirection)
        //     {
        //         case TextDirection.Horizontal:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'lrTb');
        //             break;
        //         case TextDirection.VerticalBottomToTop:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'btLr');
        //             break;
        //         case TextDirection.VerticalTopToBottom:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbRl');
        //             break;
        //         case TextDirection.HorizontalFarEast:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'lrTbV');
        //             break;
        //         case TextDirection.Vertical:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbLrV');
        //             break;
        //         case TextDirection.VerticalFarEast:
        //             m_writer.WriteAttributeString('w', 'val', W_namespace, 'tbRlV');
        //             break;
        //     }
        //     m_writer.WriteEndElement();
        // }
    }
    // Serialize the cell vertical alignment
    serializeCellVerticalAlign(writer, alignment) {
        writer.writeStartElement(undefined, 'vAlign', this.wNamespace);
        switch (alignment) {
            case 'Center':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'center');
                break;
            case 'Bottom':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'bottom');
                break;
            default:
                writer.writeAttributeString('w', 'val', this.wNamespace, 'top');
                break;
        }
        writer.writeEndElement();
    }
    // Serialize the table grid columns.
    serializeGridColumns(writer, grid) {
        for (let i = 1, count = grid.length; i < count; i++) {
            let gridValue = Math.round(grid[i] * 20);
            writer.writeStartElement(undefined, 'gridCol', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, gridValue.toString());
            writer.writeEndElement();
        }
    }
    // Serialize the row formattings.
    // Table parameter is passed for serializing table format and undefined for serializing row format.
    serializeTableFormat(writer, format, table) {
        // if (!isNullOrUndefined(table))
        // {
        //     List<Stream> tempDocxProps = new List<Stream>();
        //     for (int i = 0, cnt = table.DocxTableFormat.NodeArray.length; i < cnt; i++)
        //         tempDocxProps.Add(table.DocxTableFormat.NodeArray[i]);
        writer.writeStartElement(undefined, 'tblPr', this.wNamespace);
        //     SerializeTableStlye(format);
        //     if (format.WrapTextAround &&!((table.OwnerTextBody.Owner is WTextBox) || 
        //(table.OwnerTextBody.Owner is WComment) || (table.OwnerTextBody.Owner is WFootnote)))
        //     {
        //         SerializeTablePositioning(format.Positioning);
        //         if (!format.Positioning.AllowOverlap)
        //         {
        //             m_writer.WriteStartElement('tblOverlap', W_namespace);
        //             m_writer.WriteAttributeString('val', W_namespace, 'never');
        //             m_writer.WriteEndElement();
        //         }
        //     }
        //     SerializeDocxProps(tempDocxProps, 'tblStyleRowBandSize');
        //     SerializeDocxProps(tempDocxProps, 'tblStyleColBandSize');       
        this.serializeTableWidth(writer, table);
        this.serializeTableAlignment(writer, table.tableFormat);
        this.serializeCellSpacing(writer, table.tableFormat);
        this.serializeTableIndentation(writer, table.tableFormat);
        this.serializeTableMargins(writer, table.tableFormat);
        this.serializeTableBorders(writer, table.tableFormat);
        this.serializeShading(writer, table.tableFormat.shading);
        if (table.tableFormat.bidi) {
            writer.writeStartElement(undefined, 'bidiVisual', this.wNamespace);
            writer.writeEndElement();
        }
        this.serializeTblLayout(writer, table.tableFormat);
        // this.serializeTableCellMargin(writer, table.tableFormat);
        //     SerializeTableLook(table);
        //         if (!isNullOrUndefined(table.Title))
        //             SerializeTableTitle(table);
        //         if (!isNullOrUndefined(table.Description))
        //             SerializeTableDescription(table);
        // }
        // else
        // {
        //     SerializeCellSpacing(format);
        //     SerializeTableIndentation(format);
        //     SerializeTableBorders(format);
        //     SerializeTableShading(format);
        //     SerializeTblLayout(format);
        //     SerializeTableCellMargin(format);
        // }
        // if (!isNullOrUndefined(format.OwnerBase) && format.OwnerBase is WTable
        //   && format.OldPropertiesHash.length > 0 && !m_isAlternativeTableFormat)
        // {
        //     m_isAlternativeTableFormat = true;
        //     SerializeTrackChangeProps('tblPrChange', format.FormatChangeAuthorName, format.FormatChangeDateTime);
        //     SerializeTableTrackChanges(format, format.OwnerBase as WTable);
        //     m_writer.WriteEndElement();
        //     m_isAlternativeTableFormat = false;
        // }
        // if (!isNullOrUndefined(format.OwnerRow) && format.OldPropertiesHash.length > 0)
        // {
        //     SerializeTrackChangeProps('tblPrExChange', format.FormatChangeAuthorName, format.FormatChangeDateTime);
        //     SerializeTableTrackChanges(format, undefined);
        //     m_writer.WriteEndElement();
        // }
        // SerializeTblTrackChanges(format);
        if (!isNullOrUndefined(table)) {
            writer.writeEndElement(); //end of tblPr
        }
    }
    // serialize the table margin
    serializeTableMargins(writer, format) {
        this.serializeMargins(writer, format, 'tblCellMar');
    }
    // serialize the row margin
    serializeRowMargins(writer, format) {
        writer.writeStartElement(undefined, 'tblPrEx', this.wNamespace);
        this.serializeMargins(writer, format, 'tblCellMar');
        writer.writeEndElement();
    }
    // serialize the cell margins
    serializeCellMargins(writer, format) {
        this.serializeMargins(writer, format, 'tcMar');
    }
    // serialize the table margins, row margins, cell margins
    serializeMargins(writer, format, tag) {
        writer.writeStartElement(undefined, tag, this.wNamespace);
        if (!isNullOrUndefined(format.topMargin)) {
            let topMargin = Math.round(format.topMargin * 20);
            writer.writeStartElement(undefined, 'top', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, topMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(format.leftMargin)) {
            let leftMargin = Math.round(format.leftMargin * 20);
            writer.writeStartElement(undefined, 'left', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, leftMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(format.bottomMargin)) {
            let bottomMargin = Math.round(format.bottomMargin * 20);
            writer.writeStartElement(undefined, 'bottom', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, bottomMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(format.rightMargin)) {
            let rightMargin = Math.round(format.rightMargin * 20);
            writer.writeStartElement(undefined, 'right', this.wNamespace);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, rightMargin.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    // Serialize the table borders
    serializeShading(writer, format) {
        // if (format.textureStyle !== 'TextureNone') {
        writer.writeStartElement(undefined, 'shd', this.wNamespace);
        if (format.backgroundColor) {
            writer.writeAttributeString(undefined, 'fill', this.wNamespace, this.getColor(format.backgroundColor));
        }
        if (format.foregroundColor === 'empty' || isNullOrUndefined(format.foregroundColor)) {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, 'auto');
        }
        else {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, this.getColor(format.foregroundColor));
        }
        if (!isNullOrUndefined(format.textureStyle)) {
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getTextureStyle(format.textureStyle));
        }
        writer.writeEndElement();
        // }
    }
    getTextureStyle(textureStyle) {
        switch (textureStyle) {
            case 'Texture5Percent':
            case 'Texture2Pt5Percent':
            case 'Texture7Pt5Percent':
                return 'pct5';
            case 'Texture10Percent':
                return 'pct10';
            case 'Texture12Pt5Percent':
                return 'pct12';
            case 'Texture15Percent':
            case 'Texture17Pt5Percent':
                return 'pct15';
            case 'Texture20Percent':
            case 'Texture22Pt5Percent':
                return 'pct20';
            case 'Texture25Percent':
            case 'Texture27Pt5Percent':
                return 'pct25';
            case 'Texture30Percent':
            case 'Texture32Pt5Percent':
                return 'pct30';
            case 'Texture35Percent':
                return 'pct35';
            case 'Texture37Pt5Percent':
                return 'pct37';
            case 'Texture40Percent':
            case 'Texture42Pt5Percent':
                return 'pct40';
            case 'Texture45Percent':
            case 'Texture47Pt5Percent':
                return 'pct45';
            case 'Texture50Percent':
            case 'Texture52Pt5Percent':
                return 'pct50';
            case 'Texture55Percent':
            case 'Texture57Pt5Percent':
                return 'pct55';
            case 'Texture60Percent':
                return 'pct60';
            case 'Texture62Pt5Percent':
                return 'pct62';
            case 'Texture65Percent':
            case 'Texture67Pt5Percent':
                return 'pct65';
            case 'Texture70Percent':
            case 'Texture72Pt5Percent':
                return 'pct70';
            case 'Texture75Percent':
            case 'Texture77Pt5Percent':
                return 'pct75';
            case 'Texture80Percent':
            case 'Texture82Pt5Percent':
                return 'pct80';
            case 'Texture85Percent':
                return 'pct85';
            case 'Texture87Pt5Percent':
                return 'pct87';
            case 'Texture90Percent':
            case 'Texture92Pt5Percent':
                return 'pct90';
            case 'Texture95Percent':
            case 'Texture97Pt5Percent':
                return 'pct95';
            case 'TextureCross':
                return 'thinHorzCross';
            case 'TextureDarkCross':
                return 'horzCross';
            case 'TextureDarkDiagonalCross':
                return 'diagCross';
            case 'TextureDarkDiagonalDown':
                return 'reverseDiagStripe';
            case 'TextureDarkDiagonalUp':
                return 'diagStripe';
            case 'TextureDarkHorizontal':
                return 'horzStripe';
            case 'TextureDarkVertical':
                return 'vertStripe';
            case 'TextureDiagonalCross':
                return 'thinDiagCross';
            case 'TextureDiagonalDown':
                return 'thinReverseDiagStripe';
            case 'TextureDiagonalUp':
                return 'thinDiagStripe';
            case 'TextureHorizontal':
                return 'thinHorzStripe';
            case 'TextureSolid':
                return 'solid';
            case 'TextureVertical':
                return 'thinVertStripe';
            default:
                return 'clear';
        }
    }
    // Serialize the table borders
    serializeTableBorders(writer, format) {
        let borders = format.borders;
        // if (IsNoneBorder(borders))
        //     return;
        writer.writeStartElement(undefined, 'tblBorders', this.wNamespace);
        this.serializeBorders(writer, format.borders, 8);
        writer.writeEndElement();
    }
    // Serialize the borders.
    serializeBorders(writer, borders, multipler) {
        this.serializeBorder(writer, borders.top, 'top', multipler);
        this.serializeBorder(writer, borders.left, 'left', multipler);
        this.serializeBorder(writer, borders.bottom, 'bottom', multipler);
        this.serializeBorder(writer, borders.right, 'right', multipler);
        this.serializeBorder(writer, borders.horizontal, 'insideH', multipler);
        this.serializeBorder(writer, borders.vertical, 'insideV', multipler);
        this.serializeBorder(writer, borders.diagonalDown, 'tl2br', multipler);
        this.serializeBorder(writer, borders.diagonalUp, 'tr2bl', multipler);
    }
    // Serialize the table layout element
    serializeTblLayout(writer, format) {
        if (!format.allowAutoFit) {
            writer.writeStartElement(undefined, 'tblLayout', this.wNamespace);
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'fixed');
            writer.writeEndElement();
        }
    }
    // Serializes the Border
    serializeBorder(writer, border, tagName, multiplier) {
        let borderStyle = border.lineStyle;
        let sz = ((border.lineWidth ? border.lineWidth : 0) * multiplier);
        let space = border.space ? border.space : 0;
        if (borderStyle === 'Cleared') {
            writer.writeStartElement(undefined, tagName, this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, 'nil');
            writer.writeEndElement();
            return;
        }
        else if (((borderStyle === 'None' || isNullOrUndefined(borderStyle)) && !border.hasNoneStyle) || sz <= 0) {
            return;
        }
        writer.writeStartElement(undefined, tagName, this.wNamespace);
        writer.writeAttributeString('w', 'val', this.wNamespace, this.getBorderStyle(borderStyle));
        // if (border.color === '#000000')
        // {
        //     writer.writeAttributeString(undefined, 'color', this.wNamespace, 'auto');
        // }
        // else
        // {
        if (border.color) {
            writer.writeAttributeString(undefined, 'color', this.wNamespace, this.getColor(border.color));
        }
        // }
        writer.writeAttributeString(undefined, 'sz', this.wNamespace, this.roundToTwoDecimal(sz).toString());
        writer.writeAttributeString(undefined, 'space', this.wNamespace, space.toString());
        if (border.shadow) {
            writer.writeAttributeString(undefined, 'shadow', this.wNamespace, 'on');
        }
        writer.writeEndElement();
    }
    // Get the border style as string
    getBorderStyle(borderStyle) {
        switch (borderStyle) {
            case 'Cleared':
                return 'cleared';
            case 'DashSmallGap':
                return 'dashSmallGap';
            case 'Triple':
                return 'triple';
            case 'Dot':
                return 'dotted';
            case 'DashDot':
                return 'dotDash';
            case 'DashLargeGap':
                return 'dashed';
            case 'DashDotDot':
                return 'dotDotDash';
            case 'Double':
                return 'double';
            case 'ThinThickSmallGap':
                return 'thinThickSmallGap';
            case 'ThickThinSmallGap':
                return 'thickThinSmallGap';
            case 'ThinThickThinSmallGap':
                return 'thinThickThinSmallGap';
            case 'ThickThinMediumGap':
                return 'thickThinMediumGap';
            case 'ThinThickMediumGap':
                return 'thinThickMediumGap';
            case 'ThinThickThinMediumGap':
                return 'thinThickThinMediumGap';
            case 'ThickThinLargeGap':
                return 'thickThinLargeGap';
            case 'ThinThickLargeGap':
                return 'thinThickLargeGap';
            case 'ThinThickThinLargeGap':
                return 'thinThickThinLargeGap';
            case 'Thick':
                return 'thick';
            case 'SingleWavy':
                return 'wave';
            case 'DoubleWavy':
                return 'doubleWave';
            case 'DashDotStroked':
                return 'dashDotStroked';
            case 'Engrave3D':
                return 'threeDEngrave';
            case 'Emboss3D':
                return 'threeDEmboss';
            case 'Outset':
                return 'outset';
            case 'Inset':
                return 'inset';
            // case 'None':
            //     return 'none';
            default:
                return 'single';
        }
    }
    // Serialize the table indentation.
    serializeTableIndentation(writer, format) {
        writer.writeStartElement(undefined, 'tblInd', this.wNamespace);
        let tableIndent = Math.round(format.leftIndent * this.twipsInOnePoint);
        writer.writeAttributeString(undefined, 'w', this.wNamespace, tableIndent.toString());
        writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        writer.writeEndElement();
    }
    // Serialize the cell spacing.
    serializeCellSpacing(writer, format) {
        if (!isNullOrUndefined(format.cellSpacing) && format.cellSpacing > 0) {
            writer.writeStartElement(undefined, 'tblCellSpacing', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, this.roundToTwoDecimal(format.cellSpacing * this.twentiethOfPoint).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
            writer.writeEndElement();
        }
    }
    // Serialize the table width
    serializeTableWidth(writer, table) {
        writer.writeStartElement(undefined, 'tblW', this.wNamespace);
        if (table.tableFormat.preferredWidthType === 'Percent') {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'w', this.wNamespace, (table.tableFormat.preferredWidth * this.percentageFactor).toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'pct');
        }
        else if (table.tableFormat.preferredWidthType === 'Point') {
            let tableWidth = Math.round(table.tableFormat.preferredWidth * this.twipsInOnePoint);
            writer.writeAttributeString(undefined, 'w', this.wNamespace, tableWidth.toString());
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'dxa');
        }
        else {
            writer.writeAttributeString(undefined, 'w', this.wNamespace, '0');
            writer.writeAttributeString(undefined, 'type', this.wNamespace, 'auto');
        }
        writer.writeEndElement();
    }
    // Serialize the table alignment
    serializeTableAlignment(writer, format) {
        writer.writeStartElement(undefined, 'jc', this.wNamespace);
        switch (format.tableAlignment) {
            case 'Right':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'right');
                break;
            case 'Center':
                writer.writeAttributeString('w', 'val', this.wNamespace, 'center');
                break;
            default:
                writer.writeAttributeString('w', 'val', this.wNamespace, 'left');
                break;
        }
        writer.writeEndElement();
    }
    // Serialize the field
    serializeFieldCharacter(writer, field) {
        writer.writeStartElement(undefined, 'r', this.wNamespace);
        this.serializeCharacterFormat(writer, field.characterFormat);
        writer.writeStartElement(undefined, 'fldChar', this.wNamespace);
        let type = field.fieldType === 0 ? 'begin'
            : field.fieldType === 1 ? 'end' : 'separate';
        writer.writeAttributeString(undefined, 'fldCharType', this.wNamespace, type);
        writer.writeEndElement();
        writer.writeEndElement();
        if (field.fieldType === 0 && field.fieldCodeType === 'FieldFormTextInput') {
            writer.writeStartElement('w', 'r', this.wNamespace);
            writer.writeStartElement(undefined, 'instrText', this.wNamespace);
            writer.writeAttributeString('xml', 'space', this.xmlNamespace, 'preserve');
            writer.writeString('FORMTEXT');
            writer.writeEndElement();
            writer.writeEndElement();
        }
    }
    // Serialize the text range.
    serializeTextRange(writer, span, previousNode) {
        writer.writeStartElement('w', 'r', this.wNamespace);
        if (!isNullOrUndefined(span.characterFormat)) {
            this.serializeCharacterFormat(writer, span.characterFormat);
        }
        if (span.text === '\t') {
            writer.writeElementString(undefined, 'tab', this.wNamespace, undefined);
        }
        else if (span.text === '\v') {
            writer.writeElementString(undefined, 'br', this.wNamespace, undefined);
        }
        else if (span.text === '\f') {
            writer.writeStartElement(undefined, 'br', this.wNamespace);
            writer.writeAttributeString('w', 'type', this.wNamespace, 'page');
            writer.writeEndElement();
        }
        else {
            let isField = !isNullOrUndefined(previousNode)
                && previousNode.hasOwnProperty('fieldType') && previousNode.fieldType !== 2;
            writer.writeStartElement(undefined, isField ? 'instrText' : 't', this.wNamespace);
            writer.writeAttributeString('xml', 'space', this.xmlNamespace, 'preserve');
            writer.writeString(span.text);
            writer.writeEndElement();
        }
        writer.writeEndElement();
    }
    // Serializes the paragraph format
    serializeParagraphFormat(writer, paragraphFormat, paragraph) {
        if (!isNullOrUndefined(paragraphFormat.styleName)) {
            writer.writeStartElement(undefined, 'pStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, paragraphFormat.styleName);
            writer.writeEndElement(); //end of pStyle
        }
        if (!isNullOrUndefined(paragraph)) {
            this.serializeListFormat(writer, paragraph.paragraphFormat.listFormat);
        }
        else {
            this.serializeListFormat(writer, paragraphFormat.listFormat);
        }
        if (paragraphFormat.bidi) {
            writer.writeStartElement(undefined, 'bidi', this.wNamespace);
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(paragraphFormat.contextualSpacing)) {
            writer.writeStartElement('w', 'contextualSpacing', this.wNamespace);
            if (!paragraphFormat.contextualSpacing) {
                writer.writeAttributeString('w', 'val', this.wNamespace, '0');
            }
            writer.writeEndElement();
        }
        this.serializeParagraphSpacing(writer, paragraphFormat);
        this.serializeIndentation(writer, paragraphFormat);
        this.serializeParagraphAlignment(writer, paragraphFormat.textAlignment, paragraphFormat.bidi);
        if (!isNullOrUndefined(paragraphFormat.tabs) && paragraphFormat.tabs.length > 0) {
            this.serializeTabs(writer, paragraphFormat.tabs);
        }
    }
    // Serialize Tabs
    serializeTabs(writer, tabStops) {
        writer.writeStartElement('w', 'tabs', this.wNamespace);
        for (let i = 0; i < tabStops.length; i++) {
            this.serializeTab(writer, tabStops[i]);
        }
        writer.writeEndElement();
    }
    serializeTab(writer, tabStop) {
        let position = 0;
        writer.writeStartElement('w', 'tab', this.wNamespace);
        if (tabStop.position === 0 && tabStop.deletePosition !== 0) {
            position = tabStop.deletePosition * this.twentiethOfPoint;
            writer.writeAttributeString('w', 'val', this.wNamespace, 'clear');
        }
        else {
            position = tabStop.position * this.twentiethOfPoint;
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getTabJustification(tabStop.tabJustification));
        }
        if (!isNullOrUndefined(tabStop.tabLeader) && (tabStop.tabLeader !== 'None')) {
            writer.writeAttributeString('w', 'leader', this.wNamespace, this.getTabLeader(tabStop.tabLeader));
        }
        writer.writeAttributeString('w', 'pos', this.wNamespace, position.toString() + '');
        writer.writeEndElement();
    }
    getTabLeader(tabLeader) {
        switch (tabLeader) {
            case 'Dot':
                return 'dot';
            case 'Hyphen':
                return 'hyphen';
            case 'Underscore':
                return 'underscore';
            default:
                return 'none';
        }
    }
    getTabJustification(tabJustification) {
        switch (tabJustification) {
            case 'Bar':
                return 'bar';
            case 'Center':
                return 'center';
            case 'Decimal':
                return 'decimal';
            case 'Left':
                return 'left';
            case 'List':
                return 'num';
            case 'Right':
                return 'right';
            default:
                return 'clear';
        }
    }
    // // Seraializes the pargraph list format
    // private serializeListParagraph(writer: XmlWriter, paragraph: any): void {
    //     if (!isNullOrUndefined(paragraph.paragraphFormat.listFormat)) {
    //         this.serializeListFormat(writer, paragraph.paragraphFormat.listFormat);
    //     }
    // }
    // Serialize the list format
    serializeListFormat(writer, lf) {
        // let pStyleName = undefined;
        // if (lf.CurrentListStyle.IsBuiltInStyle && !isNullOrUndefined(lf.OwnerParagraph))
        // {
        //     pStyleName = lf.OwnerParagraph.StyleName;
        // }
        // int listId = GetListId(lf);
        // if (!isNullOrUndefined(pStyleName) && string.IsNullOrEmpty(lf.LFOStyleName)) 
        // {
        //     WordDocument doc = lf.OwnerParagraph.Document;
        //     WParagraphStyle style = doc.Styles.FindByName(pStyleName, StyleType.ParagraphStyle) as WParagraphStyle;
        //     if (style.ListIndex === -1)
        //     {
        //         ListStyle lstStyle = lf.OwnerParagraph.Document.ListStyles.FindByName(lf.CustomStyleName);
        //         style.ListIndex = listId;
        //         if (lstStyle.Levels.length > 1)
        //         {
        //             style.ListLevel = lf.ListLevelNumber;
        //         }
        //         pStyleName = pStyleName.Replace(' ', '');
        //         lstStyle.Levels[lf.ListLevelNumber].ParaStyleName = pStyleName;
        //     }
        // }
        // else
        // {
        // if (!isNullOrUndefined(lf.listId) && !isNullOrUndefined(lf.listLevelNumber)) {
        //     this.serializeNumPr(writer, lf.listId, lf.listLevelNumber);
        // }
        // }
        if (!isNullOrUndefined(lf.listId) || !isNullOrUndefined(lf.listLevelNumber)) {
            writer.writeStartElement(undefined, 'numPr', this.wNamespace);
            if (!isNullOrUndefined(lf.listLevelNumber) && lf.listLevelNumber !== -1) {
                writer.writeStartElement(undefined, 'ilvl', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, lf.listLevelNumber.toString());
                writer.writeEndElement();
            }
            if (!isNullOrUndefined(lf.listId)) {
                writer.writeStartElement(undefined, 'numId', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, (lf.listId + 1).toString());
                writer.writeEndElement();
            }
            writer.writeEndElement();
        }
    }
    // // Serializes the numbering properties to the paragraph
    // private serializeNumPr(writer: XmlWriter, listId: number, listLevel: number): void {
    //     writer.writeStartElement(undefined, 'numPr', this.wNamespace);
    //     if (listLevel !== -1) {
    //         writer.writeStartElement(undefined, 'ilvl', this.wNamespace);
    //         writer.writeAttributeString('w', 'val', this.wNamespace, listLevel.toString());
    //         writer.writeEndElement();
    //     }
    //     if (listId !== -1) {
    //         writer.writeStartElement(undefined, 'numId', this.wNamespace);
    //         writer.writeAttributeString('w', 'val', this.wNamespace, listId.toString());
    //         writer.writeEndElement();
    //     }
    //     writer.writeEndElement();
    // }
    serializeParagraphAlignment(writer, txtAlignment, isBidi) {
        if (isBidi) {
            if (txtAlignment === 'Right') {
                txtAlignment = 'Left';
            }
            else if (txtAlignment === 'Left') {
                txtAlignment = 'Right';
            }
        }
        if (!isNullOrUndefined(txtAlignment)) {
            writer.writeStartElement(undefined, 'jc', this.wNamespace);
            let alignment;
            switch (txtAlignment) {
                case 'Center':
                    alignment = 'center';
                    break;
                case 'Right':
                    alignment = 'right';
                    break;
                case 'Justify':
                    alignment = 'both';
                    break;
                default:
                    alignment = 'left';
                    break;
            }
            writer.writeAttributeString('w', 'val', this.wNamespace, alignment);
            writer.writeEndElement();
        }
    }
    // Serializes the paragraph spacings
    serializeParagraphSpacing(writer, paragraphFormat) {
        writer.writeStartElement(undefined, 'spacing', this.wNamespace);
        // if (paragraphFormat.HasValue(WParagraphFormat.BeforeLinesKey))
        // {
        //     short beforeLines = (short)Math.Round(paragraphFormat.BeforeLines * DLSConstants.HundredthsUnit);
        //     writer.WriteAttributeString('beforeLines', this.wNamespace, ToString((float)beforeLines));               
        // }
        // if (paragraphFormat.HasValue(WParagraphFormat.AfterLinesKey))
        // {
        //     short afterLines = (short)Math.Round(paragraphFormat.AfterLines * DLSConstants.HundredthsUnit);
        //     writer.WriteAttributeString('afterLines', this.wNamespace, ToString((float)afterLines));                 
        // }
        // tslint:disable-next-line:max-line-length
        if (!isNullOrUndefined(paragraphFormat.beforeSpacing)) {
            writer.writeAttributeString(undefined, 'before', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.beforeSpacing * this.twentiethOfPoint).toString());
        }
        //TODO:ISSUEFIX(paragraphFormat.beforeSpacing * this.twentiethOfPoint).toString());
        // if (paragraphFormat.HasValue(WParagraphFormat.SpacingBeforeAutoKey))
        // {
        //     if (paragraphFormat.SpaceBeforeAuto)
        //     {
        //         writer.WriteAttributeString('beforeAutospacing', this.wNamespace, '1');
        //     }
        //     else
        //     {
        //         writer.WriteAttributeString('beforeAutospacing', this.wNamespace, '0');
        //     }
        // }
        if (!isNullOrUndefined(paragraphFormat.afterSpacing)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'after', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.afterSpacing * this.twentiethOfPoint).toString());
        }
        //TODO:ISSUEFIX(paragraphFormat.afterSpacing * this.twentiethOfPoint).toString());
        // if (paragraphFormat.HasValue(WParagraphFormat.SpacingAfterAutoKey))
        // {
        //     if (paragraphFormat.SpaceAfterAuto)
        //     {
        //         writer.WriteAttributeString('afterAutospacing', this.wNamespace, '1');
        //     }
        //     else
        //     {
        //         writer.WriteAttributeString('afterAutospacing', this.wNamespace, '0');
        //     }
        // }
        //TODO:ISSUEFIX((paragraphFormat.lineSpacing) * this.twentiethOfPoint).toString());
        if (!isNullOrUndefined(paragraphFormat.lineSpacing)) {
            // tslint:disable-next-line:max-line-length
            let lineSpacingValue = (paragraphFormat.lineSpacingType === 'AtLeast' || paragraphFormat.lineSpacingType === 'Exactly') ? this.roundToTwoDecimal(paragraphFormat.lineSpacing * this.twentiethOfPoint) : this.roundToTwoDecimal(paragraphFormat.lineSpacing * 240);
            writer.writeAttributeString(undefined, 'line', this.wNamespace, lineSpacingValue.toString());
        }
        if (!isNullOrUndefined(paragraphFormat.lineSpacingType)) {
            let lineSpacingType = 'auto';
            if (paragraphFormat.lineSpacingType === 'AtLeast') {
                lineSpacingType = 'atLeast';
            }
            else if (paragraphFormat.lineSpacingType === 'Exactly') {
                lineSpacingType = 'exact';
            }
            writer.writeAttributeString(undefined, 'lineRule', this.wNamespace, lineSpacingType);
        }
        writer.writeEndElement();
    }
    // Serializes the paragraph indentation
    serializeIndentation(writer, paragraphFormat) {
        writer.writeStartElement(undefined, 'ind', this.wNamespace);
        if (!isNullOrUndefined(paragraphFormat.leftIndent)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'left', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.leftIndent * this.twipsInOnePoint).toString());
        }
        if (!isNullOrUndefined(paragraphFormat.rightIndent)) {
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString(undefined, 'right', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.rightIndent * this.twipsInOnePoint).toString());
        }
        if (!isNullOrUndefined(paragraphFormat.firstLineIndent)) {
            if (paragraphFormat.firstLineIndent < 0) {
                // tslint:disable-next-line:max-line-length
                writer.writeAttributeString(undefined, 'hanging', this.wNamespace, this.roundToTwoDecimal(-1 * paragraphFormat.firstLineIndent * this.twipsInOnePoint).toString());
            }
            else {
                // tslint:disable-next-line:max-line-length
                writer.writeAttributeString(undefined, 'firstLine', this.wNamespace, this.roundToTwoDecimal(paragraphFormat.firstLineIndent * this.twipsInOnePoint).toString());
            }
        }
        writer.writeEndElement();
    }
    // Serialize the styles (styles.xml)
    serializeStyles() {
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'styles', this.wNamespace);
        writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'w', undefined, this.wNamespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
        //writes the document defaults, latent styles and default styles.
        this.serializeDefaultStyles(writer);
        //writes the document styles
        this.serializeDocumentStyles(writer);
        writer.writeEndElement(); //end of styles tag
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.stylePath);
        this.mArchive.addItem(zipArchiveItem); //this.stylePath, styleStream, false, FileAttributes.Archive);
    }
    // Serializes the default styles (document default paragraph and character format)
    serializeDefaultStyles(writer) {
        writer.writeStartElement(undefined, 'docDefaults', this.wNamespace);
        //if (HasDefaultCharFormat())
        //{
        writer.writeStartElement(undefined, 'rPrDefault', this.wNamespace);
        // if (!isNullOrUndefined(this.mDocument.characterFormat)) {
        this.serializeCharacterFormat(writer, this.defCharacterFormat);
        writer.writeEndElement(); // end of rPrDefault
        // }
        // else {
        //     writer.writeStartElement(undefined, 'rPr', this.wNamespace);
        //     writer.writeStartElement(undefined, 'rFonts', this.wNamespace);
        //     if (!string.IsNullOrEmpty(m_document.StandardAsciiFont))
        //         writer.WriteAttributeString('ascii', this.wNamespace, m_document.StandardAsciiFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardFarEastFont))
        //         writer.WriteAttributeString('eastAsia', this.wNamespace, m_document.StandardFarEastFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardNonFarEastFont))
        //         writer.WriteAttributeString('hAnsi', this.wNamespace, m_document.StandardNonFarEastFont);
        //     if (!string.IsNullOrEmpty(m_document.StandardBidiFont))
        //         writer.WriteAttributeString('cs', this.wNamespace, m_document.StandardBidiFont);
        //     writer.WriteEndElement();
        //     float fontSize = GetDefFontSize(m_document, WCharacterFormat.FontSizeKey);
        //     if (fontSize !== 0f)
        //     {
        //         writer.WriteStartElement('sz', this.wNamespace);
        //         writer.WriteAttributeString('val', this.wNamespace, (fontSize * 2).ToString(CultureInfo.InvariantCulture));
        //         writer.WriteEndElement();
        //     }
        //     fontSize = GetDefFontSize(m_document, WCharacterFormat.FontSizeBidiKey);
        //     if (fontSize !== 0f)
        //     {
        //         writer.WriteStartElement('szCs', this.wNamespace);
        //         writer.WriteAttributeString('val', this.wNamespace, (fontSize * 2).ToString(CultureInfo.InvariantCulture));
        //         writer.WriteEndElement();
        //     }
        //     writer.WriteEndElement();
        // }
        // writer.WriteEndElement();
        // //}
        writer.writeStartElement(undefined, 'pPrDefault', this.wNamespace);
        if (!isNullOrUndefined(this.defParagraphFormat)) {
            writer.writeStartElement(undefined, 'pPr', this.wNamespace);
            this.serializeParagraphFormat(writer, this.defParagraphFormat, undefined);
            writer.writeEndElement(); //end of pPr
        }
        writer.writeEndElement(); //end of pPrDefault
        // writer.WriteEndElement();
        // SerializeLatentStyles();
        // //Default styles
        // if (m_document.Styles.length === 0 || isNullOrUndefined(m_document.Styles.FindByName('Normal')))
        // {
        //     SerializeDefaultParagraphStyle();
        // }
        // if (!IsDocumentContainsDefaultTableStyle())
        // {
        //     SerializeTableNormalStyle();
        // }
        // if (isNullOrUndefined(m_document.Styles.FindByName('No List')) && isNullOrUndefined(m_document.Styles.FindByName('NoList')))
        //     SerializeNoListStyle();
        // tslint:disable-next-line:max-line-length
        // if (isNullOrUndefined(m_document.Styles.FindByName('Table Grid')) && isNullOrUndefined(m_document.Styles.FindByName('TableGrid')))
        // {
        //     SerializeTableGridStyle();
        // }
        // }        
        writer.writeEndElement();
    }
    serializeDocumentStyles(writer) {
        for (let i = 0; i < this.mStyles.length; i++) {
            let style = this.mStyles[i];
            writer.writeStartElement(undefined, 'style', this.wNamespace);
            let type = style.type === 'Paragraph' ? 'paragraph' : 'character';
            writer.writeAttributeString('w', 'type', this.wNamespace, type);
            writer.writeAttributeString('w', 'styleId', this.wNamespace, style.name);
            //name
            writer.writeStartElement(undefined, 'name', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, style.name);
            writer.writeEndElement();
            //basedOn
            if (!isNullOrUndefined(style.basedOn)) {
                writer.writeStartElement(undefined, 'basedOn', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.basedOn);
                writer.writeEndElement();
            }
            //next
            if (!isNullOrUndefined(style.next)) {
                writer.writeStartElement(undefined, 'next', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.next);
                writer.writeEndElement();
            }
            //link
            if (!isNullOrUndefined(style.link)) {
                writer.writeStartElement(undefined, 'link', this.wNamespace);
                writer.writeAttributeString('w', 'val', this.wNamespace, style.link);
                writer.writeEndElement();
            }
            if (style.type === 'Paragraph') {
                writer.writeStartElement(undefined, 'pPr', this.wNamespace);
                this.serializeParagraphFormat(writer, style.paragraphFormat, undefined);
                writer.writeEndElement();
            }
            // let value = (style.characterFormat as WCharacterFormat).newgetCharacterFormat();
            this.serializeCharacterFormat(writer, style.characterFormat);
            writer.writeEndElement(); //end of Style
        }
    }
    // Serializes the Character format
    serializeCharacterFormat(writer, characterFormat) {
        writer.writeStartElement(undefined, 'rPr', this.wNamespace);
        if (!isNullOrUndefined(characterFormat.styleName)) {
            writer.writeStartElement(undefined, 'rStyle', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, characterFormat.styleName);
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontFamily)) {
            writer.writeStartElement(undefined, 'rFonts', this.wNamespace);
            writer.writeAttributeString(undefined, 'ascii', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'hAnsi', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'eastAsia', this.wNamespace, characterFormat.fontFamily);
            writer.writeAttributeString(undefined, 'cs', this.wNamespace, characterFormat.fontFamilyBidi);
            writer.writeEndElement(); //end         
        }
        if (!isNullOrUndefined(characterFormat.bold)) {
            this.serializeBoolProperty(writer, 'b', characterFormat.bold);
        }
        if (characterFormat.boldBidi) {
            this.serializeBoolProperty(writer, 'bCs', characterFormat.boldBidi);
        }
        if (!isNullOrUndefined(characterFormat.italic)) {
            this.serializeBoolProperty(writer, 'i', characterFormat.italic);
        }
        if (!isNullOrUndefined(characterFormat.italicBidi)) {
            this.serializeBoolProperty(writer, 'iCs', characterFormat.italicBidi);
        }
        if (characterFormat.bidi) {
            writer.writeStartElement(undefined, 'rtl', this.wNamespace);
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.strikethrough)) {
            switch (characterFormat.strikethrough) {
                case 'SingleStrike':
                    this.serializeBoolProperty(writer, 'strike', true);
                    break;
                case 'DoubleStrike':
                    this.serializeBoolProperty(writer, 'dstrike', true);
                    break;
                default:
                    this.serializeBoolProperty(writer, 'strike', false);
                    this.serializeBoolProperty(writer, 'dstrike', false);
                    break;
            }
        }
        if (!isNullOrUndefined(characterFormat.fontColor)) {
            writer.writeStartElement(undefined, 'color', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getColor(characterFormat.fontColor));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontSize)) {
            writer.writeStartElement(undefined, 'sz', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString('w', 'val', this.wNamespace, this.roundToTwoDecimal(characterFormat.fontSize * 2).toString());
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.fontSizeBidi)) {
            writer.writeStartElement(undefined, 'szCs', this.wNamespace);
            // tslint:disable-next-line:max-line-length
            writer.writeAttributeString('w', 'val', this.wNamespace, this.roundToTwoDecimal(characterFormat.fontSizeBidi * 2).toString());
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.highlightColor) && characterFormat.highlightColor !== 'NoColor') {
            writer.writeStartElement(undefined, 'highlight', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getHighlightColor(characterFormat.highlightColor));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.underline) && characterFormat.underline !== 'None') {
            writer.writeStartElement(undefined, 'u', this.wNamespace);
            writer.writeAttributeString('w', 'val', this.wNamespace, this.getUnderlineStyle(characterFormat.underline));
            writer.writeEndElement();
        }
        if (!isNullOrUndefined(characterFormat.baselineAlignment)) {
            writer.writeStartElement(undefined, 'vertAlign', this.wNamespace);
            switch (characterFormat.baselineAlignment) {
                case 'Subscript':
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'subscript');
                    break;
                case 'Superscript':
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'superscript');
                    break;
                default:
                    writer.writeAttributeString('w', 'val', this.wNamespace, 'baseline');
                    break;
            }
            writer.writeEndElement();
        }
        writer.writeEndElement(); //end of rPrChange
    }
    getColor(color) {
        if (color.length > 0) {
            if (color[0] === '#') {
                color = color.substr(1);
            }
            if (color.length > 6) {
                color = color.substr(0, 6);
            }
        }
        return color;
    }
    // Get the underline style as string
    getUnderlineStyle(underlineStyle) {
        switch (underlineStyle) {
            case 'DotDotDashHeavy':
                return 'dashDotDotHeavy';
            case 'DotDashHeavy':
                return 'dashDotHeavy';
            case 'DashHeavy':
                return 'dashedHeavy';
            case 'DashLong':
                return 'dashLong';
            case 'DashLongHeavy':
                return 'dashLongHeavy';
            case 'DotDash':
                return 'dotDash';
            case 'DotDotDash':
                return 'dotDotDash';
            case 'Dotted':
                return 'dotted';
            case 'DottedHeavy':
                return 'dottedHeavy';
            case 'Double':
                return 'double';
            case 'Single':
                return 'single';
            case 'Thick':
                return 'thick';
            case 'Wavy':
                return 'wave';
            case 'WavyDouble':
                return 'wavyDouble';
            case 'WavyHeavy':
                return 'wavyHeavy';
            case 'Words':
                return 'words';
            default:
                return 'dash';
        }
    }
    getHighlightColor(highlight) {
        switch (highlight) {
            // Highlights the content with bright green (#ff00ff00) color.
            case 'BrightGreen':
                return 'green';
            // Highlights the content with turquoise (#ff00ffff) color.
            case 'Turquoise':
                return 'cyan';
            // Highlights the content with pink (#ffff00ff) color.
            case 'Pink':
                return 'magenta';
            // Highlights the content with blue (#ff0000ff) color.
            case 'Blue':
                return 'blue';
            // Highlights the content with red (#ffff0000) color.
            case 'Red':
                return 'red';
            // Highlights the content with dark blue (#ff000080) color.
            case 'DarkBlue':
                return 'darkBlue';
            // Highlights the content with teal (#ff008080) color.
            case 'Teal':
                return 'darkCyan';
            // Highlights the content with green (#ff008000) color.
            case 'Green':
                return 'darkGreen';
            // Highlights the content with violet (#ff800080) color.
            case 'Violet':
                return 'darkMagenta';
            // Highlights the content with dark red (#ff800000) color.
            case 'DarkRed':
                return 'darkRed';
            // Highlights the content with dark yellow (#ff808000)  color.
            case 'DarkYellow':
                return 'darkYellow';
            // Highlights the content with gray 50 (#ff808080) color.
            case 'Gray50':
                return 'darkGray';
            // Highlights the content with gray 25 (#ffc0c0c0) color.
            case 'Gray25':
                return 'lightGray';
            // Highlights the content with black (#ff000000) color.
            case 'Black':
                return 'black';
            // Highlights the content with yellow (#ffffff00) color.
            default:
                return 'yellow';
        }
    }
    /*private toggleFirstCahar(text: string) {
        return text.charAt(0).toLowerCase() + text.slice(1);
    }*/
    // Serializes the bool character format property
    serializeBoolProperty(writer, tag, value) {
        writer.writeStartElement(undefined, tag, this.wNamespace);
        if (!value) {
            writer.writeAttributeString(undefined, 'val', this.wNamespace, '0');
        }
        writer.writeEndElement();
    }
    // Serialize the list styles and numberings (numberings.xml)
    serializeNumberings() {
        if (this.document.lists.length === 0) {
            return;
        }
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'numbering', this.wNamespace);
        this.writeCommonAttributeStrings(writer);
        // this.serializePictureBullets(writer, this.mDocument.lists);
        this.serializeAbstractListStyles(writer, this.document.abstractLists);
        this.serializeListInstances(writer, this.document.lists);
        // SerializeListOverrides(writer, this.mDocument.ridesm_document.ListOverrides);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.numberingPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    // Serializes the abstract list styles
    serializeAbstractListStyles(writer, listStyles) {
        for (let i = 0; i < listStyles.length; i++) {
            let abstractList = listStyles[i];
            writer.writeStartElement(undefined, 'abstractNum', this.wNamespace);
            writer.writeAttributeString(undefined, 'abstractNumId', this.wNamespace, abstractList.abstractListId.toString());
            writer.writeStartElement(undefined, 'nsid', this.wNamespace);
            writer.writeAttributeString(undefined, 'val', this.wNamespace, this.generateHex());
            writer.writeEndElement();
            for (let ilvl = 0, cnt = abstractList.levels.length; ilvl < cnt; ilvl++) {
                this.serializeListLevel(writer, abstractList.levels[ilvl], ilvl);
            }
            writer.writeEndElement(); //end of abstractNum
        }
    }
    // Serializes the list styles
    serializeListInstances(writer, listStyles) {
        for (let i = 0; i < listStyles.length; i++) {
            let list = listStyles[i];
            writer.writeStartElement(undefined, 'num', this.wNamespace);
            writer.writeAttributeString(undefined, 'numId', this.wNamespace, (list.listId + 1).toString());
            writer.writeStartElement(undefined, 'abstractNumId', this.wNamespace);
            writer.writeAttributeString(undefined, 'val', this.wNamespace, list.abstractListId.toString());
            writer.writeEndElement();
            writer.writeEndElement();
        }
    }
    generateHex() {
        return (Math.floor(Math.random() * (4000000000 - 270000000)) + 270000000).toString(16).toUpperCase();
    }
    roundToTwoDecimal(num) {
        return Math.round(num); // * 100) / 100;
    }
    // Serialize the list level
    serializeListLevel(writer, listLevel, levelIndex) {
        writer.writeStartElement(undefined, 'lvl', this.wNamespace);
        writer.writeAttributeString(undefined, 'ilvl', this.wNamespace, levelIndex.toString());
        writer.writeStartElement(undefined, 'start', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, listLevel.startAt.toString());
        writer.writeEndElement();
        writer.writeStartElement(undefined, 'numFmt', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, this.getLevelPattern(listLevel.listLevelPattern));
        writer.writeEndElement();
        // if (listLevel.restartLevel > 0) {
        //     writer.writeStartElement(undefined, 'lvlRestart', this.wNamespace);
        //     writer.writeAttributeString(undefined, 'val', this.wNamespace, '0');
        //     writer.writeEndElement();
        // }
        // if (!isNullOrUndefined(listLevel.paragraphFormat)) {
        //     string name = listLevel.ParaStyleName.Substring(0, 1).ToUpper() + listLevel.ParaStyleName.Remove(0, 1);
        //     writer.WriteStartElement('pStyle', this.wNamespace);
        //     writer.WriteAttributeString('val', this.wNamespace, name);
        //     writer.WriteEndElement();
        // }
        // if (listLevel.IsLegalStyleNumbering) {
        //     writer.WriteStartElement('isLgl', this.wNamespace);
        //     writer.WriteEndElement();
        // }
        this.serializeLevelFollow(writer, listLevel);
        this.serializeLevelText(writer, listLevel, levelIndex + 1);
        // SerializeLegacyProperties(listLevel);
        // if (listLevel.PicBulletId > 0) {
        //     writer.WriteStartElement('lvlPicBulletId', this.wNamespace);
        //     writer.WriteAttributeString('val', this.wNamespace, listLevel.PicBulletId.ToString());
        //     writer.WriteEndElement();
        // }
        // //lvlJc
        // if (listLevel.NumberAlignment !== ListNumberAlignment.Left) {
        //     writer.WriteStartElement('lvlJc', this.wNamespace);
        //     string alignment = string.Empty;
        //     if (listLevel.NumberAlignment === ListNumberAlignment.Right) {
        //         alignment = 'right';
        //     }
        //     else {
        //         alignment = 'center';
        //     }
        //     writer.WriteAttributeString('val', this.wNamespace, alignment);
        //     writer.WriteEndElement();
        // }
        writer.writeStartElement(undefined, 'pPr', this.wNamespace);
        this.serializeParagraphFormat(writer, listLevel.paragraphFormat, undefined);
        writer.writeEndElement(); //end of pPr
        this.serializeCharacterFormat(writer, listLevel.characterFormat);
        writer.writeEndElement();
    }
    getLevelPattern(levelPattern) {
        let patternType;
        switch (levelPattern) {
            case 'Arabic':
                patternType = 'decimal';
                break;
            case 'UpRoman':
                patternType = 'upperRoman';
                break;
            case 'LowRoman':
                patternType = 'lowerRoman';
                break;
            case 'UpLetter':
                patternType = 'upperLetter';
                break;
            case 'LowLetter':
                patternType = 'lowerLetter';
                break;
            // case 'Ordinal':
            //     patternType = 'ordinal';
            //     break;
            // case 'Number':
            //     patternType = 'cardinalText';
            //     break;
            // case 'OrdinalText':
            //     patternType = 'ordinalText';
            //     break;
            // case 'LeadingZero':
            //     patternType = 'decimalZero';
            //     break;
            // case 'Bullet':
            default:
                patternType = 'bullet';
                break;
            // case 'FarEast':
            //     patternType = 'aiueoFullWidth';
            //     break;
            // case 'Special':
            //     patternType = 'russianLower';
            //     break;
            // case 'None':
            //     patternType = 'none';
            //     break;
        }
        return patternType;
    }
    // Serializes the level text
    serializeLevelText(writer, listLevel, lvlIndex) {
        writer.writeStartElement(undefined, 'lvlText', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, (listLevel.numberFormat));
        writer.writeEndElement();
    }
    // Serialize the level follow character
    serializeLevelFollow(writer, listLevel) {
        let fc;
        //TODO:Type issue returns number instead of string
        if (listLevel.followCharacter === 'Tab') {
            fc = 'tab';
        }
        else if (listLevel.followCharacter === 'Space') {
            fc = 'space';
        }
        else {
            fc = 'nothing';
        }
        writer.writeStartElement(undefined, 'suff', this.wNamespace);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, fc);
        writer.writeEndElement();
    }
    serializeDocumentProtectionSettings(writer) {
        writer.writeStartElement('w', 'documentProtection', this.wNamespace);
        if (this.formatting) {
            writer.writeAttributeString('w', 'formatting', this.wNamespace, '1');
        }
        if (this.protectionType && this.protectionType === 'ReadOnly') {
            writer.writeAttributeString('w', 'edit', this.wNamespace, 'readOnly');
        }
        writer.writeAttributeString('w', 'cryptProviderType', this.wNamespace, 'rsaAES');
        writer.writeAttributeString('w', 'cryptAlgorithmClass', this.wNamespace, 'hash');
        writer.writeAttributeString('w', 'cryptAlgorithmType', this.wNamespace, 'typeAny');
        writer.writeAttributeString('w', 'cryptAlgorithmSid', this.wNamespace, '14');
        writer.writeAttributeString('w', 'cryptSpinCount', this.wNamespace, '100000');
        if (this.enforcement) {
            writer.writeAttributeString('w', 'enforcement', this.wNamespace, '1');
        }
        if (this.hashValue) {
            writer.writeAttributeString('w', 'hash', this.wNamespace, this.hashValue);
        }
        if (this.saltValue) {
            writer.writeAttributeString('w', 'salt', this.wNamespace, this.saltValue);
        }
        writer.writeEndElement();
    }
    serializeSettings() {
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'settings', this.wNamespace);
        this.writeCustom(writer);
        // writer.writeAttributeString('xmlns', 'mc', undefined, this.veNamespace);
        // writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        // writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        // writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        // writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'w14', undefined, this.w14Namespace);
        writer.writeAttributeString('xmlns', 'w15', undefined, this.w15Namespace);
        writer.writeAttributeString('xmlns', 'sl', undefined, this.slNamespace);
        writer.writeAttributeString('mc', 'Ignorable', undefined, 'w14 w15');
        // //w:writeProtection - Write Protection
        this.serializeDocumentProtectionSettings(writer);
        //w:view - Document View Setting
        // if (this.mDocument.ViewSetup.DocumentViewType !== DocumentViewType.PrintLayout &&
        //   m_document.ViewSetup.DocumentViewType !== DocumentViewType.NormalLayout)
        // {
        //     writer.writeStartElement('view', this.wNamespace);
        //     string viewTypeStr = string.Empty;
        //     if (m_document.ViewSetup.DocumentViewType === DocumentViewType.OutlineLayout)
        //     {
        //         viewTypeStr = 'outline';
        //     }
        //     else if (m_document.ViewSetup.DocumentViewType === DocumentViewType.WebLayout)
        //     {
        //         viewTypeStr = 'web';
        //     }
        //     writer.writeAttributeString('val', this.wNamespace, viewTypeStr);
        //     writer.writeEndElement();
        // }
        //w:zoom - Magnification Setting
        writer.writeStartElement('w', 'zoom', this.wNamespace);
        // switch (m_document.ViewSetup.ZoomType)
        // {
        //     case ZoomType.FullPage:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'fullPage');
        //         break;
        //     case ZoomType.PageWidth:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'bestFit');
        //         break;
        //     case ZoomType.TextFit:
        //         writer.writeAttributeString('w', 'val', this.wNamespace, 'textFit');
        //         break;
        // default:
        writer.writeAttributeString('w', 'val', this.wNamespace, 'none');
        // break;
        // }
        writer.writeAttributeString('w', 'percent', this.wNamespace, '100');
        writer.writeEndElement();
        //w:displayBackgroundShape - Display Background Objects When Displaying Document
        // if (m_document.Background.Type !== BackgroundType.NoBackground)
        // {
        writer.writeStartElement(undefined, 'displayBackgroundShape', this.wNamespace);
        writer.writeEndElement();
        // }
        //w:defaultTabStop - Distance Between Automatic Tab Stops
        writer.writeStartElement(undefined, 'defaultTabStop', this.wNamespace);
        let tabWidth = Math.round(this.defaultTabWidthValue * this.twipsInOnePoint);
        writer.writeAttributeString(undefined, 'val', this.wNamespace, tabWidth.toString());
        writer.writeEndElement();
        //w:evenAndOddHeaders - Different Even/Odd Page Headers and Footers        
        if (this.mDifferentFirstPage) {
            writer.writeStartElement(undefined, 'evenAndOddHeaders', this.wNamespace);
            writer.writeEndElement();
        }
        //w:footnotePr - Document-Wide Footnote Properties and w:endnotePr - Document-Wide Endnote Properties
        // SerializeFootnoteSettings();
        //w:compat - Compatibility Settings
        writer.writeStartElement(undefined, 'compat', this.wNamespace);
        writer.writeStartElement(undefined, 'compatSetting', this.wNamespace);
        writer.writeAttributeString(undefined, 'name', this.wNamespace, 'compatibilityMode');
        writer.writeAttributeString(undefined, 'uri', this.wNamespace, 'http://schemas.microsoft.com/office/word');
        writer.writeAttributeString(undefined, 'val', this.wNamespace, '15');
        writer.writeEndElement();
        writer.writeEndElement();
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.settingsPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    serializeCoreProperties() {
        //implementation
    }
    serializeAppProperties() {
        //implementation
    }
    serializeFontTable(contentType) {
        //implementation
    }
    serializeSettingsRelation() {
        //implementation
    }
    serializeHeaderFooters() {
        this.serializeHeaderFooter('EvenFooter');
        this.serializeHeaderFooter('EvenHeader');
        this.serializeHeaderFooter('FirstPageFooter');
        this.serializeHeaderFooter('FirstPageHeader');
        this.serializeHeaderFooter('OddFooter');
        this.serializeHeaderFooter('OddHeader');
    }
    // Serializes the Header/Footer
    serializeHeaderFooter(hfType) {
        if (this.headersFooters.length === 0) {
            return;
        }
        let headerFooterPath;
        let headerFooterRelsPath;
        if (!this.headersFooters.containsKey(hfType)) {
            return;
        }
        let hfColl = this.headersFooters.get(hfType);
        let hf = undefined;
        for (let i = 0; i < hfColl.keys.length; i++) {
            let id = hfColl.keys[i];
            hf = hfColl.get(id);
            if (hfType === 'EvenHeader' || hfType === 'FirstPageHeader' ||
                hfType === 'OddHeader') {
                headerFooterPath = this.headerPath + id.replace('rId', '') + '.xml';
                headerFooterRelsPath = this.headerRelationPath + id.replace('rId', '') + '.xml.rels';
                this.serializeHeader(hf, id, headerFooterPath, headerFooterRelsPath);
            }
            else {
                headerFooterPath = this.footerPath + id.replace('rId', '') + '.xml';
                headerFooterRelsPath = this.footerRelationPath + id.replace('rId', '') + '.xml.rels';
                this.serializeFooter(hf, id, headerFooterPath, headerFooterRelsPath);
            }
        }
    }
    // Serialize the header part
    serializeHeader(header, id, headerFooterPath, headerFooterRelsPath) {
        this.headerFooter = header;
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'hdr', this.wNamespace);
        this.writeHFCommonAttributes(writer);
        let owner = this.blockOwner;
        this.blockOwner = header;
        this.serializeBodyItems(writer, header.blocks, true);
        this.blockOwner = owner;
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterPath);
        this.mArchive.addItem(zipArchiveItem);
        this.serializeHFRelations(id, headerFooterRelsPath);
        this.headerFooter = undefined;
    }
    // Serializes the HeaderFooter relations
    serializeHFRelations(hfId, headerFooterRelsPath) {
        let hasHFImage = this.headerFooterImages.containsKey(hfId);
        // let hasHFHyperlinks = HeaderFooterHyperlinks.ContainsKey(hfId);
        // let hasHFInclPics = HeaderFooterInclPicUrls.ContainsKey(hfId);
        // let hasHFAlternateChunks = HeaderFooterAlternateChunks.ContainsKey(hfId);
        if (hasHFImage) { // || hasHFHyperlinks ||hasHFAlternateChunks
            let writer = new XmlWriter();
            writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
            this.serializeImagesRelations(this.headerFooterImages.get(hfId), writer);
            // if (hasHFHyperlinks)
            //     SerializeHyperlinkRelations(stream, HeaderFooterHyperlinks[hfId]);
            // if (hasHFAlternateChunks)
            //     SerializeAltChunkRelations(stream, HeaderFooterAlternateChunks[hfId]);
            // if (hasHFInclPics)
            //     SerializeIncludePictureUrlRelations(stream, HeaderFooterInclPicUrls[hfId]);
            // if (HFOleContainers.ContainsKey(hfId))
            // {
            //     AddOLEToZip(HFOleContainers[hfId]);
            // }
            // if (HFRelations.ContainsKey(hfId))
            //     SerializeHFCommonRelations(stream, HFRelations[hfId]);
            writer.writeEndElement();
            let zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterRelsPath);
            this.mArchive.addItem(zipArchiveItem);
        }
        else {
            return;
        }
    }
    writeHFCommonAttributes(writer) {
        writer.writeAttributeString('xmlns', 'v', undefined, this.vNamespace);
        writer.writeAttributeString('xmlns', 'w10', undefined, this.w10Namespace);
        writer.writeAttributeString('xmlns', 'o', undefined, this.oNamespace);
        writer.writeAttributeString('xmlns', 've', undefined, this.veNamespace);
        writer.writeAttributeString('xmlns', 'r', undefined, this.rNamespace);
        writer.writeAttributeString('xmlns', 'm', undefined, this.mNamespace);
        writer.writeAttributeString('xmlns', 'wne', undefined, this.wneNamespace);
        writer.writeAttributeString('xmlns', 'a', undefined, this.aNamespace);
        writer.writeAttributeString('xmlns', 'pic', undefined, this.pictureNamespace);
        writer.writeAttributeString('xmlns', 'wp', undefined, this.wpNamespace);
        writer.writeAttributeString('xmlns', 'wpc', undefined, this.wpCanvasNamespace);
        writer.writeAttributeString('xmlns', 'wp14', undefined, this.wpDrawingNamespace);
        this.writeDup(writer);
        writer.writeAttributeString('xmlns', 'wps', undefined, this.wpShapeNamespace);
        writer.writeAttributeString('ve', 'Ignorable', undefined, 'w14 w15 wp14');
    }
    // Serailize the footer and its relations
    serializeFooter(footer, id, headerFooterPath, headerFooterRelsPath) {
        this.headerFooter = footer;
        let writer = new XmlWriter();
        writer.writeStartElement('w', 'ftr', this.wNamespace);
        this.writeHFCommonAttributes(writer);
        this.serializeBodyItems(writer, footer.blocks, true);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, headerFooterPath);
        this.mArchive.addItem(zipArchiveItem);
        this.serializeHFRelations(id, headerFooterRelsPath);
    }
    serializeDocumentRelations() {
        let writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.stylesRelType, 'styles.xml');
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.settingsRelType, 'settings.xml');
        if (this.mComments.length > 0) {
            this.serializeRelationShip(writer, this.getNextRelationShipID(), this.commentsRelType, 'comments.xml');
            this.serializeRelationShip(writer, this.getNextRelationShipID(), this.commentsExRelType, 'commentsExtended.xml');
        }
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.ThemeRelType, 'theme/theme1.xml');
        if (this.document.lists.length > 0) {
            this.serializeRelationShip(writer, this.getNextRelationShipID(), this.numberingRelType, 'numbering.xml');
        }
        this.serializeHeaderFooterRelations(writer);
        // if (HasFontTable) {
        //     SerializeRelationShip(docRelstream, GetNextRelationShipID(), this.FontTableRelType, 'fontTable.xml');
        // }
        // SerializeIncludePictureUrlRelations(docRelstream, InclPicFieldUrl);
        // //// Creating relationships for every hyperlink and image containing in the document
        this.serializeImagesRelations(this.documentImages, writer);
        // serialize chart relations
        this.serializeChartDocumentRelations(this.documentCharts, writer);
        // SerializeSvgImageRelation();
        //this.serializeExternalLinkImages(writer);
        // if (HasHyperlink && HyperlinkTargets.length > 0) {
        //     SerializeHyperlinkRelations(docRelstream, HyperlinkTargets);
        // }
        // if (m_document.HasMacros
        //     && IsMacroEnabled)
        //     SerializeRelationShip(docRelstream, GetNextRelationShipID(), this.VbaProjectRelType, this.VbaProject);
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.wordRelationPath);
        this.mArchive.addItem(zipArchiveItem);
        this.headerFooter = undefined;
    }
    // serialize chart relations
    serializeChartDocumentRelations(charts, writer) {
        if (charts.length > 0) {
            let keys = charts.keys;
            for (let i = 1; i <= keys.length; i++) {
                this.serializeRelationShip(writer, keys[i - 1], this.chartRelType, 'charts/chart' + i + '.xml');
            }
        }
    }
    serializeChartRelations() {
        let writer = new XmlWriter();
        this.resetChartRelationShipId();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        let chartColorPath = 'colors' + this.chartCount + '.xml';
        let chartRelationPath = this.chartPath + '/_rels/chart' + this.chartCount + '.xml.rels';
        let chartExcelPath = '../embeddings/Microsoft_Excel_Worksheet' + this.chartCount + '.xlsx';
        // tslint:disable-next-line:max-line-length
        this.serializeRelationShip(writer, this.getNextChartRelationShipID(), this.packageRelType, chartExcelPath);
        this.serializeRelationShip(writer, this.getNextChartRelationShipID(), this.chartColorStyleRelType, chartColorPath);
        writer.writeEndElement(); // end of relationships
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, chartRelationPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    // Serializes the image relations
    serializeImagesRelations(images, writer) {
        if (images.length > 0) {
            let imagePath = '';
            let base64ImageString;
            let keys = images.keys;
            for (let i = 0; i < keys.length; i++) {
                let mImage = images.get(keys[i]);
                base64ImageString = mImage.imageString;
                if (isNullOrUndefined(base64ImageString)) {
                    imagePath = this.imagePath + '/0.jpeg';
                    this.serializeRelationShip(writer, keys[i], this.imageRelType, imagePath.replace('word/', ''));
                }
                else {
                    let imageInfo = HelperMethods.formatClippedString(base64ImageString);
                    let extension = imageInfo.extension;
                    let formatClippedString = imageInfo.formatClippedString;
                    imagePath = this.imagePath + keys[i] + extension;
                    this.serializeRelationShip(writer, keys[i], this.imageRelType, imagePath.replace('word/', ''));
                    //if (m_archive.Find(imagePath.Replace('\\', '/')) === -1)
                    // {
                    let imageBlob = new Blob([this.encodedString(formatClippedString)]);
                    let zipArchiveItem = new ZipArchiveItem(imageBlob, imagePath);
                    // let TestArchive = new ZipArchive();
                    this.mArchive.addItem(zipArchiveItem);
                    // TestArchive.save('image.zip').then(function (): void {
                    //     TestArchive.destroy();
                    // });
                    // }
                }
            }
        }
    }
    /**
     * @private
     */
    encodedString(input) {
        let keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let chr1;
        let chr2;
        let chr3;
        let encode1;
        let encode2;
        let encode3;
        let encode4;
        let count = 0;
        let resultIndex = 0;
        /*let dataUrlPrefix: string = 'data:';*/
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        let totalLength = input.length * 3 / 4;
        if (input.charAt(input.length - 1) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (input.charAt(input.length - 2) === keyStr.charAt(64)) {
            totalLength--;
        }
        if (totalLength % 1 !== 0) {
            // totalLength is not an integer, the length does not match a valid
            // base64 content. That can happen if:
            // - the input is not a base64 content
            // - the input is *almost* a base64 content, with a extra chars at the
            // beginning or at the end
            // - the input uses a base64 variant (base64url for example)
            throw new Error('Invalid base64 input, bad content length.');
        }
        let output = new Uint8Array(totalLength | 0);
        while (count < input.length) {
            encode1 = keyStr.indexOf(input.charAt(count++));
            encode2 = keyStr.indexOf(input.charAt(count++));
            encode3 = keyStr.indexOf(input.charAt(count++));
            encode4 = keyStr.indexOf(input.charAt(count++));
            chr1 = (encode1 << 2) | (encode2 >> 4);
            chr2 = ((encode2 & 15) << 4) | (encode3 >> 2);
            chr3 = ((encode3 & 3) << 6) | encode4;
            output[resultIndex++] = chr1;
            if (encode3 !== 64) {
                output[resultIndex++] = chr2;
            }
            if (encode4 !== 64) {
                output[resultIndex++] = chr3;
            }
        }
        return output;
    }
    serializeExternalLinkImages(writer) {
        let keys = this.externalImages.keys;
        for (let i = 0; i < this.externalImages.keys.length; i++) {
            this.serializeRelationShip(writer, keys[i], this.imageRelType, this.externalImages.get(keys[i]));
        }
    }
    // Serializes the HeaderFooters relations to the document relations stream
    serializeHeaderFooterRelations(writer) {
        this.serializeHFRelation(writer, 'EvenFooter');
        this.serializeHFRelation(writer, 'EvenHeader');
        this.serializeHFRelation(writer, 'FirstPageFooter');
        this.serializeHFRelation(writer, 'FirstPageHeader');
        this.serializeHFRelation(writer, 'OddFooter');
        this.serializeHFRelation(writer, 'OddHeader');
    }
    // Serializes the headers footers relations.
    serializeHFRelation(writer, hfType) {
        let headerFooterPath = '';
        let relType;
        if (!this.headersFooters.containsKey(hfType)) {
            return;
        }
        let hfColl = this.headersFooters.get(hfType);
        for (let i = 0; i < hfColl.keys.length; i++) {
            let id = hfColl.keys[i];
            if (hfType === 'EvenHeader' || hfType === 'FirstPageHeader' ||
                hfType === 'OddHeader') {
                headerFooterPath = 'header' + id.replace('rId', '') + '.xml';
                relType = this.headerRelType;
            }
            else {
                headerFooterPath = 'footer' + id.replace('rId', '') + '.xml';
                relType = this.footerRelType;
            }
            this.serializeRelationShip(writer, id, relType, headerFooterPath);
        }
    }
    // Serializes the relationship
    serializeRelationShip(writer, relationshipID, relationshipType, targetPath) {
        writer.writeStartElement(undefined, 'Relationship', undefined);
        writer.writeAttributeString(undefined, 'Id', undefined, relationshipID);
        writer.writeAttributeString(undefined, 'Type', undefined, relationshipType);
        writer.writeAttributeString(undefined, 'Target', undefined, targetPath.replace('\\', '/').replace('\v', ''));
        // tslint:disable-next-line:max-line-length
        if (relationshipType === this.hyperlinkRelType || this.startsWith(targetPath, 'http://') || this.startsWith(targetPath, 'https://') || this.startsWith(targetPath, 'file:///')) {
            // Uri targetUri;
            // if ((!targetPath.StartsWith('file:///')) && Uri.TryCreate(targetPath, UriKind.Absolute, out targetUri))
            // {
            //     //Handled using Try catch to avoid exception if the Host name type is None because in 
            //Silverlight 'HostNameType' property is not available.
            //     try
            //     {
            //         m_writer.WriteAttributeString('Target', targetUri.AbsoluteUri);
            //     }
            //     catch
            //     {
            //         m_writer.WriteAttributeString('Target', targetPath.Replace('\\', '/').Replace(ControlChar.LineBreak, string.Empty));
            //     }
            // }
            // else
            // {
            //     m_writer.WriteAttributeString('Target', targetPath.Replace('\\', '/').Replace(ControlChar.LineBreak, string.Empty));
            // }
            writer.writeAttributeString(undefined, 'TargetMode', undefined, 'External');
        }
        writer.writeEndElement();
    }
    // Get the next relationship ID
    getNextRelationShipID() {
        return 'rId' + (++this.mRelationShipID);
    }
    serializeGeneralRelations() {
        let writer = new XmlWriter();
        this.resetRelationShipID();
        writer.writeStartElement(undefined, 'Relationships', this.rpNamespace);
        this.serializeRelationShip(writer, this.getNextRelationShipID(), this.documentRelType, this.documentPath);
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.AppRelType, this.appPath);
        // this.serializeRelationShip(writer, this.getNextRelationShipID(), this.CoreRelType, this.corePath);
        //End of Relationships tag
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.generalRelationPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    serializeContentTypes(contentType) {
        let writer = new XmlWriter();
        writer.writeStartElement(undefined, 'Types', 'http://schemas.openxmlformats.org/package/2006/content-types');
        //if (m_hasOleObject)
        //{
        //    //<Default Extension='bin' ContentType='application/vnd.openxmlformats-officedocument.oleObject'/>
        //    SerializeDefaultContentType(contentStream, 'bin', 'application/vnd.openxmlformats-officedocument.oleObject');
        //}
        this.serializeDefaultContentType(writer, 'rels', this.relationContentType);
        this.serializeDefaultContentType(writer, 'xml', this.xmlContentType);
        // if (m_hasEmbedFonts && !string.IsNullOrEmpty(type))
        // {
        //     SerializeDefaultContentType(contentStream,type, this.fontContentType);
        // }
        if (this.documentImages.length > 0 || this.externalImages.length > 0 || this.headerFooterImages.length > 0) {
            this.serializeDefaultContentType(writer, 'png', 'image/png');
            this.serializeDefaultContentType(writer, 'bmp', 'image/bmp');
            this.serializeDefaultContentType(writer, 'emf', 'image/x-emf');
            this.serializeDefaultContentType(writer, 'wmf', 'image/x-wmf');
            this.serializeDefaultContentType(writer, 'gif', 'image/gif');
            this.serializeDefaultContentType(writer, 'ico', 'image/x-icon');
            this.serializeDefaultContentType(writer, 'tif', 'image/tiff');
            this.serializeDefaultContentType(writer, 'tiff', 'image/tiff');
            this.serializeDefaultContentType(writer, 'jpeg', 'image/jpeg');
            this.serializeDefaultContentType(writer, 'jpg', 'image/jpeg');
            this.serializeDefaultContentType(writer, 'svg', 'image/svg+xml');
        }
        // if (m_document.HasMacros
        //     && IsMacroEnabled && !m_isSkipBinExtension)
        // {
        //     SerializeDefaultContentType(contentStream, 'bin', this.VbaProjectContentType);
        //     m_isSkipBinExtension = true;
        // }
        // if (m_hasOleObject)
        // {
        //     SerializeOleContentType(contentStream);
        // }
        //document.xml
        this.serializeOverrideContentType(writer, this.documentPath, this.documentContentType);
        // tslint:disable-next-line:max-line-length
        //<Override PartName='/word/numbering.xml' ContentType='application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml'/>
        // if (HasNumbering) {
        this.serializeOverrideContentType(writer, this.numberingPath, this.numberingContentType);
        // }
        //Add the header/footer Alternate chunks
        // if (HeaderFooterAlternateChunks.length > 0) {
        //     foreach(Dictionary < string, string > item in m_headerFooterAlternateChunks.Values)
        //     AddAlternateChunkItem(item);
        // }
        //styles.xml
        this.serializeOverrideContentType(writer, this.stylePath, this.stylesContentType);
        //settings.xml
        this.serializeOverrideContentType(writer, this.settingsPath, this.settingsContentType);
        this.serializeOverrideContentType(writer, this.commentsPath, this.commentsContentType);
        //comments.xml
        this.serializeOverrideContentType(writer, this.commentsExtendedPath, this.commentsExContentType);
        //charts.xml
        if (this.chartCount > 0) {
            let count = 1;
            this.serializeDefaultContentType(writer, 'xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            while (count <= this.chartCount) {
                this.serializeOverrideContentType(writer, 'word/charts/chart' + count + '.xml', this.chartsContentType);
                this.serializeOverrideContentType(writer, 'word/charts/colors' + count + '.xml', this.chartColorStyleContentType);
                count++;
            }
        }
        //             //core.xml
        //             SerializeOverrideContentType(contentStream, this.corePath, this.CoreContentType);
        //             //app.xml
        //             SerializeOverrideContentType(contentStream, this.appPath, this.AppContentType);
        //             //custom.xml
        //             if (!isNullOrUndefined(m_document.CustomDocumentProperties) && m_document.CustomDocumentProperties.length > 0)
        //                 SerializeOverrideContentType(contentStream, this.CustomPath, this.CustomContentType);
        // #if Chart
        //             if (m_hasChart)
        //                 SerializeChartContentType(contentStream);
        // #endif
        this.serializeHFContentTypes(writer);
        // WriteXmlItemsContentTypes(contentStream);
        //End of Types tag
        writer.writeEndElement();
        let zipArchiveItem = new ZipArchiveItem(writer.buffer, this.contentTypesPath);
        this.mArchive.addItem(zipArchiveItem);
    }
    // Serializes the HeaderFooter content types
    serializeHFContentTypes(writer) {
        this.serializeHeaderFootersContentType(writer, 'EvenFooter');
        this.serializeHeaderFootersContentType(writer, 'EvenHeader');
        this.serializeHeaderFootersContentType(writer, 'FirstPageFooter');
        this.serializeHeaderFootersContentType(writer, 'FirstPageHeader');
        this.serializeHeaderFootersContentType(writer, 'OddFooter');
        this.serializeHeaderFootersContentType(writer, 'OddHeader');
    }
    // Serializes the HeaderFooter content types.
    serializeHeaderFootersContentType(writer, headerFooterType) {
        let contentType;
        let partName;
        if (!this.headersFooters.containsKey(headerFooterType)) {
            return;
        }
        let hfColl = this.headersFooters.get(headerFooterType);
        for (let i = 0; i < hfColl.keys.length; i++) {
            let id = hfColl.keys[i];
            if (headerFooterType === 'EvenHeader' || headerFooterType === 'FirstPageHeader' ||
                headerFooterType === 'OddHeader') {
                partName = this.headerPath + id.replace('rId', '') + '.xml';
                contentType = this.headerContentType;
            }
            else {
                partName = this.footerPath + id.replace('rId', '') + '.xml';
                contentType = this.footerContentType;
            }
            this.serializeOverrideContentType(writer, partName, contentType);
        }
    }
    // Serializes the Override content type.
    serializeOverrideContentType(writer, partName, contentType) {
        writer.writeStartElement(undefined, 'Override', undefined);
        writer.writeAttributeString(undefined, 'PartName', undefined, '/' + partName.replace('\\', '/'));
        writer.writeAttributeString(undefined, 'ContentType', undefined, contentType);
        writer.writeEndElement();
    }
    // Serializes the default content type
    serializeDefaultContentType(writer, extension, contentType) {
        writer.writeStartElement(undefined, 'Default', undefined);
        writer.writeAttributeString(undefined, 'Extension', undefined, extension);
        writer.writeAttributeString(undefined, 'ContentType', undefined, contentType);
        writer.writeEndElement();
    }
    // Reset the relationship id counter
    resetRelationShipID() {
        this.mRelationShipID = 0;
    }
    resetExcelRelationShipId() {
        this.eRelationShipId = 0;
    }
    resetChartRelationShipId() {
        this.cRelationShipId = 0;
    }
    close() {
        //Implement
    }
}

/**
 * Exports the document to Text format.
 */
class TextExport {
    constructor() {
        /**
         * @private
         */
        this.pageContent = '';
        this.curSectionIndex = 0;
        this.inField = false;
    }
    getModuleName() {
        return 'TextExport';
    }
    /**
     * @private
     */
    save(viewer, fileName) {
        this.serialize(viewer);
        let writer = new StreamWriter();
        this.writeInternal(writer);
        writer.save(fileName + '.txt');
    }
    /**
     * @private
     */
    saveAsBlob(viewer) {
        this.serialize(viewer);
        let streamWriter = new StreamWriter();
        this.writeInternal(streamWriter);
        let blob = streamWriter.buffer;
        streamWriter.destroy();
        return new Promise((resolve, reject) => {
            resolve(blob);
        });
    }
    serialize(viewer) {
        let document = viewer.owner.sfdtExportModule.write();
        this.setDocument(document);
    }
    /**
     * @private
     * @param document
     */
    setDocument(document) {
        this.document = document;
        this.mSections = document.sections;
    }
    /**
     * @private
     * @param streamWriter
     */
    writeInternal(streamWriter) {
        let section = undefined;
        let sectionCount = this.document.sections.length - 1;
        let isLastSection = false;
        this.updateLastParagraph();
        for (let i = 0; i <= sectionCount; i++) {
            section = this.document.sections[i];
            isLastSection = (i === sectionCount) ? true : false;
            this.writeBody(streamWriter, section.blocks);
            this.writeNewLine(streamWriter);
            this.writeSectionEnd(section, isLastSection);
        }
        for (let j = 0; j <= sectionCount; j++) {
            section = this.document.sections[j];
            this.writeHeadersFooters(streamWriter, section);
        }
    }
    /// <summary>
    /// Writes the specified document content to the text file.
    /// </summary>
    writeBody(streamWriter, body) {
        let bodyItemsCount = body.length - 1;
        let bodyItem = undefined;
        for (let i = 0; i <= bodyItemsCount; i++) {
            bodyItem = body[i];
            if (bodyItem.hasOwnProperty('inlines')) {
                let isLastPara = (bodyItem === this.lastPara) ? true : false;
                this.writeParagraph(streamWriter, bodyItem, isLastPara);
            }
            else {
                this.writeTable(streamWriter, bodyItem);
            }
        }
    }
    writeParagraph(streamWriter, paragraph, isLastPara) {
        for (let i = 0; i < paragraph.inlines.length; i++) {
            let item = paragraph.inlines[i];
            if (item.hasOwnProperty('fieldType')) {
                this.inField = item.fieldType === 0;
            }
            else if (item.hasOwnProperty('text') && !this.inField) {
                this.writeText(streamWriter, item.text);
            }
        }
        if (!isLastPara) {
            this.writeNewLine(streamWriter);
        }
    }
    /// }
    /// <summary>
    /// Writes the specified table text content to the text file.
    /// </summary>
    writeTable(streamWriter, table) {
        for (let i = 0; i < table.rows.length; i++) {
            let row = table.rows[i];
            for (let j = 0; j < row.cells.length; j++) {
                let cell = row.cells[j];
                this.writeBody(streamWriter, cell.blocks);
            }
        }
    }
    /// <summary>
    /// Writes the specified Header Footer text content to the text file.
    /// </summary>
    writeHeadersFooters(streamWriter, section) {
        let headersFooters = section.headersFooters;
        if (isNullOrUndefined(headersFooters)) {
            return;
        }
        this.writeHeaderFooter(streamWriter, section.headersFooters.header);
        this.writeHeaderFooter(streamWriter, section.headersFooters.footer);
        this.writeHeaderFooter(streamWriter, section.headersFooters.evenFooter);
        this.writeHeaderFooter(streamWriter, section.headersFooters.evenHeader);
        this.writeHeaderFooter(streamWriter, section.headersFooters.firstPageHeader);
        this.writeHeaderFooter(streamWriter, section.headersFooters.firstPageFooter);
    }
    writeHeaderFooter(streamWriter, headerFooter) {
        if (headerFooter && headerFooter.blocks) {
            this.writeBody(streamWriter, headerFooter.blocks);
        }
    }
    /// <summary>
    /// Writes the end of the section.
    /// </summary>
    writeSectionEnd(section, lastSection) {
        this.curSectionIndex++;
    }
    writeNewLine(writer) {
        if (!isNullOrUndefined(writer)) {
            writer.writeLine('');
        }
        else {
            this.pageContent = this.pageContent + ' ';
        }
    }
    writeText(writer, text) {
        if (!isNullOrUndefined(writer)) {
            writer.write(text);
        }
        else {
            this.pageContent += text;
        }
    }
    updateLastParagraph() {
        let cnt = this.document.sections.length;
        let sec;
        if (cnt > 0) {
            sec = this.document.sections[cnt - 1];
        }
        if (!isNullOrUndefined(sec)) {
            let paragraphs = [];
            for (let i = 0; i < sec.blocks.length; i++) {
                if (sec.blocks[i].hasOwnProperty('inlines')) {
                    paragraphs.push(sec.blocks[i]);
                }
            }
            let pCount = paragraphs.length;
            if (pCount > 0) {
                this.lastPara = paragraphs[pCount - 1];
            }
        }
    }
    /**
     * @private
     */
    destroy() {
        this.document = undefined;
        this.lastPara = undefined;
        this.mSections = undefined;
        this.sections = undefined;
    }
}

/**
 * Exports the document to Sfdt format.
 */
class SfdtExport {
    /**
     * @private
     */
    constructor(owner) {
        /* tslint:disable:no-any */
        this.endLine = undefined;
        this.endOffset = undefined;
        this.endCell = undefined;
        this.startColumnIndex = undefined;
        this.endColumnIndex = undefined;
        this.lists = undefined;
        this.viewer = undefined;
        this.document = undefined;
        this.writeInlineStyles = undefined;
        this.editRangeId = -1;
        this.viewer = owner;
    }
    getModuleName() {
        return 'SfdtExport';
    }
    clear() {
        this.writeInlineStyles = undefined;
        this.endLine = undefined;
        this.lists = undefined;
        this.document = undefined;
        this.endCell = undefined;
    }
    /**
     * Serialize the data as Syncfusion document text.
     * @private
     */
    serialize() {
        return JSON.stringify(this.write());
    }
    /**
     * @private
     */
    saveAsBlob(viewer) {
        let streamWriter = new StreamWriter();
        streamWriter.write(this.serialize());
        let blob = streamWriter.buffer;
        streamWriter.destroy();
        return new Promise((resolve, reject) => {
            resolve(blob);
        });
    }
    updateEditRangeId() {
        let index = -1;
        for (let i = 0; i < this.viewer.editRanges.keys.length; i++) {
            let keys = this.viewer.editRanges.keys;
            for (let j = 0; j < keys[i].length; j++) {
                let editRangeStart = this.viewer.editRanges.get(keys[i]);
                for (let z = 0; z < editRangeStart.length; z++) {
                    index++;
                    editRangeStart[z].editRangeId = index;
                    editRangeStart[z].editRangeEnd.editRangeId = index;
                }
            }
        }
    }
    // tslint:disable-next-line:max-line-length
    /**
     * @private
     */
    write(line, startOffset, endLine, endOffset, writeInlineStyles) {
        if (writeInlineStyles) {
            this.writeInlineStyles = true;
        }
        this.Initialize();
        this.updateEditRangeId();
        if (line instanceof LineWidget && endLine instanceof LineWidget) {
            // For selection
            let startPara = line.paragraph;
            let endPara = endLine.paragraph;
            let startCell = startPara.associatedCell;
            let endCell = endPara.associatedCell;
            // Creates section
            let bodyWidget = startPara.bodyWidget;
            let section = this.createSection(line.paragraph.bodyWidget);
            this.document.sections.push(section);
            if (startCell === endCell || isNullOrUndefined(endCell)) {
                this.endLine = endLine;
                this.endOffset = endOffset;
            }
            else {
                // Todo: Handle nested table cases
                if (startCell instanceof TableCellWidget) {
                    let startTable = startCell.getContainerTable();
                    let endTable = endCell.getContainerTable();
                    if (startTable.tableFormat === endTable.tableFormat) {
                        this.endCell = endCell;
                        if (this.endCell.ownerTable !== startCell.ownerTable && startCell.ownerTable.associatedCell
                            && startCell.ownerTable.associatedCell.ownerTable === this.endCell.ownerTable &&
                            (startCell.ownerTable.associatedCell.childWidgets.indexOf(startCell.ownerTable) === 0)) {
                            startCell = startCell.ownerTable.associatedCell;
                        }
                        this.endColumnIndex = this.endCell.columnIndex + this.endCell.cellFormat.columnSpan;
                        this.startColumnIndex = startCell.columnIndex;
                    }
                }
                else {
                    this.endCell = endCell;
                }
            }
            let nextBlock;
            if (startCell === endCell || isNullOrUndefined(startCell)) {
                let paragraph = this.createParagraph(line.paragraph);
                section.blocks.push(paragraph);
                nextBlock = this.writeParagraph(line.paragraph, paragraph, section.blocks, line.indexInOwner, startOffset);
                while (nextBlock) {
                    nextBlock = this.writeBlock(nextBlock, 0, section.blocks);
                }
                // Todo:continue in next section
            }
            else {
                // Specially handled for nested table cases
                // selection start inside table and end in paragraph outside table
                if (isNullOrUndefined(endCell) && startCell.ownerTable.associatedCell) {
                    let startTable = startCell.getContainerTable();
                    let lastRow = startTable.childWidgets[startTable.childWidgets.length - 1];
                    let endCell = lastRow.childWidgets[lastRow.childWidgets.length - 1];
                    if (endCell.ownerTable !== startCell.ownerTable && startCell.ownerTable.associatedCell
                        && (startCell.ownerTable.associatedCell.childWidgets.indexOf(startCell.ownerTable) === 0)) {
                        while (startCell.ownerTable !== endCell.ownerTable) {
                            startCell = startCell.ownerTable.associatedCell;
                        }
                    }
                    this.endColumnIndex = endCell.columnIndex + endCell.cellFormat.columnSpan;
                    this.startColumnIndex = startCell.columnIndex;
                }
                let table = this.createTable(startCell.ownerTable);
                section.blocks.push(table);
                nextBlock = this.writeTable(startCell.ownerTable, table, startCell.ownerRow.indexInOwner, section.blocks);
                while (nextBlock) {
                    nextBlock = this.writeBlock(nextBlock, 0, section.blocks);
                }
            }
        }
        else {
            if (this.viewer.pages.length > 0) {
                let page = this.viewer.pages[0];
                this.writePage(page);
            }
        }
        this.writeStyles(this.viewer);
        this.writeLists(this.viewer);
        this.writeComments(this.viewer);
        let doc = this.document;
        this.clear();
        return doc;
    }
    /**
     * @private
     */
    Initialize() {
        this.lists = [];
        this.document = {};
        this.document.sections = [];
        this.document.characterFormat = this.writeCharacterFormat(this.viewer.characterFormat);
        this.document.paragraphFormat = this.writeParagraphFormat(this.viewer.paragraphFormat);
        this.document.defaultTabWidth = this.viewer.defaultTabWidth;
        this.document.enforcement = this.viewer.isDocumentProtected;
        this.document.hashValue = this.viewer.hashValue;
        this.document.saltValue = this.viewer.saltValue;
        this.document.formatting = this.viewer.restrictFormatting;
        this.document.protectionType = this.viewer.protectionType;
    }
    /**
     * @private
     */
    writePage(page) {
        if (page.bodyWidgets.length > 0) {
            let nextBlock = page.bodyWidgets[0];
            do {
                nextBlock = this.writeBodyWidget(nextBlock, 0);
            } while (!isNullOrUndefined(nextBlock));
        }
        return this.document;
    }
    writeBodyWidget(bodyWidget, index) {
        if (!(bodyWidget instanceof BodyWidget)) {
            return undefined;
        }
        let section = this.createSection(bodyWidget);
        this.document.sections.push(section);
        this.writeHeaderFooters(this.viewer.headersFooters[bodyWidget.index], section);
        let firstBlock = bodyWidget.childWidgets[index];
        do {
            firstBlock = this.writeBlock(firstBlock, 0, section.blocks);
        } while (firstBlock);
        let next = bodyWidget;
        do {
            bodyWidget = next;
            next = next.nextRenderedWidget;
        } while (next instanceof BodyWidget && next.index === bodyWidget.index);
        return next;
    }
    writeHeaderFooters(hfs, section) {
        if (isNullOrUndefined(hfs)) {
            return;
        }
        section.headersFooters.header = this.writeHeaderFooter(hfs[0]);
        section.headersFooters.footer = this.writeHeaderFooter(hfs[1]);
        section.headersFooters.evenHeader = this.writeHeaderFooter(hfs[2]);
        section.headersFooters.evenFooter = this.writeHeaderFooter(hfs[3]);
        section.headersFooters.firstPageHeader = this.writeHeaderFooter(hfs[4]);
        section.headersFooters.firstPageFooter = this.writeHeaderFooter(hfs[5]);
    }
    writeHeaderFooter(widget) {
        if (isNullOrUndefined(widget) || widget.isEmpty) {
            return undefined;
        }
        let headerFooter = {};
        if (widget && widget.childWidgets && widget.childWidgets.length > 0) {
            headerFooter.blocks = [];
            let firstBlock = widget.firstChild;
            do {
                firstBlock = this.writeBlock(firstBlock, 0, headerFooter.blocks);
            } while (firstBlock);
        }
        return headerFooter;
    }
    createSection(bodyWidget) {
        let section = {};
        section.sectionFormat = {};
        section.sectionFormat.pageWidth = bodyWidget.sectionFormat.pageWidth;
        section.sectionFormat.pageHeight = bodyWidget.sectionFormat.pageHeight;
        section.sectionFormat.leftMargin = bodyWidget.sectionFormat.leftMargin;
        section.sectionFormat.rightMargin = bodyWidget.sectionFormat.rightMargin;
        section.sectionFormat.topMargin = bodyWidget.sectionFormat.topMargin;
        section.sectionFormat.bottomMargin = bodyWidget.sectionFormat.bottomMargin;
        section.sectionFormat.differentFirstPage = bodyWidget.sectionFormat.differentFirstPage;
        section.sectionFormat.differentOddAndEvenPages = bodyWidget.sectionFormat.differentOddAndEvenPages;
        section.sectionFormat.headerDistance = bodyWidget.sectionFormat.headerDistance;
        section.sectionFormat.footerDistance = bodyWidget.sectionFormat.footerDistance;
        section.sectionFormat.bidi = bodyWidget.sectionFormat.bidi;
        section.blocks = [];
        section.headersFooters = {};
        return section;
    }
    writeBlock(widget, index, blocks) {
        if (!(widget instanceof BlockWidget)) {
            return undefined;
        }
        if (widget instanceof ParagraphWidget) {
            let paragraph = this.createParagraph(widget);
            blocks.push(paragraph);
            return this.writeParagraph(widget, paragraph, blocks);
        }
        else {
            let tableWidget = widget;
            let table = this.createTable(tableWidget);
            blocks.push(table);
            return this.writeTable(tableWidget, table, 0, blocks);
        }
    }
    writeParagraph(paragraphWidget, paragraph, blocks, lineIndex, start) {
        if (isNullOrUndefined(lineIndex)) {
            lineIndex = 0;
        }
        if (isNullOrUndefined(start)) {
            start = 0;
        }
        let next = paragraphWidget;
        while (next instanceof ParagraphWidget) {
            if (this.writeLines(next, lineIndex, start, paragraph.inlines)) {
                return undefined;
            }
            lineIndex = 0;
            start = 0;
            paragraphWidget = next;
            next = paragraphWidget.nextSplitWidget;
        }
        next = paragraphWidget.nextRenderedWidget;
        return (next instanceof BlockWidget && paragraphWidget.containerWidget.index === next.containerWidget.index) ? next : undefined;
    }
    writeInlines(paragraph, line, inlines) {
        let lineWidget = line.clone();
        let bidi = paragraph.paragraphFormat.bidi;
        if (bidi || this.viewer.layout.isContainsRtl(lineWidget)) {
            this.viewer.layout.reArrangeElementsForRtl(lineWidget, bidi);
        }
        for (let i = 0; i < lineWidget.children.length; i++) {
            let element = lineWidget.children[i];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            let inline = this.writeInline(element);
            if (!isNullOrUndefined(inline)) {
                inlines.push(inline);
            }
        }
    }
    writeInline(element) {
        let inline = {};
        inline.characterFormat = this.writeCharacterFormat(element.characterFormat);
        if (element instanceof FieldElementBox) {
            inline.fieldType = element.fieldType;
            if (element.fieldType === 0) {
                inline.hasFieldEnd = true;
            }
            if (element.fieldCodeType && element.fieldCodeType !== '') {
                inline.fieldCodeType = element.fieldCodeType;
            }
        }
        else if (element instanceof ChartElementBox) {
            this.writeChart(element, inline);
        }
        else if (element instanceof ImageElementBox) {
            inline.imageString = element.imageString;
            inline.width = HelperMethods.convertPixelToPoint(element.width);
            inline.height = HelperMethods.convertPixelToPoint(element.height);
        }
        else if (element instanceof BookmarkElementBox) {
            inline.bookmarkType = element.bookmarkType;
            inline.name = element.name;
        }
        else if (element instanceof TextElementBox) {
            // replacing the no break hyphen character by '-'
            if (element.text.indexOf('\u001e') !== -1) {
                inline.text = element.text.replace('\u001e', '-');
            }
            else if (element.text.indexOf('\u001f') !== -1) {
                inline.text = element.text.replace('\u001f', '');
            }
            else {
                inline.text = element.text;
            }
        }
        else if (element instanceof EditRangeStartElementBox) {
            inline.user = element.user;
            inline.group = element.group;
            inline.columnFirst = element.columnFirst;
            inline.columnLast = element.columnLast;
            inline.editRangeId = element.editRangeId.toString();
        }
        else if (element instanceof EditRangeEndElementBox) {
            inline.editableRangeStart = {
                'user': element.editRangeStart.user,
                'group': element.editRangeStart.group,
                'columnFirst': element.editRangeStart.columnFirst,
                'columnLast': element.editRangeStart.columnLast
            };
            inline.editRangeId = element.editRangeId.toString();
        }
        else if (element instanceof CommentCharacterElementBox) {
            inline.commentCharacterType = element.commentType;
            inline.commentId = element.commentId;
        }
        else {
            inline = undefined;
        }
        return inline;
    }
    writeChart(element, inline) {
        inline.chartLegend = {};
        inline.chartTitleArea = {};
        inline.chartArea = {};
        inline.plotArea = {};
        inline.chartCategory = [];
        inline.chartSeries = [];
        inline.chartPrimaryCategoryAxis = {};
        inline.chartPrimaryValueAxis = {};
        this.writeChartTitleArea(element.chartTitleArea, inline.chartTitleArea);
        this.writeChartArea(element.chartArea, inline.chartArea);
        this.writeChartArea(element.chartPlotArea, inline.plotArea);
        this.writeChartCategory(element, inline.chartCategory);
        this.createChartSeries(element, inline.chartSeries);
        this.writeChartLegend(element.chartLegend, inline.chartLegend);
        this.writeChartCategoryAxis(element.chartPrimaryCategoryAxis, inline.chartPrimaryCategoryAxis);
        this.writeChartCategoryAxis(element.chartPrimaryValueAxis, inline.chartPrimaryValueAxis);
        if (element.chartDataTable.showSeriesKeys !== undefined) {
            inline.chartDataTable = {};
            this.writeChartDataTable(element.chartDataTable, inline.chartDataTable);
        }
        inline.chartTitle = element.title;
        inline.chartType = element.type;
        inline.gapWidth = element.chartGapWidth;
        inline.overlap = element.chartOverlap;
        inline.height = HelperMethods.convertPixelToPoint(element.height);
        inline.width = HelperMethods.convertPixelToPoint(element.width);
    }
    writeChartTitleArea(titleArea, chartTitleArea) {
        chartTitleArea.fontName = titleArea.chartfontName;
        chartTitleArea.fontSize = titleArea.chartFontSize;
        chartTitleArea.layout = {};
        chartTitleArea.dataFormat = this.writeChartDataFormat(titleArea.dataFormat);
        this.writeChartLayout(titleArea.layout, chartTitleArea.layout);
    }
    writeChartDataFormat(format) {
        let chartDataFormat = {};
        chartDataFormat.fill = {};
        chartDataFormat.line = {};
        chartDataFormat.fill.foreColor = format.fill.color;
        chartDataFormat.fill.rgb = format.fill.rgb;
        chartDataFormat.line.color = format.line.color;
        chartDataFormat.line.rgb = format.line.rgb;
        return chartDataFormat;
    }
    writeChartLayout(layout, chartLayout) {
        chartLayout.layoutX = layout.chartLayoutLeft;
        chartLayout.layoutY = layout.chartLayoutTop;
    }
    writeChartArea(area, chartArea) {
        chartArea.foreColor = area.chartForeColor;
    }
    writeChartLegend(legend, chartLegend) {
        chartLegend.position = legend.chartLegendPostion;
        chartLegend.chartTitleArea = {};
        this.writeChartTitleArea(legend.chartTitleArea, chartLegend.chartTitleArea);
    }
    writeChartCategoryAxis(categoryAxis, primaryCategoryAxis) {
        primaryCategoryAxis.chartTitle = categoryAxis.categoryAxisTitle;
        primaryCategoryAxis.chartTitleArea = {};
        this.writeChartTitleArea(categoryAxis.chartTitleArea, primaryCategoryAxis.chartTitleArea);
        primaryCategoryAxis.categoryType = categoryAxis.categoryAxisType;
        primaryCategoryAxis.fontSize = categoryAxis.axisFontSize;
        primaryCategoryAxis.fontName = categoryAxis.axisFontName;
        primaryCategoryAxis.numberFormat = categoryAxis.categoryNumberFormat;
        primaryCategoryAxis.maximumValue = categoryAxis.max;
        primaryCategoryAxis.minimumValue = categoryAxis.min;
        primaryCategoryAxis.majorUnit = categoryAxis.interval;
        primaryCategoryAxis.hasMajorGridLines = categoryAxis.majorGridLines;
        primaryCategoryAxis.hasMinorGridLines = categoryAxis.minorGridLines;
        primaryCategoryAxis.majorTickMark = categoryAxis.majorTick;
        primaryCategoryAxis.minorTickMark = categoryAxis.minorTick;
        primaryCategoryAxis.tickLabelPosition = categoryAxis.tickPosition;
    }
    writeChartDataTable(chartDataTable, dataTable) {
        dataTable.showSeriesKeys = chartDataTable.showSeriesKeys;
        dataTable.hasHorzBorder = chartDataTable.hasHorzBorder;
        dataTable.hasVertBorder = chartDataTable.hasVertBorder;
        dataTable.hasBorders = chartDataTable.hasBorders;
    }
    writeChartCategory(element, chartCategory) {
        let data = element.chartCategory;
        chartCategory.chartData = [];
        for (let i = 0; i < data.length; i++) {
            let xData = data[i];
            let categories = this.createChartCategory(xData, element.chartType);
            chartCategory.push(categories);
        }
    }
    createChartCategory(data, type) {
        let chartCategory = {};
        chartCategory.chartData = [];
        this.writeChartData(data, chartCategory.chartData, type);
        chartCategory.categoryXName = data.categoryXName;
        return chartCategory;
    }
    writeChartData(element, chartData, type) {
        let data = element.chartData;
        for (let i = 0; i < data.length; i++) {
            let yData = data[i];
            let yCategory = this.createChartData(yData, type);
            chartData.push(yCategory);
        }
    }
    createChartData(data, type) {
        let chartData = {};
        chartData.yValue = data.yValue;
        if (type === 'Bubble') {
            chartData.size = data.size;
        }
        return chartData;
    }
    createChartSeries(element, chartSeries) {
        let data = element.chartSeries;
        let type = element.chartType;
        for (let i = 0; i < data.length; i++) {
            let yData = data[i];
            let series = this.writeChartSeries(yData, type);
            chartSeries.push(series);
        }
    }
    writeChartSeries(series, type) {
        let isPieType = (type === 'Pie' || type === 'Doughnut');
        let chartSeries = {};
        let errorBar = {};
        let errorBarData = series.errorBar;
        chartSeries.dataPoints = [];
        chartSeries.seriesName = series.seriesName;
        if (isPieType) {
            if (!isNullOrUndefined(series.firstSliceAngle)) {
                chartSeries.firstSliceAngle = series.firstSliceAngle;
            }
            if (type === 'Doughnut') {
                chartSeries.holeSize = series.doughnutHoleSize;
            }
        }
        if (!isNullOrUndefined(series.dataLabels.labelPosition)) {
            let dataLabel = this.writeChartDataLabels(series.dataLabels);
            chartSeries.dataLabel = dataLabel;
        }
        if (!isNullOrUndefined(series.seriesFormat.markerStyle)) {
            let seriesFormat = {};
            let format = series.seriesFormat;
            seriesFormat.markerStyle = format.markerStyle;
            seriesFormat.markerSize = format.numberValue;
            seriesFormat.markerColor = format.markerColor;
            chartSeries.seriesFormat = seriesFormat;
        }
        if (!isNullOrUndefined(errorBarData.type)) {
            errorBar.type = errorBarData.type;
            errorBar.direction = errorBarData.direction;
            errorBar.endStyle = errorBarData.endStyle;
            errorBar.numberValue = errorBarData.numberValue;
            chartSeries.errorBar = errorBarData;
        }
        if (series.trendLines.length > 0) {
            chartSeries.trendLines = [];
            for (let i = 0; i < series.trendLines.length; i++) {
                let trendLine = this.writeChartTrendLines(series.trendLines[i]);
                chartSeries.trendLines.push(trendLine);
            }
        }
        for (let i = 0; i < series.chartDataFormat.length; i++) {
            let format = this.writeChartDataFormat(series.chartDataFormat[i]);
            chartSeries.dataPoints.push(format);
        }
        return chartSeries;
    }
    writeChartDataLabels(dataLabels) {
        let dataLabel = {};
        dataLabel.position = dataLabels.position;
        dataLabel.fontName = dataLabels.fontName;
        dataLabel.fontColor = dataLabels.fontColor;
        dataLabel.fontSize = dataLabels.fontSize;
        dataLabel.isLegendKey = dataLabels.isLegendKey;
        dataLabel.isBubbleSize = dataLabels.isBubbleSize;
        dataLabel.isCategoryName = dataLabels.isCategoryName;
        dataLabel.isSeriesName = dataLabels.isSeriesName;
        dataLabel.isValue = dataLabels.isValue;
        dataLabel.isPercentage = dataLabels.isPercentage;
        dataLabel.isLeaderLines = dataLabels.isLeaderLines;
        return dataLabel;
    }
    writeChartTrendLines(trendLines) {
        let trendLine = {};
        trendLine.name = trendLines.trendLineName;
        trendLine.type = trendLines.trendLineType;
        trendLine.forward = trendLines.forwardValue;
        trendLine.backward = trendLines.backwardValue;
        trendLine.intercept = trendLines.interceptValue;
        trendLine.isDisplayEquation = trendLines.isDisplayEquation;
        trendLine.isDisplayRSquared = trendLines.isDisplayRSquared;
        return trendLine;
    }
    writeLines(paragraph, lineIndex, offset, inlines) {
        let startIndex = lineIndex;
        let endParagraph = this.endLine instanceof LineWidget && this.endLine.paragraph === paragraph;
        let endIndex = endParagraph ? this.endLine.indexInOwner : paragraph.childWidgets.length - 1;
        for (let i = startIndex; i <= endIndex; i++) {
            let child = paragraph.childWidgets[i];
            if (this.endLine === child || (lineIndex === i && offset !== 0)) {
                this.writeLine(child, offset, inlines);
            }
            else {
                this.writeInlines(paragraph, child, inlines);
            }
        }
        return endParagraph;
    }
    writeLine(line, offset, inlines) {
        let isEnd = line === this.endLine;
        let lineWidget = line.clone();
        let bidi = line.paragraph.paragraphFormat.bidi;
        if (bidi || this.viewer.layout.isContainsRtl(lineWidget)) {
            this.viewer.layout.reArrangeElementsForRtl(lineWidget, bidi);
        }
        let started = false;
        let ended = false;
        let length = 0;
        for (let j = 0; j < lineWidget.children.length; j++) {
            let element = lineWidget.children[j];
            if (element instanceof ListTextElementBox) {
                continue;
            }
            let inline = undefined;
            length += element.length;
            started = length > offset;
            ended = isEnd && length >= this.endOffset;
            if (!started) {
                continue;
            }
            inline = this.writeInline(element);
            inlines[inlines.length] = inline;
            if (length > offset || ended) {
                if (inline.hasOwnProperty('text')) {
                    let startIndex = length - element.length;
                    let indexInInline = offset - startIndex;
                    let endIndex = ended ? this.endOffset - startIndex : element.length;
                    inline.text = inline.text.substring(indexInInline, endIndex);
                }
                offset = -1;
            }
            if (ended) {
                break;
            }
        }
    }
    createParagraph(paragraphWidget) {
        let paragraph = {};
        let isParaSelected = false;
        if (this.viewer.selection && !this.viewer.selection.isEmpty) {
            let endPos = this.viewer.selection.end;
            if (!this.viewer.selection.isForward) {
                endPos = this.viewer.selection.start;
            }
            let lastLine = endPos.paragraph.childWidgets[endPos.paragraph.childWidgets.length - 1];
            isParaSelected = this.viewer.selection.isParagraphLastLine(lastLine) && endPos.currentWidget === lastLine
                && endPos.offset === this.viewer.selection.getLineLength(lastLine) + 1;
        }
        else {
            isParaSelected = true;
        }
        // tslint:disable-next-line:max-line-length
        paragraph.paragraphFormat = this.writeParagraphFormat(isParaSelected ? paragraphWidget.paragraphFormat : new WParagraphFormat(paragraphWidget));
        paragraph.characterFormat = this.writeCharacterFormat(isParaSelected ? paragraphWidget.characterFormat : new WCharacterFormat(paragraphWidget));
        paragraph.inlines = [];
        return paragraph;
    }
    /**
     * @private
     */
    writeCharacterFormat(format, isInline) {
        let characterFormat = {};
        HelperMethods.writeCharacterFormat(characterFormat, isInline, format);
        if (this.writeInlineStyles && !isInline) {
            characterFormat.inlineFormat = this.writeCharacterFormat(format, true);
        }
        return characterFormat;
    }
    writeParagraphFormat(format, isInline) {
        let paragraphFormat = {};
        paragraphFormat.leftIndent = isInline ? format.leftIndent : format.getValue('leftIndent');
        paragraphFormat.rightIndent = isInline ? format.rightIndent : format.getValue('rightIndent');
        paragraphFormat.firstLineIndent = isInline ? format.firstLineIndent : format.getValue('firstLineIndent');
        paragraphFormat.textAlignment = isInline ? format.textAlignment : format.getValue('textAlignment');
        paragraphFormat.beforeSpacing = isInline ? format.beforeSpacing : format.getValue('beforeSpacing');
        paragraphFormat.afterSpacing = isInline ? format.afterSpacing : format.getValue('afterSpacing');
        paragraphFormat.lineSpacing = isInline ? format.lineSpacing : format.getValue('lineSpacing');
        paragraphFormat.lineSpacingType = isInline ? format.lineSpacingType : format.getValue('lineSpacingType');
        paragraphFormat.styleName = !isNullOrUndefined(format.baseStyle) ? format.baseStyle.name : undefined;
        paragraphFormat.outlineLevel = isInline ? format.outlineLevel : format.getValue('outlineLevel');
        paragraphFormat.listFormat = this.writeListFormat(format.listFormat, isInline);
        paragraphFormat.tabs = this.writeTabs(format.tabs);
        paragraphFormat.bidi = isInline ? format.bidi : format.getValue('bidi');
        paragraphFormat.contextualSpacing = isInline ? format.contextualSpacing : format.getValue('contextualSpacing');
        if (this.writeInlineStyles && !isInline) {
            paragraphFormat.inlineFormat = this.writeParagraphFormat(format, true);
        }
        return paragraphFormat;
    }
    writeTabs(tabStops) {
        if (isNullOrUndefined(tabStops) || tabStops.length < 1) {
            return undefined;
        }
        let tabs = [];
        for (let i = 0; i < tabStops.length; i++) {
            let tabStop = tabStops[i];
            let tab = {};
            tab.position = tabStop.position;
            tab.deletePosition = tabStop.deletePosition;
            tab.tabJustification = tabStop.tabJustification;
            tab.tabLeader = tabStop.tabLeader;
            tabs.push(tab);
        }
        return tabs;
    }
    /**
     * @private
     */
    writeListFormat(format, isInline) {
        let listFormat = {};
        let listIdValue = format.getValue('listId');
        if (!isNullOrUndefined(listIdValue)) {
            listFormat.listId = listIdValue;
            let listLevelNumber = format.getValue('listLevelNumber');
            if (!isNullOrUndefined(listLevelNumber)) {
                listFormat.listLevelNumber = listLevelNumber;
            }
            if (this.lists.indexOf(format.listId) < 0) {
                this.lists.push(format.listId);
            }
        }
        return listFormat;
    }
    writeTable(tableWidget, table, index, blocks) {
        let widget = tableWidget.childWidgets[index];
        if (widget instanceof TableRowWidget) {
            if (this.writeRow(widget, table.rows)) {
                return undefined;
            }
        }
        let next = tableWidget;
        do {
            tableWidget = next;
            next = tableWidget.nextSplitWidget;
        } while (next instanceof BlockWidget);
        next = tableWidget.nextRenderedWidget;
        return (next instanceof BlockWidget && next.containerWidget.index === tableWidget.containerWidget.index) ? next : undefined;
    }
    writeRow(rowWidget, rows) {
        if (!(rowWidget instanceof TableRowWidget)) {
            return false;
        }
        let row = this.createRow(rowWidget);
        rows.push(row);
        for (let i = 0; i < rowWidget.childWidgets.length; i++) {
            let widget = rowWidget.childWidgets[i];
            if (widget instanceof TableCellWidget) {
                if (rowWidget.index === widget.rowIndex
                    && (isNullOrUndefined(this.startColumnIndex) || widget.columnIndex >= this.startColumnIndex)
                    && (isNullOrUndefined(this.endColumnIndex) || widget.columnIndex < this.endColumnIndex)) {
                    if (this.writeCell(widget, row.cells)) {
                        return true;
                    }
                }
            }
        }
        let next = rowWidget;
        do {
            rowWidget = next;
            next = rowWidget.nextRenderedWidget;
            if (next && rowWidget.ownerTable.index !== next.ownerTable.index) {
                next = undefined;
            }
        } while (next instanceof TableRowWidget && next.index === rowWidget.index);
        return this.writeRow(next, rows);
    }
    writeCell(cellWidget, cells) {
        let cell = this.createCell(cellWidget);
        cells.push(cell);
        let firstBlock = cellWidget.firstChild;
        do {
            firstBlock = this.writeBlock(firstBlock, 0, cell.blocks);
        } while (firstBlock);
        return this.endCell instanceof TableCellWidget ? this.endCell.cellFormat === cellWidget.cellFormat : false;
    }
    createTable(tableWidget) {
        let table = {};
        table.rows = [];
        table.grid = [];
        for (let i = 0; i < tableWidget.tableHolder.columns.length; i++) {
            table.grid[i] = tableWidget.tableHolder.columns[i].preferredWidth;
        }
        table.tableFormat = this.writeTableFormat(tableWidget.tableFormat);
        table.description = tableWidget.description;
        table.title = tableWidget.title;
        table.columnCount = tableWidget.tableHolder.columns.length;
        return table;
    }
    createRow(rowWidget) {
        let row = {};
        row.cells = [];
        row.rowFormat = this.writeRowFormat(rowWidget.rowFormat);
        return row;
    }
    createCell(cellWidget) {
        let cell = {};
        cell.blocks = [];
        cell.cellFormat = this.writeCellFormat(cellWidget.cellFormat);
        cell.columnIndex = cellWidget.columnIndex;
        return cell;
    }
    writeShading(wShading) {
        let shading = {};
        shading.backgroundColor = wShading.hasValue('backgroundColor') ? wShading.backgroundColor : undefined;
        shading.foregroundColor = wShading.hasValue('foregroundColor') ? wShading.foregroundColor : undefined;
        shading.textureStyle = wShading.hasValue('textureStyle') ? wShading.textureStyle : undefined;
        return shading;
    }
    writeBorder(wBorder) {
        let border = {};
        border.color = wBorder.hasValue('color') ? wBorder.color : undefined;
        border.hasNoneStyle = wBorder.hasValue('hasNoneStyle') ? wBorder.hasNoneStyle : undefined;
        border.lineStyle = wBorder.hasValue('lineStyle') ? wBorder.lineStyle : undefined;
        border.lineWidth = wBorder.hasValue('lineWidth') ? wBorder.lineWidth : undefined;
        border.shadow = wBorder.hasValue('shadow') ? wBorder.shadow : undefined;
        border.space = wBorder.hasValue('space') ? wBorder.space : undefined;
        return border;
    }
    writeBorders(wBorders) {
        let borders = {};
        borders.top = this.writeBorder(wBorders.top);
        borders.left = this.writeBorder(wBorders.left);
        borders.right = this.writeBorder(wBorders.right);
        borders.bottom = this.writeBorder(wBorders.bottom);
        borders.diagonalDown = this.writeBorder(wBorders.diagonalDown);
        borders.diagonalUp = this.writeBorder(wBorders.diagonalUp);
        borders.horizontal = this.writeBorder(wBorders.horizontal);
        borders.vertical = this.writeBorder(wBorders.vertical);
        return borders;
    }
    writeCellFormat(wCellFormat) {
        let cellFormat = {};
        cellFormat.borders = this.writeBorders(wCellFormat.borders);
        cellFormat.shading = this.writeShading(wCellFormat.shading);
        cellFormat.topMargin = wCellFormat.hasValue('topMargin') ? wCellFormat.topMargin : undefined;
        cellFormat.rightMargin = wCellFormat.hasValue('rightMargin') ? wCellFormat.rightMargin : undefined;
        cellFormat.leftMargin = wCellFormat.hasValue('leftMargin') ? wCellFormat.leftMargin : undefined;
        cellFormat.bottomMargin = wCellFormat.hasValue('bottomMargin') ? wCellFormat.bottomMargin : undefined;
        cellFormat.preferredWidth = wCellFormat.hasValue('preferredWidth') ? wCellFormat.preferredWidth : undefined;
        cellFormat.preferredWidthType = wCellFormat.hasValue('preferredWidthType') ? wCellFormat.preferredWidthType : undefined;
        cellFormat.cellWidth = wCellFormat.hasValue('cellWidth') ? wCellFormat.cellWidth : undefined;
        cellFormat.columnSpan = wCellFormat.columnSpan;
        cellFormat.rowSpan = wCellFormat.rowSpan;
        cellFormat.verticalAlignment = wCellFormat.hasValue('verticalAlignment') ? wCellFormat.verticalAlignment : undefined;
        return cellFormat;
    }
    writeRowFormat(wRowFormat) {
        let rowFormat = {};
        rowFormat.height = wRowFormat.hasValue('height') ? wRowFormat.height : undefined;
        rowFormat.allowBreakAcrossPages = wRowFormat.hasValue('allowBreakAcrossPages') ? wRowFormat.allowBreakAcrossPages : undefined;
        rowFormat.heightType = wRowFormat.hasValue('heightType') ? wRowFormat.heightType : undefined;
        rowFormat.isHeader = wRowFormat.hasValue('isHeader') ? wRowFormat.isHeader : undefined;
        rowFormat.borders = this.writeBorders(wRowFormat.borders);
        rowFormat.gridBefore = wRowFormat.gridBefore;
        rowFormat.gridBeforeWidth = wRowFormat.hasValue('gridBeforeWidth') ? wRowFormat.gridBeforeWidth : undefined;
        rowFormat.gridBeforeWidthType = wRowFormat.hasValue('gridBeforeWidthType') ? wRowFormat.gridBeforeWidthType : undefined;
        rowFormat.gridAfter = wRowFormat.gridAfter;
        rowFormat.gridAfterWidth = wRowFormat.hasValue('gridAfterWidth') ? wRowFormat.gridAfterWidth : undefined;
        rowFormat.gridAfterWidthType = wRowFormat.hasValue('gridAfterWidthType') ? wRowFormat.gridAfterWidthType : undefined;
        rowFormat.leftMargin = wRowFormat.hasValue('leftMargin') ? wRowFormat.leftMargin : undefined;
        rowFormat.topMargin = wRowFormat.hasValue('topMargin') ? wRowFormat.topMargin : undefined;
        rowFormat.rightMargin = wRowFormat.hasValue('rightMargin') ? wRowFormat.rightMargin : undefined;
        rowFormat.bottomMargin = wRowFormat.hasValue('bottomMargin') ? wRowFormat.bottomMargin : undefined;
        rowFormat.leftIndent = wRowFormat.hasValue('leftIndent') ? wRowFormat.leftIndent : undefined;
        return rowFormat;
    }
    writeTableFormat(wTableFormat) {
        let tableFormat = {};
        tableFormat.borders = this.writeBorders(wTableFormat.borders);
        tableFormat.shading = this.writeShading(wTableFormat.shading);
        tableFormat.cellSpacing = wTableFormat.hasValue('cellSpacing') ? wTableFormat.cellSpacing : undefined;
        tableFormat.leftIndent = wTableFormat.hasValue('leftIndent') ? wTableFormat.leftIndent : undefined;
        tableFormat.tableAlignment = wTableFormat.hasValue('tableAlignment"') ? wTableFormat.tableAlignment : undefined;
        tableFormat.topMargin = wTableFormat.hasValue('topMargin') ? wTableFormat.topMargin : undefined;
        tableFormat.rightMargin = wTableFormat.hasValue('rightMargin') ? wTableFormat.rightMargin : undefined;
        tableFormat.leftMargin = wTableFormat.hasValue('leftMargin') ? wTableFormat.leftMargin : undefined;
        tableFormat.bottomMargin = wTableFormat.hasValue('bottomMargin') ? wTableFormat.bottomMargin : undefined;
        tableFormat.preferredWidth = wTableFormat.hasValue('preferredWidth') ? wTableFormat.preferredWidth : undefined;
        tableFormat.preferredWidthType = wTableFormat.hasValue('preferredWidthType') ? wTableFormat.preferredWidthType : undefined;
        tableFormat.bidi = wTableFormat.hasValue('bidi') ? wTableFormat.bidi : undefined;
        tableFormat.allowAutoFit = wTableFormat.hasValue('allowAutoFit') ? wTableFormat.allowAutoFit : undefined;
        return tableFormat;
    }
    writeStyles(viewer) {
        this.document.styles = [];
        for (let i = 0; i < viewer.styles.length; i++) {
            this.document.styles.push(this.writeStyle(viewer.styles.getItem(i)));
        }
    }
    writeStyle(style) {
        let wStyle = {};
        wStyle.name = style.name;
        if (style.type === 'Paragraph') {
            wStyle.type = 'Paragraph';
            wStyle.paragraphFormat = this.writeParagraphFormat(style.paragraphFormat);
            wStyle.characterFormat = this.writeCharacterFormat(style.characterFormat);
        }
        if (style.type === 'Character') {
            wStyle.type = 'Character';
            wStyle.characterFormat = this.writeCharacterFormat(style.characterFormat);
        }
        if (!isNullOrUndefined(style.basedOn)) {
            wStyle.basedOn = style.basedOn.name;
        }
        if (!isNullOrUndefined(style.link)) {
            wStyle.link = style.link.name;
        }
        if (!isNullOrUndefined(style.next)) {
            wStyle.next = style.next.name;
        }
        return wStyle;
    }
    writeComments(viewer) {
        this.document.comments = [];
        for (let i = 0; i < viewer.comments.length; i++) {
            this.document.comments.push(this.writeComment(viewer.comments[i]));
        }
    }
    writeComment(comments) {
        let comment = {};
        comment.commentId = comments.commentId;
        comment.author = comments.author;
        comment.date = comments.date;
        comment.blocks = [];
        comment.blocks.push(this.commentInlines(comments.text));
        comment.done = comments.isResolved;
        comment.replyComments = [];
        for (let i = 0; i < comments.replyComments.length; i++) {
            comment.replyComments.push(this.writeComment(comments.replyComments[i]));
        }
        return comment;
    }
    commentInlines(ctext) {
        let blocks = {};
        blocks.inlines = [{ text: ctext }];
        return blocks;
    }
    writeLists(viewer) {
        let abstractLists = [];
        this.document.lists = [];
        for (let i = 0; i < viewer.lists.length; i++) {
            let list = viewer.lists[i];
            if (this.lists.indexOf(list.listId) > -1) {
                this.document.lists.push(this.writeList(list));
                if (abstractLists.indexOf(list.abstractListId) < 0) {
                    abstractLists.push(list.abstractListId);
                }
            }
        }
        this.document.abstractLists = [];
        for (let i = 0; i < viewer.abstractLists.length; i++) {
            let abstractList = viewer.abstractLists[i];
            if (abstractLists.indexOf(abstractList.abstractListId) > -1) {
                this.document.abstractLists.push(this.writeAbstractList(abstractList));
            }
        }
    }
    writeAbstractList(wAbstractList) {
        let abstractList = {};
        abstractList.abstractListId = wAbstractList.abstractListId;
        abstractList.levels = [];
        for (let i = 0; i < wAbstractList.levels.length; i++) {
            abstractList.levels[i] = this.writeListLevel(wAbstractList.levels[i]);
        }
        return abstractList;
    }
    writeList(wList) {
        let list = {};
        list.abstractListId = wList.abstractListId;
        //list.levelOverrides = wList.levelOverrides;
        list.listId = wList.listId;
        return list;
    }
    writeListLevel(wListLevel) {
        let listLevel = {};
        listLevel.characterFormat = this.writeCharacterFormat(wListLevel.characterFormat);
        listLevel.paragraphFormat = this.writeParagraphFormat(wListLevel.paragraphFormat);
        listLevel.followCharacter = wListLevel.followCharacter;
        listLevel.listLevelPattern = wListLevel.listLevelPattern;
        listLevel.numberFormat = wListLevel.numberFormat;
        listLevel.restartLevel = wListLevel.restartLevel;
        listLevel.startAt = wListLevel.startAt;
        return listLevel;
    }
    /**
     * @private
     */
    destroy() {
        this.lists = undefined;
        this.endLine = undefined;
        this.endOffset = undefined;
        this.viewer = undefined;
    }
}

/**
 * Export Export
 */

/**
 * The Hyperlink dialog is used to insert or edit hyperlink at selection.
 */
/* tslint:disable:max-line-length */
class HyperlinkDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.displayText = '';
        this.navigationUrl = undefined;
        this.bookmarkDropdown = undefined;
        this.bookmarkCheckbox = undefined;
        this.bookmarks = [];
        /**
         * @private
         */
        this.onKeyUpOnUrlBox = (event) => {
            if (event.keyCode === 13) {
                if (this.displayTextBox.value !== '' && this.urlTextBox.value !== '') {
                    this.onInsertHyperlink();
                }
                return;
            }
            let selectedText = this.owner.selection.text;
            let urlValue = this.urlTextBox.value;
            if (urlValue.substring(0, 4).toLowerCase() === 'www.') {
                this.urlTextBox.value = 'http://' + urlValue;
            }
            if (this.displayText === '') {
                this.displayTextBox.value = urlValue;
            }
            this.enableOrDisableInsertButton();
        };
        /**
         * @private
         */
        this.onKeyUpOnDisplayBox = () => {
            this.displayText = this.displayTextBox.value;
            this.enableOrDisableInsertButton();
        };
        /**
         * @private
         */
        this.onInsertButtonClick = () => {
            this.onInsertHyperlink();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.clearValue();
        };
        /**
         * @private
         */
        this.loadHyperlinkDialog = () => {
            this.owner.updateFocus();
            this.bookmarks = [];
            for (let i = 0; i < this.owner.bookmarks.keys.length; i++) {
                let bookmark = this.owner.bookmarks.keys[i];
                if (bookmark.indexOf('_') !== 0) {
                    this.bookmarks.push(bookmark);
                }
            }
            let fieldBegin = this.owner.selection.getHyperlinkField();
            if (!isNullOrUndefined(fieldBegin)) {
                if (!isNullOrUndefined(fieldBegin.fieldSeparator)) {
                    let format = undefined;
                    // tslint:disable-next-line:max-line-length
                    let fieldObj = this.owner.selection.getHyperlinkDisplayText(fieldBegin.fieldSeparator.line.paragraph, fieldBegin.fieldSeparator, fieldBegin.fieldEnd, false, format);
                    this.displayText = fieldObj.displayText;
                    this.displayTextBox.disabled = fieldObj.isNestedField;
                }
                this.displayTextBox.value = this.displayText;
                let link = this.owner.selection.getLinkText(fieldBegin);
                this.urlTextBox.value = this.navigationUrl = link;
                this.owner.dialog.header = this.localObj.getConstant('Edit Hyperlink');
            }
            else {
                this.displayText = this.owner.selection.getText(true);
                if (this.displayText !== '') {
                    if (this.displayText.indexOf(String.fromCharCode(65532)) !== -1 ||
                        this.displayText.indexOf('\r') !== -1 && (this.displayText.lastIndexOf('\r') !== -1 &&
                            this.displayText.slice(0, -1).indexOf('\r') !== -1)) {
                        this.displayTextBox.value = '<<Selection in document>>';
                        this.displayTextBox.disabled = true;
                    }
                    else {
                        this.displayTextBox.value = this.displayText;
                    }
                }
            }
            this.bookmarkDiv.style.display = 'none';
            this.addressText.style.display = 'block';
            this.urlTextBox.style.display = 'block';
            this.bookmarkCheckbox.checked = false;
            this.bookmarkDropdown.dataSource = this.owner.bookmarks.keys;
            this.insertButton = document.getElementsByClassName('e-hyper-insert')[0];
            this.enableOrDisableInsertButton();
            this.urlTextBox.focus();
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
        };
        /**
         * @private
         */
        this.closeHyperlinkDialog = () => {
            this.clearValue();
            this.owner.updateFocus();
        };
        /* tslint:disable:no-any */
        this.onUseBookmarkChange = (args) => {
            if (args.checked) {
                this.bookmarkDiv.style.display = 'block';
                this.bookmarkDropdown.dataSource = this.bookmarks;
                this.addressText.style.display = 'none';
                this.urlTextBox.style.display = 'none';
            }
            else {
                this.bookmarkDiv.style.display = 'none';
                this.addressText.style.display = 'block';
                this.urlTextBox.style.display = 'block';
            }
        };
        this.onBookmarkchange = (args) => {
            if (this.bookmarkDropdown.value !== '') {
                this.insertButton.disabled = false;
            }
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'HyperlinkDialog';
    }
    /**
     * @private
     */
    initHyperlinkDialog(localValue, isRtl) {
        let instance = this;
        let id = this.owner.owner.containerId + '_insert_hyperlink';
        this.target = createElement('div', { id: id, className: 'e-de-hyperlink' });
        let container = createElement('div');
        let displayText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Text to display') });
        this.displayTextBox = createElement('input', { id: this.owner.owner.containerId + '_display_text', className: 'e-input e-de-hyperlink-dlg-input' });
        this.displayTextBox.addEventListener('keyup', instance.onKeyUpOnDisplayBox);
        container.appendChild(displayText);
        container.appendChild(this.displayTextBox);
        this.addressText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Address') });
        this.urlTextBox = createElement('input', { id: this.owner.owner.containerId + '_url_text', className: 'e-input e-de-hyperlink-dlg-input', attrs: { autofocus: 'true' } });
        this.urlTextBox.addEventListener('input', instance.onKeyUpOnUrlBox);
        this.urlTextBox.addEventListener('keyup', instance.onKeyUpOnUrlBox);
        container.appendChild(this.addressText);
        container.appendChild(this.urlTextBox);
        this.bookmarkDiv = createElement('div', { styles: 'display:none;' });
        let bookmarkText = createElement('div', { className: 'e-de-hyperlink-dlg-title', innerHTML: localValue.getConstant('Bookmark') });
        let bookmarkTextElement = createElement('div', { className: 'e-de-hyperlink-dlg-bookmark' });
        // tslint:disable-next-line:max-line-length
        let bookmarkValue = createElement('input', { id: 'e-de-hyperlink-dlg-bookmark-value' });
        bookmarkTextElement.appendChild(bookmarkValue);
        // tslint:disable-next-line:max-line-length
        this.bookmarkDropdown = new DropDownList({ dataSource: [], change: this.onBookmarkchange, popupHeight: '230px', width: '230px', noRecordsTemplate: localValue.getConstant('No bookmarks found') });
        this.bookmarkDropdown.appendTo(bookmarkValue);
        this.bookmarkDiv.appendChild(bookmarkText);
        this.bookmarkDiv.appendChild(bookmarkTextElement);
        container.appendChild(this.bookmarkDiv);
        // tslint:disable-next-line:max-line-length
        let bookmarkCheckDiv = createElement('div', { className: 'e-de-hyperlink-bookmark-check e-de-hyperlink-dlg-title' });
        let bookmarkCheck = createElement('input', { attrs: { type: 'checkbox' }, id: this.target.id + '_bookmark', className: this.target.id + '_bookmarkcheck' });
        bookmarkCheckDiv.appendChild(bookmarkCheck);
        this.bookmarkCheckbox = new CheckBox({
            label: localValue.getConstant('Use bookmarks'),
            enableRtl: isRtl, change: this.onUseBookmarkChange
        });
        this.bookmarkCheckbox.appendTo(bookmarkCheck);
        container.appendChild(bookmarkCheckDiv);
        this.target.appendChild(container);
    }
    /**
     * @private
     */
    show() {
        this.localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.localObj.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initHyperlinkDialog(this.localObj, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = this.localObj.getConstant('Insert Hyperlink');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.buttons = [{
                click: this.onInsertButtonClick,
                buttonModel: { content: this.localObj.getConstant('Ok'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: this.localObj.getConstant('Cancel'), cssClass: 'e-flat e-hyper-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.beforeOpen = this.loadHyperlinkDialog;
        this.owner.dialog.close = this.closeHyperlinkDialog;
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    hide() {
        this.closeHyperlinkDialog();
    }
    enableOrDisableInsertButton() {
        if (!isNullOrUndefined(this.insertButton)) {
            // tslint:disable-next-line:max-line-length
            this.insertButton.disabled = (this.urlTextBox.value === '' || this.displayTextBox.value === '');
        }
    }
    /**
     * @private
     */
    onInsertHyperlink() {
        let displayText = this.displayTextBox.value.trim();
        let address = this.urlTextBox.value.trim();
        let isBookmark = false;
        if (!isNullOrUndefined(this.bookmarkDropdown.value) && this.bookmarkDropdown.value !== '') {
            address = this.bookmarkDropdown.value;
            isBookmark = true;
        }
        if (address === '') {
            this.owner.dialog.hide();
            return;
        }
        if (displayText === '' && address !== '') {
            displayText = address;
        }
        else {
            displayText = this.displayTextBox.value;
        }
        if (!isNullOrUndefined(this.navigationUrl)) {
            this.owner.owner.editorModule.editHyperlink(this.owner.selection, address, displayText, isBookmark);
        }
        else {
            let remove = this.owner.selection.text !== displayText && !this.displayTextBox.disabled;
            this.owner.owner.editorModule.insertHyperlinkInternal(address, displayText, remove, isBookmark);
        }
        this.owner.dialog.hide();
        this.navigationUrl = undefined;
    }
    /* tslint:enable:no-any */
    /**
     * @private
     */
    clearValue() {
        this.displayTextBox.value = '';
        this.urlTextBox.value = '';
        this.displayText = '';
        this.displayTextBox.disabled = false;
        this.bookmarks = [];
    }
    /**
     * @private
     */
    destroy() {
        if (this.displayTextBox) {
            this.displayTextBox.innerHTML = '';
            this.displayTextBox = undefined;
        }
        if (this.urlTextBox) {
            this.urlTextBox.parentElement.removeChild(this.urlTextBox);
            this.urlTextBox = undefined;
        }
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            this.target.innerHTML = '';
            this.target = undefined;
        }
    }
}

/**
 * The Table dialog is used to insert table at selection.
 */
class TableDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.keyUpInsertTable = (event) => {
            if (event.keyCode === 13) {
                if (this.rowsCountBox.value !== '' && this.columnsCountBox.value !== '') {
                    this.onInsertTableClick();
                }
            }
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.onInsertTableClick = () => {
            let rowCount = this.rowValueTextBox.value;
            let columnCount = this.columnValueTexBox.value;
            if (!(isNullOrUndefined(rowCount) && isNullOrUndefined(columnCount))) {
                this.owner.owner.editor.insertTable(rowCount, columnCount);
            }
            this.owner.dialog.hide();
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'TableDialog';
    }
    /**
     * @private
     */
    initTableDialog(localValue) {
        let instance = this;
        let id = this.owner.owner.containerId + '_insert_Table';
        this.target = createElement('div', { id: id, className: 'e-de-insert-table' });
        let parentDiv = createElement('div');
        let columnContainer = createElement('div', {
            className: 'e-de-insert-table-dlg-sub-header', innerHTML: localValue.getConstant('Number of columns')
        });
        let columnValue = createElement('div', { className: 'e-de-insert-table-dlg-input' });
        this.columnsCountBox = createElement('input', {
            attrs: { type: 'text' }, id: this.owner.owner.containerId + '_column'
        });
        columnValue.appendChild(this.columnsCountBox);
        let rowContainer = createElement('div', {
            className: 'e-de-insert-table-dlg-sub-header', innerHTML: localValue.getConstant('Number of rows')
        });
        let rowValue = createElement('div');
        this.rowsCountBox = createElement('input', {
            attrs: { type: 'text' }, id: this.owner.owner.containerId + 'row'
        });
        rowValue.appendChild(this.rowsCountBox);
        parentDiv.appendChild(columnContainer);
        parentDiv.appendChild(columnValue);
        parentDiv.appendChild(rowContainer);
        parentDiv.appendChild(rowValue);
        this.target.appendChild(parentDiv);
        this.columnsCountBox.addEventListener('keyup', instance.keyUpInsertTable);
        this.rowsCountBox.addEventListener('keyup', instance.keyUpInsertTable);
        this.rowValueTextBox = new NumericTextBox({
            format: '#',
            value: 2,
            min: 1,
            max: 32767,
            enablePersistence: false
        });
        this.rowValueTextBox.appendTo(this.rowsCountBox);
        this.columnValueTexBox = new NumericTextBox({
            format: '#',
            value: 2,
            min: 1,
            max: 63,
            enablePersistence: false
        });
        this.columnValueTexBox.appendTo(this.columnsCountBox);
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTableDialog(localValue);
        }
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog.header = localValue.getConstant('Insert Table');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.onInsertTableClick,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-table-ok', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-table-cancel' }
            }];
        this.rowValueTextBox.value = 2;
        this.columnValueTexBox.value = 2;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    destroy() {
        if (this.columnsCountBox) {
            if (this.columnsCountBox.parentElement) {
                this.columnsCountBox.parentElement.removeChild(this.columnsCountBox);
            }
            this.columnsCountBox = undefined;
        }
        if (this.rowsCountBox) {
            if (this.rowsCountBox.parentElement) {
                this.rowsCountBox.parentElement.removeChild(this.rowsCountBox);
            }
            this.rowsCountBox = undefined;
        }
        if (this.columnValueTexBox) {
            this.columnValueTexBox.destroy();
            this.columnValueTexBox = undefined;
        }
        if (this.rowValueTextBox) {
            this.rowValueTextBox.destroy();
            this.rowValueTextBox = undefined;
        }
        this.columnsCountBox = undefined;
        this.rowsCountBox = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let i = 0; i < this.target.childNodes.length; i++) {
                this.target.removeChild(this.target.childNodes[i]);
                i--;
            }
            this.target = undefined;
        }
    }
}

/**
 * The Bookmark dialog is used to add, navigate or delete bookmarks.
 */
class BookmarkDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.onKeyUpOnTextBox = (event) => {
            this.enableOrDisableButton();
        };
        this.addBookmark = () => {
            this.owner.owner.editorModule.insertBookmark(this.textBoxInput.value);
            this.owner.dialog.hide();
        };
        /* tslint:disable:no-any */
        this.selectHandler = (args) => {
            this.focusTextBox(args.text);
        };
        this.gotoBookmark = () => {
            this.owner.selection.selectBookmark(this.textBoxInput.value);
        };
        this.deleteBookmark = () => {
            this.owner.owner.editorModule.deleteBookmark(this.textBoxInput.value);
            this.show();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'BookmarkDialog';
    }
    /**
     * @private
     */
    initBookmarkDialog(localValue, bookmarks, isRtl) {
        let id = this.owner.owner.containerId + '_insert_bookmark';
        this.target = createElement('div', { id: id, className: 'e-de-bookmark' });
        let headerValue = localValue.getConstant('Bookmark name') + ':';
        let dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-bookmark-dlgfields' });
        this.target.appendChild(dlgFields);
        let commonDiv = createElement('div', { className: 'e-bookmark-common' });
        this.target.appendChild(commonDiv);
        let searchDiv = createElement('div', { className: 'e-bookmark-list' });
        commonDiv.appendChild(searchDiv);
        if (isRtl) {
            searchDiv.classList.add('e-de-rtl');
        }
        let textBoxDiv = createElement('div', { className: 'e-bookmark-textboxdiv' });
        searchDiv.appendChild(textBoxDiv);
        // tslint:disable-next-line:max-line-length
        this.textBoxInput = createElement('input', { className: 'e-input e-bookmark-textbox-input', id: 'bookmark_text_box', attrs: { autofocus: 'true' } });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        let listviewDiv = createElement('div', { className: 'e-bookmark-listViewDiv', id: 'bookmark_listview' });
        searchDiv.appendChild(listviewDiv);
        let arts = this.owner.bookmarks.keys;
        this.listviewInstance = new ListView({
            dataSource: bookmarks,
            cssClass: 'e-bookmark-listview',
        });
        let hasNoBookmark = (bookmarks === undefined || bookmarks.length === 0);
        this.listviewInstance.appendTo(listviewDiv);
        this.listviewInstance.addEventListener('select', this.selectHandler);
        let buttonDiv = createElement('div', { className: 'e-bookmark-button' });
        commonDiv.appendChild(buttonDiv);
        let addbuttonDiv = createElement('div', { className: 'e-bookmark-addbutton' });
        buttonDiv.appendChild(addbuttonDiv);
        let addButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Add'), id: 'add',
            attrs: { type: 'button' }
        });
        addbuttonDiv.appendChild(addButtonElement);
        this.addButton = new Button({ cssClass: 'e-button-custom' });
        this.addButton.disabled = true;
        this.addButton.appendTo(addButtonElement);
        this.textBoxInput.addEventListener('input', this.onKeyUpOnTextBox);
        this.textBoxInput.addEventListener('keyup', this.onKeyUpOnTextBox);
        addButtonElement.addEventListener('click', this.addBookmark);
        let deleteButtonDiv = createElement('div', { className: 'e-bookmark-deletebutton' });
        buttonDiv.appendChild(deleteButtonDiv);
        let deleteButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Delete'), id: 'delete',
            attrs: { type: 'button' }
        });
        deleteButtonDiv.appendChild(deleteButtonElement);
        this.deleteButton = new Button({ cssClass: 'e-button-custom' });
        this.deleteButton.disabled = hasNoBookmark;
        this.deleteButton.appendTo(deleteButtonElement);
        deleteButtonElement.addEventListener('click', this.deleteBookmark);
        let gotoButtonDiv = createElement('div', { className: 'e-bookmark-gotobutton' });
        buttonDiv.appendChild(gotoButtonDiv);
        let gotoButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Go To'), id: 'goto',
            attrs: { type: 'button' }
        });
        gotoButtonDiv.appendChild(gotoButtonElement);
        this.gotoButton = new Button({ cssClass: 'e-button-custom' });
        this.gotoButton.disabled = hasNoBookmark;
        this.gotoButton.appendTo(gotoButtonElement);
        gotoButtonElement.addEventListener('click', this.gotoBookmark);
    }
    /**
     * @private
     */
    show() {
        let bookmarks = this.owner.getBookmarks();
        let localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localObj.setLocale(this.owner.owner.locale);
        // if (!this.target) {
        this.initBookmarkDialog(localObj, bookmarks, this.owner.owner.enableRtl);
        //}
        this.owner.dialog.header = localObj.getConstant('Bookmark');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.buttons = [{
                click: this.removeObjects.bind(this),
                buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        let hasNoBookmark = (bookmarks === undefined || bookmarks.length === 0);
        if (!hasNoBookmark) {
            /* tslint:disable:no-any */
            let firstItem = bookmarks[0];
            this.listviewInstance.selectItem(firstItem);
        }
        this.owner.dialog.show();
    }
    enableOrDisableButton() {
        if (!isNullOrUndefined(this.addButton)) {
            // tslint:disable-next-line:max-line-length
            this.addButton.disabled = (this.textBoxInput.value === '');
        }
    }
    /* tslint:disable:no-any */
    focusTextBox(text) {
        this.textBoxInput.value = text;
        /* tslint:disable:no-any */
        let value = document.getElementById('bookmark_text_box');
        value.setSelectionRange(0, text.length);
        value.focus();
        this.enableOrDisableButton();
    }
    removeObjects() {
        this.owner.dialog.hide();
    }
    /**
     * @private
     */
    destroy() {
        if (this.textBoxInput) {
            this.textBoxInput.remove();
            this.textBoxInput = undefined;
        }
        if (this.listviewInstance) {
            this.listviewInstance.destroy();
            this.listviewInstance = undefined;
        }
    }
}

/**
 * The Table of contents dialog is used to insert or edit table of contents at selection.
 */
class TableOfContentsDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.styleLocaleValue = (styleLocale, localValue) => {
            let styleName = [];
            for (let index = 0; index < styleLocale.length; index++) {
                styleName.push(localValue.getConstant(styleLocale[index]));
            }
            return styleName;
        };
        /**
         * @private
         */
        this.loadTableofContentDialog = () => {
            this.owner.updateFocus();
            this.pageNumber.checked = true;
            this.rightAlign.disabled = false;
            this.rightAlign.checked = true;
            this.tabLeader.enabled = true;
            this.hyperlink.checked = true;
            this.style.checked = true;
            this.outline.checked = true;
            this.outline.disabled = false;
            this.showLevel.enabled = true;
        };
        /**
         * @private
         */
        this.closeTableOfContentDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /* tslint:disable:no-any */
        this.selectHandler = (args) => {
            this.textBoxInput.value = args.text;
            /* tslint:disable:no-any */
            let value = document.getElementById('toclist');
            value.setSelectionRange(0, args.text.length);
            value.focus();
        };
        this.showStyleDialog = () => {
            if (!isNullOrUndefined(this.owner.owner.styleDialogModule)) {
                this.owner.owner.styleDialogModule.show(this.textBoxInput.value);
            }
        };
        this.changeShowLevelValue = (event) => {
            let levels = event.value;
            let values = [];
            switch (levels) {
                case 1:
                    values = ['1', null, null, null, null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 2:
                    values = ['1', '2', null, null, null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 3:
                    values = ['1', '2', '3', null, null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 4:
                    values = ['1', '2', '3', '4', null, null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 5:
                    values = ['1', '2', '3', '4', '5', null, null, null, null];
                    this.changeByValue(values);
                    break;
                case 6:
                    values = ['1', '2', '3', '4', '5', '6', null, null, null];
                    this.changeByValue(values);
                    break;
                case 7:
                    values = ['1', '2', '3', '4', '5', '6', '7', null, null];
                    this.changeByValue(values);
                    break;
                case 8:
                    values = ['1', '2', '3', '4', '5', '6', '7', '8', null];
                    this.changeByValue(values);
                    break;
                case 9:
                    values = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
                    this.changeByValue(values);
                    break;
            }
        };
        this.changeByValue = (headings) => {
            this.heading1.value = headings[0];
            this.heading2.value = headings[1];
            this.heading3.value = headings[2];
            this.heading4.value = headings[3];
            this.heading5.value = headings[4];
            this.heading6.value = headings[5];
            this.heading7.value = headings[6];
            this.heading8.value = headings[7];
            this.heading9.value = headings[8];
        };
        this.reset = () => {
            this.showLevel.enabled = true;
            this.showLevel.value = 3;
            this.outline.disabled = false;
            this.outline.checked = true;
            let values = ['1', '2', '3', null, null, null, null, null, null];
            this.changeByValue(values);
            this.normal.value = null;
        };
        this.changeStyle = (args) => {
            let headingValue = args.srcElement.value;
            let value = this.getElementValue(args.srcElement);
            if (headingValue !== value && headingValue !== '') {
                this.showLevel.enabled = false;
            }
            else {
                this.showLevel.enabled = true;
                this.checkLevel();
            }
        };
        this.changeHeadingStyle = (args) => {
            let headingValue = args.srcElement.value;
            if (headingValue === '') {
                this.showLevel.enabled = true;
            }
            else {
                this.showLevel.enabled = false;
            }
            if (this.normal === args.srcElement) {
                this.outline.checked = false;
                this.outline.disabled = true;
            }
        };
        /**
         * @private
         */
        this.changePageNumberValue = (args) => {
            if (args.checked) {
                this.rightAlign.checked = true;
                this.rightAlign.disabled = false;
                this.tabLeader.enabled = true;
            }
            else {
                this.rightAlign.disabled = true;
                this.tabLeader.enabled = false;
            }
        };
        /**
         * @private
         */
        this.changeRightAlignValue = (args) => {
            if (args.checked) {
                this.tabLeader.enabled = true;
            }
            else {
                this.tabLeader.enabled = false;
            }
        };
        /**
         * @private
         */
        this.changeStyleValue = (args) => {
            if (args.checked) {
                this.heading1.disabled = false;
                this.heading2.disabled = false;
                this.heading3.disabled = false;
                this.heading4.disabled = false;
                this.heading5.disabled = false;
                this.heading6.disabled = false;
                this.heading7.disabled = false;
                this.heading8.disabled = false;
                this.heading9.disabled = false;
                this.normal.disabled = false;
            }
            else {
                this.heading1.disabled = true;
                this.heading2.disabled = true;
                this.heading3.disabled = true;
                this.heading4.disabled = true;
                this.heading5.disabled = true;
                this.heading6.disabled = true;
                this.heading7.disabled = true;
                this.heading8.disabled = true;
                this.heading9.disabled = true;
                this.normal.disabled = true;
            }
        };
        /**
         * @private
         */
        this.applyTableOfContentProperties = () => {
            let tocSettings = {
                startLevel: 1,
                endLevel: this.showLevel.value,
                includeHyperlink: this.hyperlink.checked,
                includePageNumber: this.pageNumber.checked,
                rightAlign: this.rightAlign.checked,
                tabLeader: this.tabLeader.value,
                includeOutlineLevels: this.outline.checked
            };
            this.applyLevelSetting(tocSettings);
            this.owner.owner.editorModule.insertTableOfContents(tocSettings);
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.unWireEventsAndBindings = () => {
            this.pageNumber.checked = false;
            this.rightAlign.checked = false;
            this.tabLeader.value = '';
            this.hyperlink.checked = false;
            this.style.checked = false;
            this.outline.checked = false;
            this.normal.value = '';
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'TableOfContentsDialog';
    }
    /*tslint:disable max-func-body-length*/
    /**
     * @private
     */
    initTableOfContentDialog(locale, isRtl) {
        let ownerId = this.owner.owner.containerId;
        let id = ownerId + '_toc_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-toc-dlg-container' });
        // tslint:disable-next-line:max-line-length
        let generalDiv = createElement('div', { id: 'general_div', className: 'e-de-toc-dlg-sub-container' });
        this.target.appendChild(generalDiv);
        // tslint:disable-next-line:max-line-length
        let genLabel = createElement('div', { id: ownerId + '_genLabel', className: 'e-de-toc-dlg-main-heading', styles: 'margin-bottom: 13px;', innerHTML: locale.getConstant('General') });
        generalDiv.appendChild(genLabel);
        let leftGeneralDivStyles;
        let rightBottomGeneralDivStyles;
        if (isRtl) {
            leftGeneralDivStyles = 'float:right;';
            rightBottomGeneralDivStyles = 'float:left;position:relative;';
        }
        else {
            leftGeneralDivStyles = 'float:left;';
            rightBottomGeneralDivStyles = 'float:right;';
        }
        // tslint:disable-next-line:max-line-length
        let topContainer = createElement('div', { id: 'general_top_container', styles: 'display:inline-flex' });
        let leftGeneralDiv = createElement('div', { id: 'left_general', styles: leftGeneralDivStyles + 'position:relative;' });
        topContainer.appendChild(leftGeneralDiv);
        // tslint:disable-next-line:max-line-length
        let rightGeneralDiv = createElement('div', { className: 'e-de-toc-dlg-right-general-div' });
        topContainer.appendChild(rightGeneralDiv);
        generalDiv.appendChild(topContainer);
        // tslint:disable-next-line:max-line-length
        let bottomContainer = createElement('div', { id: 'general_bottom_container', styles: 'display:inline-flex' });
        let leftBottomGeneralDiv = createElement('div', { id: 'leftBottom_general', styles: 'float:left;' });
        bottomContainer.appendChild(leftBottomGeneralDiv);
        // tslint:disable-next-line:max-line-length
        let rightBottomGeneralDiv = createElement('div', { className: 'e-de-toc-dlg-right-sub-container', styles: rightBottomGeneralDivStyles });
        bottomContainer.appendChild(rightBottomGeneralDiv);
        generalDiv.appendChild(bottomContainer);
        // tslint:disable-next-line:max-line-length
        let pageNumberDiv = createElement('div', { id: 'pageNumber_div', className: 'e-de-toc-dlg-sub-container' });
        let pageNumber = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_pageNumber'
        });
        pageNumberDiv.appendChild(pageNumber);
        // tslint:disable-next-line:max-line-length
        let rightAlignDiv = createElement('div', { id: 'rightAlign_div', className: 'e-de-toc-dlg-sub-container' });
        let rightAlign = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_rightAlign'
        });
        rightAlignDiv.appendChild(rightAlign);
        // tslint:disable-next-line:max-line-length
        this.pageNumber = new CheckBox({ label: locale.getConstant('Show page numbers'), enableRtl: isRtl, checked: true, change: this.changePageNumberValue });
        // tslint:disable-next-line:max-line-length
        this.rightAlign = new CheckBox({ label: locale.getConstant('Right align page numbers'), enableRtl: isRtl, checked: true, change: this.changeRightAlignValue });
        this.pageNumber.appendTo(pageNumber);
        this.rightAlign.appendTo(rightAlign);
        let tabDiv = createElement('div', { id: 'tab_div', className: 'e-de-toc-dlg-tab-div' });
        // tslint:disable-next-line:max-line-length
        let tabLeaderLabelDiv = createElement('div', { id: 'tabLeaderLabel_div' });
        // tslint:disable-next-line:max-line-length
        let tabLeaderLabel = createElement('label', { id: ownerId + '_tabLeaderLabel', className: 'e-de-toc-dlg-heading', innerHTML: locale.getConstant('Tab leader') + ':' });
        tabLeaderLabelDiv.appendChild(tabLeaderLabel);
        let tabLeaderDiv = createElement('div', { id: 'tabLeader_div' });
        let tabLeader = createElement('select', {
            id: ownerId + '_tabLeader',
            innerHTML: '<option value="None">' + '(' + locale.getConstant('None').toLocaleLowerCase() + ')' +
                '</option><option value="Dot" selected>' + '....................' +
                '</option><option value="Hyphen">' + '-------------------' +
                '</option><option value="Underscore">' + '____________' + '</option>'
        });
        tabLeaderDiv.appendChild(tabLeader);
        tabDiv.appendChild(tabLeaderLabelDiv);
        tabDiv.appendChild(tabLeaderDiv);
        leftGeneralDiv.appendChild(pageNumberDiv);
        leftGeneralDiv.appendChild(rightAlignDiv);
        leftGeneralDiv.appendChild(tabDiv);
        this.tabLeader = new DropDownList({ width: 210, enableRtl: isRtl });
        this.tabLeader.appendTo(tabLeader);
        let hyperlink = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_hyperlink'
        });
        rightGeneralDiv.appendChild(hyperlink);
        //tslint:disable-next-line:max-line-length
        this.hyperlink = new CheckBox({ label: locale.getConstant('Use hyperlinks instead of page numbers'), cssClass: 'e-de-toc-label', enableRtl: isRtl, checked: true });
        this.hyperlink.appendTo(hyperlink);
        // tslint:disable-next-line:max-line-length
        let showDiv = createElement('div', { id: 'show_div', className: 'e-de-toc-dlg-style-label' });
        // tslint:disable-next-line:max-line-length
        let showLevelLabelDiv = createElement('div', { id: 'showLevelLabel_div', className: 'e-de-toc-dlg-show-level-div' });
        // tslint:disable-next-line:max-line-length
        let showLevelLabel = createElement('label', { id: ownerId + '_showLevelLabel', className: 'e-de-toc-dlg-heading', innerHTML: locale.getConstant('Show levels') + ':' });
        showLevelLabelDiv.appendChild(showLevelLabel);
        // tslint:disable-next-line:max-line-length
        let showLevelDiv = createElement('div', { id: 'showLevel_div', className: 'e-de-toc-dlg-showlevel-div' });
        // tslint:disable-next-line:max-line-length
        let showLevel = createElement('input', { id: ownerId + '_showLevel', attrs: { 'type': 'text' } });
        showLevelDiv.appendChild(showLevel);
        showDiv.appendChild(showLevelLabelDiv);
        showDiv.appendChild(showLevelDiv);
        rightGeneralDiv.appendChild(showDiv);
        this.showLevel = new NumericTextBox({ format: '#', value: 3, min: 1, max: 9, width: 210, change: this.changeShowLevelValue });
        this.showLevel.appendTo(showLevel);
        if (isRtl) {
            this.hyperlink.cssClass = 'e-de-toc-label-rtl';
            showLevelLabelDiv.classList.add('e-de-rtl');
            showLevelDiv.classList.add('e-de-rtl');
            rightBottomGeneralDiv.classList.add('e-de-rtl');
        }
        // tslint:disable-next-line:max-line-length
        let buildTableDiv = createElement('div', { id: 'buildTable_div', className: 'e-de-toc-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        let buildTableLabel = createElement('div', { id: ownerId + '_buildTableLabel', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-build-table', styles: 'margin-bottom: 13px;', innerHTML: locale.getConstant('Build table of contents from') + ':' });
        leftBottomGeneralDiv.appendChild(buildTableDiv);
        leftBottomGeneralDiv.appendChild(buildTableLabel);
        let style = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_style',
        });
        leftBottomGeneralDiv.appendChild(style);
        this.style = new CheckBox({ label: locale.getConstant('Styles'), enableRtl: isRtl, checked: true, change: this.changeStyleValue });
        this.style.appendTo(style);
        let table = createElement('TABLE', { styles: 'margin-top:3px;' });
        let tr1 = createElement('tr');
        let td1 = createElement('td', { styles: 'width:120px;padding-left:10px;' });
        let availableLabel = createElement('label', {
            // tslint:disable-next-line:max-line-length
            innerHTML: locale.getConstant('Available styles'), className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-sub-level-heading', id: this.target.id + '_availableLabel'
        });
        td1.appendChild(availableLabel);
        let td2 = createElement('td');
        let tocLabel = createElement('label', {
            innerHTML: locale.getConstant('TOC level') + ':', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-sub-level-heading',
            id: this.target.id + '_tocLabel'
        });
        td2.appendChild(tocLabel);
        tr1.appendChild(td1);
        tr1.appendChild(td2);
        table.appendChild(tr1);
        // tslint:disable-next-line:max-line-length
        let tableDiv = createElement('div', { id: 'table_div', className: 'e-de-toc-table-div' });
        let table1 = createElement('TABLE');
        let tr2 = createElement('tr');
        let td3 = createElement('td');
        let heading1Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 1',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading1Label'
        });
        td3.appendChild(heading1Label);
        let td4 = createElement('td');
        this.heading1 = createElement('input', { id: '_heading1', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading1.value = '1';
        this.heading1.addEventListener('keyup', this.changeStyle);
        td4.appendChild(this.heading1);
        tr2.appendChild(td3);
        tr2.appendChild(td4);
        let tr3 = createElement('tr');
        let td5 = createElement('td');
        let heading2Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 2',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading2Label'
        });
        td5.appendChild(heading2Label);
        let td6 = createElement('td');
        this.heading2 = createElement('input', { id: '_heading2', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading2.value = '2';
        this.heading2.addEventListener('keyup', this.changeStyle);
        td6.appendChild(this.heading2);
        tr3.appendChild(td5);
        tr3.appendChild(td6);
        let tr4 = createElement('tr');
        let td7 = createElement('td');
        let heading3Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 3',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading3Label'
        });
        td7.appendChild(heading3Label);
        let td8 = createElement('td');
        this.heading3 = createElement('input', { id: '_heading3', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading3.value = '3';
        this.heading3.addEventListener('keyup', this.changeStyle);
        td8.appendChild(this.heading3);
        tr4.appendChild(td7);
        tr4.appendChild(td8);
        let tr5 = createElement('tr');
        let td9 = createElement('td');
        let heading4Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 4',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading4Label'
        });
        td9.appendChild(heading4Label);
        let td10 = createElement('td');
        this.heading4 = createElement('input', { id: '_heading4', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading4.addEventListener('keyup', this.changeStyle);
        td10.appendChild(this.heading4);
        tr5.appendChild(td9);
        tr5.appendChild(td10);
        let tr6 = createElement('tr');
        let td11 = createElement('td');
        let heading5Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 5',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading5Label'
        });
        td11.appendChild(heading5Label);
        let td12 = createElement('td');
        this.heading5 = createElement('input', { id: '_heading5', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading5.addEventListener('keyup', this.changeStyle);
        td12.appendChild(this.heading5);
        tr6.appendChild(td11);
        tr6.appendChild(td12);
        let tr7 = createElement('tr');
        let td13 = createElement('td');
        let heading6Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 6',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading6Label'
        });
        td13.appendChild(heading6Label);
        let td14 = createElement('td');
        this.heading6 = createElement('input', { id: '_heading6', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading6.addEventListener('keyup', this.changeStyle);
        td14.appendChild(this.heading6);
        tr7.appendChild(td13);
        tr7.appendChild(td14);
        let tr8 = createElement('tr');
        let td15 = createElement('td');
        let heading7Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 7',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading7Label'
        });
        td15.appendChild(heading7Label);
        let td16 = createElement('td');
        this.heading7 = createElement('input', { id: '_heading7', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading7.addEventListener('keyup', this.changeStyle);
        td16.appendChild(this.heading7);
        tr8.appendChild(td15);
        tr8.appendChild(td16);
        let tr9 = createElement('tr');
        let td17 = createElement('td');
        let heading8Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 8',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading8Label'
        });
        td17.appendChild(heading8Label);
        let td18 = createElement('td');
        this.heading8 = createElement('input', { id: '_heading8', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading8.addEventListener('keyup', this.changeStyle);
        td18.appendChild(this.heading8);
        tr9.appendChild(td17);
        tr9.appendChild(td18);
        let tr10 = createElement('tr');
        let td19 = createElement('td');
        let heading9Label = createElement('label', {
            innerHTML: locale.getConstant('Heading') + ' 9',
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_heading9Label'
        });
        td19.appendChild(heading9Label);
        let td20 = createElement('td');
        this.heading9 = createElement('input', { id: '_heading9', className: 'e-input e-de-toc-dlg-toc-level' });
        this.heading9.addEventListener('keyup', this.changeStyle);
        td20.appendChild(this.heading9);
        tr10.appendChild(td19);
        tr10.appendChild(td20);
        let tr12 = createElement('tr');
        let td23 = createElement('td');
        let normalLabel = createElement('label', {
            innerHTML: locale.getConstant('Normal'),
            className: 'e-de-toc-dlg-sub-heading', id: this.target.id + '_normalLabel'
        });
        td23.appendChild(normalLabel);
        let td24 = createElement('td');
        this.normal = createElement('input', { id: '_normal', className: 'e-input e-de-toc-dlg-toc-level' });
        this.normal.addEventListener('keyup', this.changeHeadingStyle);
        td24.appendChild(this.normal);
        tr12.appendChild(td23);
        tr12.appendChild(td24);
        if (isRtl) {
            this.normal.classList.add('e-de-rtl');
            this.heading1.classList.add('e-de-rtl');
            this.heading2.classList.add('e-de-rtl');
            this.heading3.classList.add('e-de-rtl');
            this.heading4.classList.add('e-de-rtl');
            this.heading5.classList.add('e-de-rtl');
            this.heading6.classList.add('e-de-rtl');
            this.heading7.classList.add('e-de-rtl');
            this.heading8.classList.add('e-de-rtl');
            this.heading9.classList.add('e-de-rtl');
        }
        table1.appendChild(tr2);
        table1.appendChild(tr3);
        table1.appendChild(tr4);
        table1.appendChild(tr5);
        table1.appendChild(tr6);
        table1.appendChild(tr7);
        table1.appendChild(tr8);
        table1.appendChild(tr9);
        table1.appendChild(tr10);
        table1.appendChild(tr12);
        tableDiv.appendChild(table1);
        let stylesLevelDiv = createElement('div', { className: 'e-de-toc-styles-table-div' });
        stylesLevelDiv.appendChild(table);
        stylesLevelDiv.appendChild(tableDiv);
        leftBottomGeneralDiv.appendChild(stylesLevelDiv);
        //leftBottomGeneralDiv.appendChild(table); leftBottomGeneralDiv.appendChild(tableDiv);
        let fieldsDiv = createElement('div', { id: 'fields_div', styles: 'display: flex;' });
        leftBottomGeneralDiv.appendChild(fieldsDiv);
        let outDiv = createElement('div', { id: 'out_div' });
        // tslint:disable-next-line:max-line-length
        let outlineDiv = createElement('div', { id: 'outline_div', className: 'e-de-toc-dlg-sub-container e-de-toc-dlg-outline-levels' });
        let outline = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: '_outline'
        });
        outlineDiv.appendChild(outline);
        outDiv.appendChild(outlineDiv);
        fieldsDiv.appendChild(outDiv);
        this.outline = new CheckBox({
            label: locale.getConstant('Outline levels'),
            enableRtl: isRtl, checked: true, cssClass: 'e-de-outline-rtl'
        });
        this.outline.appendTo(outline);
        let resetButtonDiv = createElement('div', { className: 'e-de-toc-reset-button' });
        fieldsDiv.appendChild(resetButtonDiv);
        let resetElement = createElement('button', {
            innerHTML: locale.getConstant('Reset'), id: 'reset',
            attrs: { type: 'button' }
        });
        resetButtonDiv.appendChild(resetElement);
        let resetButton = new Button({ cssClass: 'e-btn e-flat' });
        resetButton.appendTo(resetElement);
        resetElement.addEventListener('click', this.reset);
        // tslint:disable-next-line:max-line-length
        let tocStylesDiv = createElement('div', { id: 'tocStyles_div', className: 'e-de-toc-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        let tocStylesLabel = createElement('div', {
            id: ownerId + '_tocStylesLabel', className: 'e-de-toc-dlg-main-heading e-de-toc-dlg-styles',
            innerHTML: locale.getConstant('Styles') + ':'
        });
        rightBottomGeneralDiv.appendChild(tocStylesDiv);
        rightBottomGeneralDiv.appendChild(tocStylesLabel);
        let textBoxDiv = createElement('div', { className: 'e-de-toc-dlg-style-input' });
        rightBottomGeneralDiv.appendChild(textBoxDiv);
        this.textBoxInput = createElement('input', { className: 'e-input', id: 'toclist' });
        this.textBoxInput.setAttribute('type', 'text');
        textBoxDiv.appendChild(this.textBoxInput);
        let listViewDiv = createElement('div', { className: 'e-de-toc-list-view' });
        let styleLocale = ['TOC 1', 'TOC 2', 'TOC 3', 'TOC 4', 'TOC 5', 'TOC 6', 'TOC 7', 'TOC 8', 'TOC 9'];
        let styleValues = this.styleLocaleValue(styleLocale, locale);
        this.listViewInstance = new ListView({ dataSource: styleValues, cssClass: 'e-toc-list-view' });
        this.listViewInstance.appendTo(listViewDiv);
        this.listViewInstance.addEventListener('select', this.selectHandler);
        rightBottomGeneralDiv.appendChild(listViewDiv);
        let modifyButtonDiv = createElement('div', { className: 'e-de-toc-modify-button' });
        rightBottomGeneralDiv.appendChild(modifyButtonDiv);
        let modifyElement = createElement('button', {
            innerHTML: locale.getConstant('Modify'), id: 'modify',
            attrs: { type: 'button' }
        });
        modifyButtonDiv.appendChild(modifyElement);
        let modifyButton = new Button({ cssClass: 'e-btn e-flat' });
        modifyButton.appendTo(modifyElement);
        modifyElement.addEventListener('click', this.showStyleDialog);
        if (isRtl) {
            resetButtonDiv.classList.add('e-de-rtl');
            tocStylesLabel.classList.add('e-de-rtl');
            textBoxDiv.classList.add('e-de-rtl');
            listViewDiv.classList.add('e-de-rtl');
            modifyButtonDiv.classList.add('e-de-rtl');
        }
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTableOfContentDialog(localValue, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = localValue.getConstant('Table of Contents');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadTableofContentDialog;
        this.owner.dialog.close = this.closeTableOfContentDialog;
        this.owner.dialog.buttons = [{
                click: this.applyTableOfContentProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-toc-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-toc-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    checkLevel() {
        if (this.heading1.value !== '') {
            this.showLevel.value = 1;
        }
        if (this.heading2.value !== '') {
            this.showLevel.value = 2;
        }
        if (this.heading3.value !== '') {
            this.showLevel.value = 3;
        }
        if (this.heading4.value !== '') {
            this.showLevel.value = 4;
        }
        if (this.heading5.value !== '') {
            this.showLevel.value = 5;
        }
        if (this.heading6.value !== '') {
            this.showLevel.value = 6;
        }
        if (this.heading7.value !== '') {
            this.showLevel.value = 7;
        }
        if (this.heading8.value !== '') {
            this.showLevel.value = 8;
        }
        if (this.heading9.value !== '') {
            this.showLevel.value = 9;
        }
    }
    getElementValue(element) {
        switch (element) {
            case this.heading1:
                return '1';
            case this.heading2:
                return '2';
            case this.heading3:
                return '3';
            case this.heading4:
                return '4';
            case this.heading5:
                return '5';
            case this.heading6:
                return '6';
            case this.heading7:
                return '7';
            case this.heading8:
                return '8';
            case this.heading9:
                return '9';
            default:
                return '1';
        }
    }
    getHeadingLevel(index) {
        switch (index) {
            case 1:
                return parseInt(this.heading1.value);
            case 2:
                return parseInt(this.heading2.value);
            case 3:
                return parseInt(this.heading3.value);
            case 4:
                return parseInt(this.heading4.value);
            case 5:
                return parseInt(this.heading5.value);
            case 6:
                return parseInt(this.heading6.value);
            case 7:
                return parseInt(this.heading7.value);
            case 8:
                return parseInt(this.heading8.value);
            case 9:
                return parseInt(this.heading9.value);
            default:
                return 0;
        }
    }
    applyLevelSetting(tocSettings) {
        tocSettings.levelSettings = {};
        let headingPrefix = 'Heading ';
        let newStartLevel = 0;
        let newEndLevel = 0;
        let isEndLevel = false;
        for (let i = 1; i <= tocSettings.endLevel; i++) {
            let outlineLevel = this.getHeadingLevel(i);
            if (i === outlineLevel) {
                if (newStartLevel === 0) {
                    newStartLevel = i;
                    isEndLevel = false;
                }
                if (!isEndLevel) {
                    newEndLevel = i;
                }
            }
            else {
                isEndLevel = true;
                if (outlineLevel !== 0) {
                    let headingStyle = headingPrefix + i.toString();
                    tocSettings.levelSettings[headingStyle] = outlineLevel;
                }
            }
        }
        tocSettings.startLevel = newStartLevel;
        tocSettings.endLevel = newEndLevel;
        if (this.normal.value !== '') {
            tocSettings.levelSettings['Normal'] = +this.normal.value;
        }
    }
    /**
     * @private
     */
    destroy() {
        if (this.pageNumber) {
            this.pageNumber.destroy();
            this.pageNumber = undefined;
        }
        if (this.rightAlign) {
            this.rightAlign.destroy();
            this.rightAlign = undefined;
        }
        if (this.tabLeader) {
            this.tabLeader.destroy();
            this.tabLeader = undefined;
        }
        if (this.showLevel) {
            this.showLevel.destroy();
            this.showLevel = undefined;
        }
        if (this.hyperlink) {
            this.hyperlink.destroy();
            this.hyperlink = undefined;
        }
        if (this.style) {
            this.style.destroy();
            this.style = undefined;
        }
        if (this.outline) {
            this.outline.destroy();
            this.outline = undefined;
        }
        if (this.listViewInstance) {
            this.listViewInstance.destroy();
            this.listViewInstance = undefined;
        }
        this.heading1 = undefined;
        this.heading2 = undefined;
        this.heading3 = undefined;
        this.heading4 = undefined;
        this.heading5 = undefined;
        this.heading6 = undefined;
        this.heading7 = undefined;
        this.heading8 = undefined;
        this.heading9 = undefined;
        this.normal = undefined;
        this.textBoxInput = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let count = 0; count < this.target.childNodes.length; count++) {
                this.target.removeChild(this.target.childNodes[count]);
                count--;
            }
            this.target = undefined;
        }
    }
}

/**
 * The Page setup dialog is used to modify formatting of selected sections.
 */
class PageSetupDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.isPortrait = true;
        /**
         * @private
         */
        this.loadPageSetupDialog = () => {
            this.owner.updateFocus();
            let sectionFormat = this.owner.selection.sectionFormat;
            this.topMarginBox.value = sectionFormat.topMargin;
            this.leftMarginBox.value = sectionFormat.leftMargin;
            this.bottomMarginBox.value = sectionFormat.bottomMargin;
            this.rightMarginBox.value = sectionFormat.rightMargin;
            this.widthBox.value = sectionFormat.pageWidth;
            this.heightBox.value = sectionFormat.pageHeight;
            this.checkBox1.checked = sectionFormat.differentOddAndEvenPages;
            this.checkBox2.checked = sectionFormat.differentFirstPage;
            this.headerBox.value = sectionFormat.headerDistance;
            this.footerBox.value = sectionFormat.footerDistance;
            if (this.widthBox.value > this.heightBox.value) {
                this.landscape.checked = true;
            }
            else {
                this.portrait.checked = true;
            }
            this.setPageSize(this.portrait.checked, sectionFormat.pageWidth, sectionFormat.pageHeight);
        };
        /**
         * @private
         */
        this.closePageSetupDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.keyUpInsertPageSettings = (event) => {
            if (event.keyCode === 13) {
                this.applyPageSetupProperties();
            }
        };
        /**
         * @private
         */
        this.applyPageSetupProperties = () => {
            let sectionFormat = new WSectionFormat();
            sectionFormat.bottomMargin = this.bottomMarginBox.value;
            sectionFormat.topMargin = this.topMarginBox.value;
            sectionFormat.leftMargin = this.leftMarginBox.value;
            sectionFormat.rightMargin = this.rightMarginBox.value;
            sectionFormat.pageWidth = this.widthBox.value;
            sectionFormat.pageHeight = this.heightBox.value;
            sectionFormat.differentOddAndEvenPages = this.checkBox1.checked;
            sectionFormat.differentFirstPage = this.checkBox2.checked;
            sectionFormat.headerDistance = this.headerBox.value;
            sectionFormat.footerDistance = this.footerBox.value;
            this.owner.owner.editorModule.onApplySectionFormat(undefined, sectionFormat);
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.changeByPaperSize = (event) => {
            let value = event.value;
            let sectionFormat = this.owner.selection.sectionFormat;
            let width = sectionFormat.pageWidth;
            let height = sectionFormat.pageHeight;
            if (this.owner.selection.sectionFormat.pageWidth > this.owner.selection.sectionFormat.pageHeight || this.landscape.checked) {
                this.isPortrait = false;
            }
            else {
                this.isPortrait = true;
            }
            if (value === 'letter') {
                if (this.isPortrait) {
                    this.widthBox.value = 612;
                    this.heightBox.value = 792;
                }
                else {
                    this.widthBox.value = 792;
                    this.heightBox.value = 612;
                }
            }
            else if (value === 'tabloid') {
                if (this.isPortrait) {
                    this.widthBox.value = 792;
                    this.heightBox.value = 1224;
                }
                else {
                    this.widthBox.value = 1224;
                    this.heightBox.value = 792;
                }
            }
            else if (value === 'legal') {
                if (this.isPortrait) {
                    this.widthBox.value = 612;
                    this.heightBox.value = 1008;
                }
                else {
                    this.widthBox.value = 1008;
                    this.heightBox.value = 612;
                }
            }
            else if (value === 'statement') {
                if (this.isPortrait) {
                    this.widthBox.value = 392;
                    this.heightBox.value = 612;
                }
                else {
                    this.widthBox.value = 612;
                    this.heightBox.value = 392;
                }
            }
            else if (value === 'executive') {
                if (this.isPortrait) {
                    this.widthBox.value = 522;
                    this.heightBox.value = 756;
                }
                else {
                    this.widthBox.value = 756;
                    this.heightBox.value = 522;
                }
            }
            else if (value === 'a3') {
                if (this.isPortrait) {
                    this.widthBox.value = 841.9;
                    this.heightBox.value = 1190.55;
                }
                else {
                    this.widthBox.value = 1190.55;
                    this.heightBox.value = 841.9;
                }
            }
            else if (value === 'a4') {
                if (this.isPortrait) {
                    this.widthBox.value = 595.3;
                    this.heightBox.value = 841.9;
                }
                else {
                    this.widthBox.value = 841.9;
                    this.heightBox.value = 595.3;
                }
            }
            else if (value === 'a5') {
                if (this.isPortrait) {
                    this.widthBox.value = 419.55;
                    this.heightBox.value = 595.3;
                }
                else {
                    this.widthBox.value = 595.3;
                    this.heightBox.value = 419.55;
                }
            }
            else if (value === 'b4') {
                if (this.isPortrait) {
                    this.widthBox.value = 728.5;
                    this.heightBox.value = 1031.8;
                }
                else {
                    this.widthBox.value = 1031.8;
                    this.heightBox.value = 728.5;
                }
            }
            else if (value === 'b5') {
                if (this.isPortrait) {
                    this.widthBox.value = 515.9;
                    this.heightBox.value = 728.5;
                }
                else {
                    this.widthBox.value = 728.5;
                    this.heightBox.value = 515.9;
                }
            }
            else if (value === 'customsize') {
                if (this.isPortrait) {
                    this.widthBox.value = 515.9;
                    this.heightBox.value = 728.5;
                }
                else {
                    this.widthBox.value = 728.5;
                    this.heightBox.value = 515.9;
                }
            }
        };
        /**
         * @private
         */
        this.onPortrait = (event) => {
            this.landscape.checked = false;
            let width = this.widthBox.value;
            let height = this.heightBox.value;
            if (width > height) {
                this.widthBox.value = height;
                this.heightBox.value = width;
            }
        };
        /**
         * @private
         */
        this.onLandscape = (event) => {
            this.portrait.checked = false;
            let width = this.widthBox.value;
            let height = this.heightBox.value;
            if (width < height) {
                this.widthBox.value = height;
                this.heightBox.value = width;
            }
        };
        /**
         * @private
         */
        this.unWireEventsAndBindings = () => {
            this.paperSize.value = undefined;
            this.topMarginBox.value = undefined;
            this.bottomMarginBox.value = undefined;
            this.leftMarginBox.value = undefined;
            this.rightMarginBox.value = undefined;
            this.headerBox.value = undefined;
            this.footerBox.value = undefined;
            this.widthBox.value = undefined;
            this.heightBox.value = undefined;
            this.checkBox1.checked = false;
            this.checkBox2.checked = false;
            this.portrait.checked = false;
            this.landscape.checked = false;
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'PageSetupDialog';
    }
    /**
     * @private
     */
    initPageSetupDialog(locale, isRtl) {
        let id = this.owner.owner.containerId + '_pagesetup_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-pagesetup-dlg-container' });
        let ejtabContainer = createElement('div', { id: this.target.id + '_MarginTabContainer' });
        this.target.appendChild(ejtabContainer);
        this.marginTab = createElement('div', {
            id: this.target.id + '_marginPropertyTab', styles: 'position: relative;'
        });
        this.paperTab = createElement('div', {
            id: this.target.id + '_paperSizePropertyTab', styles: 'position: relative;'
        });
        this.layoutTab = createElement('div', {
            id: this.target.id + '_CellPropertiesDialogTab', styles: 'position: relative;'
        });
        // tslint:disable-next-line:max-line-length
        let ejtab = createElement('div', { id: this.target.id + '_PageSetupDialogTab', className: 'e-de-page-setup-ppty-tab' });
        let headerContainer = createElement('div', { className: 'e-tab-header' });
        let marginHeader = createElement('div', {
            id: this.target.id + '_marginHeader', innerHTML: locale.getConstant('Margin')
        });
        let paperHeader = createElement('div', {
            id: this.target.id + '_paperHeader', innerHTML: locale.getConstant('Paper')
        });
        let layoutHeader = createElement('div', {
            id: this.target.id + '_layoutHeader', innerHTML: locale.getConstant('Layout')
        });
        headerContainer.appendChild(marginHeader);
        headerContainer.appendChild(paperHeader);
        headerContainer.appendChild(layoutHeader);
        let contentContainer = createElement('div', { className: 'e-content' });
        let marginContent = createElement('div', { id: this.target.id + '_marginContent' });
        let paperContent = createElement('div', { id: this.target.id + '_paperContent' });
        let layoutContent = createElement('div', { id: this.target.id + '_layoutContent' });
        marginContent.appendChild(this.marginTab);
        paperContent.appendChild(this.paperTab);
        layoutContent.appendChild(this.layoutTab);
        contentContainer.appendChild(marginContent);
        contentContainer.appendChild(paperContent);
        contentContainer.appendChild(layoutContent);
        ejtab.appendChild(headerContainer);
        ejtab.appendChild(contentContainer);
        ejtabContainer.appendChild(ejtab);
        this.initMarginProperties(this.marginTab, locale, isRtl);
        this.initPaperSizeProperties(this.paperTab, locale, isRtl);
        this.initLayoutProperties(this.layoutTab, locale, isRtl);
        let tabObj = new Tab({ enableRtl: isRtl }, ejtab);
        this.target.addEventListener('keyup', this.keyUpInsertPageSettings);
        let marginTabHeader = tabObj.element.getElementsByClassName('e-item e-toolbar-item')[0];
        let marginTabHeaderItem = marginTabHeader.getElementsByClassName('e-tab-wrap')[0];
        marginTabHeaderItem.classList.add('e-de-page-setup-dlg-margin-tab-header');
        if (isRtl) {
            marginTabHeaderItem.classList.add('e-de-rtl');
        }
    }
    /**
     * @private
     */
    initMarginProperties(element, locale, isRtl) {
        let marginDiv = createElement('div', {
            id: 'margin_div',
            className: 'e-de-page-setup-dlg-sub-container', styles: 'height:135px;'
        });
        // tslint:disable-next-line:max-line-length
        let leftMarginDiv = createElement('div', { id: 'left_margin', className: 'e-de-page-setup-dlg-left-sub-container' });
        marginDiv.appendChild(leftMarginDiv);
        // tslint:disable-next-line:max-line-length
        let rightMarginDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-sub-container' });
        marginDiv.appendChild(rightMarginDiv);
        if (isRtl) {
            leftMarginDiv.classList.add('e-de-rtl');
            rightMarginDiv.classList.add('e-de-rtl');
        }
        let topLabel = createElement('label', {
            innerHTML: locale.getConstant('Top'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_TopLabel', styles: 'padding-top:0px;'
        });
        let topTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_Top'
        });
        let bottomBoxLabel = createElement('label', {
            innerHTML: locale.getConstant('Bottom'),
            className: 'e-de-page-setup-dlg-sub-title-header', id: this.target.id + '_bottomLabel'
        });
        let bottomTextBox = createElement('input', {
            attrs: { 'type': 'text' },
            id: this.target.id + '_bottom'
        });
        leftMarginDiv.appendChild(topLabel);
        leftMarginDiv.appendChild(topTextBox);
        leftMarginDiv.appendChild(bottomBoxLabel);
        leftMarginDiv.appendChild(bottomTextBox);
        let leftBoxLabel = createElement('label', {
            innerHTML: locale.getConstant('Left'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;',
            id: this.target.id + '_leftLabel'
        });
        let leftTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_left'
        });
        let rightLabel = createElement('label', {
            innerHTML: locale.getConstant('Right'),
            id: this.target.id + '_rightLabel', className: 'e-de-page-setup-dlg-sub-title-header'
        });
        let rightTextBox = createElement('input', {
            attrs: { 'type': 'text' },
            id: this.target.id + '_right'
        });
        rightMarginDiv.appendChild(leftBoxLabel);
        rightMarginDiv.appendChild(leftTextBox);
        rightMarginDiv.appendChild(rightLabel);
        rightMarginDiv.appendChild(rightTextBox);
        element.appendChild(marginDiv);
        this.topMarginBox = new NumericTextBox({ value: 71, width: 170, decimals: 2 });
        this.topMarginBox.appendTo(topTextBox);
        this.leftMarginBox = new NumericTextBox({ value: 73, width: 170, decimals: 2 });
        this.leftMarginBox.appendTo(leftTextBox);
        this.bottomMarginBox = new NumericTextBox({ value: 72, width: 170, decimals: 2 });
        this.bottomMarginBox.appendTo(bottomTextBox);
        this.rightMarginBox = new NumericTextBox({ value: 74, width: 170, decimals: 2 });
        this.rightMarginBox.appendTo(rightTextBox);
        // tslint:disable-next-line:max-line-length
        let orientationDiv = createElement('div', { id: 'orientation_div', className: 'e-de-page-setup-dlg-sub-container-port' });
        // tslint:disable-next-line:max-line-length
        let orientationLabeldiv = createElement('div', { id: '_orientationLabelDiv', className: 'e-de-page-setup-dlg-sub-label', innerHTML: locale.getConstant('Orientation') });
        let orientationPropDiv = createElement('div', { id: '_orientationPropDiv', styles: 'display: flex;', className: 'e-de-page-setup-dlg-orientation-prop' });
        let portraitDivStyles;
        if (isRtl) {
            portraitDivStyles = 'padding-left: 30px;';
        }
        else {
            portraitDivStyles = 'padding-right: 30px;';
        }
        let portraitDiv = createElement('div', { id: '_portraitDiv', styles: portraitDivStyles });
        let portrait = createElement('input', {
            attrs: { 'type': 'radiobutton' }, id: this.target.id + '_portrait'
        });
        let landscapeDiv = createElement('div', { id: '_landscapeDiv' });
        let landscape = createElement('input', {
            attrs: { 'type': 'radiobutton' }, id: this.target.id + '_landscape'
        });
        portraitDiv.appendChild(portrait);
        landscapeDiv.appendChild(landscape);
        orientationPropDiv.appendChild(portraitDiv);
        orientationPropDiv.appendChild(landscapeDiv);
        orientationDiv.appendChild(orientationLabeldiv);
        orientationDiv.appendChild(orientationPropDiv);
        // tslint:disable-next-line:max-line-length
        this.portrait = new RadioButton({ label: locale.getConstant('Portrait'), checked: true, enableRtl: isRtl, change: this.onPortrait });
        this.landscape = new RadioButton({ label: locale.getConstant('Landscape'), enableRtl: isRtl, change: this.onLandscape });
        this.portrait.appendTo(portrait);
        this.landscape.appendTo(landscape);
        element.appendChild(orientationDiv);
    }
    /**
     * @private
     */
    initPaperSizeProperties(element, locale, isRtl) {
        let sizeDiv = createElement('div', {
            id: 'size_div',
            className: 'e-de-page-setup-dlg-sub-size-container'
        });
        // tslint:disable-next-line:max-line-length
        let leftSizeDiv = createElement('div', { id: 'left_size', className: 'e-de-page-setup-dlg-left-sub-container' });
        sizeDiv.appendChild(leftSizeDiv);
        // tslint:disable-next-line:max-line-length
        let rightSizeDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-sub-container' });
        sizeDiv.appendChild(rightSizeDiv);
        if (isRtl) {
            leftSizeDiv.classList.add('e-de-rtl');
            rightSizeDiv.classList.add('e-de-rtl');
        }
        let widthLabel = createElement('label', {
            innerHTML: locale.getConstant('Width'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_widthLabel', styles: 'padding-top:0px;'
        });
        let widthTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_Width'
        });
        leftSizeDiv.appendChild(widthLabel);
        leftSizeDiv.appendChild(widthTextBox);
        let heightLabel = createElement('label', {
            innerHTML: locale.getConstant('Height'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;',
            id: this.target.id + '_heightLabel'
        });
        let heightTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_height'
        });
        rightSizeDiv.appendChild(heightLabel);
        rightSizeDiv.appendChild(heightTextBox);
        element.appendChild(sizeDiv);
        this.widthBox = new NumericTextBox({ value: 612, width: 170, decimals: 2 });
        this.widthBox.appendTo(widthTextBox);
        this.heightBox = new NumericTextBox({ value: 792, width: 170, decimals: 2 });
        this.heightBox.appendTo(heightTextBox);
        // tslint:disable-next-line:max-line-length
        let paperSizeDiv = createElement('div', { id: '_paperSizeDiv', styles: 'height:37px;', className: 'e-de-page-setup-dlg-sub-container' });
        let paperSize = createElement('select', {
            id: this.target.id + '_papersize', styles: 'width:170px;padding-bottom: 20px;',
            innerHTML: '<option value="letter">' + locale.getConstant('Letter') +
                '</option><option value="tabloid">' + locale.getConstant('Tabloid') +
                '</option><option value="legal">' + locale.getConstant('Legal') +
                '</option><option value="statement">' + locale.getConstant('Statement') +
                '</option><option value="executive">' + locale.getConstant('Executive') +
                '</option><option value="a3">' + locale.getConstant('A3') +
                '</option><option value="a4">' + locale.getConstant('A4') +
                '</option><option value="a5">' + locale.getConstant('A5') +
                '</option><option value="b4">' + locale.getConstant('B4') +
                '</option><option value="b5">' + locale.getConstant('B5') +
                '</option><option value="customsize">' + locale.getConstant('Custom Size') + '</option>'
        });
        paperSizeDiv.appendChild(paperSize);
        this.paperSize = new DropDownList({ change: this.changeByPaperSize, width: '170px', enableRtl: isRtl });
        this.paperSize.appendTo(paperSize);
        element.appendChild(paperSizeDiv);
    }
    /**
     * @private
     */
    initLayoutProperties(element, locale, isRtl) {
        // tslint:disable-next-line:max-line-length
        let layoutDiv = createElement('div', { id: '_layoutDiv', className: 'e-de-page-setup-dlg-layout-sub-container', });
        // tslint:disable-next-line:max-line-length
        let firstPageDiv = createElement('div', { id: '_firstPageDiv', styles: 'height: 27px;', className: 'e-de-page-setup-dlg-first-page-prop' });
        let checkBox1 = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_oddoreven'
        });
        firstPageDiv.appendChild(checkBox1);
        // tslint:disable-next-line:max-line-length
        let oddOrEvenDiv = createElement('div', { id: '_oddOrEvenDiv', styles: 'height: 27px;', className: 'e-de-page-setup-dlg-odd-or-even-prop' });
        let checkBox2 = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_even'
        });
        oddOrEvenDiv.appendChild(checkBox2);
        layoutDiv.appendChild(firstPageDiv);
        layoutDiv.appendChild(oddOrEvenDiv);
        this.checkBox1 = new CheckBox({ label: locale.getConstant('Different odd and even'), enableRtl: isRtl });
        this.checkBox2 = new CheckBox({ label: locale.getConstant('Different first page'), enableRtl: isRtl });
        this.checkBox1.appendTo(checkBox1);
        this.checkBox2.appendTo(checkBox2);
        element.appendChild(layoutDiv);
        // tslint:disable-next-line:max-line-length
        let textLabelDiv = createElement('div', { id: '_textLabelDiv', className: 'e-de-page-setup-dlg-sub-label' });
        let textLabel = createElement('label', {
            innerHTML: locale.getConstant('From edge'), id: this.target.id + '_textLabel'
        });
        textLabelDiv.appendChild(textLabel);
        element.appendChild(textLabelDiv);
        // tslint:disable-next-line:max-line-length
        let propertyDiv = createElement('div', { id: '_headerFooeterPropDiv', className: 'e-de-page-setup-dlg-sub-container', styles: 'height: 65px;' });
        // tslint:disable-next-line:max-line-length
        let leftLayoutDiv = createElement('div', { id: '_leftLayoutDiv', className: 'e-de-page-setup-dlg-left-layout-container' });
        propertyDiv.appendChild(leftLayoutDiv);
        // tslint:disable-next-line:max-line-length
        let rightLayoutDiv = createElement('div', { className: 'e-de-page-setup-dlg-right-layout-container' });
        propertyDiv.appendChild(rightLayoutDiv);
        if (isRtl) {
            rightLayoutDiv.classList.add('e-de-rtl');
            leftLayoutDiv.classList.add('e-de-rtl');
        }
        let headerLabel = createElement('label', {
            innerHTML: locale.getConstant('Header'), className: 'e-de-page-setup-dlg-sub-header',
            id: this.target.id + '_headerLabel', styles: 'padding-top:0px;'
        });
        let headerBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_header'
        });
        leftLayoutDiv.appendChild(headerLabel);
        leftLayoutDiv.appendChild(headerBox);
        let footerLabel = createElement('label', {
            innerHTML: locale.getConstant('Footer'), className: 'e-de-page-setup-dlg-sub-header', styles: 'padding-top:0px;',
            id: this.target.id + '_footerLabel'
        });
        let footerBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_footer'
        });
        rightLayoutDiv.appendChild(footerLabel);
        rightLayoutDiv.appendChild(footerBox);
        element.appendChild(propertyDiv);
        this.headerBox = new NumericTextBox({ value: 612, width: 170, decimals: 2 });
        this.headerBox.appendTo(headerBox);
        this.footerBox = new NumericTextBox({ value: 792, width: 170, decimals: 2 });
        this.footerBox.appendTo(footerBox);
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initPageSetupDialog(localValue, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = localValue.getConstant('Page Setup');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadPageSetupDialog;
        this.owner.dialog.close = this.closePageSetupDialog;
        this.owner.dialog.buttons = [{
                click: this.applyPageSetupProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-layout-ppty-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-layout-ppty-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    setPageSize(isPortrait, width, height) {
        if ((isPortrait && width === 612 && height === 792)
            || (!isPortrait && width === 792 && height === 612)) {
            this.paperSize.value = 'letter';
        }
        else if ((isPortrait && width === 792 && height === 1224)
            || (!isPortrait && width === 1224 && height === 792)) {
            this.paperSize.value = 'tabloid';
        }
        else if ((isPortrait && width === 612 && height === 1008)
            || (!isPortrait && width === 1008 && height === 612)) {
            this.paperSize.value = 'legal';
        }
        else if ((isPortrait && width === 392 && height === 612)
            || (!isPortrait && width === 392 && height === 612)) {
            this.paperSize.value = 'statement';
        }
        else if ((isPortrait && width === 522 && height === 756)
            || (!isPortrait && width === 756 && height === 522)) {
            this.paperSize.value = 'executive';
        }
        else if ((isPortrait && width === 841.9 && height === 1190.55)
            || (!isPortrait && width === 1190.5 && height === 841.9)) {
            this.paperSize.value = 'a3';
        }
        else if ((isPortrait && width === 595.3 && height === 841.9)
            || (!isPortrait && width === 841.9 && height === 595.3)) {
            this.paperSize.value = 'a4';
        }
        else if ((isPortrait && width === 419.55 && height === 595.3)
            || (!isPortrait && width === 595.3 && height === 419.55)) {
            this.paperSize.value = 'a5';
        }
        else if ((isPortrait && width === 728.5 && height === 1031.8)
            || (!isPortrait && width === 1031.8 && height === 728.5)) {
            this.paperSize.value = 'b4';
        }
        else if ((isPortrait && width === 515.9 && height === 728.5)
            || (!isPortrait && width === 728.5 && height === 515.9)) {
            this.paperSize.value = 'letter';
        }
        else {
            this.paperSize.value = 'customsize';
        }
    }
    /**
     * @private
     */
    destroy() {
        if (this.topMarginBox) {
            this.topMarginBox.destroy();
            this.topMarginBox = undefined;
        }
        if (this.leftMarginBox) {
            this.leftMarginBox.destroy();
            this.leftMarginBox = undefined;
        }
        if (this.bottomMarginBox) {
            this.bottomMarginBox.destroy();
            this.bottomMarginBox = undefined;
        }
        if (this.rightMarginBox) {
            this.rightMarginBox.destroy();
            this.rightMarginBox = undefined;
        }
        if (this.headerBox) {
            this.headerBox.destroy();
            this.headerBox = undefined;
        }
        if (this.footerBox) {
            this.footerBox.destroy();
            this.footerBox = undefined;
        }
        if (this.widthBox) {
            this.widthBox.destroy();
            this.widthBox = undefined;
        }
        if (this.heightBox) {
            this.heightBox.destroy();
            this.heightBox = undefined;
        }
        if (this.paperSize) {
            this.paperSize.destroy();
            this.paperSize = undefined;
        }
        if (this.checkBox1) {
            this.checkBox1.destroy();
            this.checkBox1 = undefined;
        }
        if (this.checkBox2) {
            this.checkBox2.destroy();
            this.checkBox2 = undefined;
        }
        if (this.portrait) {
            this.portrait.destroy();
            this.portrait = undefined;
        }
        if (this.landscape) {
            this.landscape.destroy();
            this.landscape = undefined;
        }
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let s = 0; s < this.target.childNodes.length; s++) {
                this.target.removeChild(this.target.childNodes[s]);
                s--;
            }
            this.target = undefined;
        }
    }
}

/**
 * The Paragraph dialog is used to modify formatting of selected paragraphs.
 */
class ParagraphDialog {
    /**
     * @private
     */
    constructor(viewer) {
        //paragraph Format properties
        this.leftIndent = undefined;
        this.rightIndent = undefined;
        this.beforeSpacing = undefined;
        this.afterSpacing = undefined;
        this.textAlignment = undefined;
        this.firstLineIndent = undefined;
        this.lineSpacingIn = undefined;
        this.lineSpacingType = undefined;
        this.paragraphFormat = undefined;
        this.bidi = undefined;
        this.contextualSpacing = undefined;
        this.isStyleDialog = false;
        this.directionDiv = undefined;
        /**
         * @private
         */
        this.keyUpParagraphSettings = (event) => {
            if (event.keyCode === 13) {
                this.applyParagraphFormat();
            }
        };
        this.changeBeforeSpacing = (event) => {
            this.beforeSpacing = event.value;
        };
        this.changeAfterSpacing = (event) => {
            this.afterSpacing = event.value;
        };
        this.changeLeftIndent = (event) => {
            this.leftIndent = event.value;
        };
        this.changeRightIndent = (event) => {
            this.rightIndent = event.value;
        };
        this.changeLineSpacingValue = (event) => {
            this.lineSpacingIn = event.value;
        };
        this.changeFirstLineIndent = (event) => {
            this.firstLineIndent = event.value;
        };
        this.changeByTextAlignment = (args) => {
            this.textAlignment = args.value;
        };
        this.changeBidirectional = (event) => {
            if (event.value === 'ltr') {
                this.rtlButton.checked = !this.ltrButton.checked;
                this.bidi = false;
            }
            else {
                this.ltrButton.checked = !this.rtlButton.checked;
                this.bidi = true;
            }
            this.changeAlignmentByBidi();
        };
        this.changeContextualSpacing = (args) => {
            this.contextualSpacing = args.checked;
        };
        /**
         * @private
         */
        this.changeByValue = (event) => {
            let paragraphFormat = this.owner.selection.paragraphFormat;
            switch (this.special.index) {
                case 0:
                    if (paragraphFormat.firstLineIndent !== 0) {
                        this.byIn.value = 0;
                    }
                    break;
                case 1:
                    if (paragraphFormat.firstLineIndent === 0 || isNullOrUndefined(paragraphFormat.firstLineIndent)) {
                        this.byIn.value = 0.1;
                    }
                    else if (paragraphFormat.firstLineIndent < 0) {
                        this.byIn.value = -(paragraphFormat.firstLineIndent);
                    }
                    break;
                case 2:
                    if (paragraphFormat.firstLineIndent === 0 || isNullOrUndefined(paragraphFormat.firstLineIndent)) {
                        paragraphFormat.firstLineIndent = -0.1;
                    }
                    else if (paragraphFormat.firstLineIndent > 0) {
                        this.byIn.value = -(paragraphFormat.firstLineIndent);
                    }
                    break;
            }
        };
        /**
         * @private
         */
        this.changeBySpacing = (event) => {
            if (isNullOrUndefined(this.lineSpacing)) {
                return;
            }
            switch (this.lineSpacing.index) {
                case 0:
                    this.lineSpacingType = 'AtLeast';
                    this.atIn.value = 12;
                    break;
                case 1:
                    this.lineSpacingType = 'Exactly';
                    this.atIn.value = 12;
                    break;
                case 2:
                    this.lineSpacingType = 'Multiple';
                    this.atIn.value = 1;
                    break;
            }
        };
        /* tslint:enable */
        /**
         * @private
         */
        this.loadParagraphDialog = () => {
            if (this.isStyleDialog) {
                this.directionDiv.classList.add('e-de-disabledbutton');
            }
            else {
                this.directionDiv.classList.remove('e-de-disabledbutton');
            }
            let selectionFormat;
            if (this.paragraphFormat) {
                selectionFormat = this.paragraphFormat;
            }
            else {
                selectionFormat = this.owner.selection.paragraphFormat;
            }
            let alignValue = this.getAlignmentValue(selectionFormat.textAlignment);
            this.alignment.index = alignValue;
            this.beforeSpacingIn.value = selectionFormat.beforeSpacing;
            this.afterSpacingIn.value = selectionFormat.afterSpacing;
            this.leftIndentIn.value = selectionFormat.leftIndent;
            this.rightIndentIn.value = selectionFormat.rightIndent;
            this.byIn.value = selectionFormat.firstLineIndent;
            let lineSpaceValue = this.lineSpacing.index;
            if (selectionFormat.lineSpacingType === 'AtLeast') {
                lineSpaceValue = 0;
            }
            else if (selectionFormat.lineSpacingType === 'Exactly') {
                lineSpaceValue = 1;
            }
            else {
                lineSpaceValue = 2;
            }
            this.lineSpacing.index = lineSpaceValue;
            this.atIn.value = selectionFormat.lineSpacing;
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
            if (selectionFormat.bidi) {
                this.rtlButton.checked = true;
                this.ltrButton.checked = false;
            }
            else {
                this.ltrButton.checked = true;
                this.rtlButton.checked = false;
            }
            this.contextSpacing.checked = selectionFormat.contextualSpacing;
        };
        /**
         * @private
         */
        this.applyParagraphFormat = () => {
            let paraFormat;
            let isApply;
            if (this.paragraphFormat) {
                paraFormat = this.paragraphFormat;
                isApply = false;
            }
            else {
                paraFormat = new WParagraphFormat();
                isApply = true;
            }
            if (!isNullOrUndefined(this.beforeSpacing)) {
                paraFormat.beforeSpacing = this.beforeSpacing;
            }
            if (!isNullOrUndefined(this.afterSpacing)) {
                paraFormat.afterSpacing = this.afterSpacing;
            }
            if (!isNullOrUndefined(this.lineSpacingType)) {
                paraFormat.lineSpacingType = this.lineSpacingType;
            }
            if (!isNullOrUndefined(this.leftIndent)) {
                paraFormat.leftIndent = this.leftIndent;
            }
            if (!isNullOrUndefined(this.rightIndent)) {
                paraFormat.rightIndent = this.rightIndent;
            }
            if (!isNullOrUndefined(this.lineSpacingIn)) {
                paraFormat.lineSpacing = this.lineSpacingIn;
            }
            if (!isNullOrUndefined(this.firstLineIndent)) {
                paraFormat.firstLineIndent = this.firstLineIndent;
            }
            if (!isNullOrUndefined(this.bidi)) {
                paraFormat.bidi = this.bidi;
            }
            if (!isNullOrUndefined(this.textAlignment)) {
                paraFormat.textAlignment = this.textAlignment;
            }
            if (!isNullOrUndefined(this.contextualSpacing)) {
                paraFormat.contextualSpacing = this.contextualSpacing;
            }
            if (isApply) {
                this.onParagraphFormat(paraFormat);
            }
            else {
                this.owner.owner.styleDialogModule.updateParagraphFormat();
            }
            this.owner.dialog.hide();
        };
        /**
         * @private
         */
        this.closeParagraphDialog = () => {
            this.leftIndent = undefined;
            this.afterSpacing = undefined;
            this.beforeSpacing = undefined;
            this.firstLineIndent = undefined;
            this.textAlignment = undefined;
            this.rightIndent = undefined;
            this.lineSpacingIn = undefined;
            this.lineSpacingType = undefined;
            this.paragraphFormat = undefined;
            this.owner.dialog.hide();
            this.owner.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'ParagraphDialog';
    }
    /*tslint:disable max-func-body-length*/
    /**
     * @private
     */
    initParagraphDialog(locale) {
        let instance = this;
        let ownerId = this.owner.owner.containerId;
        let id = ownerId + '_paragraph_dialog';
        this.target = createElement('div', { id: id, className: 'e-de-para-dlg-container' });
        // tslint:disable-next-line:max-line-length
        let div = createElement('div', { id: 'property_div', styles: 'width:400px;' });
        let generalDiv = createElement('div', { id: 'genral_div', className: 'e-de-para-dlg-sub-container' });
        // tslint:disable-next-line:max-line-length
        let genLabel = createElement('div', { id: ownerId + '_genLabel', className: 'e-de-para-dlg-heading', innerHTML: locale.getConstant('General') });
        let alignLabel = createElement('div', { id: ownerId + '_AlignLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Alignment') });
        let alignment = createElement('select', {
            id: ownerId + '_Alignment',
            innerHTML: '<option value="Center">' + locale.getConstant('Center') +
                '</option><option value="Left">' + locale.getConstant('Left') +
                '</option><option value="Right">' + locale.getConstant('Right') +
                '</option><option value="Justify">' + locale.getConstant('Justify') + '</option>'
        });
        generalDiv.appendChild(genLabel);
        generalDiv.appendChild(alignLabel);
        generalDiv.appendChild(alignment);
        let dirLabel = createElement('div', {
            id: ownerId + '_DirLabel',
            className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Direction')
        });
        this.directionDiv = createElement('div', { id: ownerId + '_DirDiv', styles: 'display:flex' });
        let rtlDiv = createElement('div', { id: ownerId + '_DirDiv', className: 'e-de-rtl-btn-div' });
        let rtlInputELe = createElement('input', { id: ownerId + '_rtlEle' });
        rtlDiv.appendChild(rtlInputELe);
        this.directionDiv.appendChild(rtlDiv);
        let isRtl = this.owner.owner.enableRtl;
        if (isRtl) {
            rtlDiv.classList.add('e-de-rtl');
        }
        let ltrDiv = createElement('div', { id: ownerId + '_DirDiv', className: 'e-de-ltr-btn-div' });
        let ltrInputELe = createElement('input', { id: ownerId + '_ltrEle' });
        ltrDiv.appendChild(ltrInputELe);
        this.directionDiv.appendChild(ltrDiv);
        generalDiv.appendChild(dirLabel);
        generalDiv.appendChild(this.directionDiv);
        this.rtlButton = new RadioButton({
            label: locale.getConstant('Right-to-left'), enableRtl: isRtl,
            value: 'rtl', cssClass: 'e-small', change: this.changeBidirectional
        });
        this.rtlButton.appendTo(rtlInputELe);
        this.ltrButton = new RadioButton({
            label: locale.getConstant('Left-to-right'), enableRtl: isRtl,
            value: 'ltr', cssClass: 'e-small', change: this.changeBidirectional
        });
        this.ltrButton.appendTo(ltrInputELe);
        // tslint:disable-next-line:max-line-length
        let indentionDiv = createElement('div', { id: 'indention_div', styles: 'width: 400px;', className: 'e-de-para-dlg-sub-container e-para-dlg-sub-height' });
        let leftIndentionDiv = createElement('div', { id: 'left_indention', styles: 'float:left;position:relative;' });
        indentionDiv.appendChild(leftIndentionDiv);
        // tslint:disable-next-line:max-line-length
        let rightIndentionDiv = createElement('div', { className: 'e-de-para-dlg-right-sub-container', styles: 'float:right;position:relative;' });
        indentionDiv.appendChild(rightIndentionDiv);
        // tslint:disable-next-line:max-line-length
        let spacingDiv = createElement('div', { id: 'spacing_div' });
        let leftSpacingDiv = createElement('div', { id: 'left_spacing', styles: 'float:left;position:relative;' });
        spacingDiv.appendChild(leftSpacingDiv);
        let contextSpacingStyles = 'float:left';
        if (isRtl) {
            contextSpacingStyles = 'float:right;';
        }
        let contextSpacingDiv = createElement('div', { id: 'context_spacing', styles: contextSpacingStyles + 'position:relative;' });
        spacingDiv.appendChild(contextSpacingDiv);
        // tslint:disable-next-line:max-line-length
        let rightSpacingDiv = createElement('div', { styles: 'display:inline-flex;' });
        spacingDiv.appendChild(rightSpacingDiv);
        let contextInputEle = createElement('input', {
            attrs: { type: 'checkbox' },
            id: ownerId + '_contextSpacing'
        });
        contextSpacingDiv.appendChild(contextInputEle);
        // tslint:disable-next-line:max-line-length
        let indentLabel = createElement('div', {
            id: ownerId + '_indentLabel', className: 'e-de-para-dlg-heading', innerHTML: locale.getConstant('Indentation')
        });
        let beforeTextLabel = createElement('div', {
            id: ownerId + '_bfTextLabel',
            className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Before text')
        });
        // tslint:disable-next-line:max-line-length
        let leftIndent = createElement('input', { id: ownerId + '_leftIndent', attrs: { 'type': 'text' } });
        let specialLabel = createElement('div', { id: ownerId + '_specialLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Special') });
        let special = createElement('select', {
            id: ownerId + '_special',
            innerHTML: '<option value="None">' + locale.getConstant('None') +
                '</option><option value="First Line">' + locale.getConstant('First line') +
                '</option><option value="Hanging">' + locale.getConstant('Hanging') + '</option> '
        });
        leftIndentionDiv.appendChild(indentLabel);
        leftIndentionDiv.appendChild(beforeTextLabel);
        leftIndentionDiv.appendChild(leftIndent);
        leftIndentionDiv.appendChild(specialLabel);
        leftIndentionDiv.appendChild(special);
        // tslint:disable-next-line:max-line-length
        let afterTextLabel = createElement('div', { id: ownerId + '_afTextLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('After text') });
        let rightIndent = createElement('input', { id: ownerId + '_rightIndent', attrs: { 'type': 'text' } });
        // tslint:disable-next-line:max-line-length
        let byLabel = createElement('label', { id: ownerId + '_byLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('By') });
        let by = createElement('input', { id: ownerId + '_By', attrs: { 'type': 'text' } });
        rightIndentionDiv.appendChild(afterTextLabel);
        rightIndentionDiv.appendChild(rightIndent);
        rightIndentionDiv.appendChild(byLabel);
        rightIndentionDiv.appendChild(by);
        // tslint:disable-next-line:max-line-length
        let spaceLabel = createElement('div', { innerHTML: locale.getConstant('Spacing'), className: 'e-de-para-dlg-heading', id: ownerId + '_spaceLabel' });
        let spacingWholeDiv = createElement('div', { id: ownerId + '_spacingWholeDiv', styles: 'display:inline-flex;' });
        let beforeSpacingWholeDiv = createElement('div', { id: ownerId + '_beforeSpacingWholeDiv' });
        // tslint:disable-next-line:max-line-length
        let beforeLabel = createElement('div', { className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Before'), id: ownerId + '_beforeLabel' });
        // tslint:disable-next-line:max-line-length
        let beforeSpacing = createElement('input', { id: ownerId + '_beforeSpacing', attrs: { 'type': 'text' } });
        let afterSpacingWholeDiv = createElement('div', { id: ownerId + '_afterSpacingWholeDiv', className: 'e-de-para-dlg-spacing-div' });
        // tslint:disable-next-line:max-line-length
        let afterLabel = createElement('div', { innerHTML: locale.getConstant('After'), className: 'e-de-dlg-sub-header', id: ownerId + '_afterLabel' });
        let afterSpacing = createElement('input', { id: ownerId + '_afterSpacing', attrs: { 'type': 'text' } });
        leftSpacingDiv.appendChild(spaceLabel);
        leftSpacingDiv.appendChild(spacingWholeDiv);
        beforeSpacingWholeDiv.appendChild(beforeLabel);
        beforeSpacingWholeDiv.appendChild(beforeSpacing);
        spacingWholeDiv.appendChild(beforeSpacingWholeDiv);
        afterSpacingWholeDiv.appendChild(afterLabel);
        afterSpacingWholeDiv.appendChild(afterSpacing);
        spacingWholeDiv.appendChild(afterSpacingWholeDiv);
        let lineSpacingDiv = createElement('div', { id: ownerId + '_lineSpacingWholeDiv' });
        // tslint:disable-next-line:max-line-length
        let lineSpaceLabel = createElement('div', { id: ownerId + '_lineSpaceLabel', className: 'e-de-dlg-sub-header', innerHTML: locale.getConstant('Line Spacing') });
        // tslint:disable-next-line:max-line-length
        let lineSpacing = createElement('select', {
            id: ownerId + '_lineSpacing', styles: 'width:180px;',
            innerHTML: '<option value="At least">' + locale.getConstant('At least') +
                '</option><option value="Exactly">' + locale.getConstant('Exactly') +
                '</option><option value="Multiple">' + locale.getConstant('Multiple') + '</option>'
        });
        // tslint:disable-next-line:max-line-length
        let lineTypeDiv = createElement('div', { id: ownerId + '_lineTypeWholeDiv', className: 'e-de-para-dlg-spacing-div' });
        // tslint:disable-next-line:max-line-length
        let atLabel = createElement('div', { innerHTML: locale.getConstant('At'), id: ownerId + '_atLabel', className: 'e-de-dlg-sub-header' });
        let lineSpacingAt = createElement('input', { id: ownerId + '_lineSpacingAt', attrs: { 'type': 'text' } });
        lineSpacingDiv.appendChild(lineSpaceLabel);
        lineSpacingDiv.appendChild(lineSpacing);
        rightSpacingDiv.appendChild(lineSpacingDiv);
        lineTypeDiv.appendChild(atLabel);
        lineTypeDiv.appendChild(lineSpacingAt);
        rightSpacingDiv.appendChild(lineTypeDiv);
        div.appendChild(generalDiv);
        div.appendChild(indentionDiv);
        div.appendChild(spacingDiv);
        this.target.appendChild(div);
        this.leftIndentIn = new NumericTextBox({
            format: 'n1', value: 0, min: -1584, max: 1584, width: 180, enablePersistence: false, change: this.changeLeftIndent
        });
        this.leftIndentIn.appendTo(leftIndent);
        this.rightIndentIn = new NumericTextBox({
            format: 'n1', value: 0, min: -1584, max: 1584, width: 180, enablePersistence: false, change: this.changeRightIndent
        });
        this.rightIndentIn.appendTo(rightIndent);
        this.byIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, enablePersistence: false, change: this.changeFirstLineIndent
        });
        this.byIn.appendTo(by);
        this.beforeSpacingIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, step: 6, enablePersistence: false,
            change: this.changeBeforeSpacing
        });
        this.beforeSpacingIn.appendTo(beforeSpacing);
        this.afterSpacingIn = new NumericTextBox({
            format: 'n1', value: 0, min: 0, max: 1584, width: 180, step: 6, enablePersistence: false,
            change: this.changeAfterSpacing
        });
        this.afterSpacingIn.appendTo(afterSpacing);
        this.atIn = new NumericTextBox({
            format: 'n1', value: 0, min: 1, max: 1584, width: 180, step: 0.5, enablePersistence: false, change: this.changeLineSpacingValue
        });
        this.special = new DropDownList({ change: this.changeByValue, width: 180, enableRtl: isRtl });
        this.special.appendTo(special);
        this.lineSpacing = new DropDownList({ change: this.changeBySpacing, width: '180px', enableRtl: isRtl });
        this.lineSpacing.appendTo(lineSpacing);
        this.alignment = new DropDownList({ width: 180, change: this.changeByTextAlignment, enableRtl: isRtl });
        this.alignment.appendTo(alignment);
        this.atIn.appendTo(lineSpacingAt);
        this.contextSpacing = new CheckBox({
            change: this.changeContextualSpacing,
            label: locale.getConstant("Don't add space between the paragraphs of the same styles"),
            enableRtl: isRtl,
            cssClass: 'e-de-para-dlg-cs-check-box'
        });
        this.contextSpacing.appendTo(contextInputEle);
        this.target.addEventListener('keyup', instance.keyUpParagraphSettings);
        if (isRtl) {
            afterSpacingWholeDiv.classList.add('e-de-rtl');
            lineTypeDiv.classList.add('e-de-rtl');
        }
    }
    changeAlignmentByBidi() {
        if (this.textAlignment === 'Left') {
            this.textAlignment = 'Right';
        }
        else if (this.textAlignment === 'Right') {
            this.textAlignment = 'Left';
        }
        if (!isNullOrUndefined(this.textAlignment)) {
            this.alignment.index = this.getAlignmentValue(this.textAlignment);
        }
        else {
            if (this.alignment.index === 0) {
                this.textAlignment = 'Center';
            }
            else {
                this.textAlignment = 'Justify';
            }
        }
    }
    getAlignmentValue(textAlignment) {
        let alignValue;
        if (textAlignment === 'Center') {
            alignValue = 0;
        }
        else if (textAlignment === 'Left') {
            alignValue = 1;
        }
        else if (textAlignment === 'Right') {
            alignValue = 2;
        }
        else {
            alignValue = 3;
        }
        return alignValue;
    }
    /**
     * Applies Paragraph Format
     * @param  {WParagraphFormat} paragraphFormat
     * @private
     */
    onParagraphFormat(paragraphFormat) {
        let selection = this.owner.selection;
        let isListBidi = paragraphFormat.bidi && selection.paragraphFormat.listId !== -1;
        if (!isListBidi) {
            this.owner.layout.isBidiReLayout = true;
        }
        this.owner.owner.editorModule.initHistory('ParagraphFormat');
        this.owner.owner.isShiftingEnabled = true;
        if (this.owner.selection.isEmpty) {
            this.owner.owner.editorModule.applyParaFormatProperty(selection.start.paragraph, undefined, paragraphFormat, false);
            this.owner.owner.editor.layoutItemBlock(selection.start.paragraph, false);
        }
        else {
            this.owner.owner.editorModule.updateSelectionParagraphFormatting('ParagraphFormat', paragraphFormat, false);
        }
        this.owner.owner.editorModule.reLayout(selection);
        if (!isListBidi) {
            this.owner.layout.isBidiReLayout = false;
        }
    }
    /**
     * @private
     */
    show(paragraphFormat) {
        if (paragraphFormat) {
            this.isStyleDialog = true;
            this.paragraphFormat = paragraphFormat;
        }
        else {
            this.isStyleDialog = false;
        }
        let local = new L10n('documenteditor', this.owner.owner.defaultLocale);
        local.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initParagraphDialog(local);
        }
        this.loadParagraphDialog();
        this.owner.dialog.header = local.getConstant('Paragraph');
        this.owner.dialog.content = this.target;
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.buttons = [{
                click: this.applyParagraphFormat,
                buttonModel: { content: local.getConstant('Ok'), cssClass: 'e-flat e-para-okay', isPrimary: true }
            },
            {
                click: this.closeParagraphDialog,
                buttonModel: { content: local.getConstant('Cancel'), cssClass: 'e-flat e-para-cancel' }
            }];
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    destroy() {
        if (this.afterSpacingIn) {
            this.afterSpacingIn.destroy();
            this.afterSpacingIn = undefined;
        }
        if (this.beforeSpacingIn) {
            this.beforeSpacingIn.destroy();
            this.beforeSpacingIn = undefined;
        }
        if (this.leftIndentIn) {
            this.leftIndentIn.destroy();
            this.leftIndentIn = undefined;
        }
        if (this.rightIndentIn) {
            this.rightIndentIn.destroy();
            this.rightIndentIn = undefined;
        }
        if (this.byIn) {
            this.byIn.destroy();
            this.byIn = undefined;
        }
        if (this.atIn) {
            this.atIn.destroy();
            this.atIn = undefined;
        }
        if (this.alignment) {
            this.alignment.change = undefined;
            this.alignment.destroy();
        }
        this.alignment = undefined;
        if (this.lineSpacing) {
            this.lineSpacing.change = undefined;
            this.lineSpacing.destroy();
        }
        this.lineSpacing = undefined;
        if (this.special) {
            this.special.change = undefined;
            this.special.destroy();
        }
        this.special = undefined;
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let q = 0; q < this.target.childNodes.length; q++) {
                this.target.removeChild(this.target.childNodes[q]);
                q--;
            }
            this.target = undefined;
        }
    }
}

/**
 * List view model implementation
 * @private
 */
class ListViewModel {
    /**
     * @private
     */
    constructor() {
        this.listIn = undefined;
        this.levelNumberIn = undefined;
        /**
         * @private
         */
        this.dialog = undefined;
        this.levelNumber = 0;
    }
    /**
     * @private
     */
    get levelNumber() {
        return this.levelNumberIn;
    }
    /**
     * @private
     */
    set levelNumber(value) {
        this.levelNumberIn = value;
    }
    /**
     * @private
     */
    get list() {
        return this.listIn;
    }
    /**
     * @private
     */
    set list(value) {
        if (isNullOrUndefined(value)) {
            this.createList();
        }
        else {
            this.listIn = value;
        }
    }
    /**
     * @private
     */
    get listLevel() {
        if (!isNullOrUndefined(this.list) && this.levelNumber >= 0 && this.levelNumber < 9) {
            if (!isNullOrUndefined(this.dialog.owner.getAbstractListById(this.list.abstractListId))) {
                if (this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.length <= this.levelNumber) {
                    this.addListLevels();
                }
                return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels[this.levelNumber];
            }
            else {
                this.dialog.owner.lists.push(this.list);
                let abstractList = this.list.abstractList;
                if (!this.list.abstractList) {
                    abstractList = new WAbstractList();
                    abstractList.abstractListId = this.list.abstractListId;
                }
                let listLevelAdv = new WListLevel(abstractList);
                listLevelAdv.characterFormat = new WCharacterFormat(listLevelAdv);
                listLevelAdv.paragraphFormat = new WParagraphFormat(listLevelAdv);
                listLevelAdv.paragraphFormat.leftIndent = (1) * 48;
                listLevelAdv.paragraphFormat.firstLineIndent = -24;
                listLevelAdv.numberFormat = '%' + (1).toString() + '.';
                listLevelAdv.listLevelPattern = 'UpRoman';
                listLevelAdv.followCharacter = 'Tab';
                listLevelAdv.startAt = 1;
                listLevelAdv.restartLevel = 1;
                this.dialog.owner.abstractLists.push(abstractList);
                return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels[0];
                // return this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.getItem(0);
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    get listLevelPattern() {
        if (!isNullOrUndefined(this.listLevel)) {
            return this.listLevel.listLevelPattern;
        }
        return 'Arabic';
    }
    /**
     * @private
     */
    set listLevelPattern(value) {
        if (!isNullOrUndefined(this.listLevel)) {
            this.listLevel.listLevelPattern = value;
        }
    }
    /**
     * @private
     */
    get followCharacter() {
        if (!isNullOrUndefined(this.listLevel)) {
            return this.listLevel.followCharacter;
        }
        return 'None';
    }
    /**
     * @private
     */
    set followCharacter(value) {
        if (!isNullOrUndefined(this.listLevel)) {
            this.listLevel.followCharacter = value;
        }
    }
    createList() {
        this.list = new WList();
        this.list.listId = this.dialog.owner.lists.length + 1;
        let abstractList = new WAbstractList();
        abstractList.abstractListId = this.dialog.owner.abstractLists.length + 1;
        this.list.abstractListId = abstractList.abstractListId;
        this.dialog.owner.lists.push(this.list);
        let listLevel = new WListLevel(abstractList);
        listLevel.paragraphFormat = new WParagraphFormat(listLevel);
        listLevel.paragraphFormat.leftIndent = 48;
        listLevel.paragraphFormat.firstLineIndent = -24;
        listLevel.characterFormat = new WCharacterFormat(listLevel);
        listLevel.numberFormat = '%1.';
        listLevel.startAt = 1;
        abstractList.levels.push(listLevel);
        this.dialog.owner.abstractLists.push(abstractList);
    }
    addListLevels() {
        if (!isNullOrUndefined(this.list) && !isNullOrUndefined(this.list.abstractListId)) {
            for (let i = this.dialog.owner.getAbstractListById(this.list.abstractListId).levels.length; i < 9; i++) {
                let listLevelAdv = new WListLevel(this.dialog.owner.getAbstractListById(this.list.abstractListId));
                listLevelAdv.characterFormat = new WCharacterFormat(listLevelAdv);
                listLevelAdv.paragraphFormat = new WParagraphFormat(listLevelAdv);
                listLevelAdv.paragraphFormat.leftIndent = (i + 1) * 48;
                listLevelAdv.paragraphFormat.firstLineIndent = -24;
                listLevelAdv.numberFormat = '%' + (i + 1).toString() + '.';
                listLevelAdv.listLevelPattern = 'Arabic';
                listLevelAdv.followCharacter = 'Tab';
                listLevelAdv.startAt = 1;
                listLevelAdv.restartLevel = i;
                (this.dialog.owner).getAbstractListById(this.list.abstractListId).levels.push(listLevelAdv);
            }
        }
    }
    /**
     * @private
     */
    destroy() {
        this.list = undefined;
        this.followCharacter = undefined;
        this.levelNumber = undefined;
        this.listLevelPattern = undefined;
    }
}

// tslint:disable-next-line:max-line-length
/**
 * The List dialog is used to create or modify lists.
 */
/* tslint:disable:no-any */
class ListDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.dialog = undefined;
        this.target = undefined;
        /**
         * @private
         */
        this.owner = undefined;
        this.viewModel = undefined;
        this.startAt = undefined;
        this.textIndent = undefined;
        this.alignedAt = undefined;
        this.listLevelElement = undefined;
        this.followNumberWith = undefined;
        this.numberStyle = undefined;
        this.numberFormat = undefined;
        this.restartBy = undefined;
        /**
         * @private
         */
        this.isListCharacterFormat = false;
        this.onTextIndentChanged = (args) => {
            this.viewModel.listLevel.paragraphFormat.leftIndent = args.value;
        };
        this.onStartValueChanged = (args) => {
            if (!isNullOrUndefined(this.viewModel) && !isNullOrUndefined(this.viewModel.listLevel)) {
                this.viewModel.listLevel.startAt = args.value;
            }
        };
        this.onListLevelValueChanged = (args) => {
            this.viewModel.levelNumber = parseInt(args.value.slice(args.value.length - 1), 10) - 1;
            if (isNullOrUndefined(this.listLevel)) {
                return;
            }
            if (isNullOrUndefined(this.listLevel.characterFormat)) {
                this.listLevel.characterFormat = new WCharacterFormat(this.viewModel.listLevel);
            }
            if (!isNullOrUndefined(this.listLevel.paragraphFormat)) {
                this.listLevel.paragraphFormat = new WParagraphFormat(this.viewModel.listLevel);
            }
            this.updateDialogValues();
            this.updateRestartLevelBox();
        };
        this.onNumberFormatChanged = (args) => {
            this.viewModel.listLevel.numberFormat = args.target.value;
        };
        this.onAlignedAtValueChanged = (args) => {
            this.viewModel.listLevel.paragraphFormat.firstLineIndent = args.value;
        };
        this.onFollowCharacterValueChanged = (args) => {
            if (args.value) {
                this.viewModel.followCharacter = args.value;
            }
        };
        this.onLevelPatternValueChanged = (args) => {
            this.viewModel.listLevelPattern = args.value;
            let numberFormat = '%' + (this.levelNumber + 1).toString();
            // tslint:disable-next-line:max-line-length
            let numberFormatTextBox = document.getElementById(this.owner.owner.containerId + '_numberFormat');
            if (this.listLevel.listLevelPattern === 'Bullet') {
                this.listLevel.numberFormat = '\uf0b7';
                numberFormatTextBox.value = this.listLevel.numberFormat;
                this.listLevel.characterFormat.fontFamily = 'Wingdings';
            }
            else {
                if (this.listLevel.listLevelPattern === 'None') {
                    this.listLevel.numberFormat = '';
                }
                if (!this.listLevel.numberFormat.match(numberFormat) && this.listLevel.listLevelPattern !== 'None') {
                    this.listLevel.numberFormat = numberFormat + '.';
                }
                numberFormatTextBox.value = this.listLevel.numberFormat;
            }
        };
        this.loadListDialog = () => {
            this.owner.updateFocus();
            if (isNullOrUndefined(this.owner.owner)) {
                return;
            }
            this.viewModel = new ListViewModel();
            this.viewModel.dialog = this;
            if (this.owner.selection.paragraphFormat.listLevelNumber > 0) {
                this.viewModel.levelNumber = this.owner.selection.paragraphFormat.listLevelNumber;
            }
            this.viewModel.list = this.owner.selection.paragraphFormat.getList();
            if (isNullOrUndefined(this.listLevel)) {
                return;
            }
            if (isNullOrUndefined(this.listLevel.characterFormat)) {
                this.listLevel.characterFormat = new WCharacterFormat(this.viewModel.listLevel);
            }
            if (isNullOrUndefined(this.listLevel.paragraphFormat)) {
                this.listLevel.paragraphFormat = new WParagraphFormat(this.viewModel.listLevel);
            }
            this.updateDialogValues();
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
        };
        this.showFontDialog = () => {
            this.owner.owner.fontDialogModule.showFontDialog(this.listLevel.characterFormat);
        };
        this.onApplyList = () => {
            if (!isNullOrUndefined(this.owner)) {
                this.owner.selection.paragraphFormat.setList(this.list);
            }
            this.owner.dialog2.hide();
            this.owner.updateFocus();
        };
        this.onCancelButtonClick = () => {
            this.disposeBindingForListUI();
            this.owner.dialog2.hide();
            this.owner.updateFocus();
            this.isListCharacterFormat = false;
        };
        this.closeListDialog = () => {
            this.disposeBindingForListUI();
            this.owner.updateFocus();
            this.isListCharacterFormat = false;
        };
        this.owner = viewer;
        this.viewModel = new ListViewModel();
    }
    /**
     * @private
     */
    get listLevel() {
        if (!isNullOrUndefined(this.viewModel)) {
            return this.viewModel.listLevel;
        }
        return undefined;
    }
    /**
     * @private
     */
    get list() {
        if (!isNullOrUndefined(this.viewModel)) {
            return this.viewModel.list;
        }
        return undefined;
    }
    /**
     * @private
     */
    get levelNumber() {
        if (this.listLevel.ownerBase instanceof WLevelOverride) {
            return this.listLevel.ownerBase.levelNumber;
            // tslint:disable-next-line:max-line-length
        }
        else if (this.listLevel.ownerBase instanceof WAbstractList && !isNullOrUndefined(this.listLevel.ownerBase.levels)) {
            return this.listLevel.ownerBase.levels.indexOf(this.listLevel);
        }
        else {
            return -1;
        }
    }
    /**
     * @private
     */
    getModuleName() {
        return 'ListDialog';
    }
    /**
     * @private
     */
    showListDialog() {
        let locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initListDialog(locale, this.owner.owner.enableRtl);
        }
        this.isListCharacterFormat = true;
        this.owner.dialog2.header = locale.getConstant('Define new Multilevel list');
        this.owner.dialog2.height = 'auto';
        this.owner.dialog2.width = 'auto';
        this.owner.dialog2.content = this.target;
        let buttonClass;
        let isRtl = this.owner.owner.enableRtl;
        if (isRtl) {
            buttonClass = 'e-flat e-list-dlg-font e-de-dlg-target.e-de-rtl e-font-rtl';
        }
        else {
            buttonClass = 'e-flat e-list-dlg-font e-font';
        }
        this.owner.dialog2.buttons = [{
                click: this.showFontDialog,
                buttonModel: { content: locale.getConstant('Font'), cssClass: buttonClass }
            }, {
                click: this.onApplyList,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-list-dlg', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-list-dlg' }
            }];
        this.owner.dialog2.dataBind();
        this.wireAndBindEvent(locale, isRtl);
        this.owner.dialog2.beforeOpen = this.loadListDialog;
        this.owner.dialog2.close = this.closeListDialog;
        this.owner.dialog2.position = { X: 'center', Y: 'top' };
        this.owner.dialog2.show();
    }
    /**
     * Shows the table properties dialog
     * @private
     */
    initListDialog(locale, isRtl) {
        let containerId = this.owner.owner.containerId;
        let id = containerId + '_insert_list';
        this.target = createElement('div', { id: id, className: 'e-de-list-dlg' });
        // tslint:disable-next-line:max-line-length
        let listLevelDiv = createElement('div', { innerHTML: '<label id="' + containerId + '_listLevellabel" style="display:block;" class=e-de-list-ddl-header-list-level>' + locale.getConstant('List level') + '</label><label id="' + containerId + '_modifyLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Choose level to modify') + '</label><select style="height:20px;width:43%" id="' + containerId + '_listLevel"><option>' + locale.getConstant('Level') + ' 1' + '</option><option>' + locale.getConstant('Level') + ' 2' + '</option><option>' + locale.getConstant('Level') + ' 3' + '</option><option>' + locale.getConstant('Level') + ' 4' + '</option><option>' + locale.getConstant('Level') + ' 5' + '</option><option>' + locale.getConstant('Level') + ' 6' + '</option><option>' + locale.getConstant('Level') + ' 7' + '</option><option>' + locale.getConstant('Level') + ' 8' + '</option><option>' + locale.getConstant('Level') + ' 9' + '</option></select>' });
        this.target.appendChild(listLevelDiv);
        let div = createElement('div');
        let divStyle;
        if (isRtl) {
            divStyle = '<div style="float:right;display:block;width:241px;">';
        }
        else {
            divStyle = '<div style="float:left;display:block;">';
        }
        // tslint:disable-next-line:max-line-length
        let numberStyleDiv = createElement('div', { innerHTML: divStyle + '<label id="' + containerId + '_numberFormatLabel" style="display:block;" class=e-de-list-ddl-header>' + locale.getConstant('Number format') + '</label><label id="' + containerId + '_numberStyleLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Number style for this level') + '</label><select style="height:20px;width:100%" id="' + containerId + '_numberStyle"><option>' + locale.getConstant('Arabic') + '</option><option>' + locale.getConstant('UpRoman') + '</option><option>' + locale.getConstant('LowRoman') + '</option><option>' + locale.getConstant('UpLetter') + '</option><option>' + locale.getConstant('LowLetter') + '</option><option>' + locale.getConstant('Number') + '</option><option>' + locale.getConstant('Leading zero') + '</option><option>' + locale.getConstant('Bullet') + '</option><option>' + locale.getConstant('Ordinal') + '</option><option>' + locale.getConstant('Ordinal Text') + '</option><option>' + locale.getConstant('Special') + '</option><option>' + locale.getConstant('For East') + '</option></select><label id="' + containerId + '_startAtLabel" style="display:block;" class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Start at') + '</label><input type="text" id="' + containerId + '_startAt">' });
        div.appendChild(numberStyleDiv);
        // tslint:disable-next-line:max-line-length
        this.numberFormatDiv = createElement('div', { className: 'e-de-list-dlg-subdiv', innerHTML: '<div><div><label id="' + containerId + '_formatLabel" style="display:inline-block;width:86%" class=e-de-list-ddl-subheader>' + locale.getConstant('Enter formatting for number') + '</label><button type="button" id="' + containerId + '_list_info" class="e-control e-btn e-primary e-de-list-format-info">i</button></div><input style=width:180px; type="text" id="' + containerId + '_numberFormat" class=e-input></div><label id="' + containerId + '_restartLabel" style="display:block;" class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Restart list after') + '</label><select style="height:20px;width:100%" id="' + containerId + '_restartBy"><option>' + locale.getConstant('No Restart') + '</option></select></div>' });
        div.appendChild(this.numberFormatDiv);
        this.target.appendChild(div);
        let indentsDivLabelStyle;
        if (isRtl) {
            indentsDivLabelStyle = 'display:block;position:relative; ';
        }
        else {
            indentsDivLabelStyle = 'display:block; ';
        }
        // tslint:disable-next-line:max-line-length
        let indentsDiv = createElement('div', { innerHTML: divStyle + '<label id="' + containerId + '_IndentsLabel" style=' + indentsDivLabelStyle + 'class=e-de-list-ddl-header>' + locale.getConstant('Position') + '</label><label id="' + containerId + '_textIndentLabel" style=' + indentsDivLabelStyle + 'class=e-de-list-ddl-subheader>' + locale.getConstant('Text indent at') + '</label><input type="text" id="' + containerId + '_textIndent"><label id="' + containerId + '_followCharacterLabel" style=' + indentsDivLabelStyle + 'class=e-de-list-ddl-subheaderbottom>' + locale.getConstant('Follow number with') + '</label><select style="height:20px;width:100%" id="' + containerId + '_followCharacter"><option>' + locale.getConstant('Tab character') + '</option><option>' + locale.getConstant('Space') + '</option><option>' + locale.getConstant('Nothing') + '</option></select></div><div id="e-de-list-dlg-div" class="e-de-list-dlg-div"><label id="' + containerId + '_alignedAtLabel" style="display:block;" class=e-de-list-ddl-subheader>' + locale.getConstant('Aligned at') + '</label><input type="text" id="' + containerId + '_alignedAt"></div>', });
        this.target.appendChild(indentsDiv);
    }
    wireAndBindEvent(locale, isRtl) {
        let instance = this;
        let containerId = this.owner.owner.containerId;
        if (isRtl) {
            document.getElementById('e-de-list-dlg-div').classList.add('e-de-rtl');
            this.numberFormatDiv.classList.add('e-de-rtl');
        }
        let startAtTextBox = document.getElementById(containerId + '_startAt');
        let textIndentAtTextBox = document.getElementById(containerId + '_textIndent');
        let alignedAtTextBox = document.getElementById(containerId + '_alignedAt');
        this.startAt = new NumericTextBox({
            format: '#',
            decimals: 0,
            min: 0,
            max: 50,
            width: '180px',
            enablePersistence: false,
        });
        this.startAt.addEventListener('change', instance.onStartValueChanged);
        this.startAt.appendTo(startAtTextBox);
        this.textIndent = new NumericTextBox({
            format: '#',
            decimals: 0,
            min: 0,
            max: 1584,
            width: '180px',
            step: 4,
            enablePersistence: false
        });
        this.textIndent.addEventListener('change', instance.onTextIndentChanged);
        this.textIndent.appendTo(textIndentAtTextBox);
        this.alignedAt = new NumericTextBox({
            format: '#',
            max: 1584,
            step: 6,
            width: '180px',
            enablePersistence: false
        });
        this.alignedAt.addEventListener('change', instance.onAlignedAtValueChanged);
        this.alignedAt.appendTo(alignedAtTextBox);
        let listLevel = document.getElementById(containerId + '_listLevel');
        // tslint:disable-next-line:max-line-length
        this.listLevelElement = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl, change: instance.onListLevelValueChanged });
        this.listLevelElement.appendTo(listLevel);
        let followCharacterElement = document.getElementById(containerId + '_followCharacter');
        // tslint:disable-next-line:max-line-length
        this.followNumberWith = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl, change: instance.onFollowCharacterValueChanged });
        this.followNumberWith.appendTo(followCharacterElement);
        let numberStyleEle = document.getElementById(containerId + '_numberStyle');
        // tslint:disable-next-line:max-line-length
        this.numberStyle = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl, change: instance.onLevelPatternValueChanged });
        this.numberStyle.appendTo(numberStyleEle);
        this.numberFormat = document.getElementById(containerId + '_numberFormat');
        this.numberFormat.addEventListener('change', instance.onNumberFormatChanged);
        let restartElement = document.getElementById(containerId + '_restartBy');
        this.restartBy = new DropDownList({ popupHeight: '150px', width: '180px', enableRtl: isRtl });
        this.restartBy.appendTo(restartElement);
        let button = document.getElementById(containerId + '_list_info');
        this.formatInfoToolTip = new Tooltip({ width: 200 });
        // tslint:disable-next-line:max-line-length
        this.formatInfoToolTip.content = locale.getConstant('Number format tooltip information');
        this.formatInfoToolTip.position = 'RightTop';
        this.formatInfoToolTip.appendTo(button);
    }
    updateRestartLevelBox() {
        let containerId = this.owner.owner.containerId;
        let listLevel = document.getElementById(containerId + '_listLevel');
        let restartBy = document.getElementById(containerId + '_restartBy');
        for (let i = 0; i < restartBy.options.length; i) {
            restartBy.options.remove(i);
        }
        if (listLevel.selectedIndex === 0) {
            let option = document.createElement('option');
            option.value = 'No Restart';
            option.innerHTML = 'No Restart';
            restartBy.appendChild(option);
        }
        else {
            for (let i = listLevel.selectedIndex; i > 0; i--) {
                let option = document.createElement('option');
                option.value = 'Level ' + i;
                option.innerHTML = 'Level ' + i;
                restartBy.appendChild(option);
            }
            let option = document.createElement('option');
            option.value = 'No Restart';
            option.innerHTML = 'No Restart';
            restartBy.appendChild(option);
        }
        restartBy.selectedIndex = 0;
    }
    listPatternConverter(listLevelPattern) {
        switch (listLevelPattern) {
            case 'Arabic': return 0;
            case 'UpRoman': return 1;
            case 'LowRoman': return 2;
            case 'UpLetter': return 3;
            case 'LowLetter': return 4;
            case 'Number': return 5;
            case 'LeadingZero': return 6;
            case 'Bullet': return 7;
            case 'Ordinal': return 8;
            case 'OrdinalText': return 9;
            case 'Special': return 10;
            case 'FarEast': return 11;
            default: return 12;
        }
    }
    followCharacterConverter(followCharacter) {
        switch (followCharacter) {
            case 'Tab':
                return 0;
            case 'Space':
                return 1;
            default:
                return 2;
        }
    }
    updateDialogValues() {
        // tslint:disable-next-line:max-line-length
        let restartByTextBox = document.getElementById(this.owner.owner.containerId + '_restartBy');
        if (!isNullOrUndefined(this.viewModel) && !isNullOrUndefined(this.viewModel.listLevel)) {
            this.startAt.value = this.viewModel.listLevel.startAt;
            this.textIndent.value = this.viewModel.listLevel.paragraphFormat.leftIndent;
            this.alignedAt.value = this.viewModel.listLevel.paragraphFormat.firstLineIndent;
            this.followNumberWith.index = this.followCharacterConverter(this.viewModel.followCharacter);
            this.numberFormat.value = this.viewModel.listLevel.numberFormat;
            this.numberStyle.index = this.listPatternConverter(this.viewModel.listLevelPattern);
            this.listLevelElement.index = this.viewModel.levelNumber;
            this.viewModel.levelNumber = this.viewModel.levelNumber;
        }
    }
    disposeBindingForListUI() {
        this.followNumberWith.index = -1;
        this.numberFormat.value = ' ';
        this.numberStyle.index = -1;
        this.listLevelElement.index = -1;
        this.restartBy.index = -1;
        this.viewModel.destroy();
    }
    /**
     * @private
     */
    destroy() {
        if (this.alignedAt) {
            this.alignedAt.destroy();
        }
        this.alignedAt = undefined;
        this.dialog = undefined;
        if (this.followNumberWith) {
            this.followNumberWith.destroy();
        }
        this.followNumberWith = undefined;
        if (this.listLevelElement) {
            this.listLevelElement.destroy();
        }
        this.listLevelElement = undefined;
        if (this.textIndent) {
            this.textIndent.destroy();
        }
        this.textIndent = undefined;
        if (this.startAt) {
            this.startAt.destroy();
        }
        this.startAt = undefined;
        if (this.numberStyle) {
            this.numberStyle.destroy();
        }
        this.numberStyle = undefined;
        this.numberFormat = undefined;
        if (this.restartBy) {
            this.restartBy.destroy();
        }
        this.restartBy = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let l = 0; l < this.target.childNodes.length; l++) {
                this.target.removeChild(this.target.childNodes[l]);
                l--;
            }
            this.target = undefined;
        }
        this.owner = undefined;
        this.viewModel = undefined;
    }
}
/* tslint:enable:no-any */

/**
 * The Style dialog is used to create or modify styles.
 */
class StyleDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.target = undefined;
        this.styleType = undefined;
        this.styleBasedOn = undefined;
        this.styleParagraph = undefined;
        this.onlyThisDocument = undefined;
        this.template = undefined;
        this.fontFamily = undefined;
        this.fontSize = undefined;
        this.characterFormat = undefined;
        this.paragraphFormat = undefined;
        /* tslint:disable-next-line:no-any */
        this.openDialog = (args) => {
            switch (args.item.id) {
                case 'style_font':
                    this.showFontDialog();
                    break;
                case 'style_paragraph':
                    this.showParagraphDialog();
                    break;
                case 'style_numbering':
                    this.showNumberingBulletDialog();
                    break;
            }
        };
        this.setBoldProperty = () => {
            this.characterFormat.bold = !this.characterFormat.bold;
            this.fontButtonClicked(undefined);
        };
        this.setItalicProperty = () => {
            this.characterFormat.italic = !this.characterFormat.italic;
            this.fontButtonClicked(undefined);
        };
        this.setUnderlineProperty = () => {
            this.characterFormat.underline = this.characterFormat.underline === 'None' ? 'Single' : 'None';
            this.fontButtonClicked(undefined);
        };
        /* tslint:disable-next-line:no-any */
        this.fontButtonClicked = (args) => {
            if (this.characterFormat.bold) {
                if (!this.bold.classList.contains('e-active')) {
                    this.bold.classList.add('e-active');
                }
            }
            else {
                if (this.bold.classList.contains('e-active')) {
                    this.bold.classList.remove('e-active');
                }
            }
            if (this.characterFormat.italic) {
                if (!this.italic.classList.contains('e-active')) {
                    this.italic.classList.add('e-active');
                }
            }
            else {
                if (this.italic.classList.contains('e-active')) {
                    this.italic.classList.remove('e-active');
                }
            }
            if (this.characterFormat.underline !== undefined && this.characterFormat.underline !== 'None') {
                if (!this.underline.classList.contains('e-active')) {
                    this.underline.classList.add('e-active');
                    this.characterFormat.underline = 'Single';
                }
            }
            else {
                if (this.underline.classList.contains('e-active')) {
                    this.underline.classList.remove('e-active');
                    this.characterFormat.underline = 'None';
                }
            }
        };
        /* tslint:disable-next-line:no-any */
        this.fontSizeUpdate = (args) => {
            this.characterFormat.fontSize = args.value;
        };
        /* tslint:disable-next-line:no-any */
        this.fontFamilyChanged = (args) => {
            this.characterFormat.fontFamily = args.value;
        };
        /* tslint:disable-next-line:no-any */
        this.fontColorUpdate = (args) => {
            this.characterFormat.fontColor = args.currentValue.rgba;
        };
        this.setLeftAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Left') {
                this.paragraphFormat.textAlignment = 'Justify';
            }
            else {
                this.paragraphFormat.textAlignment = 'Left';
            }
            this.updateParagraphFormat();
        };
        this.setRightAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Right') {
                this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                this.paragraphFormat.textAlignment = 'Right';
            }
            this.updateParagraphFormat();
        };
        this.setCenterAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Center') {
                this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                this.paragraphFormat.textAlignment = 'Center';
            }
            this.updateParagraphFormat();
        };
        this.setJustifyAlignment = () => {
            if (this.paragraphFormat.textAlignment === 'Justify') {
                this.paragraphFormat.textAlignment = 'Left';
            }
            else {
                this.paragraphFormat.textAlignment = 'Justify';
            }
            this.updateParagraphFormat();
        };
        this.increaseBeforeAfterSpacing = () => {
            this.paragraphFormat.beforeSpacing += 6;
            this.paragraphFormat.afterSpacing += 6;
        };
        this.decreaseBeforeAfterSpacing = () => {
            if (this.paragraphFormat.beforeSpacing >= 6) {
                this.paragraphFormat.beforeSpacing -= 6;
            }
            else {
                this.paragraphFormat.beforeSpacing = 0;
            }
            if (this.paragraphFormat.afterSpacing >= 6) {
                this.paragraphFormat.afterSpacing -= 6;
            }
            else {
                this.paragraphFormat.afterSpacing = 0;
            }
        };
        /**
         * @private
         */
        this.updateNextStyle = (args) => {
            let typedName = args.srcElement.value;
            // tslint:disable-next-line:max-line-length
            if (this.getTypeValue() === this.localObj.getConstant('Paragraph') && !isNullOrUndefined(typedName) && typedName !== '' && !this.isUserNextParaUpdated) {
                let styles = this.owner.owner.viewer.styles.getStyleNames(this.getTypeValue());
                if (this.isEdit) {
                    styles = styles.filter((e) => e !== this.editStyleName);
                }
                styles.push(typedName);
                this.styleParagraph.dataSource = styles;
                this.styleParagraph.index = null;
                this.styleParagraph.index = styles.indexOf(typedName);
                this.styleParagraph.dataBind();
            }
        };
        /**
         * @private
         */
        this.updateOkButton = () => {
            let styleName = this.target.getElementsByClassName('e-input e-de-style-dlg-name-input').item(0).value;
            this.enableOrDisableOkButton();
        };
        /**
         * @private
         */
        /* tslint:disable-next-line:no-any */
        this.styleTypeChange = (args) => {
            if (args.isInteracted) {
                let type;
                if (args.value === this.localObj.getConstant('Character')) {
                    this.style = new WCharacterStyle();
                    type = 'Character';
                }
                // tslint:disable-next-line:max-line-length
                if (args.value === this.localObj.getConstant('Paragraph') || args.value === this.localObj.getConstant('Linked(Paragraph and Character)')) {
                    this.style = new WParagraphStyle();
                    type = 'Paragraph';
                }
                this.toggleDisable();
                this.updateStyleNames(type);
            }
        };
        /* tslint:disable-next-line:no-any */
        this.styleBasedOnChange = (args) => {
            //Based on change
        };
        /**
         * @private
         */
        /* tslint:disable-next-line:no-any */
        this.styleParagraphChange = (args) => {
            if (args.isInteracted) {
                this.isUserNextParaUpdated = true;
            }
            //Next change
        };
        /**
         * @private
         */
        this.showFontDialog = () => {
            if (!isNullOrUndefined(this.owner.owner.fontDialogModule)) {
                this.owner.owner.showFontDialog(this.characterFormat);
            }
            this.updateCharacterFormat();
        };
        /**
         * @private
         */
        this.showParagraphDialog = () => {
            if (!isNullOrUndefined(this.owner.owner.paragraphDialogModule)) {
                this.owner.owner.showParagraphDialog(this.paragraphFormat);
            }
        };
        /**
         * @private
         */
        this.showNumberingBulletDialog = () => {
            this.numberingBulletDialog = new BulletsAndNumberingDialog(this.owner.owner.viewer);
            if (this.style instanceof WParagraphStyle && (!isNullOrUndefined(this.style.paragraphFormat))) {
                // tslint:disable-next-line:max-line-length
                this.numberingBulletDialog.showNumberBulletDialog(this.style.paragraphFormat.listFormat, this.abstractList);
            }
        };
        /**
         * @private
         */
        this.onOkButtonClick = () => {
            let styleName = this.styleNameElement.value;
            if (styleName.length > 0) {
                let style = this.owner.owner.viewer.styles.findByName(styleName);
                let name;
                if (!isNullOrUndefined(style)) {
                    this.style.type = this.getTypeValue();
                    this.style.basedOn = this.owner.owner.viewer.styles.findByName(this.styleBasedOn.value);
                    // tslint:disable-next-line:max-line-length
                    if (this.styleType.value === this.localObj.getConstant('Paragraph') || this.styleType.value === this.localObj.getConstant('Linked(Paragraph and Character)')) {
                        this.style.next = this.owner.owner.viewer.styles.findByName(this.styleParagraph.value);
                        this.style.characterFormat.mergeFormat(style.characterFormat);
                        this.style.paragraphFormat.mergeFormat(style.paragraphFormat, true);
                        this.updateList();
                        // tslint:disable-next-line:max-line-length
                        this.style.link = (this.styleType.value === this.localObj.getConstant('Linked(Paragraph and Character)')) ? this.createLinkStyle(styleName, this.isEdit) : undefined;
                    }
                    //Updating existing style implementation
                    this.style.name = style.name;
                    name = style.name;
                    style = this.style;
                    this.owner.owner.isShiftingEnabled = true;
                    this.owner.owner.editorModule.layoutWholeDocument();
                    this.owner.owner.isShiftingEnabled = false;
                }
                else {
                    /* tslint:disable-next-line:no-any */
                    let tmpStyle = this.getTypeValue() === 'Paragraph' ? new WParagraphStyle() : new WCharacterStyle;
                    tmpStyle.copyStyle(this.style);
                    /* tslint:disable-next-line:no-any */
                    let basedOn = this.owner.owner.viewer.styles.findByName(this.styleBasedOn.value);
                    // tslint:disable-next-line:max-line-length
                    if (this.styleType.value === this.localObj.getConstant('Paragraph') || this.styleType.value === this.localObj.getConstant('Linked(Paragraph and Character)')) {
                        if (styleName === this.styleParagraph.value) {
                            tmpStyle.next = tmpStyle;
                        }
                        else {
                            tmpStyle.next = this.owner.owner.viewer.styles.findByName(this.styleParagraph.value);
                        }
                        this.updateList();
                    }
                    // tslint:disable-next-line:max-line-length
                    tmpStyle.link = (this.styleType.value === this.localObj.getConstant('Linked(Paragraph and Character)')) ? this.createLinkStyle(styleName) : undefined;
                    tmpStyle.type = this.getTypeValue();
                    tmpStyle.name = styleName;
                    tmpStyle.basedOn = basedOn;
                    /* tslint:disable-next-line:no-any */
                    this.owner.owner.viewer.styles.push(tmpStyle);
                    name = styleName;
                    this.owner.owner.editorModule.applyStyle(name);
                }
                this.owner.owner.viewer.dialog2.hide();
            }
            else {
                throw new Error('Enter valid Style name');
            }
            if (this.style) {
                //this.style.destroy();
            }
        };
        /* tslint:disable-next-line:no-any */
        this.loadStyleDialog = (args) => {
            this.owner.owner.viewer.updateFocus();
            this.isUserNextParaUpdated = false;
            /* tslint:disable-next-line:max-line-length */
            this.styleNameElement = this.target.getElementsByClassName('e-input e-de-style-dlg-name-input').item(0);
            this.styleNameElement.value = null;
            if (!this.isEdit) {
                this.styleType.index = 0; //Set to paragraph            
            }
            let name;
            if (this.isEdit) {
                this.styleNameElement.value = this.editStyleName;
                name = this.editStyleName;
            }
            /* tslint:disable-next-line:max-line-length */
            this.okButton = this.owner.dialog2.element.getElementsByClassName('e-flat e-style-okay').item(0);
            this.enableOrDisableOkButton();
            this.updateStyleNames(this.getTypeValue(), name);
            this.updateCharacterFormat(this.style.characterFormat);
            this.updateParagraphFormat(this.style.paragraphFormat);
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            if (!this.isEdit && this.style) {
                this.style.destroy();
            }
            this.owner.owner.viewer.dialog2.hide();
        };
        /**
         * @private
         */
        this.closeStyleDialog = () => {
            this.owner.owner.viewer.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'StyleDialog';
    }
    /**
     * @private
     */
    //tslint:disable: max-func-body-length
    initStyleDialog(localValue, isRtl) {
        this.localObj = localValue;
        let id = this.owner.owner.containerId + '_style';
        this.target = createElement('div', { id: id, className: 'e-de-style-dialog' });
        let container = createElement('div');
        // tslint:disable-next-line:max-line-length
        let properties = createElement('div', { className: 'e-de-style-properties', innerHTML: localValue.getConstant('Properties') });
        container.appendChild(properties);
        let styleNameTypeDiv = createElement('div', { styles: 'display:flex', className: 'e-de-style-nametype-div' });
        container.appendChild(styleNameTypeDiv);
        let nameWholeDiv = createElement('div', { className: 'e-de-style-left-div' });
        styleNameTypeDiv.appendChild(nameWholeDiv);
        let name = createElement('div', { className: 'e-de-style-name', innerHTML: localValue.getConstant('Name') + ':' });
        nameWholeDiv.appendChild(name);
        // tslint:disable-next-line:max-line-length
        let nameValue = createElement('input', { id: this.owner.owner.containerId + '_style_name', styles: 'width:210px;', className: 'e-input e-de-style-dlg-name-input' });
        nameValue.addEventListener('keyup', this.updateOkButton);
        nameValue.addEventListener('input', this.updateOkButton);
        nameValue.addEventListener('blur', this.updateNextStyle);
        nameWholeDiv.appendChild(nameValue);
        let styleTypeWholeDiv = createElement('div');
        styleNameTypeDiv.appendChild(styleTypeWholeDiv);
        // tslint:disable-next-line:max-line-length
        let styleType = createElement('div', { className: 'e-de-style-styletype', innerHTML: localValue.getConstant('Style type') + ':' });
        styleTypeWholeDiv.appendChild(styleType);
        let styleTypeDivElement = createElement('div', { className: 'e-de-style-style-type-div' });
        let styleTypeValue = createElement('select', { id: 'e-de-style-style-type' });
        // tslint:disable-next-line:max-line-length
        styleTypeValue.innerHTML = '<option>' + localValue.getConstant('Paragraph') + '</option><option>' + localValue.getConstant('Character') + '</option><option>' + localValue.getConstant('Linked(Paragraph and Character)') + '</option>'; //<option>Linked(Paragraph and Character)</option><option>Table</option><option>List</option>';
        styleTypeDivElement.appendChild(styleTypeValue);
        this.styleType = new DropDownList({ change: this.styleTypeChange, popupHeight: '253px', width: '210px', enableRtl: isRtl });
        this.styleType.appendTo(styleTypeValue);
        styleTypeWholeDiv.appendChild(styleTypeDivElement);
        // tslint:disable-next-line:max-line-length
        let styleBasedParaDiv = createElement('div', { styles: 'display:flex', className: 'e-de-style-based-para-div' });
        container.appendChild(styleBasedParaDiv);
        let styleBasedOnWholeDiv = createElement('div', { className: 'e-de-style-left-div' });
        styleBasedParaDiv.appendChild(styleBasedOnWholeDiv);
        // tslint:disable-next-line:max-line-length
        let styleBasedOn = createElement('div', { className: 'e-de-style-style-based-on', innerHTML: localValue.getConstant('Style based on') + ':' });
        styleBasedOnWholeDiv.appendChild(styleBasedOn);
        let styleBasedOnDivElement = createElement('div', { className: 'e-de-style-style-based-on-div' });
        // tslint:disable-next-line:max-line-length
        let styleBasedOnValue = createElement('input', { id: 'e-de-style-style-based-on-value' });
        //styleBasedOnValue.innerHTML = '<option>Normal</option><option>Heading 1</option><option>Heading 2</option><option>Heading 3</option><option>Heading 4</option><option>Heading 5</option><option>Heading 6</option>';
        styleBasedOnDivElement.appendChild(styleBasedOnValue);
        // tslint:disable-next-line:max-line-length
        this.styleBasedOn = new DropDownList({ dataSource: [], select: this.styleBasedOnChange, popupHeight: '253px', width: '210px', enableRtl: isRtl });
        this.styleBasedOn.appendTo(styleBasedOnValue);
        styleBasedOnWholeDiv.appendChild(styleBasedOnDivElement);
        let styleParagraphWholeDiv = createElement('div');
        styleBasedParaDiv.appendChild(styleParagraphWholeDiv);
        if (isRtl) {
            nameWholeDiv.classList.add('e-de-rtl');
            styleBasedOnWholeDiv.classList.add('e-de-rtl');
            styleParagraphWholeDiv.classList.add('e-de-rtl');
        }
        // tslint:disable-next-line:max-line-length
        let styleParagraph = createElement('div', { className: 'e-de-style-style-paragraph', innerHTML: localValue.getConstant('Style for following paragraph') + ':' });
        styleParagraphWholeDiv.appendChild(styleParagraph);
        let styleParagraphDivElement = createElement('div', { className: 'e-de-style-style-paragraph-div' });
        // tslint:disable-next-line:max-line-length
        let styleParagraphValue = createElement('input', { id: 'e-de-style-style-paragraph-value' });
        // tslint:disable-next-line:max-line-length
        //styleParagraphValue.innerHTML = '<option>Normal</option><option>Heading 1</option><option>Heading 2</option><option>Heading 3</option><option>Heading 4</option><option>Heading 5</option><option>Heading 6</option>';
        styleParagraphDivElement.appendChild(styleParagraphValue);
        // tslint:disable-next-line:max-line-length
        this.styleParagraph = new DropDownList({ dataSource: [], select: this.styleParagraphChange, popupHeight: '253px', width: '210px', enableRtl: isRtl });
        this.styleParagraph.appendTo(styleParagraphValue);
        styleParagraphWholeDiv.appendChild(styleParagraphDivElement);
        // tslint:disable-next-line:max-line-length
        let formatting = createElement('div', { className: 'e-de-style-formatting', innerHTML: localValue.getConstant('Formatting') });
        container.appendChild(formatting);
        let optionsDiv = createElement('div', { className: 'e-de-style-options-div' });
        container.appendChild(optionsDiv);
        let fontOptionsDiv = createElement('div', { styles: 'display:flex;margin-bottom: 14px;' });
        optionsDiv.appendChild(fontOptionsDiv);
        this.createFontOptions(fontOptionsDiv, isRtl);
        let paragraphOptionsDiv = createElement('div', { styles: 'display:flex', className: 'e-style-paragraph' });
        optionsDiv.appendChild(paragraphOptionsDiv);
        this.createParagraphOptions(paragraphOptionsDiv);
        // let radioOptionsDiv: HTMLElement = createElement('div', { styles: 'display:flex' });
        // container.appendChild(radioOptionsDiv);
        // let onlyThisDocumentDiv: HTMLElement = createElement('div', { className: 'e-de-style-radio-button' });
        // tslint:disable-next-line:max-line-length
        // let onlyThisDocument: HTMLInputElement = createElement('input', { className: 'e-de-style-only-this-doc', attrs: { type: 'radio' } }) as HTMLInputElement;
        // onlyThisDocumentDiv.appendChild(onlyThisDocument);
        // tslint:disable-next-line:max-line-length
        // this.onlyThisDocument = new RadioButton({ label: 'Only in this document', value: 'only in this document', checked: true, name: 'styles' });
        // this.onlyThisDocument.appendTo(onlyThisDocument);
        // radioOptionsDiv.appendChild(onlyThisDocumentDiv);
        // let templateDiv: HTMLElement = createElement('div', { className: 'e-de-style-radio-button' });
        // tslint:disable-next-line:max-line-length
        // let template: HTMLInputElement = createElement('input', { className: 'e-de-style-temp', attrs: { type: 'radio' } }) as HTMLInputElement;
        // templateDiv.appendChild(template);
        // this.template = new RadioButton({ label: 'Template', value: 'template', name: 'styles' });
        // this.template.appendTo(template);
        // radioOptionsDiv.appendChild(templateDiv);
        this.createFormatDropdown(container, localValue, isRtl);
        this.target.appendChild(container);
    }
    createFormatDropdown(parentDiv, localValue, isRtl) {
        let formatBtn = createElement('button', {
            id: 'style_format_dropdown', innerHTML: localValue.getConstant('Format'),
            attrs: { type: 'button' }
        });
        formatBtn.style.height = '31px';
        parentDiv.appendChild(formatBtn);
        let items = [{ text: localValue.getConstant('Font') + '..', id: 'style_font' },
            { text: localValue.getConstant('Paragraph') + '..', id: 'style_paragraph' },
            { text: localValue.getConstant('Numbering') + '..', id: 'style_numbering' }];
        this.styleDropdwn = new DropDownButton({
            items: items, cssClass: 'e-de-style-format-dropdwn', enableRtl: isRtl,
            beforeItemRender: (args) => {
                if (this.styleType.value === localValue.getConstant('Character')) {
                    if (args.item.text === localValue.getConstant('Paragraph')) {
                        args.element.classList.add('e-disabled');
                    }
                    if (args.item.text === 'Numbering') {
                        args.element.classList.add('e-disabled');
                    }
                }
                else {
                    if (args.item.text === localValue.getConstant('Paragraph')) {
                        args.element.classList.remove('e-disabled');
                    }
                    if (args.item.text === 'Numbering') {
                        args.element.classList.remove('e-disabled');
                    }
                }
            }
        });
        this.styleDropdwn.appendTo(formatBtn);
        this.styleDropdwn.addEventListener('select', this.openDialog);
    }
    createFontOptions(parentDiv, isRtl) {
        let fontFamilyElement = createElement('select', { id: this.target.id + '_fontName' });
        fontFamilyElement.innerHTML = '<option>Arial</option><option>Calibri</option><option>Candara</option>' +
            '<option>Comic Sans MS</option><option>Consolas</option><option>Constantia</option><option>Corbel</option>' +
            '<option>Courier New</option><option>Ebrima</option><option>Franklin Gothic</option>' +
            '<option>Gabriola</option><option>Gadugi</option><option>Georgia</option><option>Impact</option>' +
            '<option>Javanese Text</option><option>Microsoft Sans Serif</option><option>MS Gothic</option><option>MS UI Gothic</option>' +
            '<option>Segoe Print</option><option>Times New Roman</option><option>Verdana</option><option>Segoe UI</option>' +
            '<option>Algerian</option><option>Cambria</option><option>Georgia</option><option>Consolas</option>';
        parentDiv.appendChild(fontFamilyElement);
        this.fontFamily = new ComboBox({
            width: '123px', popupWidth: '123px',
            cssClass: 'e-style-font-fmaily-right', enableRtl: isRtl, change: this.fontFamilyChanged
        });
        this.fontFamily.showClearButton = false;
        this.fontFamily.appendTo(fontFamilyElement);
        let fontSizeElement = createElement('input');
        parentDiv.appendChild(fontSizeElement);
        let sizeDataSource = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
        this.fontSize = new ComboBox({
            dataSource: sizeDataSource, width: '73px', cssClass: 'e-style-font-fmaily-right',
            enableRtl: isRtl, change: this.fontSizeUpdate
        });
        this.fontSize.showClearButton = false;
        this.fontSize.appendTo(fontSizeElement);
        let fontGroupButton = createElement('div', { className: 'e-de-style-font-group-button' });
        parentDiv.appendChild(fontGroupButton);
        // tslint:disable-next-line:max-line-length
        this.bold = this.createButtonElement(fontGroupButton, 'e-de-bold', 'e-de-style-bold-button-size', this.owner.owner.containerId + '_style_bold');
        this.bold.addEventListener('click', this.setBoldProperty);
        // tslint:disable-next-line:max-line-length
        this.italic = this.createButtonElement(fontGroupButton, 'e-de-italic', 'e-de-style-icon-button-size', this.owner.owner.containerId + '_style_italic');
        this.italic.addEventListener('click', this.setItalicProperty);
        // tslint:disable-next-line:max-line-length
        this.underline = this.createButtonElement(fontGroupButton, 'e-de-underline', 'e-de-style-icon-button-size', this.owner.owner.containerId + '_style_underline');
        this.underline.addEventListener('click', this.setUnderlineProperty);
        let fontColorElement = createElement('input', { attrs: { type: 'color' }, className: 'e-de-style-icon-button-size' });
        parentDiv.appendChild(fontColorElement);
        // tslint:disable-next-line:max-line-length
        this.fontColor = new ColorPicker({ cssClass: 'e-de-style-font-color-picker', enableRtl: isRtl, change: this.fontColorUpdate, locale: this.owner.owner.locale });
        this.fontColor.appendTo(fontColorElement);
    }
    createParagraphOptions(parentDiv) {
        let alignmentDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(alignmentDiv);
        this.leftAlign = this.createButtonElement(alignmentDiv, 'e-de-align-left', 'e-de-style-icon-button-size');
        this.leftAlign.addEventListener('click', this.setLeftAlignment);
        this.centerAlign = this.createButtonElement(alignmentDiv, 'e-de-align-center', 'e-de-style-icon-button-size');
        this.centerAlign.addEventListener('click', this.setCenterAlignment);
        this.rightAlign = this.createButtonElement(alignmentDiv, 'e-de-align-right', 'e-de-style-icon-button-size');
        this.rightAlign.addEventListener('click', this.setRightAlignment);
        this.justify = this.createButtonElement(alignmentDiv, 'e-de-justify', 'e-de-style-icon-button-last-size');
        this.justify.addEventListener('click', this.setJustifyAlignment);
        let lineSpacingDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(lineSpacingDiv);
        this.singleLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-single-spacing', 'e-de-style-icon-button-first-size');
        this.singleLineSpacing.addEventListener('click', () => {
            this.paragraphFormat.lineSpacing = 1;
            this.updateParagraphFormat();
        });
        // tslint:disable-next-line:max-line-length
        this.onePointFiveLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-one-point-five-spacing', 'e-de-style-icon-button-size');
        this.onePointFiveLineSpacing.addEventListener('click', () => {
            this.paragraphFormat.lineSpacing = 1.5;
            this.updateParagraphFormat();
        });
        this.doubleLineSpacing = this.createButtonElement(lineSpacingDiv, 'e-de-double-spacing', 'e-de-style-icon-button-last-size');
        this.doubleLineSpacing.addEventListener('click', () => {
            this.paragraphFormat.lineSpacing = 2;
            this.updateParagraphFormat();
        });
        let spacingDiv = createElement('div', { className: 'e-de-style-paragraph-group-button' });
        parentDiv.appendChild(spacingDiv);
        let beforeSpacing = this.createButtonElement(spacingDiv, 'e-de-before-spacing', 'e-de-style-icon-button-first-size');
        let afterSpacing = this.createButtonElement(spacingDiv, 'e-de-after-spacing', 'e-de-style-icon-button-last-size');
        beforeSpacing.addEventListener('click', this.increaseBeforeAfterSpacing);
        afterSpacing.addEventListener('click', this.decreaseBeforeAfterSpacing);
        let indentingDiv = createElement('div', { className: 'e-de-style-paragraph-indent-group-button' });
        parentDiv.appendChild(indentingDiv);
        let decreaseIndent = this.createButtonElement(indentingDiv, 'e-de-indent', 'e-de-style-icon-button-first-size');
        decreaseIndent.addEventListener('click', () => {
            if (this.paragraphFormat.leftIndent >= 36) {
                this.paragraphFormat.leftIndent -= 36;
            }
            else {
                this.paragraphFormat.leftIndent = 0;
            }
        });
        let increaseindent = this.createButtonElement(indentingDiv, 'e-de-outdent', 'e-de-style-icon-button-size');
        increaseindent.addEventListener('click', () => {
            this.paragraphFormat.leftIndent += 36;
        });
    }
    createButtonElement(parentDiv, iconCss, className, id) {
        let buttonElement = createElement('button', { attrs: { type: 'button' } });
        if (!isNullOrUndefined(id)) {
            buttonElement.id = id;
        }
        parentDiv.appendChild(buttonElement);
        let button = new Button({ iconCss: iconCss, cssClass: className });
        button.appendTo(buttonElement);
        return buttonElement;
    }
    toggleDisable() {
        if (this.styleType.value === this.localObj.getConstant('Character')) {
            this.styleParagraph.enabled = false;
            // tslint:disable-next-line:max-line-length
            this.target.getElementsByClassName('e-style-paragraph').item(0).setAttribute('style', 'display:flex;pointer-events:none;opacity:0.5');
        }
        else {
            this.styleParagraph.enabled = true;
            this.target.getElementsByClassName('e-style-paragraph').item(0).removeAttribute('style');
            this.target.getElementsByClassName('e-style-paragraph').item(0).setAttribute('style', 'display:flex');
        }
        this.styleBasedOn.enabled = true;
    }
    /**
     * @private
     */
    show(styleName, header) {
        let localObj = new L10n('documenteditor', this.owner.owner.defaultLocale);
        this.isEdit = (!isNullOrUndefined(styleName) && styleName.length > 0) ? true : false;
        this.editStyleName = styleName;
        this.abstractList = new WAbstractList();
        // tslint:disable-next-line:max-line-length
        let style = this.owner.owner.viewer.styles.findByName(styleName);
        this.style = !this.isEdit ? new WParagraphStyle() : style ? style : this.getStyle(styleName);
        localObj.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initStyleDialog(localObj, this.owner.owner.enableRtl);
        }
        if (isNullOrUndefined(header)) {
            header = localObj.getConstant('Create New Style');
        }
        this.owner.owner.viewer.dialog2.header = header;
        this.owner.owner.viewer.dialog2.height = 'auto';
        this.owner.owner.viewer.dialog2.width = 'auto';
        this.owner.owner.viewer.dialog2.content = this.target;
        this.owner.owner.viewer.dialog2.buttons = [{
                click: this.onOkButtonClick,
                buttonModel: { content: localObj.getConstant('Ok'), cssClass: 'e-flat e-style-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: localObj.getConstant('Cancel'), cssClass: 'e-flat e-style-cancel' }
            }];
        this.toggleDisable();
        this.owner.owner.viewer.dialog2.dataBind();
        this.owner.owner.viewer.dialog2.beforeOpen = this.loadStyleDialog;
        this.owner.owner.viewer.dialog2.close = this.closeStyleDialog;
        this.owner.owner.viewer.dialog2.position = { X: 'center', Y: 'center' };
        this.owner.owner.viewer.dialog2.show();
    }
    updateList() {
        let listId = this.style.paragraphFormat.listFormat.listId;
        if (listId > -1) {
            if (this.owner.owner.viewer.lists.filter((a) => (a.listId === listId)).length === 0) {
                this.owner.owner.viewer.lists.push(this.style.paragraphFormat.listFormat.list);
            }
            else {
                this.owner.owner.viewer.lists = this.owner.owner.viewer.lists.filter((a) => (a.listId !== listId));
                this.owner.owner.viewer.lists.push(this.style.paragraphFormat.listFormat.list);
            }
        }
        if (this.abstractList.abstractListId !== -1) {
            this.owner.owner.viewer.abstractLists.push(this.abstractList);
        }
    }
    createLinkStyle(name, isEdit) {
        let charStyle;
        if (isEdit) {
            charStyle = this.owner.owner.viewer.styles.findByName((name + ' Char'), 'Character');
        }
        else {
            charStyle = new WCharacterStyle();
        }
        charStyle.type = 'Character';
        charStyle.name = name + ' Char';
        charStyle.characterFormat = this.style.characterFormat.cloneFormat();
        charStyle.basedOn = this.style.basedOn;
        if (!isEdit) {
            this.owner.owner.viewer.styles.push(charStyle);
        }
        return this.owner.owner.viewer.styles.findByName(charStyle.name, 'Character');
    }
    /**
     * @private
     */
    updateCharacterFormat(characterFormat) {
        if (!isNullOrUndefined(characterFormat)) {
            this.characterFormat = characterFormat;
        }
        this.fontFamily.value = this.characterFormat.fontFamily;
        this.fontSize.value = this.characterFormat.fontSize;
        this.fontColor.value = this.characterFormat.fontColor;
        this.fontButtonClicked(undefined);
    }
    /**
     * @private
     */
    updateParagraphFormat(paragraphFOrmat) {
        if (!isNullOrUndefined(paragraphFOrmat)) {
            this.paragraphFormat = paragraphFOrmat;
        }
        if (this.paragraphFormat.textAlignment === 'Left') {
            if (!this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.add('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Right') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (!this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.add('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Center') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (!this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.add('e-active');
            }
            if (this.justify.classList.contains('e-active')) {
                this.justify.classList.remove('e-active');
            }
        }
        else if (this.paragraphFormat.textAlignment === 'Justify') {
            if (this.leftAlign.classList.contains('e-active')) {
                this.leftAlign.classList.remove('e-active');
            }
            if (this.rightAlign.classList.contains('e-active')) {
                this.rightAlign.classList.remove('e-active');
            }
            if (this.centerAlign.classList.contains('e-active')) {
                this.centerAlign.classList.remove('e-active');
            }
            if (!this.justify.classList.contains('e-active')) {
                this.justify.classList.add('e-active');
            }
        }
        if (this.paragraphFormat.lineSpacing === 1) {
            this.singleLineSpacing.classList.add('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
        else if (this.paragraphFormat.lineSpacing === 1.5) {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.add('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
        else if (this.paragraphFormat.lineSpacing === 2) {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.add('e-active');
        }
        else {
            this.singleLineSpacing.classList.remove('e-active');
            this.onePointFiveLineSpacing.classList.remove('e-active');
            this.doubleLineSpacing.classList.remove('e-active');
        }
    }
    enableOrDisableOkButton() {
        if (!isNullOrUndefined(this.okButton)) {
            this.okButton.disabled = (this.styleNameElement.value === '');
        }
    }
    getTypeValue() {
        if (this.styleType.value === this.localObj.getConstant('Linked(Paragraph and Character)') || this.styleType.value === this.localObj.getConstant('Paragraph')) {
            return 'Paragraph';
        }
        else {
            return 'Character';
        }
    }
    updateStyleNames(type, name) {
        let styles = this.owner.owner.viewer.styles.getStyleNames(type);
        this.styleParagraph.dataSource = styles;
        this.styleParagraph.index = null;
        if (name) {
            this.styleBasedOn.dataSource = styles.filter((e) => e !== name);
            this.styleBasedOn.index = null;
            let style = this.getStyle(name);
            if (style.basedOn instanceof String || isNullOrUndefined(style.basedOn)) {
                this.styleBasedOn.enabled = false;
            }
            else {
                /* tslint:disable-next-line:max-line-length */
                this.styleBasedOn.index = styles.indexOf(style.basedOn.name) > -1 ? styles.indexOf(style.basedOn.name) : 0;
            }
            if (style.type === 'Paragraph') {
                if (!isNullOrUndefined(style.link)) {
                    this.styleType.index = 2;
                }
                else {
                    this.styleType.index = 0;
                }
            }
            else {
                this.styleType.index = 1;
            }
            if (!isNullOrUndefined(style.next)) {
                let nxtName = style.next.name;
                let index = 0;
                if (styles.indexOf(nxtName) > -1) {
                    index = styles.indexOf(nxtName);
                }
                this.styleParagraph.index = index;
                this.isUserNextParaUpdated = (nxtName === name) ? false : true;
            }
        }
        else {
            this.styleBasedOn.dataSource = styles;
            this.styleBasedOn.index = null;
            let basedOnIndex = 0;
            if (this.owner.owner.selectionModule) {
                let styleName;
                if (type === 'Character') {
                    styleName = this.owner.owner.selection.characterFormat.styleName;
                }
                else {
                    styleName = this.owner.owner.selection.paragraphFormat.styleName;
                }
                basedOnIndex = styles.indexOf(styleName);
            }
            this.styleBasedOn.index = basedOnIndex;
            this.styleParagraph.index = 0;
        }
        if (this.isEdit) {
            this.styleType.enabled = false;
        }
        else {
            this.styleType.enabled = true;
        }
        this.styleBasedOn.dataBind();
        this.styleParagraph.dataBind();
    }
    getStyle(styleName) {
        /* tslint:disable-next-line:max-line-length */
        if (isNullOrUndefined(this.owner.owner.viewer.styles.findByName(styleName))) {
            /* tslint:disable-next-line:max-line-length */
            this.owner.owner.editor.createStyle(this.owner.owner.viewer.preDefinedStyles.get(styleName));
        }
        return this.owner.owner.viewer.styles.findByName(styleName);
    }
    /**
     * @private
     */
    destroy() {
        this.owner = undefined;
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let n = 0; n < this.target.childNodes.length; n++) {
                this.target.removeChild(this.target.childNodes[n]);
                n--;
            }
            this.target = undefined;
        }
        if (this.fontColor) {
            this.fontColor.destroy();
            this.fontColor = undefined;
        }
        if (this.fontSize) {
            this.fontSize.destroy();
            this.fontSize = undefined;
        }
        if (this.fontFamily) {
            this.fontFamily.destroy();
            this.fontFamily = undefined;
        }
        if (this.styleType) {
            this.styleType.destroy();
            this.styleType = undefined;
        }
        if (this.styleBasedOn) {
            this.styleBasedOn.destroy();
            this.styleBasedOn = undefined;
        }
        if (this.styleParagraph) {
            this.styleParagraph.destroy();
            this.styleParagraph = undefined;
        }
        if (this.onlyThisDocument) {
            this.onlyThisDocument.destroy();
        }
        this.onlyThisDocument = undefined;
        if (this.template) {
            this.template.destroy();
            this.template = undefined;
        }
        if (this.style) {
            this.style = undefined;
        }
        if (this.abstractList) {
            this.abstractList = undefined;
        }
        if (this.numberingBulletDialog) {
            this.numberingBulletDialog.destroy();
            this.numberingBulletDialog = undefined;
        }
        if (this.styleDropdwn) {
            this.styleDropdwn.destroy();
            this.styleDropdwn = undefined;
        }
    }
}

/**
 * The Bullets and Numbering dialog is used to apply list format for a paragraph style.
 */
/* tslint:disable:no-any */
class BulletsAndNumberingDialog {
    /**
     * @private
     */
    constructor(layoutViewer) {
        this.isBullet = false;
        /**
         * @private
         */
        this.numberListClick = (args) => {
            this.isBullet = false;
            this.setActiveElement(args);
            if (args.currentTarget.classList.contains('e-de-list-numbered-none')) {
                this.numberFormat = undefined;
                this.listLevelPattern = undefined;
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-number-dot')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'Arabic';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-number-brace')) {
                this.numberFormat = '%1)';
                this.listLevelPattern = 'Arabic';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-up-roman')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'UpRoman';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-up-letter')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'UpLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-low-letter-brace')) {
                this.numberFormat = '%1)';
                this.listLevelPattern = 'LowLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-numbered-low-letter-dot')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'LowLetter';
            }
            else if (args.currentTarget.classList.contains('e-de-list-numbered-low-roman')) {
                this.numberFormat = '%1.';
                this.listLevelPattern = 'LowRoman';
            }
        };
        /**
         * @private
         */
        this.bulletListClick = (args) => {
            this.isBullet = true;
            this.setActiveElement(args);
            if (args.currentTarget.classList.contains('e-bullet-none')) {
                this.symbol = undefined;
                this.fontFamily = undefined;
            }
            else if (args.currentTarget.classList.contains('e-bullet-dot')) {
                this.symbol = '\uf0b7';
                this.fontFamily = 'Symbol';
            }
            else if (args.currentTarget.classList.contains('e-bullet-circle')) {
                this.symbol = '\uf06f' + '\u0020';
                this.fontFamily = 'Symbol';
            }
            else if (args.currentTarget.classList.contains('e-bullet-square')) {
                this.symbol = '\uf0a7';
                this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-flower')) {
                this.symbol = '\uf076';
                this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-arrow')) {
                this.symbol = '\uf0d8';
                this.fontFamily = 'Wingdings';
            }
            else if (args.currentTarget.classList.contains('e-bullet-tick')) {
                this.symbol = '\uf0fc';
                this.fontFamily = 'Wingdings';
            }
        };
        /**
         * @private
         */
        this.loadNumberingBulletDialog = () => {
            //Load 
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.closeNumberingBulletDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.isBullet = false;
            this.listLevelPattern = undefined;
            this.numberFormat = undefined;
            this.symbol = undefined;
            this.fontFamily = undefined;
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.onOkButtonClick = () => {
            if (this.owner.owner.viewer.lists.length > 0) {
                this.listFormat.list.listId = this.owner.owner.viewer.lists[this.owner.owner.viewer.lists.length - 1].listId + 1;
                this.listFormat.listId = this.listFormat.list.listId;
            }
            else {
                this.listFormat.list.listId = 0;
                this.listFormat.listId = 0;
            }
            if (this.owner.owner.viewer.abstractLists.length > 0) {
                /* tslint:disable-next-line:max-line-length */
                this.abstractList.abstractListId = this.owner.owner.viewer.abstractLists[this.owner.owner.viewer.abstractLists.length - 1].abstractListId + 1;
            }
            else {
                this.abstractList.abstractListId = 0;
            }
            this.listFormat.list.abstractListId = this.abstractList.abstractListId;
            let listLevel = new WListLevel(this.abstractList);
            listLevel.listLevelPattern = !isNullOrUndefined(this.listLevelPattern) ? this.listLevelPattern : 'Bullet';
            listLevel.numberFormat = this.isBullet ? this.symbol : this.numberFormat;
            if (listLevel.listLevelPattern !== 'Bullet') {
                listLevel.startAt = 1;
            }
            listLevel.characterFormat.fontFamily = !isNullOrUndefined(this.fontFamily) ? this.fontFamily : 'Verdana';
            listLevel.paragraphFormat.leftIndent = 36;
            listLevel.paragraphFormat.firstLineIndent = -18;
            this.abstractList.levels.push(listLevel);
            this.listFormat.listLevelNumber = 0;
            this.listFormat.list.abstractList = this.abstractList;
            this.owner.dialog.hide();
        };
        this.owner = layoutViewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'BulletsAndNumberingDialog';
    }
    /**
     * @private
     */
    initNumberingBulletDialog(locale) {
        let id = this.owner.owner.containerId;
        this.target = createElement('div', { id: id + '_insertNumberBulletDialog', className: 'e-de-number-bullet-dlg' });
        let tabTarget = createElement('div', { id: id + '_tabNumberBulletDialog', className: 'e-de-tab-number-bullet-dlg' });
        this.target.appendChild(tabTarget);
        this.createNumberList(id);
        this.createBulletList(id);
        //Initialize Tab component
        this.tabObj = new Tab({
            items: [
                {
                    header: { 'text': createElement('div', { innerHTML: locale.getConstant('Numbering') }) },
                    content: this.numberListDiv,
                },
                {
                    header: { 'text': createElement('div', { innerHTML: locale.getConstant('Bullets') }) },
                    content: this.bulletListDiv,
                }
            ],
            heightAdjustMode: 'None',
            width: 272,
            selecting: this.onTabSelect.bind(this)
        });
        //Render initialized Tab component
        this.tabObj.appendTo(tabTarget);
    }
    onTabSelect(args) {
        if (args.selectingIndex === 1) {
            this.bulletListDiv.style.display = 'block';
        }
    }
    createNumberList(id) {
        this.numberListDiv = createElement('div', { className: 'e-de-style-numbered-list', id: id + '_Number' });
        let numberListDiv = this.numberListDiv;
        numberListDiv.style.height = '270px';
        let ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;',
            id: 'listMenu',
            className: 'e-de-ui-wfloating-menu e-de-ui-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        numberListDiv.appendChild(ulTag);
        let numberedNone = this.createNumberNoneListTag(ulTag);
        let numberedNumberDot = this.createNumberListTag(ulTag, '1.', '2.', '3.', 'e-de-list-numbered-number-dot');
        let numberedNumberBrace = this.createNumberListTag(ulTag, '1)', '2)', '3)', 'e-de-list-numbered-number-brace');
        let numberedUpRoman = this.createNumberListTag(ulTag, 'I.', 'II.', 'III.', 'e-de-list-numbered-up-roman');
        let numberedUpLettter = this.createNumberListTag(ulTag, 'A.', 'B.', 'C.', 'e-de-list-numbered-up-letter');
        let numberedLowLetterDot = this.createNumberListTag(ulTag, 'a.', 'b.', 'c.', 'e-de-numbered-low-letter-dot');
        let numberedLowLetterBrace = this.createNumberListTag(ulTag, 'a)', 'b)', 'c)', 'e-de-list-numbered-low-letter-brace');
        let numberedLowRoman = this.createNumberListTag(ulTag, 'i.', 'ii.', 'iii.', 'e-de-list-numbered-low-roman');
        numberedNone.addEventListener('click', this.numberListClick);
        numberedNumberDot.addEventListener('click', this.numberListClick);
        numberedNumberBrace.addEventListener('click', this.numberListClick);
        numberedUpRoman.addEventListener('click', this.numberListClick);
        numberedUpLettter.addEventListener('click', this.numberListClick);
        numberedLowLetterBrace.addEventListener('click', this.numberListClick);
        numberedLowLetterDot.addEventListener('click', this.numberListClick);
        numberedLowRoman.addEventListener('click', this.numberListClick);
        this.target.appendChild(numberListDiv);
    }
    createNumberListTag(ulTag, text1, text2, text3, className) {
        let liTag = createElement('li', {
            styles: 'display:block',
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-menuitem-md e-de-list-items  e-de-list-item-size ' + className
        });
        ulTag.appendChild(liTag);
        /* tslint:disable-next-line:max-line-length */
        let innerHTML = '<div>' + text1 + '<span class="e-de-ui-list-line"></span></div><div>' + text2 + '<span class="e-de-ui-list-line">';
        innerHTML += '</span></div><div>' + text3 + '<span class="e-de-ui-list-line"> </span></div >';
        let liInnerDiv = createElement('div', {
            className: 'e-de-ui-list-header-presetmenu',
            id: 'e-de-ui-zlist0', innerHTML: innerHTML
        });
        liTag.style.cssFloat = 'left';
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createNumberNoneListTag(ulTag) {
        let liTag = createElement('li', {
            styles: 'display:block',
            /* tslint:disable-next-line:max-line-length */
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-menuitem-md e-de-list-items  e-de-list-item-size e-de-list-numbered-none'
        });
        ulTag.appendChild(liTag);
        let innerHTML = '<div class="e-de-ui-bullets e-de-bullet-icons">None</div>';
        let liInnerDiv = createElement('div', {
            className: 'e-de-ui-list-header-presetmenu',
            id: 'e-de-ui-zlist0', innerHTML: innerHTML
        });
        liTag.style.cssFloat = 'left';
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createBulletListTag(ulTag, iconCss, className) {
        let liTag = createElement('li', {
            styles: 'display:block;',
            className: 'e-de-ui-wfloating-menuitem e-de-ui-wfloating-bullet-menuitem-md e-de-list-items  e-de-list-item-size ' + className
        });
        ulTag.appendChild(liTag);
        /* tslint:disable-next-line:max-line-length */
        let liInnerDiv = createElement('div', { className: 'e-de-ui-bullet-list-header-presetmenu e-de-bullet-icon-size', id: 'e-de-ui-zlist0' });
        let liNextDiv = createElement('div', { className: iconCss });
        liInnerDiv.appendChild(liNextDiv);
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createBulletList(id) {
        this.bulletListDiv = createElement('div', { className: 'e-de-ui-bullet-list-header-presetmenu', id: id + '_Bullet' });
        let bulletListDiv = this.bulletListDiv;
        bulletListDiv.style.height = '270px';
        bulletListDiv.style.display = 'none';
        let ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;', id: 'listMenu',
            className: 'e-de-ui-wfloating-menu e-de-ui-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        bulletListDiv.appendChild(ulTag);
        let bulletNone = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-none e-de-bullet-icons', 'e-bullet-none');
        let bulletDot = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-dot e-de-bullet-icons', 'e-bullet-dot');
        /* tslint:disable-next-line:max-line-length */
        let bulletCircle = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-circle e-de-bullet-icons', 'e-bullet-circle');
        let bulletSquare = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-square e-de-bullet-icons', 'e-bullet-square');
        /* tslint:disable-next-line:max-line-length */
        let bulletFlower = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-flower e-de-bullet-icons', 'e-bullet-flower');
        let bulletArrow = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-arrow e-de-bullet-icons', 'e-bullet-arrow');
        let bulletTick = this.createBulletListTag(ulTag, 'e-de-icon-bullet-list-tick e-de-bullet-icons', 'e-bullet-tick');
        bulletNone.addEventListener('click', this.bulletListClick);
        bulletDot.addEventListener('click', this.bulletListClick);
        bulletCircle.addEventListener('click', this.bulletListClick);
        bulletSquare.addEventListener('click', this.bulletListClick);
        bulletFlower.addEventListener('click', this.bulletListClick);
        bulletArrow.addEventListener('click', this.bulletListClick);
        bulletTick.addEventListener('click', this.bulletListClick);
        this.target.appendChild(bulletListDiv);
    }
    /**
     * @private
     */
    showNumberBulletDialog(listFormat, abstractList) {
        if (!isNullOrUndefined(listFormat)) {
            this.listFormat = listFormat;
        }
        else {
            this.listFormat = new WListFormat();
        }
        if (isNullOrUndefined(this.listFormat.list)) {
            this.listFormat.list = new WList();
        }
        if (!isNullOrUndefined(abstractList)) {
            this.abstractList = abstractList;
        }
        else {
            this.abstractList = new WAbstractList();
        }
        let locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initNumberingBulletDialog(locale);
        }
        this.owner.dialog.header = locale.getConstant('Numbering and Bullets');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadNumberingBulletDialog;
        this.owner.dialog.close = this.closeNumberingBulletDialog;
        this.owner.dialog.position = { X: 'center', Y: 'center' };
        this.owner.dialog.buttons = [{
                click: this.onOkButtonClick,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-numbering-bullet-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-numbering-bullet-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
        this.tabObj.refresh();
    }
    setActiveElement(args) {
        let html = args.currentTarget.parentElement;
        for (let i = 0; i < html.childElementCount; i++) {
            if (html.childNodes[i].classList.contains('e-de-list-active')) {
                html.childNodes[i].classList.remove('e-de-list-active');
            }
        }
        args.currentTarget.classList.add('e-de-list-active');
    }
    /**
     * @private
     */
    unWireEventsAndBindings() {
        //Unwire events
    }
    /**
     * @private
     */
    destroy() {
        this.owner = undefined;
        if (this.listFormat) {
            this.listFormat.destroy();
            this.listFormat = undefined;
        }
        if (this.tabObj) {
            this.tabObj.destroy();
            this.tabObj = undefined;
        }
        if (this.abstractList) {
            this.abstractList.destroy();
            this.abstractList = undefined;
        }
        if (this.target && this.target.parentElement) {
            this.target.parentElement.removeChild(this.target);
            for (let m = 0; m < this.target.childNodes.length; m++) {
                this.target.removeChild(this.target.childNodes[m]);
                m--;
            }
            this.target = undefined;
        }
        this.bulletListDiv = undefined;
        this.numberListDiv = undefined;
    }
}
/* tslint:enable:no-any */

/**
 * The Font dialog is used to modify formatting of selected text.
 */
/* tslint:disable:no-any */
class FontDialog {
    /**
     * @private
     */
    constructor(layoutViewer) {
        this.fontStyleInternal = undefined;
        this.fontNameList = undefined;
        this.fontStyleText = undefined;
        this.fontSizeText = undefined;
        this.colorPicker = undefined;
        this.underlineDrop = undefined;
        this.strikethroughBox = undefined;
        this.doublestrikethrough = undefined;
        this.superscript = undefined;
        this.subscript = undefined;
        //Character Format Property
        this.bold = undefined;
        this.italic = undefined;
        this.underline = undefined;
        this.strikethrough = undefined;
        this.baselineAlignment = undefined;
        this.fontSize = undefined;
        this.fontFamily = undefined;
        this.fontColor = undefined;
        /**
         * @private
         */
        this.characterFormat = undefined;
        /**
         * @private
         */
        this.loadFontDialog = () => {
            this.owner.updateFocus();
            let characterFormat;
            if (this.characterFormat) {
                characterFormat = this.characterFormat;
            }
            else {
                characterFormat = this.owner.owner.selection.characterFormat;
            }
            this.fontNameList.value = characterFormat.fontFamily;
            if (!characterFormat.bold && !characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 0;
            }
            else if (characterFormat.bold && !characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 1;
            }
            else if (!characterFormat.bold && characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 2;
            }
            else if (characterFormat.bold && characterFormat.italic) {
                this.fontStyleText.value = this.fontSizeText.value;
                this.fontStyleText.index = 3;
            }
            if (!isNullOrUndefined(characterFormat.fontSize)) {
                for (let i = 0; i <= 15; i++) {
                    let items = this.fontSizeText.getItems();
                    if (characterFormat.fontSize.toString() === items[i].innerHTML) {
                        this.fontSizeText.value = characterFormat.fontSize;
                        this.fontSizeText.index = i;
                        break;
                    }
                }
            }
            if (!isNullOrUndefined(characterFormat.fontColor)) {
                this.colorPicker.value = characterFormat.fontColor;
            }
            else {
                this.colorPicker.value = '#000000';
            }
            if (characterFormat.underline === 'None') {
                this.underlineDrop.index = 0;
            }
            else if (characterFormat.underline === 'Single') {
                this.underlineDrop.index = 1;
            }
            if (characterFormat.strikethrough === 'SingleStrike') {
                this.strikethroughBox.checked = true;
            }
            else if (characterFormat.strikethrough === 'DoubleStrike') {
                this.doublestrikethrough.checked = true;
            }
            else {
                this.strikethroughBox.checked = false;
                this.doublestrikethrough.checked = false;
            }
            if (characterFormat.baselineAlignment === 'Superscript') {
                this.superscript.checked = true;
            }
            else if (characterFormat.baselineAlignment === 'Subscript') {
                this.subscript.checked = true;
            }
            else {
                this.superscript.checked = false;
                this.subscript.checked = false;
            }
            if (this.owner.selection.caret.style.display !== 'none') {
                this.owner.selection.caret.style.display = 'none';
            }
        };
        /**
         * @private
         */
        this.closeFontDialog = () => {
            this.unWireEventsAndBindings();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.onCancelButtonClick = () => {
            this.owner.dialog.hide();
            this.unWireEventsAndBindings();
        };
        /**
         * @private
         */
        this.onInsertFontFormat = () => {
            let format;
            if (this.characterFormat) {
                format = this.characterFormat;
            }
            else {
                format = new WCharacterFormat(undefined);
            }
            if (!isNullOrUndefined(this.bold)) {
                format.bold = this.bold;
            }
            if (!isNullOrUndefined(this.italic)) {
                format.italic = this.italic;
            }
            if (!isNullOrUndefined(this.fontSize) && this.fontSize > 0) {
                format.fontSize = this.fontSize;
            }
            if (!isNullOrUndefined(this.fontColor)) {
                format.fontColor = this.fontColor;
            }
            if (!isNullOrUndefined(this.baselineAlignment)) {
                format.baselineAlignment = this.baselineAlignment;
            }
            if (!isNullOrUndefined(this.strikethrough)) {
                format.strikethrough = this.strikethrough;
            }
            if (!isNullOrUndefined(this.underline)) {
                format.underline = this.underline;
            }
            if (!isNullOrUndefined(this.fontFamily)) {
                format.fontFamily = this.fontFamily;
            }
            if (!this.characterFormat) {
                this.onCharacterFormat(this.owner.selection, format);
            }
            else {
                this.owner.owner.styleDialogModule.updateCharacterFormat();
            }
            this.owner.dialog.hide();
        };
        this.fontSizeUpdate = (args) => {
            this.fontSize = args.value;
        };
        this.fontStyleUpdate = (args) => {
            this.fontStyle = args.value;
        };
        this.fontFamilyUpdate = (args) => {
            this.fontFamily = args.value;
        };
        this.underlineUpdate = (args) => {
            this.underline = args.value;
        };
        this.fontColorUpdate = (args) => {
            if (!isNullOrUndefined(args.currentValue)) {
                this.fontColor = args.currentValue.hex;
            }
        };
        this.singleStrikeUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.strikethrough = 'SingleStrike';
            }
            else {
                this.strikethrough = 'None';
            }
        };
        this.doubleStrikeUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.strikethrough = 'DoubleStrike';
            }
            else {
                this.strikethrough = 'None';
            }
        };
        this.superscriptUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.baselineAlignment = 'Superscript';
            }
            else {
                this.baselineAlignment = 'Normal';
            }
        };
        this.subscriptUpdate = (args) => {
            this.enableCheckBoxProperty(args);
            if (args.checked) {
                this.baselineAlignment = 'Subscript';
            }
            else {
                this.baselineAlignment = 'Normal';
            }
        };
        this.owner = layoutViewer;
    }
    /**
     * @private
     */
    get fontStyle() {
        return this.fontStyleInternal;
    }
    /**
     * @private
     */
    set fontStyle(value) {
        this.fontStyleInternal = value;
        switch (this.fontStyle) {
            case 'Bold':
                this.bold = true;
                this.italic = false;
                break;
            case 'Italic':
                this.bold = false;
                this.italic = true;
                break;
            case 'BoldItalic':
                this.bold = true;
                this.italic = true;
                break;
            case 'Regular':
                this.bold = false;
                this.italic = false;
                break;
        }
    }
    /**
     * @private
     */
    getModuleName() {
        return 'FontDialog';
    }
    createInputElement(type, id, className) {
        let element = createElement('input', {
            attrs: { type: type },
            id: id,
            className: className
        });
        return element;
    }
    /**
     * @private
     */
    initFontDialog(locale, isRtl) {
        let effectLabel;
        let strikeThroughElement;
        let superScriptElement;
        let subScriptElement;
        let doubleStrikeThroughElement;
        let id = this.owner.owner.containerId;
        this.target = createElement('div', { id: id + '_insertFontDialog', className: 'e-de-font-dlg' });
        let fontDiv = this.getFontDiv(locale, isRtl);
        this.target.appendChild(fontDiv);
        let sizeDiv = this.getFontSizeDiv(locale, isRtl);
        this.target.appendChild(sizeDiv);
        let colorDiv = createElement('div', { id: id + '_fontColor', styles: 'margin-top:14px;' });
        this.fontColorDiv = createElement('div', { id: id + '_fontColorDiv', className: 'e-de-font-dlg-display' });
        let fontColorLabel = createElement('label', {
            className: 'e-de-font-dlg-header-font-color e-de-font-color-margin',
            innerHTML: locale.getConstant('Font color'), styles: 'width:63px'
        });
        if (isRtl) {
            fontColorLabel.classList.add('e-de-rtl');
        }
        this.fontColorDiv.appendChild(fontColorLabel);
        let fontColorElement = this.createInputElement('color', this.target.id + '_ColorDiv', 'e-de-font-dlg-color');
        this.fontColorDiv.appendChild(fontColorElement);
        colorDiv.appendChild(this.fontColorDiv);
        this.target.appendChild(colorDiv);
        let fontEffectsDiv = createElement('div', { id: id + '_fontEffectsDiv' });
        let fontEffectSubDiv1 = createElement('div', {
            className: 'e-de-font-color-label e-de-font-dlg-display',
            id: this.target.id + '_fontEffectsSubDiv1'
        });
        effectLabel = createElement('label', {
            className: 'e-de-font-dlg-header-effects',
            innerHTML: locale.getConstant('Effects'), styles: 'width:58px'
        });
        fontEffectSubDiv1.appendChild(effectLabel);
        strikeThroughElement = this.createInputElement('checkbox', this.target.id + '_strikeThrough', '');
        fontEffectSubDiv1.appendChild(strikeThroughElement);
        superScriptElement = this.createInputElement('checkbox', this.target.id + '_superScript', '');
        fontEffectSubDiv1.appendChild(superScriptElement);
        fontEffectsDiv.appendChild(fontEffectSubDiv1);
        let fontEffectSubDiv2 = createElement('div', { className: 'e-de-font-checkbox', id: id + '_fontEffectsSubDiv2' });
        subScriptElement = this.createInputElement('checkbox', this.target.id + '_subScript', '');
        fontEffectSubDiv2.appendChild(subScriptElement);
        doubleStrikeThroughElement = this.createInputElement('checkbox', this.target.id + '_doubleStrikeThrough', '');
        fontEffectSubDiv2.appendChild(doubleStrikeThroughElement);
        fontEffectsDiv.appendChild(fontEffectSubDiv2);
        this.target.appendChild(fontEffectsDiv);
        this.colorPicker = new ColorPicker({
            change: this.fontColorUpdate, value: '#000000', enableRtl: isRtl, locale: this.owner.owner.locale
        });
        this.colorPicker.appendTo(fontColorElement);
        this.strikethroughBox = new CheckBox({
            change: this.singleStrikeUpdate,
            cssClass: 'e-de-font-content-label',
            label: locale.getConstant('Strikethrough'),
            enableRtl: isRtl
        });
        this.strikethroughBox.appendTo(strikeThroughElement);
        this.doublestrikethrough = new CheckBox({
            change: this.doubleStrikeUpdate,
            cssClass: 'e-de-font-content-checkbox-label',
            label: locale.getConstant('Double strikethrough'),
            enableRtl: isRtl
        });
        this.doublestrikethrough.appendTo(doubleStrikeThroughElement);
        this.subscript = new CheckBox({
            label: locale.getConstant('Subscript'),
            cssClass: 'e-de-font-content-label-width',
            change: this.subscriptUpdate,
            enableRtl: isRtl
        });
        this.subscript.appendTo(subScriptElement);
        this.superscript = new CheckBox({
            label: locale.getConstant('Superscript'),
            cssClass: 'e-de-font-content-label', change: this.superscriptUpdate,
            enableRtl: isRtl
        });
        this.superscript.appendTo(superScriptElement);
        if (isRtl) {
            fontEffectSubDiv2.classList.add('e-de-rtl');
            this.doublestrikethrough.cssClass = 'e-de-font-content-checkbox-label-rtl';
        }
    }
    getFontSizeDiv(locale, isRtl) {
        let fontSize;
        let sizeDiv;
        let id = this.owner.owner.containerId;
        sizeDiv = createElement('div', { id: id + '_fontSizeAndUnderlineDiv', className: 'e-de-font-dlg-padding e-de-font-dlg-display' });
        let sizeSubDiv1 = createElement('div', { id: id + '_fontSizeAndUnderlineSubDiv1' });
        let sizeLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: locale.getConstant('Size') });
        let styles = 'font-family:Roboto;font-size:14px;opacity:0.8;';
        fontSize = createElement('select', { id: this.target.id + '_fontSize', styles: styles });
        fontSize.innerHTML = '<option>8</option><option>9</option><option>10</option><option>11</option><option>12</option>' +
            '<option>14</option><option>16</option><option>18</option><option>20</option><option>24</option><option>26</option>' +
            '<option>28</option><option>36</option><option>48</option><option>72</option><option>96</option>';
        sizeSubDiv1.appendChild(sizeLabel);
        sizeSubDiv1.appendChild(fontSize);
        sizeDiv.appendChild(sizeSubDiv1);
        let sizeSubDiv2 = createElement('div', {
            className: 'e-de-font-dlg-cb-right',
            id: id + '_fontSizeAndUnderlineSubDiv2'
        });
        if (isRtl) {
            sizeSubDiv2.classList.add('e-de-rtl');
        }
        let html = locale.getConstant('Underline style');
        let underlineLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: html });
        let underlineElement;
        underlineElement = createElement('select', { id: this.target.id + '_underLine', styles: styles });
        underlineElement.innerHTML = '<option>' + locale.getConstant('None') + '</option><option>________</option>';
        sizeSubDiv2.appendChild(underlineLabel);
        sizeSubDiv2.appendChild(underlineElement);
        sizeDiv.appendChild(sizeSubDiv2);
        this.fontSizeText = new ComboBox({ change: this.fontSizeUpdate, popupHeight: '170px', width: '170px', enableRtl: isRtl });
        this.fontSizeText.showClearButton = false;
        this.fontSizeText.appendTo(fontSize);
        this.underlineDrop = new DropDownList({ change: this.underlineUpdate, popupHeight: '100px', width: '170px', enableRtl: isRtl });
        this.underlineDrop.appendTo(underlineElement);
        return sizeDiv;
    }
    getFontDiv(locale, isRtl) {
        let id = this.owner.owner.containerId;
        let fontDiv = createElement('div', { id: id + '_fontDiv', className: 'e-de-font-dlg-display' });
        let fontSubDiv1 = createElement('div', { id: id + '_fontSubDiv1' });
        let fontNameLabel = createElement('label', {
            className: 'e-de-font-dlg-header',
            innerHTML: locale.getConstant('Font')
        });
        let fontNameValues = createElement('select', { id: this.target.id + '_fontName' });
        fontNameValues.innerHTML = '<option>Arial</option><option>Calibri</option><option>Candara</option><option>Comic Sans MS</option>' +
            '<option>Consolas</option><option>Constantia</option><option>Corbel</option>' +
            '<option>Courier New</option><option>Ebrima</option><option>Franklin Gothic</option>' +
            '<option>Gabriola</option><option>Gadugi</option><option>Georgia</option><option>Impact</option>' +
            '<option>Javanese Text</option><option>Microsoft Sans Serif</option><option>MS Gothic</option><option>MS UI Gothic</option>' +
            '<option>Segoe Print</option><option>Times New Roman</option><option>Verdana</option><option>Segoe UI</option>' +
            '<option>Algerian</option><option>Cambria</option><option>Georgia</option><option>Consolas</option>';
        fontSubDiv1.appendChild(fontNameLabel);
        fontSubDiv1.appendChild(fontNameValues);
        fontDiv.appendChild(fontSubDiv1);
        let fontSubDiv2;
        let fontStyleLabel;
        let fontStyleValues;
        fontSubDiv2 = createElement('div', { className: 'e-de-font-dlg-cb-right', id: id + '_fontSubDiv2', styles: 'float:right;' });
        if (isRtl) {
            fontSubDiv2.classList.add('e-de-rtl');
        }
        fontStyleLabel = createElement('label', { className: 'e-de-font-dlg-header', innerHTML: locale.getConstant('Font style') });
        let fontStyle = 'font-family:Roboto;font-size:14px;opacity:0.8;';
        fontStyleValues = createElement('select', { id: this.target.id + '_fontStyle', styles: fontStyle });
        fontStyleValues.innerHTML = '<option>' +
            locale.getConstant('Regular') + '</option><option>' + locale.getConstant('Bold') + '</option><option>' +
            locale.getConstant('Italic') + '</option><option>' + locale.getConstant('Bold') + locale.getConstant('Italic') + '</option>';
        fontSubDiv2.appendChild(fontStyleLabel);
        fontSubDiv2.appendChild(fontStyleValues);
        fontDiv.appendChild(fontSubDiv2);
        this.fontNameList = new ComboBox({ change: this.fontFamilyUpdate, popupHeight: '200px', width: '170px', enableRtl: isRtl });
        this.fontNameList.showClearButton = false;
        this.fontNameList.appendTo(fontNameValues);
        this.fontStyleText = new DropDownList({ change: this.fontStyleUpdate, popupHeight: '170px', width: '170px', enableRtl: isRtl });
        this.fontStyleText.appendTo(fontStyleValues);
        return fontDiv;
    }
    /**
     * @private
     */
    showFontDialog(characterFormat) {
        if (characterFormat) {
            this.characterFormat = characterFormat;
        }
        let locale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        locale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initFontDialog(locale, this.owner.owner.enableRtl);
        }
        this.owner.dialog.header = locale.getConstant('Font');
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.loadFontDialog;
        this.owner.dialog.close = this.closeFontDialog;
        this.owner.dialog.buttons = [{
                click: this.onInsertFontFormat,
                buttonModel: { content: locale.getConstant('Ok'), cssClass: 'e-flat e-font-okay', isPrimary: true }
            },
            {
                click: this.onCancelButtonClick,
                buttonModel: { content: locale.getConstant('Cancel'), cssClass: 'e-flat e-font-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * Applies character format
     * @param  {Selection} selection
     * @param  {WCharacterFormat} format
     * @private
     */
    onCharacterFormat(selection, format) {
        this.owner.owner.editorModule.initHistory('CharacterFormat');
        if (selection.isEmpty) {
            if (selection.start.offset === selection.getParagraphLength(selection.start.paragraph)) {
                // tslint:disable-next-line:max-line-length
                this.owner.owner.editorModule.applyCharFormatValueInternal(selection, selection.start.paragraph.characterFormat, undefined, format);
                this.owner.owner.editorModule.reLayout(selection);
            }
            this.owner.updateFocus();
            return;
        }
        else {
            //Iterate and update formating.
            this.owner.owner.editorModule.setOffsetValue(this.owner.selection);
            this.owner.owner.editorModule.updateSelectionCharacterFormatting('CharacterFormat', format, false);
        }
    }
    /**
     * @private
     */
    enableCheckBoxProperty(args) {
        if (this.strikethroughBox.checked && this.doublestrikethrough.checked) {
            this.strikethroughBox.checked = false;
            this.doublestrikethrough.checked = false;
            if (args.event.currentTarget.id === this.target.id + '_doubleStrikeThrough') {
                this.doublestrikethrough.checked = true;
            }
            else {
                this.strikethroughBox.checked = true;
            }
        }
        if (this.superscript.checked && this.subscript.checked) {
            this.subscript.checked = false;
            this.superscript.checked = false;
            if (args.event.currentTarget.id === this.target.id + '_subScript') {
                this.subscript.checked = true;
            }
            else {
                this.superscript.checked = true;
            }
        }
    }
    /**
     * @private
     */
    unWireEventsAndBindings() {
        this.fontNameList.value = '';
        this.fontSizeText.value = '';
        this.fontStyleText.value = '';
        this.strikethroughBox.checked = false;
        this.doublestrikethrough.checked = false;
        this.superscript.checked = false;
        this.subscript.checked = false;
        this.bold = undefined;
        this.italic = undefined;
        this.underline = undefined;
        this.strikethrough = undefined;
        this.baselineAlignment = undefined;
        this.fontColor = undefined;
        this.fontSize = undefined;
        this.fontFamily = undefined;
    }
    /**
     * @private
     */
    destroy() {
        this.owner = undefined;
        if (this.characterFormat) {
            this.characterFormat.destroy();
            this.characterFormat = undefined;
        }
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let m = 0; m < this.target.childNodes.length; m++) {
                this.target.removeChild(this.target.childNodes[m]);
                m--;
            }
            this.target = undefined;
        }
        if (this.fontNameList) {
            this.fontNameList.destroy();
        }
        this.fontNameList = undefined;
        if (this.fontStyleText) {
            this.fontStyleText.destroy();
        }
        this.fontStyleText = undefined;
        if (this.fontSizeText) {
            this.fontSizeText.destroy();
        }
        this.fontSizeText = undefined;
        if (this.colorPicker) {
            this.colorPicker.destroy();
        }
        this.colorPicker = undefined;
        if (this.underlineDrop) {
            this.underlineDrop.destroy();
        }
        this.underlineDrop = undefined;
        if (this.strikethroughBox) {
            this.strikethroughBox.destroy();
        }
        this.strikethroughBox = undefined;
        if (this.doublestrikethrough) {
            this.doublestrikethrough.destroy();
        }
        this.doublestrikethrough = undefined;
        if (this.superscript) {
            this.superscript.destroy();
        }
        this.superscript = undefined;
        if (this.subscript) {
            this.subscript.destroy();
        }
        this.subscript = undefined;
    }
}
/* tslint:enable:no-any */

/**
 * The Table properties dialog is used to modify properties of selected table.
 */
class TablePropertiesDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.hasTableWidth = false;
        this.hasCellWidth = false;
        this.bidi = false;
        /**
         * @private
         */
        this.isTableBordersAndShadingUpdated = false;
        /**
         * @private
         */
        this.isCellBordersAndShadingUpdated = false;
        this.tabObj = undefined;
        this.localValue = undefined;
        /**
         * @private
         */
        this.isCellOptionsUpdated = false;
        /**
         * @private
         */
        this.isTableOptionsUpdated = false;
        this.onBeforeOpen = () => {
            this.owner.updateFocus();
            this.loadTableProperties();
        };
        /**
         * @private
         */
        this.onCloseTablePropertyDialog = () => {
            this.unWireEvent.bind(this);
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.applyTableProperties = () => {
            let selection = this.owner.selection;
            if (!this.preferCheckBox.checked && !this.preferCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.tableFormat.preferredWidth) || selection.tableFormat.preferredWidth !== 0) {
                    this.tableFormat.preferredWidth = 0;
                    this.tableFormat.preferredWidthType = 'Point';
                }
            }
            if (this.tableFormat.hasValue('tableAlignment') && this.tableFormat.tableAlignment !== 'Left') {
                if (isNullOrUndefined(selection.tableFormat.leftIndent) || selection.tableFormat.leftIndent !== 0) {
                    this.tableFormat.leftIndent = 0;
                }
            }
            if (!this.rowHeightCheckBox.checked && !this.rowHeightCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.rowFormat.height) || selection.rowFormat.height !== 0) {
                    this.rowFormat.heightType = 'AtLeast';
                    this.rowFormat.height = 0;
                }
            }
            if (!this.preferredCellWidthCheckBox.checked && !this.preferredCellWidthCheckBox.indeterminate) {
                if (isNullOrUndefined(selection.cellFormat.preferredWidth) || selection.cellFormat.preferredWidth === 0) {
                    this.cellFormat.preferredWidthType = 'Point';
                    this.cellFormat.preferredWidth = 0;
                }
            }
            else {
                if (this.cellFormat.preferredWidthType === 'Percent') {
                    if (!this.tableFormat.hasValue('preferredWidth') && !this.tableFormat.hasValue('preferredWidthType')
                        && this.owner.selection.start.paragraph.associatedCell.ownerTable.tableFormat.preferredWidth === 0) {
                        // tslint:disable-next-line:max-line-length
                        let containerWidth = this.owner.selection.start.paragraph.associatedCell.ownerTable.getOwnerWidth(true);
                        let tableWidth = this.owner.selection.start.paragraph.associatedCell.ownerTable.getTableClientWidth(containerWidth);
                        this.tableFormat.preferredWidthType = 'Percent';
                        this.tableFormat.preferredWidth = tableWidth / HelperMethods.convertPixelToPoint(this.owner.clientArea.width) * 100;
                    }
                }
            }
            if (this.rowHeightValue) {
                this.rowFormat.height = this.rowHeightValue;
            }
            this.owner.owner.editorModule.initComplexHistory('TableProperties');
            this.owner.owner.editorModule.onTableFormat(this.tableFormat);
            this.owner.owner.editorModule.onRowFormat(this.rowFormat);
            this.owner.owner.editorModule.onCellFormat(this.cellFormat);
            this.owner.owner.editorHistory.updateComplexHistory();
            this.closeTablePropertiesDialog();
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.applyTableSubProperties = () => {
            if (this.isCellOptionsUpdated) {
                let cellFormat = this.owner.owner.cellOptionsDialogModule.cellFormat;
                this.owner.owner.cellOptionsDialogModule.applySubCellOptions(cellFormat);
            }
            if (this.isTableOptionsUpdated) {
                let tableFormat = this.owner.owner.tableOptionsDialogModule.tableFormat;
                this.owner.owner.tableOptionsDialogModule.applySubTableOptions(tableFormat);
            }
            this.isCellOptionsUpdated = false;
            this.isTableOptionsUpdated = false;
        };
        /**
         * @private
         */
        this.unWireEvent = () => {
            //Table Format
            this.preferCheckBox.change = undefined;
            this.tableWidthBox.change = undefined;
            this.tableWidthType.change = undefined;
            this.leftIndentBox.change = undefined;
            //Row Format
            this.rowHeightCheckBox.change = undefined;
            this.rowHeightBox.change = undefined;
            this.rowHeightType.change = undefined;
            this.repeatHeader.change = undefined;
            this.allowRowBreak.change = undefined;
            //Cell Format
            this.preferredCellWidthCheckBox.change = undefined;
            this.cellWidthBox.change = undefined;
            this.cellWidthType.change = undefined;
            this.cellFormat.destroy();
            this.rowFormat.destroy();
            this.tableFormat.destroy();
            this.rowHeightValue = undefined;
            this.owner.dialog2.open = this.owner.selection.hideCaret.bind(this.owner);
        };
        /**
         * @private
         */
        this.closeTablePropertiesDialog = () => {
            this.owner.dialog2.hide();
            this.owner.updateFocus();
        };
        this.changeBidirectional = (event) => {
            if (event.value === 'ltr') {
                this.rtlButton.checked = !this.ltrButton.checked;
                this.tableFormat.bidi = false;
            }
            else {
                this.ltrButton.checked = !this.rtlButton.checked;
                this.tableFormat.bidi = true;
            }
            if (this.tableFormat.bidi && this.tableFormat.tableAlignment === 'Left') {
                this.tableFormat.tableAlignment = 'Right';
            }
            else if (!this.tableFormat.bidi && this.tableFormat.tableAlignment === 'Right') {
                this.tableFormat.tableAlignment = 'Left';
            }
            this.activeTableAlignment(this.tableFormat, true);
        };
        /**
         * @private
         */
        this.changeTableCheckBox = () => {
            let enable = (this.preferCheckBox.checked || this.preferCheckBox.indeterminate);
            this.tableWidthBox.enabled = enable;
            this.tableWidthType.enabled = enable;
            if (enable) {
                this.tableFormat.preferredWidthType = (this.tableWidthType.value === 'Points') ?
                    'Point' : this.tableWidthType.value;
            }
            else {
                this.tableFormat.preferredWidthType = this.owner.selection.tableFormat.preferredWidthType;
            }
        };
        /**
         * @private
         */
        this.changeTableAlignment = (event) => {
            this.updateClassForAlignmentProperties(this.tableTab);
            let element = event.target;
            classList(element, ['e-de-table-alignment-active'], ['e-de-table-properties-alignment']);
            let bidi = this.tableFormat.bidi || this.rtlButton.checked;
            if ((element.classList.contains('e-de-table-left-alignment') && !bidi) ||
                (element.classList.contains('e-de-table-right-alignment') && bidi)) {
                this.leftIndentBox.enabled = true;
            }
            else {
                this.leftIndentBox.enabled = false;
            }
            this.tableFormat.tableAlignment = this.getTableAlignment();
        };
        /**
         * @private
         */
        this.changeTableRowCheckBox = () => {
            this.rowHeightType.enabled = this.rowHeightCheckBox.checked;
            this.rowHeightBox.enabled = this.rowHeightCheckBox.checked;
            if (this.rowHeightType.enabled) {
                this.rowFormat.heightType = this.rowHeightType.value;
            }
            else {
                this.rowFormat.heightType = this.owner.selection.rowFormat.heightType;
            }
        };
        /**
         * @private
         */
        this.changeTableCellCheckBox = () => {
            this.cellWidthType.enabled = this.preferredCellWidthCheckBox.checked;
            this.cellWidthBox.enabled = this.preferredCellWidthCheckBox.checked;
        };
        /**
         * @private
         */
        this.changeCellAlignment = (event) => {
            this.updateClassForCellAlignment(this.cellTab);
            let element = event.target;
            classList(element, ['e-de-table-alignment-active'], ['e-de-tablecell-alignment']);
            this.cellFormat.verticalAlignment = this.getCellAlignment();
        };
        //#endregion
        /**
         * @private
         */
        this.showTableOptionsDialog = () => {
            this.owner.owner.tableOptionsDialogModule.show();
            this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        /**
         * @private
         */
        this.showBordersShadingsPropertiesDialog = () => {
            this.owner.owner.bordersAndShadingDialogModule.show();
            this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        /**
         * @private
         */
        this.showCellOptionsDialog = () => {
            this.owner.owner.cellOptionsDialogModule.show();
            this.owner.dialog2.element.style.pointerEvents = 'none';
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    get cellFormat() {
        if (isNullOrUndefined(this.cellFormatIn)) {
            return this.cellFormatIn = new WCellFormat();
        }
        return this.cellFormatIn;
    }
    /**
     * @private
     */
    set cellFormat(value) {
        this.cellFormatIn = value;
    }
    /**
     * @private
     */
    get tableFormat() {
        if (isNullOrUndefined(this.tableFormatIn)) {
            this.tableFormatIn = new WTableFormat();
            return this.tableFormatIn;
        }
        return this.tableFormatIn;
    }
    /**
     * @private
     */
    set tableFormat(value) {
        this.tableFormatIn = value;
    }
    /**
     * @private
     */
    get rowFormat() {
        if (isNullOrUndefined(this.rowFormatInternal)) {
            this.rowFormatInternal = new WRowFormat();
            return this.rowFormatInternal;
        }
        return this.rowFormatInternal;
    }
    getModuleName() {
        return 'TablePropertiesDialog';
    }
    /**
     * @private
     */
    initTablePropertyDialog(localValue, isRtl) {
        this.localValue = localValue;
        let id = this.owner.owner.containerId + '_TablePropertiesDialog';
        this.target = createElement('div', { id: id, className: 'e-de-table-properties-dlg' });
        let ejtabContainer = createElement('div', { id: this.target.id + '_TabContainer' });
        this.target.appendChild(ejtabContainer);
        this.tableTab = createElement('div', {
            id: this.target.id + '_TablePropertiesContentDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        this.rowTab = createElement('div', {
            id: this.target.id + '_RowPropertiesDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        this.cellTab = createElement('div', {
            id: this.target.id + '_CellPropertiesDialogTab', className: 'e-de-table-ppty-dlg-tabs'
        });
        let separatorLine = createElement('div', { className: 'e-de-table-dialog-separator-line' });
        // tslint:disable-next-line:max-line-length
        let ejtab = createElement('div', { id: this.target.id + '_TablePropertiesDialogTab', className: 'e-de-table-ppty-tab' });
        let headerContainer = createElement('div', { className: 'e-tab-header' });
        let tableHeader = createElement('div', {
            id: this.target.id + '_tableHeader', innerHTML: localValue.getConstant('Table')
        });
        let rowHeader = createElement('div', {
            id: this.target.id + '_rowHeader', innerHTML: localValue.getConstant('Row')
        });
        let cellHeader = createElement('div', {
            id: this.target.id + '_cellHeader', innerHTML: localValue.getConstant('Cell')
        });
        headerContainer.appendChild(tableHeader);
        headerContainer.appendChild(rowHeader);
        headerContainer.appendChild(cellHeader);
        let contentContainer = createElement('div', { className: 'e-content' });
        let tableContent = createElement('div', { id: this.target.id + '_tableContent' });
        let rowContent = createElement('div', { id: this.target.id + '_rowContent' });
        let cellContent = createElement('div', { id: this.target.id + '_cellContent' });
        tableContent.appendChild(this.tableTab);
        rowContent.appendChild(this.rowTab);
        cellContent.appendChild(this.cellTab);
        contentContainer.appendChild(tableContent);
        contentContainer.appendChild(rowContent);
        contentContainer.appendChild(cellContent);
        ejtab.appendChild(headerContainer);
        ejtab.appendChild(contentContainer);
        ejtabContainer.appendChild(ejtab);
        this.initTableProperties(this.tableTab, localValue, this.owner.owner.enableRtl);
        this.initTableRowProperties(this.rowTab, localValue, this.owner.owner.enableRtl);
        this.initTableCellProperties(this.cellTab, localValue, this.owner.owner.enableRtl);
        this.tabObj = new Tab({ enableRtl: isRtl }, ejtab);
        this.target.appendChild(separatorLine);
        let alignMentButtons = this.tableTab.getElementsByClassName(this.tableTab.id + 'e-de-table-alignment');
        for (let i = 0; i < alignMentButtons.length; i++) {
            alignMentButtons[i].addEventListener('click', this.changeTableAlignment);
        }
        let cellAlignment = this.cellTab.getElementsByClassName(this.cellTab.id + 'e-de-table-cell-alignment');
        for (let i = 0; i < cellAlignment.length; i++) {
            cellAlignment[i].addEventListener('click', this.changeCellAlignment);
        }
        let tableTabHeader = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[0];
        let tableTabHeaderItem = tableTabHeader.getElementsByClassName('e-tab-wrap')[0];
        let rowTabHeader = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[1];
        let rowTabHeaderItem = rowTabHeader.getElementsByClassName('e-tab-wrap')[0];
        rowTabHeaderItem.classList.add('e-de-table-ppty-dlg-row-header');
        let cellTabHeader = this.tabObj.element.getElementsByClassName('e-item e-toolbar-item')[2];
        let cellTabHeaderItem = cellTabHeader.getElementsByClassName('e-tab-wrap')[0];
        cellTabHeaderItem.classList.add('e-de-table-ppty-dlg-cell-header');
        if (isRtl) {
            tableTabHeaderItem.classList.add('e-de-rtl');
            this.tabObj.element.getElementsByClassName('e-indicator')[0].style.left = '155px';
        }
        else {
            this.tabObj.element.getElementsByClassName('e-indicator')[0].style.right = '155px';
        }
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTablePropertyDialog(localValue, this.owner.owner.enableRtl);
        }
        if (this.owner.selection.caret.style.display !== 'none') {
            this.owner.selection.caret.style.display = 'none';
        }
        this.owner.dialog2.header = localValue.getConstant('Table Properties');
        this.owner.dialog2.position = { X: 'center', Y: 'center' };
        this.owner.dialog2.width = 'auto';
        this.owner.dialog2.height = 'auto';
        this.owner.dialog2.content = this.target;
        this.owner.dialog2.beforeOpen = this.onBeforeOpen;
        this.owner.dialog2.close = this.onCloseTablePropertyDialog;
        this.owner.dialog2.open = this.wireEvent.bind(this);
        this.owner.dialog2.buttons = [{
                click: this.applyTableProperties,
                buttonModel: { content: localValue.getConstant('Ok'), cssClass: 'e-flat e-table-ppty-okay', isPrimary: true }
            },
            {
                click: this.closeTablePropertiesDialog,
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-table-ppty-cancel' }
            }];
        //this.tabObj.select(0);
        this.owner.dialog2.dataBind();
        this.owner.dialog2.show();
    }
    /**
     * @private
     */
    calculateGridValue(table) {
        table.calculateGrid();
        table.isGridUpdated = false;
        table.buildTableColumns();
        table.isGridUpdated = true;
        this.owner.selection.owner.isLayoutEnabled = true;
        this.owner.layout.reLayoutTable(table);
        this.owner.owner.editorModule.reLayout(this.owner.selection);
        this.owner.owner.editorModule.updateSelectionTextPosition(true);
        let history = this.owner.owner.editorHistory;
        if (history && history.currentBaseHistoryInfo) {
            if (history.currentBaseHistoryInfo.modifiedProperties.length > 0) {
                history.currentBaseHistoryInfo.updateSelection();
            }
            history.updateHistory();
        }
        this.owner.owner.editorModule.fireContentChange();
    }
    /**
     * @private
     */
    loadTableProperties() {
        this.setTableProperties();
        this.setTableRowProperties();
        this.setTableCellProperties();
        if (!this.owner.owner.bordersAndShadingDialogModule) {
            this.bordersAndShadingButton.disabled = true;
        }
        else {
            this.bordersAndShadingButton.disabled = false;
        }
        // if (!this.owner.owner.tableOptionsDialogModule) {
        //     this.tableOptionButton.disabled = true;
        // } else {
        this.tableOptionButton.disabled = false;
        // }
        // if (!this.owner.owner.cellOptionsDialogModule) {
        //     this.cellOptionButton.disabled = true;
        // } else {
        this.cellOptionButton.disabled = false;
        // }
    }
    /**
     * @private
     */
    wireEvent() {
        this.owner.selection.hideCaret();
        //Table Format
        this.preferCheckBox.change = this.changeTableCheckBox.bind(this);
        this.tableWidthBox.change = this.onTableWidthChange.bind(this);
        this.tableWidthType.change = this.onTableWidthTypeChange.bind(this);
        this.leftIndentBox.change = this.onLeftIndentChange.bind(this);
        //Row Format
        this.rowHeightCheckBox.change = this.changeTableRowCheckBox.bind(this);
        this.rowHeightBox.change = this.onRowHeightChange.bind(this);
        this.rowHeightType.change = this.onRowHeightTypeChange.bind(this);
        this.allowRowBreak.change = this.onAllowBreakAcrossPage.bind(this);
        this.repeatHeader.change = this.onRepeatHeader.bind(this);
        //Cell Format
        this.preferredCellWidthCheckBox.change = this.changeTableCellCheckBox.bind(this);
        this.cellWidthBox.change = this.onCellWidthChange.bind(this);
        this.cellWidthType.change = this.onCellWidthTypeChange.bind(this);
    }
    //#region Table Format
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    initTableProperties(element, localValue, isRtl) {
        let container = createElement('div', { id: element.id + '_table_TabContainer' });
        let sizeHeader = createElement('div', {
            id: container.id + '_sizeLabel', innerHTML: localValue.getConstant('Size'),
            styles: 'width:100%;margin:0px;', className: 'e-de-table-dialog-options-label'
        });
        let parentContainer = createElement('div', { styles: 'display: inline-flex;' });
        let childContainer1 = createElement('div', {
            styles: 'float: left;',
            className: 'e-de-table-container-div'
        });
        let childContainer2 = createElement('div', {
            className: 'e-de-table-ppty-dlg-preferred-width-div'
        });
        let child1 = createElement('div', {
            styles: 'display: inline;',
            className: 'e-de-table-ppty-dlg-measure-div'
        });
        let child2 = createElement('div', {
            styles: 'display: inline;position: absolute;',
            className: 'e-de-table-ppty-dlg-measure-drop-down-div'
        });
        let childContainer3 = createElement('div');
        let preferCheckBox = createElement('input', {
            id: element.id + '_Prefer_Width_CheckBox', attrs: { 'type': 'checkbox' }
        });
        this.preferredWidth = createElement('input', { id: element.id + 'preferred_Width' });
        let controlDiv = createElement('div');
        let tableWidthType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('Points') +
                '</option><option>' + localValue.getConstant('Percent') + '</option>', id: element.id + '_width_dropdown'
        });
        let labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Measure in'), styles: 'width: 60px;font-size: 11px; font-weight: normal;'
        });
        let alignmentHeader = createElement('div', {
            innerHTML: localValue.getConstant('Alignment'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;margin: 0px;'
        });
        let alignmentContainer = createElement('div', { styles: 'height:85px;display:inline-flex' });
        let classDivName = element.id + 'e-de-table-alignment';
        let leftAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.left = createElement('div', {
            className: 'e-icons e-de-table-properties-alignment e-de-table-left-alignment ' + classDivName,
            id: element.id + '_left_alignment', styles: 'width:54px;height:54px;margin:2px'
        });
        leftAlignDiv.appendChild(this.left);
        let centerAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.center = createElement('div', {
            className: 'e-icons e-de-table-properties-alignment  e-de-table-center-alignment ' + classDivName,
            id: element.id + '_center_alignment', styles: 'width:54px;height:54px;margin:2px'
        });
        centerAlignDiv.appendChild(this.center);
        this.right = createElement('div', {
            styles: 'width:54px;height:54px;margin:2px', id: element.id + '_right_alignment',
            className: 'e-icons e-de-table-properties-alignment  e-de-table-right-alignment ' + classDivName
        });
        let rightAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        rightAlignDiv.appendChild(this.right);
        let leftlabel = createElement('label', {
            innerHTML: localValue.getConstant('Left'), className: 'e-de-table-dia-align-label'
        });
        let centerlabel = createElement('label', {
            innerHTML: localValue.getConstant('Center'), className: 'e-de-table-dia-align-label'
        });
        let rightlabel = createElement('label', {
            innerHTML: localValue.getConstant('Right'), className: 'e-de-table-dia-align-label'
        });
        let leftIndenetContainer = createElement('div', {
            className: 'e-de-table-ppty-dlg-left-indent-container'
        });
        let leftIndentLabelMargin;
        let leftIndentBoxMargin;
        if (isRtl) {
            leftIndentLabelMargin = 'left: 45px;';
            leftIndentBoxMargin = 'left: 45px;';
        }
        else {
            leftIndentLabelMargin = 'right: 45px;';
            leftIndentBoxMargin = 'right: 45px;';
        }
        this.indentingLabel = createElement('label', {
            innerHTML: localValue.getConstant('Indent from left'),
            // tslint:disable-next-line:max-line-length
            styles: 'font-weight: normal;font-size: 11px;position:relative;display:block;margin-bottom:18px;top:10px;' + leftIndentLabelMargin
        });
        let leftIndentBox = createElement('div', {
            styles: 'margin-top: 15px;position: relative;' + leftIndentBoxMargin
        });
        this.leftIndent = createElement('input', { id: element.id + '_left_indent' });
        let tableDirHeader = createElement('div', {
            innerHTML: localValue.getConstant('Table direction'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;margin: 0px;padding-top:14px;'
        });
        let tableDirContainer = createElement('div', { styles: 'display:flex' });
        let rtlDiv = createElement('div', { id: element.id + '_TableDirDiv', className: 'e-de-tbl-rtl-btn-div' });
        let rtlInputELe = createElement('input', { id: element.id + '_rtlEle' });
        rtlDiv.appendChild(rtlInputELe);
        tableDirContainer.appendChild(rtlDiv);
        let ltrDiv = createElement('div', { id: element.id + '_DirDiv', className: 'e-de-tbl-ltr-btn-div' });
        let ltrInputELe = createElement('input', { id: element.id + '_ltrEle' });
        ltrDiv.appendChild(ltrInputELe);
        tableDirContainer.appendChild(ltrDiv);
        this.rtlButton = new RadioButton({
            label: localValue.getConstant('Right-to-left'),
            value: 'rtl', cssClass: 'e-small', change: this.changeBidirectional,
            enableRtl: isRtl
        });
        this.rtlButton.appendTo(rtlInputELe);
        this.ltrButton = new RadioButton({
            label: localValue.getConstant('Left-to-right'),
            value: 'ltr', cssClass: 'e-small', change: this.changeBidirectional,
            enableRtl: isRtl
        });
        this.ltrButton.appendTo(ltrInputELe);
        let tableOptionContiner = createElement('div', {
            className: 'e-de-tbl-dlg-border-btn'
        });
        if (isRtl) {
            tableOptionContiner.style.cssFloat = 'left';
        }
        this.bordersAndShadingButton = createElement('button', {
            innerHTML: localValue.getConstant('Borders and Shading'),
            id: element.id + '_borders_and_shadings', className: 'e-control e-btn e-flat e-de-ok-button',
            attrs: { type: 'button' }
        });
        this.tableOptionButton = createElement('button', {
            className: 'e-control e-btn e-flat', innerHTML: localValue.getConstant('Options'),
            id: element.id + '_table_cellmargin', attrs: { type: 'button' }
        });
        this.tableOptionButton.addEventListener('click', this.showTableOptionsDialog);
        this.bordersAndShadingButton.addEventListener('click', this.showBordersShadingsPropertiesDialog);
        tableOptionContiner.appendChild(this.bordersAndShadingButton);
        tableOptionContiner.appendChild(this.tableOptionButton);
        leftIndenetContainer.appendChild(this.indentingLabel);
        leftIndentBox.appendChild(this.leftIndent);
        leftIndenetContainer.appendChild(leftIndentBox);
        alignmentContainer.appendChild(leftAlignDiv);
        alignmentContainer.appendChild(centerAlignDiv);
        alignmentContainer.appendChild(rightAlignDiv);
        leftAlignDiv.appendChild(leftlabel);
        centerAlignDiv.appendChild(centerlabel);
        rightAlignDiv.appendChild(rightlabel);
        alignmentContainer.appendChild(leftIndenetContainer);
        container.appendChild(sizeHeader);
        element.appendChild(container);
        childContainer1.appendChild(preferCheckBox);
        parentContainer.appendChild(childContainer1);
        childContainer2.appendChild(this.preferredWidth);
        parentContainer.appendChild(childContainer2);
        controlDiv.appendChild(tableWidthType);
        child1.appendChild(labeltext);
        child2.appendChild(controlDiv);
        childContainer3.appendChild(child1);
        childContainer3.appendChild(child2);
        parentContainer.appendChild(childContainer3);
        element.appendChild(parentContainer);
        element.appendChild(alignmentHeader);
        element.appendChild(alignmentContainer);
        element.appendChild(tableDirHeader);
        element.appendChild(tableDirContainer);
        element.appendChild(tableOptionContiner);
        this.tableWidthBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.tableWidthBox.appendTo(this.preferredWidth);
        this.leftIndentBox = new NumericTextBox({
            value: 0, decimals: 2, min: -1584, max: 1584, width: 140, enablePersistence: false
        });
        this.leftIndentBox.appendTo(this.leftIndent);
        this.preferCheckBox = new CheckBox({
            label: localValue.getConstant('Preferred Width'), enableRtl: isRtl
        });
        this.preferCheckBox.appendTo(preferCheckBox);
        this.tableWidthType = new DropDownList({ width: '120px', enableRtl: isRtl });
        this.tableWidthType.appendTo(tableWidthType);
        if (isRtl) {
            rtlDiv.classList.add('e-de-rtl');
            childContainer2.classList.add('e-de-rtl');
            child1.classList.add('e-de-rtl');
            child2.classList.add('e-de-rtl');
            leftIndenetContainer.classList.add('e-de-rtl');
            tableOptionContiner.classList.add('e-de-rtl');
            this.bordersAndShadingButton.classList.add('e-de-rtl');
            leftAlignDiv.classList.add('e-de-rtl');
            centerAlignDiv.classList.add('e-de-rtl');
            rightAlignDiv.classList.add('e-de-rtl');
        }
    }
    /**
     * @private
     */
    onTableWidthChange() {
        this.tableFormat.preferredWidth = this.tableWidthBox.value;
    }
    /**
     * @private
     */
    onTableWidthTypeChange() {
        let value;
        let table = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        let width = HelperMethods.convertPixelToPoint(this.owner.clientArea.width);
        if (this.tableWidthType.text === 'Percent' && this.owner.selection.tableFormat.preferredWidthType !== 'Percent') {
            value = this.tableWidthBox.value / width * 100;
            this.formatNumericTextBox(this.tableWidthBox, 'Percent', value);
        }
        else if (this.tableWidthType.text === 'Points' && this.owner.selection.tableFormat.preferredWidthType !== 'Point') {
            value = width / 100 * this.tableWidthBox.value;
            this.formatNumericTextBox(this.tableWidthBox, 'Point', value);
        }
        else {
            if (this.tableWidthBox.format === '#\'\%\'') {
                if (this.tableWidthType.text === 'Points') {
                    value = width / 100 * this.tableWidthBox.value;
                }
                else {
                    value = this.tableWidthBox.value;
                }
            }
            else {
                if (this.tableWidthType.text === 'Percent') {
                    value = this.tableWidthBox.value / width * 100;
                }
                else {
                    value = this.tableWidthBox.value;
                }
            }
            // tslint:disable-next-line:max-line-length
            this.formatNumericTextBox(this.tableWidthBox, (this.tableWidthType.text === 'Points') ? 'Point' : this.tableWidthType.text, value);
        }
        this.tableFormat.preferredWidthType = (this.tableWidthType.text === 'Points') ? 'Point' : this.tableWidthType.text;
    }
    /**
     * @private
     */
    onLeftIndentChange() {
        this.tableFormat.leftIndent = this.leftIndentBox.value;
    }
    setTableProperties() {
        //instance of Table Property values
        let tableFormat = this.owner.selection.tableFormat;
        let tableHasWidth = tableFormat.preferredWidth > 0;
        let preferredWidth = tableFormat.preferredWidth;
        if (isNullOrUndefined(tableFormat.preferredWidth)) {
            this.preferCheckBox.indeterminate = true;
            let startTable = this.owner.selection.start.paragraph.associatedCell.ownerTable;
            let table = startTable.combineWidget(this.owner);
            preferredWidth = table.tableFormat.preferredWidth;
        }
        else {
            this.preferCheckBox.checked = tableHasWidth;
        }
        this.tableWidthBox.enabled = tableHasWidth;
        this.tableWidthType.enabled = tableHasWidth;
        this.formatNumericTextBox(this.tableWidthBox, tableFormat.preferredWidthType, preferredWidth);
        if (tableFormat.preferredWidthType === 'Auto' || tableFormat.preferredWidthType === 'Point') {
            this.tableWidthType.index = 0;
        }
        else {
            this.tableWidthType.index = 1;
        }
        this.activeTableAlignment(tableFormat, false);
        if (tableFormat.bidi) {
            this.rtlButton.checked = true;
            this.ltrButton.checked = false;
        }
        else {
            this.ltrButton.checked = true;
            this.rtlButton.checked = false;
        }
    }
    activeTableAlignment(tableFormat, isChanged) {
        let tableAlignment = isChanged ? this.tableFormat.tableAlignment : undefined;
        // Consider the TableAlignment based on the Bidirectional property.
        if (isNullOrUndefined(tableAlignment)) {
            if (tableFormat.bidi) {
                if (tableFormat.tableAlignment === 'Left') {
                    tableAlignment = 'Right';
                }
                else if (tableFormat.tableAlignment === 'Right') {
                    tableAlignment = 'Left';
                }
            }
            else {
                tableAlignment = tableFormat.tableAlignment;
            }
        }
        if (tableFormat.bidi) {
            this.leftIndentBox.enabled = tableAlignment === 'Right';
            this.indentingLabel.innerHTML = this.localValue.getConstant('Indent from right');
        }
        else {
            this.leftIndentBox.enabled = tableAlignment === 'Left';
            this.indentingLabel.innerHTML = this.localValue.getConstant('Indent from left');
        }
        this.leftIndentBox.value = tableFormat.leftIndent;
        classList(this.left, [], ['e-de-table-alignment-active']);
        classList(this.right, [], ['e-de-table-alignment-active']);
        classList(this.center, [], ['e-de-table-alignment-active']);
        if (tableAlignment === 'Left') {
            this.left.classList.add('e-de-table-alignment-active');
        }
        else if (tableAlignment === 'Center') {
            this.center.classList.add('e-de-table-alignment-active');
        }
        else if (tableAlignment === 'Right') {
            this.right.classList.add('e-de-table-alignment-active');
        }
    }
    /**
     * @private
     */
    getTableAlignment() {
        let id = this.tableTab.id;
        let groupButtons = this.tableTab.getElementsByClassName(id + 'e-de-table-alignment');
        for (let j = 0; j < groupButtons.length; j++) {
            let groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                if (j === 0) {
                    return this.ltrButton.checked ? 'Left' : 'Right';
                }
                else if (j === 1) {
                    return 'Center';
                }
                else {
                    return this.ltrButton.checked ? 'Right' : 'Left';
                }
            }
        }
        return undefined;
    }
    /**
     * @private
     */
    updateClassForAlignmentProperties(element) {
        let id = element.id;
        let groupButtons = element.getElementsByClassName(id + 'e-de-table-alignment');
        for (let j = 0; j < groupButtons.length; j++) {
            let groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                classList(groupButton, ['e-de-table-properties-alignment'], ['e-de-table-alignment-active']);
            }
        }
    }
    //#endregion
    //#region Row Format
    /**
     * @private
     */
    initTableRowProperties(element, localValue, isRtl) {
        let rowDiv = createElement('div', { styles: 'width: 100%;' });
        let sizeLabeldiv = createElement('div', {
            innerHTML: localValue.getConstant('Size'),
            styles: 'width: 100%;',
            className: 'e-de-table-dialog-options-label'
        });
        let parentDiv = createElement('div', { styles: 'display: inline-flex;width: 100%;' });
        let childDiv1 = createElement('div', {
            className: 'e-de-table-header-div', styles: 'margin-top:6px'
        });
        let rowHeightCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_height_CheckBox'
        });
        let childdiv2 = createElement('div', {
            className: 'e-de-row-ht-top'
        });
        this.rowHeight = createElement('input', {
            attrs: { 'type': 'text' }, 'id': element.id + '_table_row_height'
        });
        let child2 = createElement('div', { className: 'e-de-ht-wdth-type' });
        let child3 = createElement('div');
        let child4 = createElement('div');
        let controlDiv = createElement('div');
        let rowHeightType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('At least')
                + '</option><option>' + localValue.getConstant('Exactly') + '</option>',
            id: element.id + '_height_type'
        });
        // tslint:disable-next-line:max-line-length
        let labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Row height is'), styles: 'font-size: 11px;font-weight: normal;width: 75px;display:block;margin-bottom:8px'
        });
        rowDiv.appendChild(sizeLabeldiv);
        element.appendChild(rowDiv);
        childDiv1.appendChild(rowHeightCheckBox);
        parentDiv.appendChild(childDiv1);
        childdiv2.appendChild(this.rowHeight);
        parentDiv.appendChild(childdiv2);
        controlDiv.appendChild(rowHeightType);
        child3.appendChild(labeltext);
        child4.appendChild(controlDiv);
        child2.appendChild(child3);
        child2.appendChild(child4);
        parentDiv.appendChild(child2);
        element.appendChild(parentDiv);
        let alignmentDiv = createElement('div', {
            innerHTML: localValue.getConstant('Options'), styles: 'width: 100%;',
            className: 'e-de-table-dialog-options-label'
        });
        // tslint:disable-next-line:max-line-length
        let allowRowContainer = createElement('div', { className: 'e-de-table-ppty-options-break' });
        let repeatHeaderContaniner = createElement('div', { className: 'e-de-table-ppty-options-header-row' });
        let allowRowBreak = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_allow_row_break'
        });
        let repeatHeader = createElement('input', {
            attrs: { 'type': 'checkbox' }, 'id': element.id + '_repeat_header'
        });
        allowRowContainer.appendChild(allowRowBreak);
        repeatHeaderContaniner.appendChild(repeatHeader);
        element.appendChild(alignmentDiv);
        element.appendChild(allowRowContainer);
        element.appendChild(repeatHeaderContaniner);
        this.rowHeightBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.rowHeightBox.appendTo(this.rowHeight);
        this.rowHeightCheckBox = new CheckBox({
            label: localValue.getConstant('Specify height'),
            enableRtl: isRtl
        });
        this.rowHeightCheckBox.appendTo(rowHeightCheckBox);
        this.rowHeightType = new DropDownList({ width: '120px', enableRtl: isRtl });
        this.rowHeightType.appendTo(rowHeightType);
        this.allowRowBreak = new CheckBox({
            label: localValue.getConstant('Allow row to break across pages'),
            enableRtl: isRtl
        });
        this.allowRowBreak.appendTo(allowRowBreak);
        this.repeatHeader = new CheckBox({
            label: localValue.getConstant('Repeat as header row at the top of each page'),
            enableRtl: isRtl
        });
        this.repeatHeader.appendTo(repeatHeader);
        if (isRtl) {
            child3.classList.add('e-de-rtl');
            child4.classList.add('e-de-rtl');
            childdiv2.classList.add('e-de-rtl');
        }
    }
    setTableRowProperties() {
        let rowFormat = this.owner.selection.rowFormat;
        let enableRowHeight = (rowFormat.height > 0 || rowFormat.heightType === 'Exactly');
        //instance of table row values
        if (enableRowHeight) {
            this.rowHeightCheckBox.checked = true;
        }
        else {
            if (rowFormat.heightType === undefined) {
                this.rowHeightCheckBox.indeterminate = true;
                enableRowHeight = true;
            }
            else {
                this.rowHeightCheckBox.checked = false;
            }
        }
        this.rowHeightBox.enabled = enableRowHeight;
        this.rowHeightType.enabled = enableRowHeight;
        let enabledHeader = this.enableRepeatHeader() ? false : true;
        if (isNullOrUndefined(this.owner.selection.rowFormat.isHeader)) {
            this.repeatHeader.indeterminate = true;
            this.repeatHeader.disabled = true;
        }
        else if (this.owner.selection.rowFormat.isHeader) {
            this.repeatHeader.checked = !enabledHeader;
            this.repeatHeader.indeterminate = enabledHeader;
            this.repeatHeader.disabled = enabledHeader;
        }
        else {
            this.repeatHeader.checked = false;
            this.repeatHeader.indeterminate = false;
            this.repeatHeader.disabled = enabledHeader;
        }
        if (isNullOrUndefined(rowFormat.allowBreakAcrossPages)) {
            this.allowRowBreak.indeterminate = true;
        }
        else {
            this.allowRowBreak.checked = rowFormat.allowBreakAcrossPages;
        }
        this.rowHeightBox.value = rowFormat.height;
        if (rowFormat.heightType === 'Auto' || rowFormat.heightType === 'AtLeast') {
            this.rowHeightType.index = 0;
        }
        else {
            this.rowHeightType.index = 1;
        }
    }
    /**
     * @private
     */
    onRowHeightChange() {
        this.rowHeightValue = this.rowHeightBox.value;
    }
    /**
     * @private
     */
    onRowHeightTypeChange() {
        this.rowFormat.heightType = this.rowHeightType.text;
    }
    /**
     * @private
     */
    onAllowBreakAcrossPage() {
        this.rowFormat.allowBreakAcrossPages = this.allowRowBreak.checked;
    }
    /**
     * @private
     */
    onRepeatHeader() {
        this.rowFormat.isHeader = this.repeatHeader.checked;
    }
    /**
     * @private
     */
    enableRepeatHeader() {
        let selection = this.owner.selection;
        let start = selection.start;
        let end = selection.end;
        if (!selection.isForward) {
            start = selection.end;
            end = selection.start;
        }
        let startCell = start.paragraph.associatedCell;
        let endCell = end.paragraph.associatedCell;
        return startCell.ownerRow.index === 0 && endCell.ownerTable.equals(startCell.ownerTable);
    }
    //#endregion
    //#region Cell Format
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    initTableCellProperties(element, localValue, isRtl) {
        let sizeDiv = createElement('div', { styles: 'width: 100%;' });
        let div = createElement('div', {
            innerHTML: localValue.getConstant('Size'), className: 'e-de-table-dialog-options-label',
            styles: 'width: 100%;',
        });
        let parentdiv = createElement('div', { styles: 'width: 100%;display: inline-flex;' });
        let childdiv1 = createElement('div', {
            className: 'e-de-table-cell-header-div', styles: 'margin-top:9px'
        });
        let preferredCellWidthCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: element.id + '_Prefer_Width_CheckBox_cell'
        });
        let childdiv2 = createElement('div', {
            styles: 'padding:0px 20px',
        });
        this.preferredCellWidth = createElement('input', {
            id: element.id + 'tablecell_Width_textBox', attrs: { 'type': 'text' }
        });
        let child2 = createElement('div', {
            className: 'e-de-ht-wdth-type'
        });
        let child3 = createElement('div');
        let child4 = createElement('div');
        let controlDiv = createElement('div');
        let cellWidthType = createElement('select', {
            innerHTML: '<option>' + localValue.getConstant('Points') + '</option><option>' +
                localValue.getConstant('Percent') + '</option>', 'id': element.id + '_measure_type_cell'
        });
        let labeltext = createElement('label', {
            innerHTML: localValue.getConstant('Measure in'),
            styles: 'font-size: 11px;font-weight: normal;display:block;margin-bottom:8px'
        });
        sizeDiv.appendChild(div);
        element.appendChild(sizeDiv);
        childdiv1.appendChild(preferredCellWidthCheckBox);
        parentdiv.appendChild(childdiv1);
        childdiv2.appendChild(this.preferredCellWidth);
        parentdiv.appendChild(childdiv2);
        controlDiv.appendChild(cellWidthType);
        child3.appendChild(labeltext);
        child4.appendChild(controlDiv);
        child2.appendChild(child3);
        child2.appendChild(child4);
        parentdiv.appendChild(child2);
        element.appendChild(parentdiv);
        let alignmentDiv = createElement('div', {
            innerHTML: localValue.getConstant('Vertical alignment'),
            styles: 'width: 100%;margin: 0px;',
            className: 'e-de-table-dialog-options-label'
        });
        let classDivName = element.id + 'e-de-table-cell-alignment';
        let divAlignment = createElement('div', {
            styles: 'width: 100%;height: 100px;'
        });
        let divStyle = 'width:54px;height:54px;margin:2px;border-style:solid;border-width:1px';
        let topAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellTopAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_top-alignment',
            className: 'e-icons e-de-tablecell-alignment  e-de-tablecell-top-alignment ' + classDivName
        });
        topAlignDiv.appendChild(this.cellTopAlign);
        let centerAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellCenterAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_center-alignment',
            className: 'e-icons e-de-tablecell-alignment  e-de-tablecell-center-alignment ' + classDivName
        });
        centerAlignDiv.appendChild(this.cellCenterAlign);
        let bottomAlignDiv = createElement('div', { className: 'e-de-table-dia-align-div' });
        this.cellBottomAlign = createElement('div', {
            styles: divStyle, id: element.id + '_cell_bottom-alignment',
            className: 'e-icons e-de-tablecell-alignment e-de-tablecell-bottom-alignment  ' + classDivName
        });
        bottomAlignDiv.appendChild(this.cellBottomAlign);
        let topLabel = createElement('label', {
            innerHTML: localValue.getConstant('Top'), className: 'e-de-table-dia-align-label'
        });
        let centerLabel = createElement('label', {
            innerHTML: localValue.getConstant('Center'), className: 'e-de-table-dia-align-label'
        });
        let bottomLabel = createElement('label', {
            innerHTML: localValue.getConstant('Bottom'), className: 'e-de-table-dia-align-label'
        });
        this.cellOptionButton = createElement('button', {
            innerHTML: localValue.getConstant('Options'), id: element.id + '_table_cellmargin',
            className: 'e-control e-btn e-flat', attrs: { type: 'button' }
        });
        this.cellOptionButton.style.cssFloat = isRtl ? 'left' : 'right';
        divAlignment.appendChild(topAlignDiv);
        divAlignment.appendChild(centerAlignDiv);
        divAlignment.appendChild(bottomAlignDiv);
        topAlignDiv.appendChild(topLabel);
        centerAlignDiv.appendChild(centerLabel);
        bottomAlignDiv.appendChild(bottomLabel);
        element.appendChild(alignmentDiv);
        element.appendChild(divAlignment);
        element.appendChild(this.cellOptionButton);
        this.cellOptionButton.addEventListener('click', this.showCellOptionsDialog);
        this.cellWidthBox = new NumericTextBox({
            value: 0, decimals: 2, min: 0, max: 1584, width: 120, enablePersistence: false
        });
        this.cellWidthBox.appendTo(this.preferredCellWidth);
        this.preferredCellWidthCheckBox = new CheckBox({ label: localValue.getConstant('Preferred Width'), enableRtl: isRtl });
        this.preferredCellWidthCheckBox.appendTo(preferredCellWidthCheckBox);
        this.cellWidthType = new DropDownList({ width: '120px', enableRtl: isRtl });
        this.cellWidthType.appendTo(cellWidthType);
        if (isRtl) {
            childdiv2.classList.add('e-de-rtl');
            child3.classList.add('e-de-rtl');
            child4.classList.add('e-de-rtl');
            this.cellOptionButton.classList.add('e-de-rtl');
            topAlignDiv.classList.add('e-de-rtl');
            centerAlignDiv.classList.add('e-de-rtl');
            bottomAlignDiv.classList.add('e-de-rtl');
        }
    }
    setTableCellProperties() {
        let cellFormat = this.owner.selection.cellFormat;
        //instance of table cell Values
        this.hasCellWidth = cellFormat.preferredWidth > 0;
        let preferredWidth = cellFormat.preferredWidth;
        if (isNullOrUndefined(cellFormat.preferredWidth)) {
            this.preferredCellWidthCheckBox.indeterminate = true;
            preferredWidth = this.owner.selection.start.paragraph.associatedCell.cellFormat.preferredWidth;
        }
        else {
            this.preferredCellWidthCheckBox.checked = this.hasCellWidth;
        }
        this.cellWidthBox.enabled = this.hasCellWidth;
        this.cellWidthType.enabled = this.hasCellWidth;
        if (cellFormat.preferredWidthType === 'Auto' || cellFormat.preferredWidthType === 'Point') {
            this.cellWidthType.index = 0;
        }
        else {
            this.cellWidthType.index = 1;
        }
        this.formatNumericTextBox(this.cellWidthBox, cellFormat.preferredWidthType, preferredWidth);
        classList(this.cellTopAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        classList(this.cellCenterAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        classList(this.cellBottomAlign, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
        if (cellFormat.verticalAlignment === 'Top') {
            this.cellTopAlign.classList.add('e-de-table-alignment-active');
        }
        else if (cellFormat.verticalAlignment === 'Center') {
            this.cellCenterAlign.classList.add('e-de-table-alignment-active');
        }
        else if (cellFormat.verticalAlignment === 'Bottom') {
            this.cellBottomAlign.classList.add('e-de-table-alignment-active');
        }
    }
    /**
     * @private
     */
    updateClassForCellAlignment(element) {
        let cellAlignments = element.getElementsByClassName(element.id + 'e-de-table-cell-alignment');
        for (let j = 0; j < cellAlignments.length; j++) {
            let cellAlignment = cellAlignments[j];
            if (cellAlignment.classList.contains('e-de-table-alignment-active')) {
                classList(cellAlignment, ['e-de-tablecell-alignment'], ['e-de-table-alignment-active']);
            }
        }
    }
    /**
     * @private
     */
    formatNumericTextBox(textBox, format, value) {
        if (format === 'Auto' || format === 'Point') {
            textBox.format = 'n2';
        }
        else {
            textBox.format = '#\'\%\'';
        }
        textBox.step = 1;
        textBox.decimals = 2;
        textBox.value = value;
    }
    /**
     * @private
     */
    getCellAlignment() {
        let id = this.cellTab.id;
        let groupButtons = this.cellTab.getElementsByClassName(id + 'e-de-table-cell-alignment');
        for (let j = 0; j < groupButtons.length; j++) {
            let groupButton = groupButtons[j];
            if (groupButton.classList.contains('e-de-table-alignment-active')) {
                if (j === 0) {
                    return 'Top';
                }
                else if (j === 1) {
                    return 'Center';
                }
                else {
                    return 'Bottom';
                }
            }
        }
        return this.owner.selection.cellFormat.verticalAlignment;
    }
    /**
     * @private
     */
    onCellWidthChange() {
        this.cellFormat.preferredWidth = this.cellWidthBox.value;
    }
    /**
     * @private
     */
    onCellWidthTypeChange() {
        let value;
        let table = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        let containerWidth = table.getOwnerWidth(true);
        let tableWidth = table.getTableClientWidth(containerWidth);
        if (this.cellWidthType.text === 'Percent' && this.owner.selection.cellFormat.preferredWidthType !== 'Percent') {
            value = this.cellWidthBox.value / tableWidth * 100;
            this.formatNumericTextBox(this.cellWidthBox, 'Percent', value);
        }
        else if (this.cellWidthType.text === 'Points' && this.owner.selection.cellFormat.preferredWidthType !== 'Point') {
            value = tableWidth / 100 * this.cellWidthBox.value;
            this.formatNumericTextBox(this.cellWidthBox, 'Point', value);
        }
        else {
            if (this.cellWidthBox.format === '#\'\%\'') {
                if (this.cellWidthType.text === 'Points') {
                    value = tableWidth / 100 * this.cellWidthBox.value;
                }
                else {
                    value = this.cellWidthBox.value;
                }
            }
            else {
                if (this.cellWidthType.text === 'Percent') {
                    value = this.cellWidthBox.value / tableWidth * 100;
                }
                else {
                    value = this.cellWidthBox.value;
                }
            }
            // tslint:disable-next-line:max-line-length
            this.formatNumericTextBox(this.cellWidthBox, (this.cellWidthType.text === 'Points') ? 'Point' : this.cellWidthType.text, value);
        }
        this.cellFormat.preferredWidthType = (this.cellWidthType.text === 'Points') ? 'Point' : this.cellWidthType.text;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let s = 0; s < this.target.childNodes.length; s++) {
                this.target.removeChild(this.target.childNodes[s]);
                s--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.cellAlignment = undefined;
        this.tableAlignment = undefined;
        this.owner = undefined;
        this.preferCheckBox = undefined;
        this.tableWidthType = undefined;
        this.preferredWidth = undefined;
        this.rowHeightType = undefined;
        this.rowHeightCheckBox = undefined;
        this.rowHeight = undefined;
        this.cellWidthType = undefined;
        this.preferredCellWidthCheckBox = undefined;
        this.preferredCellWidth = undefined;
        this.tableTab = undefined;
        this.rowTab = undefined;
        this.cellTab = undefined;
        this.left = undefined;
        this.center = undefined;
        this.right = undefined;
        this.leftIndent = undefined;
        this.allowRowBreak = undefined;
        this.repeatHeader = undefined;
        this.cellTopAlign = undefined;
        this.cellCenterAlign = undefined;
        this.cellBottomAlign = undefined;
        this.tableFormat.destroy();
        this.cellFormat.destroy();
        this.tableFormat = undefined;
        this.cellFormat = undefined;
    }
}

/**
 * The Borders and Shading dialog is used to modify borders and shading options for selected table or cells.
 */
class BordersAndShadingDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.cellFormat = new WCellFormat();
        this.tableFormat = new WTableFormat();
        this.isShadingChanged = false;
        this.applyBordersShadingsProperties = () => {
            let tablePropertiesDialog = this.owner.owner.tablePropertiesDialogModule;
            let selectedCell = this.owner.selection.start.paragraph.associatedCell;
            //Need to bind the properties with current cell and current table formats.
            let borders = undefined;
            if (this.checkClassName(this.previewDivTopTop) || this.checkClassName(this.previewDivTopBottom)
                || this.checkClassName(this.previewDivTopCenter) || this.checkClassName(this.previewDivBottomcenter)
                || this.checkClassName(this.previewDivBottomLeft) || this.checkClassName(this.previewDivBottomRight)
                || this.checkClassName(this.previewDivDiagonalRight) || this.checkClassName(this.previewDivLeftDiagonal)) {
                borders = new WBorders();
                if (this.checkClassName(this.previewDivTopTop)) {
                    borders.top = this.getBorder();
                }
                if (this.checkClassName(this.previewDivTopBottom)) {
                    borders.bottom = this.getBorder();
                }
                if (this.checkClassName(this.previewDivBottomLeft)) {
                    borders.left = this.getBorder();
                }
                if (this.checkClassName(this.previewDivBottomRight)) {
                    borders.right = this.getBorder();
                }
                if (this.checkClassName(this.previewDivTopCenter)) {
                    borders.horizontal = this.getBorder();
                }
                if (this.checkClassName(this.previewDivBottomcenter)) {
                    borders.vertical = this.getBorder();
                }
                if (this.checkClassName(this.previewDivLeftDiagonal)) {
                    borders.diagonalDown = this.getBorder();
                }
                if (this.checkClassName(this.previewDivDiagonalRight)) {
                    borders.diagonalUp = this.getBorder();
                }
            }
            let shading = new WShading();
            let editorModule = this.owner.owner.editorModule;
            shading.backgroundColor = this.shadingColorPicker.value;
            if (this.ulelementShading.index === 0) {
                this.applyTo = 0;
                if (tablePropertiesDialog) {
                    tablePropertiesDialog.isCellBordersAndShadingUpdated = true;
                }
                this.cellFormat.borders = new WBorders();
                if (!isNullOrUndefined(borders)) {
                    editorModule.applyBordersInternal(this.cellFormat.borders, borders);
                }
                else if (this.noneDiv.classList.contains('e-de-table-border-inside-setting-click')) {
                    editorModule.applyBordersInternal(this.cellFormat.borders, new WBorders());
                }
                // Once option has been added for texture and foreground, need to handle this similar to Shading Fill.
                if (!isNullOrUndefined(selectedCell.cellFormat.shading)) {
                    shading.foregroundColor = selectedCell.cellFormat.shading.foregroundColor;
                    shading.textureStyle = selectedCell.cellFormat.shading.textureStyle;
                }
                this.cellFormat.shading = new WShading();
                editorModule.applyShading(this.cellFormat.shading, shading);
            }
            else {
                if (tablePropertiesDialog) {
                    tablePropertiesDialog.isTableBordersAndShadingUpdated = true;
                }
                this.applyTo = 1;
                let currentTableFormat = this.owner.owner.selection.tableFormat.table.tableFormat;
                this.tableFormat.copyFormat(currentTableFormat);
                this.tableFormat.borders = new WBorders();
                if (!isNullOrUndefined(borders)) {
                    editorModule.applyBordersInternal(this.tableFormat.borders, borders);
                }
                else if (this.noneDiv.classList.contains('e-de-table-border-inside-setting-click')) {
                    editorModule.applyBordersInternal(this.tableFormat.borders, new WBorders());
                }
                // Once option has been added for texture and foreground, need to handle this similar to Shading Fill.
                if (!isNullOrUndefined(currentTableFormat.shading)) {
                    shading.foregroundColor = currentTableFormat.shading.foregroundColor;
                    shading.textureStyle = currentTableFormat.shading.textureStyle;
                }
                this.tableFormat.shading = new WShading();
                this.isShadingChanged = currentTableFormat.shading.backgroundColor !== shading.backgroundColor;
                editorModule.applyShading(this.tableFormat.shading, shading);
            }
            this.applyFormat();
            this.closeDialog();
        };
        /**
         * @private
         */
        this.closeDialog = () => {
            this.owner.dialog.hide();
            this.closeBordersShadingsDialog();
        };
        this.closeBordersShadingsDialog = () => {
            this.owner.dialog2.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        this.handleSettingCheckBoxAction = (event) => {
            let targetId = event.target.id;
            let tableBorderDialogId = this.target.id;
            if (targetId === tableBorderDialogId + '_None_Div' || targetId === tableBorderDialogId + '_None_Div_Container'
                || targetId === tableBorderDialogId + '_None_Div_Transparent') {
                this.updateClassForSettingDivElements();
                this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('none');
            }
            else if (targetId === tableBorderDialogId + '_Box_Div' || targetId === tableBorderDialogId + '_Box_Div_Container'
                || targetId === tableBorderDialogId + '_Box_Div_Transparent') {
                this.updateClassForSettingDivElements();
                this.boxDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('box');
            }
            else if (targetId === tableBorderDialogId + '_All_Div' || targetId === tableBorderDialogId + '_All_Div_Container'
                || targetId === tableBorderDialogId + '_All_Div_Transparent') {
                this.updateClassForSettingDivElements();
                this.allDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('all');
            }
            else {
                this.updateClassForSettingDivElements();
                this.customDiv.classList.add('e-de-table-border-inside-setting-click');
                this.setSettingPreviewDivElement('customDiv');
            }
        };
        this.handlePreviewCheckBoxAction = (event) => {
            let target = event.target;
            let targetId = target.id;
            let tableBorderDialog = this.target;
            let tableBorderDialogId = this.target.id;
            let compareClass = 'e-de-table-border-inside-preview-click';
            this.customDiv.click();
            if (targetId === tableBorderDialogId + '_Preview_Div_TopTop_Container' || targetId === tableBorderDialogId + '_Preview_Div_TopTop'
                || targetId === tableBorderDialogId + '_previewDivTopTopTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivTopTop);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_TopTop', 'TopTop');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_TopCenter_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_TopCenter'
                || targetId === tableBorderDialogId + '_previewDivTopCenterTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivTopCenter);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Horizontal', '_Preview_Div_TopCenter', 'TopCenter');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_TopBottom_Container' || targetId === tableBorderDialogId + '_Preview_Div_TopBottom'
                || targetId === tableBorderDialogId + '_previewDivTopBottomTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivTopBottom);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_TopBottom', 'TopBottom');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_LeftDiagonal_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_LeftDiagonal'
                || targetId === tableBorderDialogId + '_previewDivLeftDiagonalTransParent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivLeftDiagonal);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Left_Diagonal', '_Preview_Div_LeftDiagonal', 'LeftDiagonal');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomLeft_Container' || targetId === tableBorderDialogId + '_Preview_Div_BottomLeft'
                || targetId === tableBorderDialogId + '_previewDivBottomLeftTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivBottomLeft);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_BottomLeft', 'BottomLeft');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomCenter_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_BottomCenter'
                || targetId === tableBorderDialogId + '_previewDivBottomcenterTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivBottomcenter);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Vertical', '_Preview_Div_BottomCenter', 'BottomCenter');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_BottomRight_Container' || targetId === tableBorderDialogId + '_Preview_Div_BottomRight'
                || targetId === tableBorderDialogId + '_previewDivBottomRightTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivBottomRight);
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div', '_Preview_Div_BottomRight', 'BottomRight');
            }
            else if (targetId === tableBorderDialogId + '_Preview_Div_RightDiagonal_Container'
                || targetId === tableBorderDialogId + '_Preview_Div_RightDiagonal'
                || targetId === tableBorderDialogId + '_previewDivDiagonalRightTransparent') {
                this.handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, this.previewDivDiagonalRight);
                // tslint:disable-next-line:max-line-length
                this.showHidePreviewDivElements(tableBorderDialogId, compareClass, '_Preview_Div_Right_Diagonal', '_Preview_Div_RightDiagonal', 'RightDiagonal');
            }
        };
        this.applyTableCellPreviewBoxes = () => {
            this.customDiv.click();
            if (!isNullOrUndefined(this.ulelementShading)) {
                if (this.ulelementShading.index === 0) {
                    this.previewDivBottomcenterContainer.style.display = 'none';
                    this.previewDivTopCenterContainer.style.display = 'none';
                    this.previewVerticalDiv.style.display = 'none';
                    this.previewHorizontalDiv.style.display = 'none';
                    this.previewDivLeftDiagonal.style.display = '';
                    this.previewDivDiagonalRight.style.display = '';
                    this.previewDivBottomRightContainer.style.left = '80px';
                }
                else {
                    this.previewDivLeftDiagonal.style.display = 'none';
                    this.previewDivDiagonalRight.style.display = 'none';
                    this.previewDivBottomcenterContainer.style.display = '';
                    this.previewDivTopCenterContainer.style.display = '';
                    this.previewVerticalDiv.style.display = '';
                    this.previewHorizontalDiv.style.display = '';
                    this.previewDivBottomRightContainer.style.left = '110px';
                }
            }
        };
        this.applyPreviewTableBackgroundColor = (args) => {
            if (!isNullOrUndefined(args.currentValue)) {
                let color = args.currentValue.hex;
                this.previewDiv.style.backgroundColor = color;
            }
        };
        this.applyPreviewTableBorderColor = (args) => {
            if (!isNullOrUndefined(args.currentValue)) {
                let color = args.currentValue.hex;
                this.previewDiv.style.borderColor = color;
                this.previewRightDiagonalDiv.style.backgroundColor = color;
                this.previewLeftDiagonalDiv.style.backgroundColor = color;
                this.previewVerticalDiv.style.backgroundColor = color;
                this.previewHorizontalDiv.style.backgroundColor = color;
            }
        };
        this.owner = viewer;
    }
    getModuleName() {
        return 'BordersAndShadingDialog';
    }
    /**
     * @private
     */
    // tslint:disable-next-line:max-func-body-length
    initBordersAndShadingsDialog(localeValue, isRtl) {
        let instance = this;
        this.target = createElement('div', {
            id: instance.owner.owner.containerId + '_table_border_shadings',
            className: 'e-de-table-border-shading-dlg'
        });
        let displayText = createElement('div', {
            innerHTML: localeValue.getConstant('Borders'), styles: 'position: absolute;top: 65px;',
            id: this.target.id + '_border_label', className: 'e-de-table-border-heading'
        });
        let settingsContiner = createElement('div', {
            styles: 'display: inline-block;position: absolute;top: 105px;width: 100px;height: 235px;border-style: none;',
            id: this.target.id + '_border_settings'
        });
        let styleContainerPosition;
        if (isRtl) {
            styleContainerPosition = 'left: 148px;';
        }
        else {
            styleContainerPosition = 'left: 125px;';
        }
        let styleContainer = createElement('div', {
            // tslint:disable-next-line:max-line-length
            styles: 'display: inline-block;position: absolute;' + styleContainerPosition + 'top: 125px;width: 150px;height: 235px;padding-left: 40px;border-style: none;padding-right: 40px;',
            id: this.target.id + '_border_style'
        });
        let previewContinerPosition;
        if (isRtl) {
            previewContinerPosition = 'right: 342px;';
        }
        else {
            previewContinerPosition = 'left: 339px;';
        }
        let previewContiner = createElement('div', {
            // tslint:disable-next-line:max-line-length
            styles: 'display: inline-block;position: absolute;' + previewContinerPosition + 'top: 87px;width: 180px;height: 235px;padding: 0px;border-style: none;',
            id: this.target.id + '_border_preview'
        });
        let styleText = createElement('div', {
            innerHTML: localeValue.getConstant('Style'), styles: 'width: 100%;padding-bottom: 10px;',
            className: 'e-de-table-element-subheading'
        });
        let dropDownList = createElement('select', {
            id: this.target.id + '_border_style_dropDown'
        });
        dropDownList.innerHTML = '<option>' + 'None' + '</option><option>'
            + 'Single' + '</option><option>' + 'Dot' + '</option><option>'
            + 'DashSmallGap' + '</option><option>' + 'DashLargeGap' + '</option><option>'
            + 'DashDot' + '</option><option>' + 'DashDotDot' + '</option><option>'
            + 'Double' + '</option><option>' + 'Triple' + '</option><option>'
            + 'ThinThickSmallGap' + '</option><option>'
            + 'ThickThinSmallGap' + '</option><option>' + 'ThinThickThinSmallGap'
            + '</option><option>' + 'ThinThickMediumGap' + '</option><option>'
            + 'ThickThinMediumGap' + '</option><option>' + 'ThinThickThinMediumGap'
            + '</option><option>' + 'ThinThickLargeGap' + '</option><option>'
            + 'ThickThinLargeGap' + '</option><option>' + 'ThinThickThinLargeGap'
            + '</option><option>' + 'SingleWavy' + '</option><option>'
            + 'DoubleWavy' + '</option><option>' + 'DashDotStroked'
            + '</option><option>' + 'Emboss3D' + '</option><option>' + 'Engrave3D'
            + '</option><option>' + 'Outset' + '</option><option>'
            + 'Inset' + '</option><option>' + 'Thick' + '</option>';
        let widthText = createElement('div', {
            innerHTML: localeValue.getConstant('Width'), styles: 'width:100%;padding-top: 20px;padding-bottom: 10px;',
            className: 'e-de-table-element-subheading'
        });
        let widthNumeric = createElement('input', {
            id: this.target.id + '_width'
        });
        let colorText = createElement('div', {
            innerHTML: localeValue.getConstant('Color'), styles: 'padding-top: 25px;',
            className: 'e-de-table-setting-heading'
        });
        let borderColorPickerElement = createElement('input', {
            attrs: { 'type': 'color' },
            id: this.target.id + '_border_color',
            styles: 'width: 30px;position: absolute;left: 90px;',
            className: 'e-dlg-clr-pkr-top'
        });
        let settingText = createElement('div', {
            innerHTML: localeValue.getConstant('Setting'), styles: 'width: 100%;position: absolute;',
            className: 'e-de-table-setting-heading'
        });
        let noneDivContainer = createElement('div', {
            id: this.target.id + '_None_Div_Container', className: 'e-de-table-border-none'
        });
        let divLabelPadding;
        if (isRtl) {
            divLabelPadding = 'padding-right:10px;';
        }
        else {
            divLabelPadding = 'padding-left:10px;';
        }
        this.noneDiv = createElement('div', {
            id: this.target.id + '_None_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let noneDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('None'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 20px;position: absolute;',
            id: this.target.id + '_None_Div_Label'
        });
        let boxDivContainer = createElement('div', {
            id: this.target.id + '_Box_Div_Container', className: 'e-de-table-border-box'
        });
        this.boxDiv = createElement('div', {
            id: this.target.id + '_Box_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let boxDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('Box'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 20px;position: absolute;',
            id: this.target.id + '_Box_Div_Label'
        });
        let allDivContainer = createElement('div', {
            id: this.target.id + '_All_Div_Container', className: 'e-de-table-border-all'
        });
        this.allDiv = createElement('div', {
            id: this.target.id + '_All_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let allDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('All'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 25px;position: absolute;',
            id: this.target.id + '_All_Div_Label'
        });
        let customDivContainer = createElement('div', {
            id: this.target.id + '_Custom_Div_Container', className: 'e-de-table-border-custom'
        });
        this.customDiv = createElement('div', {
            id: this.target.id + '_Custom_Div',
            className: 'e-de-table-border-inside-setting e-de-table-border-setting-genral'
        });
        let customDivLabel = createElement('label', {
            innerHTML: localeValue.getConstant('Custom'), className: 'e-de-table-setting-labels-heading',
            styles: divLabelPadding + 'top: 25px;position: absolute;',
            id: this.target.id + '_Custom_Div_Label'
        });
        this.noneDivTransparent = createElement('div', {
            id: this.target.id + '_None_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-none-setting'
        });
        this.boxDivTransparent = createElement('div', {
            id: this.target.id + '_Box_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-box-setting'
        });
        this.allDivTransparent = createElement('div', {
            id: this.target.id + '_All_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-all-setting'
        });
        this.customDivTransparent = createElement('div', {
            id: this.target.id + '_Custom_Div_Transparent', className: 'e-icons e-de-table-border-setting e-de-table-border-custom-setting'
        });
        if (isRtl) {
            this.noneDivTransparent.classList.add('e-de-rtl');
            this.boxDivTransparent.classList.add('e-de-rtl');
            this.allDivTransparent.classList.add('e-de-rtl');
            this.customDivTransparent.classList.add('e-de-rtl');
        }
        let previewTextPosition;
        if (isRtl) {
            previewTextPosition = 'margin-right: 10px;';
        }
        else {
            previewTextPosition = 'margin-left: 10px;';
        }
        let previewText = createElement('div', {
            innerHTML: localeValue.getConstant('Preview'), className: 'e-de-table-setting-heading',
            styles: 'position: absolute;top: 20px;' + previewTextPosition
        });
        this.previewDiv = createElement('div', {
            styles: 'width: 80px;height: 80px;position: absolute; left: 50px;top: 50px;',
            id: this.target.id + '_Preview_Div', className: 'e-de-border-dlg-preview-div'
        });
        this.previewRightDiagonalDiv = createElement('div', {
            styles: 'position: absolute;width:1px;height:113px;left: 90px;top: 34px;transform: rotate(135deg);',
            id: this.target.id + '_Preview_Div_Right_Diagonal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewLeftDiagonalDiv = createElement('div', {
            styles: 'position: absolute;width: 1px;height: 113px;left: 90px;top: 34px;transform:rotate(45deg);',
            id: this.target.id + '_Preview_Div_Left_Diagonal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewVerticalDiv = createElement('div', {
            styles: 'width: 1px;height: 81px;position: absolute;left: 90px;top: 50px;',
            id: this.target.id + '_Preview_Div_Vertical',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        this.previewHorizontalDiv = createElement('div', {
            styles: 'width: 81px;height: 1px;position: absolute;left: 50px;top: 90px;',
            id: this.target.id + '_Preview_Div_Horizontal',
            className: 'e-de-border-dlg-preview-inside-divs'
        });
        let previewDivTopPosition;
        if (isRtl) {
            previewDivTopPosition = 'right: 10px;';
        }
        else {
            previewDivTopPosition = 'left: 10px;';
        }
        this.previewDivTopTopContainer = createElement('div', {
            styles: 'top: 50px;position: absolute;' + previewDivTopPosition, id: this.target.id + '_Preview_Div_TopTop_Container'
        });
        this.previewDivTopTop = createElement('div', {
            id: this.target.id + '_Preview_Div_TopTop',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopCenterContainer = createElement('div', {
            styles: 'top: 80px;position: absolute;' + previewDivTopPosition, id: this.target.id + '_Preview_Div_TopCenter_Container'
        });
        this.previewDivTopCenter = createElement('div', {
            id: this.target.id + '_Preview_Div_TopCenter',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopBottomContainer = createElement('div', {
            styles: 'top: 110px;position: absolute;' + previewDivTopPosition, id: this.target.id + '_Preview_Div_TopBottom_Container'
        });
        this.previewDivTopBottom = createElement('div', {
            id: this.target.id + '_Preview_Div_TopBottom',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivLeftDiagonalContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;left: 10px;', id: this.target.id + '_Preview_Div_LeftDiagonal_Container'
        });
        this.previewDivLeftDiagonal = createElement('div', {
            id: this.target.id + '_Preview_Div_LeftDiagonal',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        let previewDivBottomLeftPosition;
        let previewDivBottomCenterPosition;
        let previewDivBottomRightPosition;
        if (isRtl) {
            previewDivBottomLeftPosition = 'left: 104px';
            previewDivBottomCenterPosition = 'left: 74px';
            previewDivBottomRightPosition = 'left: 44px';
        }
        else {
            previewDivBottomLeftPosition = 'left: 50px;';
            previewDivBottomCenterPosition = 'left : 80px;';
            previewDivBottomRightPosition = 'left : 110px';
        }
        this.previewDivBottomLeftContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;' + previewDivBottomLeftPosition,
            id: this.target.id + '_Preview_Div_BottomLeft_Container'
        });
        this.previewDivBottomLeft = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomLeft',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivBottomcenterContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;' + previewDivBottomCenterPosition,
            id: this.target.id + '_Preview_Div_BottomCenter_Container'
        });
        this.previewDivBottomcenter = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomCenter',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivBottomRightContainer = createElement('div', {
            styles: 'top: 145px;position: absolute;' + previewDivBottomRightPosition,
            id: this.target.id + '_Preview_Div_BottomRight_Container'
        });
        this.previewDivBottomRight = createElement('div', {
            id: this.target.id + '_Preview_Div_BottomRight',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivDiagonalRightContainer = createElement('div', {
            styles: 'top: 145px; position: absolute; left: 110px;', id: this.target.id + '_Preview_Div_RightDiagonal_Container'
        });
        this.previewDivDiagonalRight = createElement('div', {
            id: this.target.id + '_Preview_Div_RightDiagonal',
            className: 'e-de-table-border-inside-preview e-de-table-border-preview-genral'
        });
        this.previewDivTopTopTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopTopTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-toptop-alignment'
        });
        this.previewDivTopCenterTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopCenterTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-topcenter-alignment'
        });
        this.previewDivTopBottomTransParent = createElement('div', {
            id: this.target.id + '_previewDivTopBottomTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-topbottom-alignment'
        });
        this.previewDivLeftDiagonalTransParent = createElement('div', {
            id: this.target.id + '_previewDivLeftDiagonalTransParent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-diagionalup-alignment'
        });
        this.previewDivBottomLeftTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomLeftTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomleft-alignment'
        });
        this.previewDivBottomcenterTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomcenterTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomcenter-alignment'
        });
        this.previewDivBottomRightTransparent = createElement('div', {
            id: this.target.id + '_previewDivBottomRightTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-bottomright-alignment'
        });
        this.previewDivDiagonalRightTransparent = createElement('div', {
            id: this.target.id + '_previewDivDiagonalRightTransparent',
            className: 'e-icons e-de-table-border-preview e-de-table-border-diagionaldown-alignment'
        });
        let shadingContainerPosition;
        if (isRtl) {
            shadingContainerPosition = 'left:60px;';
        }
        else {
            shadingContainerPosition = 'left:17px;';
        }
        this.shadingContiner = createElement('div', {
            /* tslint:disable:max-line-length */
            styles: 'display:inline-block;position:absolute;' + shadingContainerPosition + ';width:400px;height:100px;padding:0px;border-style: none;margin-left:10px;',
            id: this.target.id + '_shading_preview', className: 'e-de-table-shading-preview'
        });
        let shadingText = createElement('div', {
            innerHTML: localeValue.getConstant('Shading'), className: 'e-de-table-border-heading',
            styles: 'padding-top: 30px;left: 5px;'
        });
        let shadings = createElement('div', { styles: 'display:flex;' });
        let label = createElement('div', {
            innerHTML: localeValue.getConstant('Fill'), className: 'e-de-table-setting-heading e-de-table-border-fill',
            styles: 'top: 50px;left: 10px;'
        });
        let shadingColorPickerElement = createElement('input', {
            attrs: { 'type': 'color' },
            id: this.target.id + '_shading_color', styles: 'position: absolute;top: 75px;left: 40px;width: 30px;'
        });
        let shdApplyPosition;
        if (isRtl) {
            shdApplyPosition = 'left: 75px;';
        }
        else {
            shdApplyPosition = 'left: 150px;';
        }
        let shdApply = createElement('div', {
            styles: 'position:absolute;top:44px;' + shdApplyPosition + 'width:180px;'
        });
        let div = createElement('div', {
            styles: 'width:100px;padding-bottom: 10px;', innerHTML: localeValue.getConstant('Apply To'),
            className: 'e-de-table-element-subheading'
        });
        let divsion = createElement('div', { styles: 'width:100px;position:absolute;' });
        let ulelementShading = createElement('select', {
            innerHTML: '<option>' + localeValue.getConstant('Cell') + '</option>'
                + '<option>' + localeValue.getConstant('Table') + '</option>',
            id: this.target.id + '_shading'
        });
        divsion.appendChild(ulelementShading);
        this.noneDiv.appendChild(this.noneDivTransparent);
        this.boxDiv.appendChild(this.boxDivTransparent);
        this.allDiv.appendChild(this.allDivTransparent);
        this.customDiv.appendChild(this.customDivTransparent);
        noneDivContainer.appendChild(this.noneDiv);
        noneDivContainer.appendChild(noneDivLabel);
        boxDivContainer.appendChild(this.boxDiv);
        boxDivContainer.appendChild(boxDivLabel);
        allDivContainer.appendChild(this.allDiv);
        allDivContainer.appendChild(allDivLabel);
        customDivContainer.appendChild(this.customDiv);
        customDivContainer.appendChild(customDivLabel);
        settingsContiner.appendChild(settingText);
        settingsContiner.appendChild(noneDivContainer);
        settingsContiner.appendChild(boxDivContainer);
        settingsContiner.appendChild(allDivContainer);
        settingsContiner.appendChild(customDivContainer);
        this.previewDivBottomcenter.appendChild(this.previewDivBottomcenterTransparent);
        this.previewDivBottomRight.appendChild(this.previewDivBottomRightTransparent);
        this.previewDivBottomLeft.appendChild(this.previewDivBottomLeftTransparent);
        this.previewDivTopTop.appendChild(this.previewDivTopTopTransParent);
        this.previewDivTopCenter.appendChild(this.previewDivTopCenterTransParent);
        this.previewDivTopBottom.appendChild(this.previewDivTopBottomTransParent);
        this.previewDivDiagonalRight.appendChild(this.previewDivDiagonalRightTransparent);
        this.previewDivLeftDiagonal.appendChild(this.previewDivLeftDiagonalTransParent);
        this.previewDivBottomcenterContainer.appendChild(this.previewDivBottomcenter);
        this.previewDivBottomLeftContainer.appendChild(this.previewDivBottomLeft);
        this.previewDivBottomRightContainer.appendChild(this.previewDivBottomRight);
        this.previewDivDiagonalRightContainer.appendChild(this.previewDivDiagonalRight);
        this.previewDivLeftDiagonalContainer.appendChild(this.previewDivLeftDiagonal);
        this.previewDivTopBottomContainer.appendChild(this.previewDivTopBottom);
        this.previewDivTopCenterContainer.appendChild(this.previewDivTopCenter);
        this.previewDivTopTopContainer.appendChild(this.previewDivTopTop);
        previewContiner.appendChild(previewText);
        previewContiner.appendChild(this.previewDiv);
        previewContiner.appendChild(this.previewRightDiagonalDiv);
        previewContiner.appendChild(this.previewHorizontalDiv);
        previewContiner.appendChild(this.previewLeftDiagonalDiv);
        previewContiner.appendChild(this.previewVerticalDiv);
        previewContiner.appendChild(this.previewDivBottomcenterContainer);
        previewContiner.appendChild(this.previewDivBottomLeftContainer);
        previewContiner.appendChild(this.previewDivBottomRightContainer);
        previewContiner.appendChild(this.previewDivDiagonalRightContainer);
        previewContiner.appendChild(this.previewDivLeftDiagonalContainer);
        previewContiner.appendChild(this.previewDivTopBottomContainer);
        previewContiner.appendChild(this.previewDivTopCenterContainer);
        previewContiner.appendChild(this.previewDivTopTopContainer);
        shdApply.appendChild(div);
        shdApply.appendChild(divsion);
        shadings.appendChild(label);
        shadings.appendChild(shadingColorPickerElement);
        shadings.appendChild(shdApply);
        this.shadingContiner.appendChild(shadingText);
        this.shadingContiner.appendChild(shadings);
        styleContainer.appendChild(styleText);
        styleContainer.appendChild(dropDownList);
        styleContainer.appendChild(widthText);
        styleContainer.appendChild(widthNumeric);
        styleContainer.appendChild(colorText);
        styleContainer.appendChild(borderColorPickerElement);
        this.target.appendChild(displayText);
        this.target.appendChild(settingsContiner);
        this.target.appendChild(styleContainer);
        this.target.appendChild(previewContiner);
        this.target.appendChild(this.shadingContiner);
        // Handling Setting Container
        noneDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        boxDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        allDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        customDivContainer.addEventListener('click', this.handleSettingCheckBoxAction);
        // Handling Preview Div Container
        this.previewDivBottomcenterContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivBottomLeftContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivBottomRightContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopTopContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopBottomContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivTopCenterContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivDiagonalRightContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        this.previewDivLeftDiagonalContainer.addEventListener('click', this.handlePreviewCheckBoxAction);
        // handling dropdown change
        this.borderWidth = new NumericTextBox({
            value: 0, min: 0, max: 6, decimals: 2,
            width: 150, enablePersistence: false
        });
        this.borderWidth.appendTo(widthNumeric);
        this.borderStyle = new DropDownList({
            width: '150px', popupHeight: '150px', index: 1,
            enableRtl: isRtl
        });
        this.borderStyle.appendTo(dropDownList);
        this.ulelementShading = new DropDownList({
            width: '150px', change: this.applyTableCellPreviewBoxes, index: 1,
            enableRtl: isRtl
        });
        this.ulelementShading.appendTo(ulelementShading);
        this.borderColorPicker = new ColorPicker({
            value: '#000000', change: this.applyPreviewTableBorderColor,
            enableRtl: isRtl, locale: this.owner.owner.locale, cssClass: 'e-de-dlg-clr-picker'
        });
        this.borderColorPicker.appendTo(borderColorPickerElement);
        this.shadingColorPicker = new ColorPicker({
            value: '#000000', change: this.applyPreviewTableBackgroundColor,
            enableRtl: isRtl, locale: this.owner.owner.locale, cssClass: 'e-de-dlg-clr-picker'
        });
        this.shadingColorPicker.appendTo(shadingColorPickerElement);
        if (isRtl) {
            label.classList.add('e-de-rtl');
        }
    }
    applyFormat() {
        let selection = this.owner.selection;
        let editorModule = this.owner.owner.editorModule;
        editorModule.initComplexHistory('BordersAndShading');
        editorModule.isBordersAndShadingDialog = true;
        if (this.applyTo === 0) {
            editorModule.onCellFormat(this.cellFormat);
        }
        else {
            editorModule.onTableFormat(this.tableFormat, this.isShadingChanged);
        }
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
        editorModule.isBordersAndShadingDialog = false;
    }
    getBorder() {
        let border = new WBorder();
        border.color = this.borderColorPicker.value;
        border.lineStyle = this.borderStyle.text;
        border.lineWidth = this.borderWidth.value;
        return border;
    }
    checkClassName(element) {
        return element.classList.contains('e-de-table-border-inside-preview-click');
    }
    /**
     * @private
     */
    show() {
        let localeValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localeValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initBordersAndShadingsDialog(localeValue, this.owner.owner.enableRtl);
        }
        this.loadBordersShadingsPropertiesDialog();
        this.owner.dialog.content = this.target;
        this.owner.dialog.header = localeValue.getConstant('Borders and Shading');
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.closeBordersShadingsDialog;
        this.owner.dialog.position = { X: 'center', Y: 'center' };
        this.owner.dialog.width = 'auto';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.buttons = [{
                click: this.applyBordersShadingsProperties,
                buttonModel: { content: localeValue.getConstant('Ok'), cssClass: 'e-flat e-table-border-shading-okay', isPrimary: true }
            },
            {
                click: this.closeDialog,
                buttonModel: { content: localeValue.getConstant('Cancel'), cssClass: 'e-flat e-table-border-shading-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    updateClassForSettingDivElements() {
        let settingDivs = this.target.getElementsByClassName('e-de-table-border-inside-setting');
        for (let j = 0; j < settingDivs.length; j++) {
            if (settingDivs[j].className.indexOf('e-de-table-border-inside-setting-click') !== -1) {
                let tempClassName = settingDivs[j].className;
                tempClassName = tempClassName.replace('e-de-table-border-inside-setting-click', '');
                settingDivs[j].className = tempClassName;
            }
        }
    }
    setSettingPreviewDivElement(position) {
        switch (position) {
            case 'none':
                this.previewDivTopTop.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('none');
                break;
            case 'box':
                this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('box');
                break;
            case 'all':
                this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
                this.previewDivBottomcenter.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                this.previewDivTopCenter.classList.add('e-de-table-border-inside-preview-click');
                this.isShowHidePreviewTableElements('all');
                break;
        }
    }
    isShowHidePreviewTableElements(settingDiv) {
        switch (settingDiv) {
            case 'none':
                this.previewDiv.style.border = 'none';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'none';
                this.previewVerticalDiv.style.display = 'none';
                break;
            case 'box':
                this.previewDiv.style.border = '1px solid rgba(0, 0, 0, .54)';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'none';
                this.previewVerticalDiv.style.display = 'none';
                break;
            case 'all':
                this.previewDiv.style.border = '1px solid rgba(0, 0, 0, .54)';
                this.previewRightDiagonalDiv.style.display = 'none';
                this.previewLeftDiagonalDiv.style.display = 'none';
                this.previewHorizontalDiv.style.display = 'block';
                this.previewVerticalDiv.style.display = 'block';
                break;
        }
    }
    handlePreviewCheckBoxShowHide(tableBorderDialogId, compareClass, element) {
        if (element.classList.contains(compareClass)) {
            element.classList.remove(compareClass);
        }
        else {
            element.classList.add(compareClass);
        }
    }
    // tslint:disable-next-line:max-line-length
    showHidePreviewDivElements(tableBorderDialogId, compareClass, elementClass, compareElementClass, position) {
        let setElement = document.getElementById(tableBorderDialogId + elementClass);
        let compareElement = document.getElementById(tableBorderDialogId + compareElementClass);
        if (position === 'TopTop') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-top');
        }
        else if (position === 'TopCenter') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'TopBottom') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-bottom');
        }
        else if (position === 'LeftDiagonal') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'BottomLeft') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-left');
        }
        else if (position === 'BottomCenter') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
        else if (position === 'BottomRight') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'border-right');
        }
        else if (position === 'RightDiagonal') {
            this.setPropertyPreviewDivElement(setElement, compareElement, compareClass, 'display');
        }
    }
    setPropertyPreviewDivElement(ele, compareElement, compareClass, property) {
        if (compareElement.classList.contains(compareClass) && property.split('-')[0] === 'border') {
            /* tslint:disable:no-any */
            ele.style[property] = '1px solid rgba(0, 0, 0, .54)';
        }
        else if (compareElement.classList.contains(compareClass) && property === 'display') {
            ele.style[property] = 'block';
        }
        else {
            ele.style[property] = 'none';
            /* tslint:enable:no-any */
        }
    }
    loadBordersShadingsPropertiesDialog() {
        let tableFormat = this.owner.selection.tableFormat.table.tableFormat;
        let lineStyle;
        let borderColor;
        let fillColor;
        let borderWidth;
        if (!isNullOrUndefined(tableFormat) && !isNullOrUndefined(tableFormat.borders)) {
            this.cloneBorders(tableFormat.borders);
            if (isNullOrUndefined(tableFormat.borders) || isNullOrUndefined(tableFormat.borders.top)) {
                lineStyle = 1;
                borderColor = '#000000';
                borderWidth = 0;
                fillColor = '#000000';
            }
            else {
                lineStyle = this.getLineStyle(tableFormat.borders.top.lineStyle);
                borderColor = tableFormat.borders.top.color;
                borderWidth = tableFormat.borders.top.getLineWidth();
                fillColor = tableFormat.shading.backgroundColor;
            }
        }
        this.borderColorPicker.value = borderColor;
        this.shadingColorPicker.value = fillColor;
        /* tslint:disable:no-any */
        let colorPickerEvent = {
            target: this.borderColorPicker, ctrlKey: false,
            shiftKey: false, which: 0
        };
        let fillColorEvent = {
            target: this.shadingColorPicker, ctrlKey: false,
            shiftKey: false, which: 0
        };
        /* tslint:enable:no-any */
        this.applyPreviewTableBackgroundColor(fillColorEvent);
        this.applyPreviewTableBorderColor(colorPickerEvent);
        this.ulelementShading.index = 1;
        this.previewDivLeftDiagonal.style.display = 'none';
        this.previewDivDiagonalRight.style.display = 'none';
        this.borderWidth.value = borderWidth;
        this.borderStyle.index = lineStyle;
    }
    // tslint:disable:max-func-body-length
    cloneBorders(borders) {
        let topBorder = false;
        let bottomBorder = false;
        let leftBorder = false;
        let rightBorder = false;
        let horizontalBorder = false;
        let verticalBorder = false;
        let diagonalDownBorder = false;
        let customBorder = false;
        let diagonalUpBorder = false;
        if (borders !== null) {
            if (borders.top && (borders.top.hasNoneStyle || borders.top.lineStyle !== 'None')) {
                topBorder = true;
            }
            if (borders.bottom && (borders.bottom.hasNoneStyle || borders.bottom.lineStyle !== 'None')) {
                bottomBorder = true;
            }
            if (borders.left && (borders.left.hasNoneStyle || borders.left.lineStyle !== 'None')) {
                leftBorder = true;
            }
            if (borders.right && (borders.right.hasNoneStyle || borders.right.lineStyle !== 'None')) {
                rightBorder = true;
            }
            if (borders.horizontal && (borders.horizontal.hasNoneStyle || borders.horizontal.lineStyle !== 'None')) {
                horizontalBorder = true;
            }
            if (borders.vertical && (borders.vertical.hasNoneStyle || borders.vertical.lineStyle !== 'None')) {
                verticalBorder = true;
            }
            if (borders.diagonalDown && (borders.diagonalDown.hasNoneStyle || borders.diagonalDown.lineStyle !== 'None')) {
                diagonalDownBorder = true;
            }
            if (borders.diagonalUp && (borders.diagonalUp.hasNoneStyle || borders.diagonalUp.lineStyle !== 'None')) {
                diagonalUpBorder = true;
            }
            if (!(!topBorder || !bottomBorder || !leftBorder || !rightBorder)) {
                if (!(!topBorder || !bottomBorder || !leftBorder || !rightBorder || !horizontalBorder
                    || !verticalBorder || diagonalUpBorder || diagonalDownBorder)) {
                    if ((topBorder && bottomBorder && leftBorder && rightBorder && horizontalBorder && verticalBorder
                        && !diagonalUpBorder && !diagonalDownBorder)) {
                        if (borders.top.hasNoneStyle && borders.bottom.hasNoneStyle && borders.left.hasNoneStyle
                            && borders.right.hasNoneStyle && borders.horizontal.hasNoneStyle && borders.vertical.hasNoneStyle) {
                            this.setSettingPreviewDivElement('none');
                            this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                            this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                        }
                        else {
                            this.setSettingPreviewDivElement('all');
                            this.allDiv.classList.add('e-de-table-border-inside-setting-click');
                            this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                            this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                        }
                    }
                }
                else if ((leftBorder && bottomBorder && topBorder && rightBorder && !horizontalBorder && !verticalBorder)) {
                    if (borders.top.hasNoneStyle && borders.bottom.hasNoneStyle && borders.left.hasNoneStyle
                        && borders.right.hasNoneStyle && borders.horizontal.hasNoneStyle && borders.vertical.hasNoneStyle) {
                        this.setSettingPreviewDivElement('none');
                        this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.noneDiv.classList.add('e-de-table-border-inside-setting-click');
                    }
                    else {
                        this.setSettingPreviewDivElement('box');
                        this.customDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                        this.boxDiv.classList.add('e-de-table-border-inside-setting-click');
                        this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                    }
                }
                else {
                    customBorder = true;
                }
            }
            else {
                customBorder = true;
            }
            this.previewDivLeftDiagonal.classList.remove('e-de-table-border-inside-preview-click');
            this.previewDivDiagonalRight.classList.remove('e-de-table-border-inside-preview-click');
            if (customBorder) {
                this.customDiv.classList.add('e-de-table-border-inside-setting-click');
                this.noneDiv.classList.remove('e-de-table-border-inside-setting-click');
                this.boxDiv.classList.remove('e-de-table-border-inside-setting-click');
                this.allDiv.classList.remove('e-de-table-border-inside-setting-click');
                if (topBorder) {
                    this.previewDivTopTop.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopTop.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (bottomBorder) {
                    this.previewDivTopBottom.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopBottom.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (leftBorder) {
                    this.previewDivBottomLeft.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomLeft.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (rightBorder) {
                    this.previewDivBottomRight.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomRight.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (verticalBorder) {
                    this.previewDivBottomcenter.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivBottomcenter.classList.remove('e-de-table-border-inside-preview-click');
                }
                if (horizontalBorder) {
                    this.previewDivTopCenter.classList.add('e-de-table-border-inside-preview-click');
                }
                else {
                    this.previewDivTopCenter.classList.remove('e-de-table-border-inside-preview-click');
                }
            }
        }
    }
    getLineStyle(lineStyle) {
        switch (lineStyle) {
            case 'Single': return 1;
            case 'Dot': return 2;
            case 'DashSmallGap': return 3;
            case 'DashLargeGap': return 4;
            case 'DashDot': return 5;
            case 'DashDotDot': return 6;
            case 'Double': return 7;
            case 'Triple': return 8;
            case 'ThinThickSmallGap': return 9;
            case 'ThickThinSmallGap': return 10;
            case 'ThinThickThinSmallGap': return 11;
            case 'ThinThickMediumGap': return 12;
            case 'ThickThinMediumGap': return 13;
            case 'ThinThickThinMediumGap': return 14;
            case 'ThinThickLargeGap': return 15;
            case 'ThickThinLargeGap': return 16;
            case 'ThinThickThinLargeGap': return 17;
            case 'SingleWavy': return 18;
            case 'DoubleWavy': return 19;
            case 'DashDotStroked': return 20;
            case 'Emboss3D': return 21;
            case 'Engrave3D': return 22;
            case 'Outset': return 23;
            case 'Inset': return 24;
            case 'Thick': return 25;
        }
        return 0;
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let k = 0; k < this.target.childNodes.length; k++) {
                this.target.removeChild(this.target.childNodes[k]);
                k--;
            }
            this.target = undefined;
        }
        if (this.cellFormat) {
            this.cellFormat.destroy();
            this.cellFormat = undefined;
        }
        if (this.tableFormat) {
            this.tableFormat.destroy();
            this.tableFormat = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        if (!isNullOrUndefined(this.borderStyle)) {
            this.borderStyle.destroy();
        }
        this.borderStyle = undefined;
        if (!isNullOrUndefined(this.borderColorPicker)) {
            this.borderColorPicker.destroy();
        }
        this.borderColorPicker = undefined;
        if (!isNullOrUndefined(this.shadingColorPicker)) {
            this.shadingColorPicker.destroy();
        }
        this.shadingColorPicker = undefined;
        if (!isNullOrUndefined(this.ulelementShading)) {
            this.ulelementShading.destroy();
        }
        this.ulelementShading = undefined;
        this.noneDivTransparent = undefined;
        this.boxDivTransparent = undefined;
        this.allDivTransparent = undefined;
        this.customDivTransparent = undefined;
        this.previewDiv = undefined;
        this.previewRightDiagonalDiv = undefined;
        this.previewLeftDiagonalDiv = undefined;
        this.previewVerticalDiv = undefined;
        this.previewHorizontalDiv = undefined;
        this.previewDivTopTopContainer = undefined;
        this.previewDivTopTop = undefined;
        this.previewDivTopCenterContainer = undefined;
        this.previewDivTopCenter = undefined;
        this.previewDivTopBottomContainer = undefined;
        this.previewDivTopBottom = undefined;
        this.previewDivLeftDiagonalContainer = undefined;
        this.previewDivLeftDiagonal = undefined;
        this.previewDivBottomLeftContainer = undefined;
        this.previewDivBottomLeft = undefined;
        this.previewDivBottomcenterContainer = undefined;
        this.previewDivBottomcenter = undefined;
        this.previewDivBottomRightContainer = undefined;
        this.previewDivBottomRight = undefined;
        this.previewDivDiagonalRightContainer = undefined;
        this.previewDivDiagonalRight = undefined;
        this.previewDivTopTopTransParent = undefined;
        this.previewDivTopCenterTransParent = undefined;
        this.previewDivTopBottomTransParent = undefined;
        this.previewDivLeftDiagonalTransParent = undefined;
        this.previewDivBottomLeftTransparent = undefined;
        this.previewDivBottomcenterTransparent = undefined;
        this.previewDivBottomRightTransparent = undefined;
        this.previewDivDiagonalRightTransparent = undefined;
        this.shadingContiner = undefined;
        this.noneDiv = undefined;
        this.customDiv = undefined;
        this.allDiv = undefined;
        this.boxDiv = undefined;
    }
}

/**
 * The Table options dialog is used to modify default cell margins and cell spacing of selected table.
 */
class TableOptionsDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.applyTableCellProperties = () => {
            let tableFormat = this.owner.selection.tableFormat;
            if (!isNullOrUndefined(this.bottomMarginBox.value || this.leftMarginBox.value
                || this.rightMarginBox.value || this.topMarginBox.value || this.cellSpaceTextBox.value)
                && (tableFormat.bottomMargin !== this.bottomMarginBox.value
                    || tableFormat.leftMargin !== this.leftMarginBox.value
                    || tableFormat.rightMargin !== this.rightMarginBox.value
                    || tableFormat.topMargin !== this.topMarginBox.value
                    || tableFormat.cellSpacing !== this.cellSpaceTextBox.value)) {
                this.owner.owner.tablePropertiesDialogModule.isTableOptionsUpdated = true;
                this.applyTableOptions(this.tableFormat);
                this.owner.owner.tablePropertiesDialogModule.applyTableSubProperties();
            }
            this.closeCellMarginsDialog();
        };
        /**
         * @private
         */
        this.closeCellMarginsDialog = () => {
            this.owner.dialog.hide();
            this.owner.dialog.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.changeAllowSpaceCheckBox = () => {
            if (this.allowSpaceCheckBox.checked) {
                this.cellSpaceTextBox.enabled = true;
            }
            else {
                this.cellSpaceTextBox.enabled = false;
            }
        };
        /**
         * @private
         */
        this.removeEvents = () => {
            this.owner.dialog2.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    get tableFormat() {
        if (isNullOrUndefined(this.tableFormatIn)) {
            return this.tableFormatIn = new WTableFormat();
        }
        return this.tableFormatIn;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'TableOptionsDialog';
    }
    /**
     * @private
     */
    initTableOptionsDialog(localValue, isRtl) {
        let instance = this.owner;
        this.target = createElement('div', {
            id: this.owner.owner.containerId + '_insertCellMarginsDialog', className: 'e-de-table-options-dlg'
        });
        let innerDiv = createElement('div', {
            styles: 'width: 504px;position: relative;height: auto;margin-bottom: 14px'
        });
        let innerDivLabel = createElement('Label', {
            id: this.target.id + '_innerDivLabel', className: 'e-de-cell-dia-options-label',
            innerHTML: localValue.getConstant('Default cell margins')
        });
        innerDiv.appendChild(innerDivLabel);
        CellOptionsDialog.getCellMarginDialogElements(this, innerDiv, localValue);
        let div = createElement('div', { styles: 'width: 475px; position: relative;' });
        let cellSpaceLabel = createElement('Label', {
            className: 'e-de-cell-dia-options-label',
            id: this.target.id + '_cellSpaceLabel'
        });
        cellSpaceLabel.innerHTML = localValue.getConstant('Default cell spacing');
        div.appendChild(cellSpaceLabel);
        let table2 = createElement('TABLE', {
            styles: 'height: 30px;'
        });
        let tr3 = createElement('tr');
        let td5 = createElement('td');
        let allowSpaceCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_cellcheck'
        });
        let td6Padding;
        if (isRtl) {
            td6Padding = 'padding-right:15px;';
        }
        else {
            td6Padding = 'padding-left:14px;';
        }
        let td6 = createElement('td', { styles: td6Padding, });
        this.cellspacingTextBox = createElement('input', {
            attrs: { 'type': 'text' }, id: this.target.id + '_cellspacing'
        });
        td5.appendChild(allowSpaceCheckBox);
        td6.appendChild(this.cellspacingTextBox);
        tr3.appendChild(td5);
        tr3.appendChild(td6);
        table2.appendChild(tr3);
        div.appendChild(table2);
        let divBtn = document.createElement('div');
        this.target.appendChild(div);
        this.target.appendChild(divBtn);
        this.cellSpaceTextBox = new NumericTextBox({
            value: 0, min: 0, max: 264.5, width: 163,
            decimals: 2, enablePersistence: false
        });
        this.cellSpaceTextBox.appendTo(this.cellspacingTextBox);
        this.allowSpaceCheckBox = new CheckBox({
            label: localValue.getConstant('Allow spacing between cells'),
            change: this.changeAllowSpaceCheckBox,
            enableRtl: isRtl,
            cssClass: 'e-de-tbl-margin-sub-header',
        });
        this.allowSpaceCheckBox.appendTo(allowSpaceCheckBox);
    }
    /**
     * @private
     */
    loadCellMarginsDialog() {
        let tableFormat = this.owner.selection.tableFormat;
        this.cellSpaceTextBox.value = tableFormat.cellSpacing;
        this.bottomMarginBox.value = tableFormat.bottomMargin;
        this.topMarginBox.value = tableFormat.topMargin;
        this.rightMarginBox.value = tableFormat.rightMargin;
        this.leftMarginBox.value = tableFormat.leftMargin;
        if (tableFormat.cellSpacing > 0) {
            this.allowSpaceCheckBox.checked = true;
            this.cellSpaceTextBox.enabled = true;
        }
        else {
            this.allowSpaceCheckBox.checked = false;
            this.cellSpaceTextBox.enabled = false;
        }
    }
    /**
     * @private
     */
    applySubTableOptions(tableFormat) {
        this.owner.owner.editorHistory.initComplexHistory(this.owner.selection, 'TableMarginsSelection');
        this.applyTableOptionsHistory(tableFormat);
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
    }
    /**
     * @private
     */
    applyTableOptionsHelper(tableFormat) {
        this.applySubTableOptionsHelper(tableFormat);
    }
    /**
     * @private
     */
    applyTableOptionsHistory(tableFormat) {
        this.owner.owner.editorModule.initHistory('TableOptions');
        this.applySubTableOptionsHelper(tableFormat);
    }
    /**
     * @private
     */
    applySubTableOptionsHelper(tableFormat) {
        let ownerTable = this.owner.selection.start.currentWidget.paragraph.associatedCell.ownerTable;
        ownerTable = ownerTable.combineWidget(this.owner);
        let currentTableFormat = ownerTable.tableFormat;
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentBaseHistoryInfo)) {
            this.owner.owner.editorHistory.currentBaseHistoryInfo.addModifiedTableOptions(currentTableFormat);
        }
        currentTableFormat.cellSpacing = tableFormat.cellSpacing;
        currentTableFormat.leftMargin = tableFormat.leftMargin;
        currentTableFormat.topMargin = tableFormat.topMargin;
        currentTableFormat.rightMargin = tableFormat.rightMargin;
        currentTableFormat.bottomMargin = tableFormat.bottomMargin;
        this.owner.owner.tablePropertiesDialogModule.calculateGridValue(ownerTable);
    }
    /**
     * @private
     */
    applyTableOptions(tableFormat) {
        tableFormat.leftMargin = this.leftMarginBox.value;
        tableFormat.topMargin = this.topMarginBox.value;
        tableFormat.bottomMargin = this.bottomMarginBox.value;
        tableFormat.rightMargin = this.rightMarginBox.value;
        if (this.allowSpaceCheckBox.checked) {
            tableFormat.cellSpacing = this.cellSpaceTextBox.value;
        }
    }
    /**
     * @private
     */
    show() {
        let documentLocale = new L10n('documenteditor', this.owner.owner.defaultLocale);
        documentLocale.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initTableOptionsDialog(documentLocale, this.owner.owner.enableRtl);
        }
        this.loadCellMarginsDialog();
        this.owner.dialog.header = documentLocale.getConstant('Table Options');
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = undefined;
        this.owner.dialog.position = { X: 'center', Y: 'center' };
        //  this.owner.dialog.cssClass = 'e-de-table-margin-size';
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.open = undefined;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.removeEvents;
        this.owner.dialog.buttons = [{
                click: this.applyTableCellProperties,
                buttonModel: { content: documentLocale.getConstant('Ok'), cssClass: 'e-flat e-table-cell-okay', isPrimary: true }
            },
            {
                click: this.closeCellMarginsDialog,
                buttonModel: { content: documentLocale.getConstant('Cancel'), cssClass: 'e-flat e-table-cell-cancel' }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let p = 0; p < this.target.childNodes.length; p++) {
                this.target.removeChild(this.target.childNodes[p]);
                p--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.owner = undefined;
        this.cellspacingTextBox = undefined;
        this.allowSpaceCheckBox = undefined;
    }
}

/**
 * The Cell options dialog is used to modify margins of selected cells.
 */
class CellOptionsDialog {
    /**
     * @private
     */
    constructor(viewer) {
        /**
         * @private
         */
        this.removeEvents = () => {
            this.owner.dialog2.element.style.pointerEvents = '';
            this.owner.updateFocus();
        };
        /**
         * @private
         */
        this.changeSameAsTable = () => {
            if (this.sameAsTableCheckBox.checked) {
                this.leftMarginBox.enabled = false;
                this.rightMarginBox.enabled = false;
                this.bottomMarginBox.enabled = false;
                this.topMarginBox.enabled = false;
            }
            else {
                this.leftMarginBox.enabled = true;
                this.rightMarginBox.enabled = true;
                this.bottomMarginBox.enabled = true;
                this.topMarginBox.enabled = true;
            }
        };
        /**
         * @private
         */
        this.applyTableCellProperties = () => {
            let cellFormat = this.owner.selection.cellFormat;
            if (!isNullOrUndefined(this.bottomMarginBox.value || this.leftMarginBox.value
                || this.rightMarginBox.value || this.topMarginBox.value) &&
                (cellFormat.bottomMargin !== this.bottomMarginBox.value || cellFormat.leftMargin !== this.leftMarginBox.value
                    || cellFormat.rightMargin !== this.rightMarginBox.value || cellFormat.topMargin !== this.topMarginBox.value)) {
                this.owner.owner.tablePropertiesDialogModule.isCellOptionsUpdated = true;
                this.applyTableOptions(this.cellFormat);
                this.owner.owner.tablePropertiesDialogModule.applyTableSubProperties();
            }
            this.closeCellMarginsDialog();
        };
        /**
         * @private
         */
        this.closeCellMarginsDialog = () => {
            this.owner.dialog.hide();
            this.owner.dialog.element.style.pointerEvents = '';
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    get cellFormat() {
        if (isNullOrUndefined(this.cellFormatIn)) {
            return this.cellFormatIn = new WCellFormat();
        }
        return this.cellFormatIn;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'CellOptionsDialog';
    }
    /**
     * @private
     */
    initCellMarginsDialog(localValue, isRtl) {
        let instance = this.owner;
        this.target = createElement('div', {
            id: this.owner.owner.containerId + '_tableCellMarginsDialog', className: 'e-de-table-cell-margin-dlg'
        });
        let innerDiv = createElement('div', { styles: 'width: 504px;position: relative;height: auto;' });
        let innerDivLabel = createElement('Label', {
            className: 'e-de-cell-dia-options-label', id: this.target.id + '_innerDivLabel'
        });
        innerDivLabel.innerHTML = localValue.getConstant('Cell margins');
        innerDiv.appendChild(innerDivLabel);
        let table = createElement('TABLE', {
            styles: 'padding-bottom: 8px;padding-top: 8px;', className: 'e-de-cell-margin-top'
        });
        let tr = createElement('tr');
        let td = createElement('td', { className: 'e-de-tbl-btn-seperator' });
        let sameAsTableCheckBox = createElement('input', {
            attrs: { 'type': 'checkbox' }, id: this.target.id + '_sameAsCheckBox'
        });
        td.appendChild(sameAsTableCheckBox);
        tr.appendChild(td);
        table.appendChild(tr);
        innerDiv.appendChild(table);
        CellOptionsDialog.getCellMarginDialogElements(this, innerDiv, localValue);
        let divBtn = document.createElement('div');
        this.target.appendChild(divBtn);
        this.sameAsTableCheckBox = new CheckBox({
            label: localValue.getConstant('Same as the whole table'),
            change: this.changeSameAsTable,
            enableRtl: isRtl
        });
        this.sameAsTableCheckBox.appendTo(sameAsTableCheckBox);
        this.sameAsTableCheckBox.addEventListener('change', this.changeSameAsTable);
    }
    /**
     * @private
     */
    show() {
        let localizeValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localizeValue.setLocale(this.owner.owner.locale);
        if (!this.target) {
            this.initCellMarginsDialog(localizeValue, this.owner.owner.enableRtl);
        }
        this.loadCellMarginsDialog();
        this.owner.dialog.header = localizeValue.getConstant('Cell Options');
        this.owner.dialog.position = { X: 'center', Y: 'top' };
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = undefined;
        this.owner.dialog.open = undefined;
        this.owner.dialog.close = this.removeEvents;
        this.owner.dialog.buttons = [{
                click: this.applyTableCellProperties,
                buttonModel: { content: localizeValue.getConstant('Ok'), cssClass: 'e-flat e-table-cell-margin-okay', isPrimary: true }
            },
            {
                click: this.closeCellMarginsDialog,
                buttonModel: { content: localizeValue.getConstant('Cancel'), cssClass: 'e-flat e-table-cell-margin-cancel' }
            }];
        this.owner.dialog.show();
    }
    /**
     * @private
     */
    loadCellMarginsDialog() {
        let cellFormat = this.owner.selection.cellFormat;
        this.sameAsTable = isNullOrUndefined(cellFormat.leftMargin || cellFormat.topMargin
            || cellFormat.rightMargin || cellFormat.bottomMargin);
        if (this.sameAsTable) {
            let tableFormat = this.owner.selection.tableFormat;
            this.loadCellProperties(tableFormat, false, true);
        }
        else {
            this.loadCellProperties(cellFormat, true, false);
        }
    }
    loadCellProperties(format, enableTextBox, enableCheckBox) {
        this.leftMarginBox.value = format.leftMargin;
        this.rightMarginBox.value = format.rightMargin;
        this.topMarginBox.value = format.topMargin;
        this.bottomMarginBox.value = format.bottomMargin;
        this.leftMarginBox.enabled = enableTextBox;
        this.rightMarginBox.enabled = enableTextBox;
        this.topMarginBox.enabled = enableTextBox;
        this.bottomMarginBox.enabled = enableTextBox;
        this.sameAsTableCheckBox.checked = enableCheckBox;
    }
    /**
     * @private
     */
    applySubCellOptions(cellFormat) {
        this.owner.owner.editorHistory.initComplexHistory(this.owner.selection, 'CellMarginsSelection');
        this.owner.owner.editorModule.initHistory('CellOptions');
        /* tslint:disable:max-line-length */
        let startTable = this.owner.selection.start.paragraph.associatedCell.ownerTable;
        startTable = startTable.combineWidget(this.owner);
        this.applyCellmarginsValue(this.owner.selection.start.paragraph.associatedCell.ownerRow.combineWidget(this.owner), this.owner.selection.start, this.owner.selection.end, cellFormat);
        this.owner.owner.editorModule.reLayout(this.owner.selection, false);
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentHistoryInfo)) {
            this.owner.owner.editorHistory.updateComplexHistory();
        }
    }
    /**
     * @private
     */
    applyCellmarginsValue(row, start, end, cellFormat) {
        this.applyCellMarginsInternal(row, cellFormat);
        if (end.paragraph.associatedCell.ownerRow === row) {
            return;
        }
        let newRow = row.nextWidget;
        if (!isNullOrUndefined(newRow)) {
            this.applyCellmarginsValue(newRow, start, end, cellFormat);
        }
    }
    applyCellMarginsInternal(row, cellFormat) {
        if (!isNullOrUndefined(this.owner.owner.editorHistory.currentBaseHistoryInfo)) {
            let currentFormat = row.childWidgets[0].cellFormat;
            /* tslint:disable:max-line-length */
            cellFormat = this.owner.owner.editorHistory.currentBaseHistoryInfo.addModifiedCellOptions(currentFormat, cellFormat, row.ownerTable);
        }
        if (!isNullOrUndefined(cellFormat)) {
            this.applyCellMarginsForCells(row, cellFormat);
        }
    }
    /**
     * @private
     */
    applyCellMarginsForCells(row, cellFormat) {
        let rowCells = row.childWidgets;
        this.iterateCells(rowCells, cellFormat);
    }
    /**
     * @private
     */
    iterateCells(cells, cellFormat) {
        for (let i = 0; i < cells.length; i++) {
            this.applySubCellMargins(cells[i].cellFormat, cellFormat);
        }
        this.owner.owner.tablePropertiesDialogModule.calculateGridValue(cells[0].ownerTable);
    }
    /**
     * @private
     */
    applySubCellMargins(sourceFormat, cellFormat) {
        sourceFormat.leftMargin = cellFormat.leftMargin;
        sourceFormat.topMargin = cellFormat.topMargin;
        sourceFormat.rightMargin = cellFormat.rightMargin;
        sourceFormat.bottomMargin = cellFormat.bottomMargin;
    }
    /**
     * @private
     */
    applyTableOptions(cellFormat) {
        if (!this.sameAsTableCheckBox.checked) {
            cellFormat.leftMargin = this.leftMarginBox.value;
            cellFormat.topMargin = this.topMarginBox.value;
            cellFormat.bottomMargin = this.bottomMarginBox.value;
            cellFormat.rightMargin = this.rightMarginBox.value;
        }
    }
    /**
     * @private
     */
    destroy() {
        if (!isNullOrUndefined(this.target)) {
            if (this.target.parentElement) {
                this.target.parentElement.removeChild(this.target);
            }
            for (let y = 0; y < this.target.childNodes.length; y++) {
                this.target.removeChild(this.target.childNodes[y]);
                y--;
            }
            this.target = undefined;
        }
        this.dialog = undefined;
        this.target = undefined;
        this.owner = undefined;
        this.sameAsTableCheckBox = undefined;
    }
    /**
     * @private
     */
    static getCellMarginDialogElements(dialog, div, locale) {
        if (!isNullOrUndefined(dialog)) {
            let table = createElement('TABLE', { className: 'e-de-cell-margin-top' });
            let tr1 = createElement('tr', { styles: 'height: 50px;' });
            let td1 = createElement('td');
            let topLabel = createElement('label', {
                innerHTML: locale.getConstant('Top'), className: 'e-de-cell-dia-label-common',
                id: dialog.target.id + '_TopLabel'
            });
            let topTextBox = createElement('input', {
                attrs: { 'type': 'text' }, styles: 'width:100%', id: dialog.target.id + '_Top'
            });
            td1.appendChild(topLabel);
            td1.appendChild(topTextBox);
            let td2 = createElement('td', { className: 'e-de-tbl-btn-seperator' });
            let leftLabel = createElement('label', {
                innerHTML: locale.getConstant('Left'), className: 'e-de-cell-dia-label-common',
                id: dialog.target.id + '_leftLabel'
            });
            let leftTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_left'
            });
            td2.appendChild(leftLabel);
            td2.appendChild(leftTextBox);
            tr1.appendChild(td1);
            tr1.appendChild(td2);
            let tr2 = createElement('tr', { styles: 'height: 50px;' });
            let td3 = createElement('td', { styles: 'width:40%;' });
            let bottomLabel = createElement('label', {
                innerHTML: locale.getConstant('Bottom'),
                className: 'e-de-cell-dia-label-common', id: dialog.target.id + '_bottomLabel'
            });
            let bottomTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_bottom'
            });
            td3.appendChild(bottomLabel);
            td3.appendChild(bottomTextBox);
            let td4 = createElement('td', { styles: 'width:40%;' });
            let rightLabel = createElement('label', {
                innerHTML: locale.getConstant('Right'), id: dialog.target.id + '_rightLabel',
                className: 'e-de-cell-dia-label-common'
            });
            let rightTextBox = createElement('input', {
                attrs: { 'type': 'text' },
                styles: 'width:100%', id: dialog.target.id + '_right'
            });
            td4.appendChild(rightLabel);
            td4.appendChild(rightTextBox);
            tr2.appendChild(td3);
            tr2.appendChild(td4);
            table.appendChild(tr1);
            table.appendChild(tr2);
            div.appendChild(table);
            dialog.target.appendChild(div);
            dialog.topMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175, decimals: 2,
                enablePersistence: false
            });
            dialog.topMarginBox.appendTo(topTextBox);
            dialog.leftMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175,
                decimals: 2, enablePersistence: false
            });
            dialog.leftMarginBox.appendTo(leftTextBox);
            dialog.bottomMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175, decimals: 2,
                enablePersistence: false
            });
            dialog.bottomMarginBox.appendTo(bottomTextBox);
            dialog.rightMarginBox = new NumericTextBox({
                value: 0, min: 0, max: 1584, width: 175,
                decimals: 2, enablePersistence: false
            });
            dialog.rightMarginBox.appendTo(rightTextBox);
        }
    }
}

/**
 * The Styles dialog is used to create or modify styles.
 */
class StylesDialog {
    /**
     * @private
     */
    constructor(viewer) {
        this.updateStyleNames = (localValue) => {
            let collection = this.owner.owner.viewer.styles.getStyleNames('Paragraph');
            let styleNames = ['Normal', 'Heading 1', 'Heading 2', 'Heading 3', 'Heading 4', 'Heading 5', 'Heading 6'];
            let defaultStyleNames = this.defaultStyleName(styleNames, localValue);
            let finalList = collection.concat(defaultStyleNames).filter((v, i, a) => a.indexOf(v) === i);
            return finalList;
        };
        this.defaultStyleName = (styleNames, localValue) => {
            let styleName = [];
            for (let index = 0; index < styleNames.length; index++) {
                styleName.push(localValue.getConstant(styleNames[index]));
            }
            return styleName;
        };
        this.modifyStyles = () => {
            this.owner.dialog.hide();
            this.owner.owner.styleDialogModule.show(this.styleName, this.localValue.getConstant('Modify Style'));
        };
        /* tslint:disable:no-any */
        this.selectHandler = (args) => {
            this.styleName = args.text;
        };
        this.addNewStyles = () => {
            this.owner.dialog.hide();
            this.owner.owner.styleDialogModule.show();
        };
        this.owner = viewer;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'StylesDialog';
    }
    /**
     * @private
     */
    initStylesDialog(localValue, styles, isRtl) {
        let id = this.owner.owner.containerId + '_insert_styles';
        this.target = createElement('div', { id: id, className: 'e-de-styles' });
        let headerValue = localValue.getConstant('Styles');
        let dlgFields = createElement('div', { innerHTML: headerValue, className: 'e-styles-dlgfields' });
        this.target.appendChild(dlgFields);
        let commonDiv = createElement('div', { className: 'e-styles-common' });
        this.target.appendChild(commonDiv);
        let searchDiv = createElement('div', { className: 'e-styles-list' });
        commonDiv.appendChild(searchDiv);
        if (isRtl) {
            searchDiv.classList.add('e-de-rtl');
        }
        let listviewDiv = createElement('div', { className: 'e-styles-listViewDiv', id: 'styles_listview' });
        searchDiv.appendChild(listviewDiv);
        this.listviewInstance = new ListView({
            dataSource: styles,
            cssClass: 'e-styles-listview',
        });
        this.listviewInstance.appendTo(listviewDiv);
        this.listviewInstance.addEventListener('select', this.selectHandler);
        let buttonDiv = createElement('div', { className: 'e-styles-button' });
        commonDiv.appendChild(buttonDiv);
        let newButtonDiv = createElement('div', { className: 'e-styles-addbutton' });
        buttonDiv.appendChild(newButtonDiv);
        let newButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('New'), id: 'new',
            attrs: { type: 'button' }
        });
        newButtonDiv.appendChild(newButtonElement);
        let newbutton = new Button({ cssClass: 'e-button-custom' });
        newbutton.appendTo(newButtonElement);
        newButtonElement.addEventListener('click', this.addNewStyles);
        let modifybuttonDiv = createElement('div', { className: 'e-styles-addbutton' });
        buttonDiv.appendChild(modifybuttonDiv);
        let modifyButtonElement = createElement('button', {
            innerHTML: localValue.getConstant('Modify'), id: 'modify',
            attrs: { type: 'button' }
        });
        modifybuttonDiv.appendChild(modifyButtonElement);
        let addbutton = new Button({ cssClass: 'e-button-custom' });
        addbutton.appendTo(modifyButtonElement);
        modifyButtonElement.addEventListener('click', this.modifyStyles);
    }
    /**
     * @private
     */
    show() {
        let localValue = new L10n('documenteditor', this.owner.owner.defaultLocale);
        localValue.setLocale(this.owner.owner.locale);
        let styles = this.updateStyleNames(localValue);
        this.localValue = localValue;
        this.initStylesDialog(localValue, styles, this.owner.owner.enableRtl);
        this.owner.dialog.content = this.target;
        this.owner.dialog.beforeOpen = this.owner.updateFocus;
        this.owner.dialog.close = this.owner.updateFocus;
        this.owner.dialog.header = localValue.getConstant('Styles');
        this.owner.dialog.height = 'auto';
        this.owner.dialog.width = 'auto';
        this.owner.dialog.buttons = [{
                click: this.hideObjects.bind(this),
                buttonModel: { content: localValue.getConstant('Cancel'), cssClass: 'e-flat e-hyper-insert', isPrimary: true }
            }];
        this.owner.dialog.dataBind();
        this.owner.dialog.show();
    }
    hideObjects() {
        this.owner.dialog.hide();
    }
    /**
     * @private
     */
    destroy() {
        if (this.listviewInstance) {
            this.listviewInstance.destroy();
            this.listviewInstance = undefined;
        }
    }
}

/**
 * Export dialogs
 */

/**
 * Spell checker export
 */

/**
 * Restrict editing
 */

/**
 * @private
 */
class CommentReviewPane {
    constructor(owner) {
        this.isNewComment = false;
        this.owner = owner;
        let localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.initReviewPane(localObj);
        this.reviewPane.style.display = 'none';
    }
    get previousSelectedComment() {
        return this.previousSelectedCommentInt;
    }
    set previousSelectedComment(value) {
        if (!isNullOrUndefined(value) && value !== this.previousSelectedCommentInt) {
            if (this.commentPane.comments.containsKey(value)) {
                let commentStart = this.commentPane.getCommentStart(value);
                let commentMark = commentStart.commentMark;
                if (commentMark) {
                    classList(commentMark, [], ['e-de-cmt-mark-selected']);
                    this.commentPane.removeSelectionMark('e-de-cmt-selection');
                    this.commentPane.removeSelectionMark('e-de-cmt-mark-selected');
                }
                let commentView = this.commentPane.comments.get(value);
                commentView.hideDrawer();
                for (let i = 0; i < value.replyComments.length; i++) {
                    commentView = this.commentPane.comments.get(value.replyComments[i]);
                    if (commentView) {
                        commentView.hideDrawer();
                        commentView.hideMenuItems();
                    }
                }
            }
        }
        this.previousSelectedCommentInt = value;
    }
    /**
     * @private
     */
    showHidePane(show) {
        if (this.reviewPane) {
            this.reviewPane.style.display = show ? 'block' : 'none';
        }
        if (show) {
            this.commentPane.updateHeight();
        }
        if (this.owner) {
            this.owner.resize();
        }
    }
    initReviewPane(localValue) {
        let reviewContainer = this.owner.viewer.optionsPaneContainer;
        reviewContainer.style.display = 'inline-flex';
        reviewContainer.appendChild(this.initPaneHeader(localValue));
        this.initCommentPane();
    }
    initPaneHeader(localValue) {
        this.headerContainer = createElement('div');
        this.reviewPane = createElement('div', { className: 'e-de-cmt-pane', styles: 'display:none' });
        if (this.owner.enableRtl) {
            classList(this.reviewPane, ['e-rtl'], []);
        }
        let headerWholeDiv = createElement('div', { className: 'e-de-cp-whole-header' });
        let headerDiv1 = createElement('div', {
            innerHTML: localValue.getConstant('Comments'), className: 'e-de-cp-header'
        });
        this.closeButton = createElement('button', {
            className: 'e-de-cp-close e-btn e-flat e-icon-btn', id: 'close',
            attrs: { type: 'button' }
        });
        this.closeButton.title = localValue.getConstant('Close');
        headerWholeDiv.appendChild(this.closeButton);
        headerWholeDiv.appendChild(headerDiv1);
        let closeSpan = createElement('span', { className: 'e-de-op-close-icon e-btn-icon e-icons' });
        this.closeButton.appendChild(closeSpan);
        this.headerContainer.appendChild(headerWholeDiv);
        this.headerContainer.appendChild(this.initToolbar(localValue));
        this.reviewPane.appendChild(this.headerContainer);
        this.closeButton.addEventListener('click', this.closePane.bind(this));
        return this.reviewPane;
    }
    closePane() {
        if (this.commentPane && this.commentPane.isEditMode) {
            if (!isNullOrUndefined(this.commentPane.currentEditingComment)
                && this.commentPane.isInsertingReply && this.commentPane.currentEditingComment.replyViewTextBox.value === '') {
                this.owner.viewer.currentSelectedComment = undefined;
                this.commentPane.currentEditingComment.cancelReply();
                this.owner.showComments = false;
            }
            else if (this.isNewComment || !isNullOrUndefined(this.commentPane.currentEditingComment)
                && this.commentPane.isInsertingReply && this.commentPane.currentEditingComment.replyViewTextBox.value !== '' ||
                !isNullOrUndefined(this.commentPane.currentEditingComment) && !this.commentPane.isInsertingReply &&
                    this.commentPane.currentEditingComment.textArea.value !== this.commentPane.currentEditingComment.comment.text) {
                let localObj = new L10n('documenteditor', this.owner.defaultLocale);
                localObj.setLocale(this.owner.locale);
                this.confirmDialog = DialogUtility.confirm({
                    title: localObj.getConstant('Un-posted comments'),
                    content: localObj.getConstant('Added comments not posted. If you continue, that comment will be discarded.'),
                    okButton: {
                        text: 'Discard', click: this.discardButtonClick.bind(this)
                    },
                    cancelButton: {
                        text: 'Cancel', click: this.closeDialogUtils.bind(this)
                    },
                    showCloseIcon: true,
                    closeOnEscape: true,
                    animationSettings: { effect: 'Zoom' },
                    position: { X: 'Center', Y: 'Center' }
                });
            }
            else {
                this.owner.viewer.currentSelectedComment = undefined;
                this.commentPane.currentEditingComment.cancelEditing();
                this.owner.showComments = false;
            }
        }
        else {
            this.owner.viewer.currentSelectedComment = undefined;
            this.owner.showComments = false;
        }
    }
    discardButtonClick() {
        if (this.commentPane.currentEditingComment) {
            let isNewComment = this.isNewComment;
            if (this.commentPane.currentEditingComment && this.commentPane.isInsertingReply) {
                this.commentPane.currentEditingComment.cancelReply();
            }
            else {
                this.commentPane.currentEditingComment.cancelEditing();
                if (isNewComment) {
                    this.discardComment(this.commentPane.currentEditingComment.comment);
                }
            }
            this.owner.viewer.currentSelectedComment = undefined;
            this.closeDialogUtils();
            this.owner.showComments = false;
        }
    }
    closeDialogUtils() {
        this.confirmDialog.close();
        this.confirmDialog = undefined;
    }
    initToolbar(localValue) {
        this.toolbarElement = createElement('div');
        this.toolbar = new Toolbar({
            items: [
                {
                    prefixIcon: 'e-de-new-cmt e-de-cmt-tbr', tooltipText: localValue.getConstant('New Comment'),
                    text: localValue.getConstant('New Comment'), click: this.insertComment.bind(this)
                },
                {
                    prefixIcon: 'e-de-nav-left-arrow e-de-cmt-tbr', align: 'Right',
                    tooltipText: localValue.getConstant('Previous Comment'), click: this.navigatePreviousComment.bind(this)
                },
                {
                    prefixIcon: 'e-de-nav-right-arrow e-de-cmt-tbr', align: 'Right',
                    tooltipText: localValue.getConstant('Next Comment'), click: this.navigateNextComment.bind(this)
                }
            ],
            enableRtl: this.owner.enableRtl
        });
        this.toolbar.appendTo(this.toolbarElement);
        return this.toolbarElement;
    }
    insertComment() {
        if (this.owner && this.owner.editorModule) {
            this.owner.editorModule.insertComment('');
        }
    }
    addComment(comment, isNewComment) {
        this.isNewComment = isNewComment;
        this.owner.viewer.currentSelectedComment = comment;
        this.commentPane.insertComment(comment);
        if (!isNewComment) {
            let commentView = this.commentPane.comments.get(comment);
            commentView.cancelEditing();
            this.enableDisableToolbarItem();
        }
        this.selectComment(comment);
    }
    deleteComment(comment) {
        if (this.commentPane) {
            this.commentPane.deleteComment(comment);
        }
    }
    selectComment(comment) {
        if (this.commentPane.isEditMode) {
            return;
        }
        if (comment.isReply) {
            comment = comment.ownerComment;
        }
        if (this.owner && this.owner.viewer && this.owner.viewer.currentSelectedComment !== comment) {
            this.owner.viewer.currentSelectedComment = comment;
        }
        this.commentPane.selectComment(comment);
    }
    resolveComment(comment) {
        this.commentPane.resolveComment(comment);
    }
    reopenComment(comment) {
        this.commentPane.reopenComment(comment);
    }
    addReply(comment, newComment) {
        this.isNewComment = newComment;
        this.commentPane.insertReply(comment);
        if (!newComment) {
            let commentView = this.commentPane.comments.get(comment);
            commentView.cancelEditing();
            this.enableDisableToolbarItem();
        }
        this.selectComment(comment.ownerComment);
    }
    navigatePreviousComment() {
        if (this.owner && this.owner.editorModule) {
            this.owner.selection.navigatePreviousComment();
        }
    }
    navigateNextComment() {
        if (this.owner && this.owner.editorModule) {
            this.owner.selection.navigateNextComment();
        }
    }
    enableDisableToolbarItem() {
        if (this.toolbar) {
            let enable = true;
            if (this.commentPane.isEditMode) {
                enable = !this.commentPane.isEditMode;
            }
            let elements = this.toolbar.element.querySelectorAll('.' + 'e-de-cmt-tbr');
            this.toolbar.enableItems(elements[0].parentElement.parentElement, enable);
            if (enable && this.owner && this.owner.viewer) {
                enable = !(this.owner.viewer.comments.length === 0);
            }
            this.toolbar.enableItems(elements[1].parentElement.parentElement, enable);
            this.toolbar.enableItems(elements[2].parentElement.parentElement, enable);
        }
    }
    initCommentPane() {
        this.commentPane = new CommentPane(this.owner, this);
        this.commentPane.initCommentPane();
    }
    layoutComments() {
        for (let i = 0; i < this.owner.viewer.comments.length; i++) {
            this.commentPane.addComment(this.owner.viewer.comments[i]);
        }
    }
    clear() {
        this.previousSelectedCommentInt = undefined;
        this.commentPane.clear();
    }
    discardComment(comment) {
        if (comment) {
            if (this.owner.editorHistory) {
                this.owner.editorHistory.undo();
                this.owner.editorHistory.redoStack.pop();
            }
            else if (this.owner.editor) {
                this.owner.editor.deleteCommentInternal(comment);
            }
        }
    }
    destroy() {
        if (this.commentPane) {
            this.commentPane.destroy();
        }
        this.commentPane = undefined;
        if (this.closeButton && this.closeButton.parentElement) {
            this.closeButton.parentElement.removeChild(this.closeButton);
        }
        this.closeButton = undefined;
        if (this.toolbar) {
            this.toolbar.destroy();
        }
        this.toolbar = undefined;
        if (this.toolbarElement && this.toolbarElement.parentElement) {
            this.toolbarElement.parentElement.removeChild(this.toolbarElement);
        }
        this.toolbarElement = undefined;
        if (this.headerContainer && this.headerContainer.parentElement) {
            this.headerContainer.parentElement.removeChild(this.headerContainer);
        }
        this.headerContainer = undefined;
        this.previousSelectedCommentInt = undefined;
        if (this.reviewPane && this.reviewPane.parentElement) {
            this.reviewPane.parentElement.removeChild(this.reviewPane);
        }
        this.reviewPane.innerHTML = '';
        this.reviewPane = undefined;
        this.owner = undefined;
    }
}
/**
 * @private
 */
class CommentPane {
    constructor(owner, pane) {
        this.isEditModeInternal = false;
        this.isInsertingReply = false;
        this.owner = owner;
        this.parentPane = pane;
        this.parent = pane.reviewPane;
        this.comments = new Dictionary();
    }
    /**
     * @private
     */
    get isEditMode() {
        return this.isEditModeInternal;
    }
    /**
     * @private
     */
    set isEditMode(value) {
        this.isEditModeInternal = value;
        let keys = this.comments.keys;
        for (let i = 0; i < keys.length; i++) {
            let commentView = this.comments.get(keys[i]);
            if (value) {
                commentView.menuBar.style.display = 'none';
            }
            else if (!commentView.comment.isReply) {
                commentView.menuBar.style.display = 'block';
            }
        }
        if (this.parentPane) {
            this.parentPane.enableDisableToolbarItem();
        }
        if (this.owner) {
            if (this.isEditModeInternal) {
                this.owner.trigger('commentBegin');
            }
            else {
                this.owner.trigger('commentEnd');
            }
        }
    }
    initCommentPane() {
        this.commentPane = createElement('div', { className: 'e-de-cmt-container' });
        let localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.noCommentIndicator = createElement('div', {
            className: 'e-de-cmt-no-cmt',
            innerHTML: localObj.getConstant('No comments in this document')
        });
        this.commentPane.appendChild(this.noCommentIndicator);
        this.parent.appendChild(this.commentPane);
    }
    addComment(comment) {
        let commentView = new CommentView(this.owner, this, comment);
        let commentParent = commentView.layoutComment(false);
        this.comments.add(comment, commentView);
        this.commentPane.appendChild(commentParent);
        for (let i = 0; i < comment.replyComments.length; i++) {
            let replyView = new CommentView(this.owner, this, comment.replyComments[i]);
            this.comments.add(comment.replyComments[i], replyView);
            commentParent.insertBefore(replyView.layoutComment(true), commentView.replyViewContainer);
        }
        this.updateCommentStatus();
        commentView.hideDrawer();
    }
    updateHeight() {
        this.commentPane.style.height = this.parent.clientHeight - this.parentPane.headerContainer.clientHeight + 'px';
    }
    insertReply(replyComment) {
        let parentComment = replyComment.ownerComment;
        let parentView = this.comments.get(parentComment);
        let replyView = new CommentView(this.owner, this, replyComment);
        this.comments.add(replyComment, replyView);
        let replyElement = replyView.layoutComment(true);
        let replyIndex = parentComment.replyComments.indexOf(replyComment);
        if (replyIndex === parentComment.replyComments.length - 1) {
            parentView.parentElement.insertBefore(replyElement, parentView.replyViewContainer);
        }
        else {
            let nextReply = parentComment.replyComments[replyIndex + 1];
            parentView.parentElement.insertBefore(replyElement, this.comments.get(nextReply).parentElement);
        }
        replyView.editComment();
    }
    insertComment(comment) {
        let commentView = new CommentView(this.owner, this, comment);
        let commentParent = commentView.layoutComment(false);
        this.comments.add(comment, commentView);
        if (this.owner.viewer.comments.indexOf(comment) === this.owner.viewer.comments.length - 1) {
            this.commentPane.appendChild(commentParent);
        }
        else {
            let index = this.owner.viewer.comments.indexOf(comment);
            let element = this.comments.get(this.owner.viewer.comments[index + 1]).parentElement;
            this.commentPane.insertBefore(commentParent, element);
            commentParent.focus();
        }
        this.updateCommentStatus();
        commentView.editComment();
    }
    removeSelectionMark(className) {
        if (this.parent) {
            let elements = this.parent.getElementsByClassName(className);
            for (let i = 0; i < elements.length; i++) {
                classList(elements[i], [], [className]);
            }
        }
    }
    selectComment(comment) {
        this.removeSelectionMark('e-de-cmt-selection');
        if (comment.isReply) {
            comment = comment.ownerComment;
        }
        if (comment) {
            let commentView = this.comments.get(comment);
            let selectedElement = commentView.parentElement;
            if (selectedElement) {
                classList(selectedElement, ['e-de-cmt-selection'], []);
                selectedElement.focus();
            }
            let commentStart = this.getCommentStart(comment);
            if (!commentStart.commentMark) {
                commentStart.renderCommentMark();
            }
            classList(commentStart.commentMark, ['e-de-cmt-mark-selected'], []);
            commentView.showDrawer();
        }
    }
    getCommentStart(comment) {
        let commentStart = undefined;
        if (comment && comment.commentStart) {
            commentStart = comment.commentStart;
        }
        return this.getFirstCommentInLine(commentStart);
    }
    getFirstCommentInLine(commentStart) {
        for (let i = 0; i < commentStart.line.children.length; i++) {
            let startComment = commentStart.line.children[i];
            if (startComment instanceof CommentCharacterElementBox && startComment.commentType === 0) {
                return startComment;
            }
        }
        return commentStart;
    }
    deleteComment(comment) {
        let commentView = this.comments.get(comment);
        if (commentView.parentElement && commentView.parentElement.parentElement) {
            commentView.parentElement.parentElement.removeChild(commentView.parentElement);
        }
        //this.commentPane.removeChild();
        this.comments.remove(comment);
        commentView.destroy();
        this.updateCommentStatus();
    }
    resolveComment(comment) {
        let commentView = this.comments.get(comment);
        if (commentView) {
            commentView.resolveComment();
        }
    }
    reopenComment(comment) {
        let commentView = this.comments.get(comment);
        if (commentView) {
            commentView.reopenComment();
        }
    }
    updateCommentStatus() {
        if (this.owner.viewer.comments.length === 0) {
            if (!this.noCommentIndicator.parentElement) {
                this.commentPane.appendChild(this.noCommentIndicator);
            }
            this.noCommentIndicator.style.display = 'block';
        }
        else {
            this.noCommentIndicator.style.display = 'none';
        }
        if (this.parentPane) {
            this.parentPane.enableDisableToolbarItem();
        }
    }
    clear() {
        this.isEditMode = false;
        this.currentEditingComment = undefined;
        this.isInsertingReply = false;
        this.removeChildElements();
        this.commentPane.innerHTML = '';
        this.updateCommentStatus();
    }
    removeChildElements() {
        let comments = this.comments.keys;
        for (let i = 0; i < comments.length; i++) {
            this.comments.get(comments[i]).destroy();
        }
        this.comments.clear();
    }
    destroy() {
        this.removeChildElements();
        if (this.noCommentIndicator && this.noCommentIndicator) {
            this.noCommentIndicator.parentElement.removeChild(this.noCommentIndicator);
        }
        this.noCommentIndicator = undefined;
        if (this.commentPane && this.commentPane.parentElement) {
            this.commentPane.parentElement.removeChild(this.commentPane);
        }
        this.commentPane.innerHTML = '';
        this.parentPane = undefined;
        this.owner = undefined;
    }
}
/**
 * @private
 */
class CommentView {
    constructor(owner, commentPane, comment) {
        this.isReply = false;
        this.isDrawerExpand = false;
        this.owner = owner;
        this.comment = comment;
        this.commentPane = commentPane;
    }
    layoutComment(isReply) {
        this.isReply = isReply;
        let classList$$1 = 'e-de-cmt-sub-container';
        if (isReply) {
            classList$$1 += ' e-de-cmt-reply';
        }
        let localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.parentElement = createElement('div', { className: classList$$1 });
        this.initCommentHeader(localObj);
        this.initCommentView(localObj);
        this.initDateView();
        if (!this.comment.isReply) {
            this.parentElement.tabIndex = 0;
            this.initReplyView(localObj);
            this.initResolveOption(localObj);
            this.initDrawer();
            if (this.comment.isResolved) {
                this.resolveComment();
            }
        }
        else {
            this.menuBar.style.display = 'none';
        }
        this.commentView.addEventListener('mouseenter', this.showMenuItems.bind(this));
        this.commentView.addEventListener('mouseleave', this.hideMenuItemOnMouseLeave.bind(this));
        return this.parentElement;
    }
    initCommentHeader(localObj) {
        let commentDiv = createElement('div', { className: 'e-de-cmt-view' });
        let commentUserInfo = createElement('div', { className: 'e-de-cmt-author' });
        let userName = createElement('div', { className: 'e-de-cmt-author-name' });
        userName.textContent = this.comment.author;
        //if (this.comment.author === this.owner.currentUser) {
        this.menuBar = createElement('button', { className: 'e-de-cp-option' });
        let userOption = [{ text: localObj.getConstant('Edit') },
            { text: localObj.getConstant('Delete') },
            { text: localObj.getConstant('Reply') },
            { text: localObj.getConstant('Resolve') }];
        let menuItem = new DropDownButton({
            items: this.isReply ? userOption.splice(0, 2) : userOption,
            select: this.userOptionSelectEvent.bind(this),
            iconCss: 'e-de-menu-icon',
            cssClass: 'e-caret-hide',
            enableRtl: this.owner.enableRtl
        });
        menuItem.appendTo(this.menuBar);
        commentUserInfo.appendChild(this.menuBar);
        this.dropDownButton = menuItem;
        //}
        commentUserInfo.appendChild(userName);
        commentDiv.appendChild(commentUserInfo);
        this.commentView = commentDiv;
        this.parentElement.appendChild(commentDiv);
        commentDiv.addEventListener('click', this.selectComment.bind(this));
    }
    selectComment(event) {
        if (this.commentPane) {
            if (!this.commentPane.isEditMode) {
                this.owner.selection.selectComment(this.comment);
            }
            else if (this.commentPane.isEditMode && this.commentPane.isInsertingReply
                && this.commentPane.currentEditingComment && this.commentPane.currentEditingComment.replyViewTextBox.value === '') {
                let comment = this.comment;
                if (comment && comment.isReply) {
                    comment = this.comment.ownerComment;
                }
                if (comment && this.owner.viewer.currentSelectedComment === comment) {
                    return;
                }
                this.commentPane.currentEditingComment.cancelReply();
                this.owner.selection.selectComment(this.comment);
            }
        }
    }
    initCommentView(localObj) {
        this.commentText = createElement('div', { className: 'e-de-cmt-readonly' });
        this.commentText.innerText = this.comment.text;
        this.commentView.appendChild(this.commentText);
        this.initEditView(localObj);
    }
    initEditView(localObj) {
        this.textAreaContainer = createElement('div', { styles: 'display:none' });
        this.textArea = createElement('textarea', { className: 'e-de-cmt-textarea e-input' });
        this.textArea.placeholder = localObj.getConstant('Type your comment hear');
        this.textArea.rows = 1;
        this.textArea.value = this.comment.text.trim();
        this.textArea.addEventListener('keydown', this.updateTextAreaHeight.bind(this));
        this.textArea.addEventListener('keyup', this.enableDisablePostButton.bind(this));
        let editRegionFooter = createElement('div', { className: 'e-de-cmt-action-button' });
        let postButton = createElement('button', { className: 'e-de-cmt-post-btn e-btn e-flat' });
        //tslint:disable-next-line:max-line-length
        this.postButton = new Button({ cssClass: 'e-btn e-flat e-primary', iconCss: 'e-de-cmt-post', disabled: true }, postButton);
        postButton.addEventListener('click', this.postComment.bind(this));
        let cancelButton = createElement('button', {
            className: 'e-de-cmt-cancel-btn e-btn e-flat'
        });
        this.cancelButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-cancel' }, cancelButton);
        cancelButton.addEventListener('click', this.cancelEditing.bind(this));
        editRegionFooter.appendChild(postButton);
        editRegionFooter.appendChild(cancelButton);
        this.textAreaContainer.appendChild(this.textArea);
        this.textAreaContainer.appendChild(editRegionFooter);
        this.commentView.appendChild(this.textAreaContainer);
    }
    initDateView() {
        this.commentDate = createElement('div', { className: 'e-de-cmt-date' });
        let modifiedDate = new Date(this.comment.date);
        let date = modifiedDate.toString().split(' ').splice(1, 2).join(' ');
        let time = modifiedDate.toLocaleTimeString().split(' ')[0].split(':').splice(0, 2).join(':')
            + modifiedDate.toLocaleTimeString().split(' ')[1];
        this.commentDate.innerText = date + ', ' + modifiedDate.getFullYear() + ', ' + time;
        this.commentView.appendChild(this.commentDate);
    }
    initDrawer() {
        this.drawerElement = createElement('div', { styles: 'display:none;', className: 'e-de-cmt-drawer-cnt' });
        let leftPane = createElement('div', { className: 'e-de-cmt-drawer' });
        let spanElement = createElement('span');
        leftPane.appendChild(spanElement);
        this.drawerElement.appendChild(leftPane);
        this.drawerSpanElement = spanElement;
        this.drawerAction = leftPane;
        this.drawerAction.addEventListener('click', this.showOrHideDrawer.bind(this));
        this.parentElement.appendChild(this.drawerElement);
    }
    initReplyView(localObj) {
        this.replyViewContainer = createElement('div', { className: 'e-de-cmt-rply-view' });
        if (this.commentPane.parentPane.isNewComment) {
            this.replyViewContainer.style.display = 'none';
        }
        this.replyViewTextBox = createElement('textarea', { className: 'e-de-cmt-textarea e-input' });
        this.replyViewTextBox.placeholder = localObj.getConstant('Reply');
        this.replyViewTextBox.rows = 1;
        this.replyViewTextBox.value = '';
        this.replyViewTextBox.readOnly = true;
        this.replyViewTextBox.addEventListener('click', this.enableReplyView.bind(this));
        this.replyViewTextBox.addEventListener('keydown', this.updateReplyTextAreaHeight.bind(this));
        this.replyViewTextBox.addEventListener('keyup', this.enableDisableReplyPostButton.bind(this));
        let editRegionFooter = createElement('div', { styles: 'display:none', className: 'e-de-cmt-action-button' });
        let postButton = createElement('button', { className: 'e-de-cmt-post-btn e-btn e-flat' });
        //tslint:disable-next-line:max-line-length
        this.replyPostButton = new Button({ cssClass: 'e-btn e-flat e-primary', iconCss: 'e-de-cmt-post', disabled: true }, postButton);
        postButton.addEventListener('click', this.postReply.bind(this));
        let cancelButton = createElement('button', {
            className: 'e-de-cmt-cancel-btn e-btn e-flat'
        });
        this.replyCancelButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-cancel' }, cancelButton);
        cancelButton.addEventListener('click', this.cancelReply.bind(this));
        editRegionFooter.appendChild(postButton);
        editRegionFooter.appendChild(cancelButton);
        this.replyFooter = editRegionFooter;
        this.replyViewContainer.appendChild(this.replyViewTextBox);
        this.replyViewContainer.appendChild(editRegionFooter);
        this.parentElement.appendChild(this.replyViewContainer);
    }
    initResolveOption(localObj) {
        let editRegionFooter = createElement('div', { className: 'e-de-cmt-resolve-btn' });
        let postButton = createElement('button', { className: 'e-de-cmt-post-btn e-btn e-flat' });
        //tslint:disable-next-line:max-line-length
        this.reopenButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-reopen' }, postButton);
        postButton.title = localObj.getConstant('Reopen');
        postButton.addEventListener('click', this.reopenButtonClick.bind(this));
        let cancelButton = createElement('button', {
            className: 'e-de-cmt-cancel-btn e-btn e-flat'
        });
        cancelButton.title = localObj.getConstant('Delete');
        this.deleteButton = new Button({ cssClass: 'e-btn e-flat', iconCss: 'e-de-cmt-delete' }, cancelButton);
        cancelButton.addEventListener('click', this.deleteButtonClick.bind(this));
        editRegionFooter.appendChild(postButton);
        editRegionFooter.appendChild(cancelButton);
        this.parentElement.appendChild(editRegionFooter);
    }
    reopenButtonClick() {
        this.owner.editor.reopenComment(this.comment);
    }
    deleteButtonClick() {
        this.owner.editorModule.deleteCommentInternal(this.comment);
    }
    updateReplyTextAreaHeight() {
        setTimeout(() => {
            this.replyViewTextBox.style.height = 'auto';
            let scrollHeight = this.replyViewTextBox.scrollHeight;
            this.replyViewTextBox.style.height = scrollHeight + 'px';
        });
    }
    enableDisableReplyPostButton() {
        this.replyPostButton.disabled = this.replyViewTextBox.value === '';
    }
    enableReplyView() {
        if (this.commentPane.isEditMode) {
            return;
        }
        this.commentPane.currentEditingComment = this;
        this.commentPane.isInsertingReply = true;
        if (this.owner.viewer.currentSelectedComment !== this.comment) {
            this.owner.selection.selectComment(this.comment);
        }
        this.commentPane.isEditMode = true;
        this.replyViewTextBox.readOnly = false;
        this.replyFooter.style.display = 'block';
        setTimeout(() => {
            this.replyViewTextBox.focus();
        });
    }
    postReply() {
        let replyText = this.replyViewTextBox.value;
        this.cancelReply();
        this.updateReplyTextAreaHeight();
        this.owner.editorModule.replyComment(this.comment, replyText);
    }
    cancelReply() {
        this.commentPane.currentEditingComment = undefined;
        this.commentPane.isInsertingReply = true;
        this.commentPane.isEditMode = false;
        this.replyPostButton.disabled = true;
        this.replyViewTextBox.value = '';
        this.replyViewTextBox.readOnly = true;
        this.replyFooter.style.display = 'none';
    }
    updateTextAreaHeight() {
        setTimeout(() => {
            this.textArea.style.height = 'auto';
            let scrollHeight = this.textArea.scrollHeight;
            this.textArea.style.height = scrollHeight + 'px';
        });
    }
    showMenuItems() {
        if (this.comment.isReply) {
            if (!this.commentPane.isEditMode && (!isNullOrUndefined(this.comment) && !this.comment.isResolved)) {
                this.menuBar.style.display = 'block';
            }
        }
        let commentStart = this.commentPane.getCommentStart(this.comment);
        if (!isNullOrUndefined(commentStart) && !isNullOrUndefined(commentStart.commentMark)) {
            commentStart.commentMark.classList.add('e-de-cmt-mark-hover');
        }
    }
    hideMenuItemOnMouseLeave() {
        if (this.comment.isReply) {
            if (this.owner.viewer.currentSelectedComment !== this.comment.ownerComment) {
                this.hideMenuItems();
            }
        }
        if (this.commentPane) {
            let commentStart = this.commentPane.getCommentStart(this.comment);
            if (!isNullOrUndefined(commentStart) && !isNullOrUndefined(commentStart.commentMark)) {
                commentStart.commentMark.classList.remove('e-de-cmt-mark-hover');
            }
        }
    }
    hideMenuItems() {
        this.menuBar.style.display = 'none';
    }
    enableDisablePostButton() {
        this.postButton.disabled = this.textArea.value === '';
    }
    editComment() {
        this.commentPane.currentEditingComment = this;
        this.commentPane.isInsertingReply = false;
        this.commentPane.isEditMode = true;
        this.commentText.style.display = 'none';
        this.textAreaContainer.style.display = 'block';
        this.commentDate.style.display = 'none';
        this.menuBar.style.display = 'none';
        this.updateTextAreaHeight();
        setTimeout(() => {
            this.textArea.focus();
        });
    }
    resolveComment() {
        classList(this.parentElement, ['e-de-cmt-resolved'], []);
        let localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.dropDownButton.items = [{ text: localObj.getConstant('Reopen') }, { text: localObj.getConstant('Delete') }];
    }
    reopenComment() {
        classList(this.parentElement, [], ['e-de-cmt-resolved']);
        let localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        this.dropDownButton.items = [{ text: localObj.getConstant('Edit') },
            { text: localObj.getConstant('Delete') },
            { text: localObj.getConstant('Reply') },
            { text: localObj.getConstant('Resolve') }];
        this.showDrawer();
    }
    postComment() {
        let updatedText = this.textArea.value;
        this.commentText.innerText = updatedText;
        this.comment.text = updatedText;
        this.showCommentView();
        if (this.commentPane && this.commentPane.parentPane) {
            this.commentPane.parentPane.isNewComment = false;
        }
        if (!isNullOrUndefined(this.replyViewContainer)) {
            this.replyViewContainer.style.display = '';
        }
    }
    showCommentView() {
        this.commentPane.isEditMode = false;
        this.textAreaContainer.style.display = 'none';
        this.commentText.style.display = 'block';
        this.commentDate.style.display = 'block';
        this.menuBar.style.display = 'block';
    }
    cancelEditing() {
        this.showCommentView();
        this.textArea.value = this.comment.text.trim();
        if (this.commentPane.parentPane.isNewComment) {
            if (this.commentPane && this.commentPane.parentPane) {
                this.commentPane.parentPane.isNewComment = false;
            }
            this.commentPane.parentPane.discardComment(this.comment);
        }
    }
    showOrHideDrawer() {
        if (this.isDrawerExpand) {
            this.hideDrawer();
        }
        else {
            this.showDrawer();
        }
    }
    hideDrawer() {
        if (this.parentElement) {
            let localObj = new L10n('documenteditor', this.owner.defaultLocale);
            localObj.setLocale(this.owner.locale);
            let elements = this.parentElement.getElementsByClassName('e-de-cmt-sub-container');
            if (elements.length > 1) {
                for (let i = 1; i < elements.length; i++) {
                    elements[i].style.display = 'none';
                }
                this.drawerElement.style.display = 'block';
                classList(this.drawerSpanElement, [], ['e-de-nav-up']);
                this.drawerSpanElement.innerText = '+' + (elements.length - 1) + ' ' + localObj.getConstant('more') + '...';
            }
            this.isDrawerExpand = false;
        }
    }
    showDrawer() {
        if (this.parentElement) {
            let elements = this.parentElement.getElementsByClassName('e-de-cmt-sub-container');
            if (elements.length > 1) {
                for (let i = 0; i < elements.length; i++) {
                    elements[i].style.display = 'block';
                }
                this.drawerElement.style.display = 'block';
                this.drawerSpanElement.innerText = '';
                classList(this.drawerSpanElement, ['e-de-nav-up'], []);
            }
            this.isDrawerExpand = true;
        }
    }
    userOptionSelectEvent(event) {
        let selectedItem = event.item.text;
        let localObj = new L10n('documenteditor', this.owner.defaultLocale);
        localObj.setLocale(this.owner.locale);
        switch (selectedItem) {
            case localObj.getConstant('Edit'):
                this.editComment();
                break;
            case localObj.getConstant('Reply'):
                this.enableReplyView();
                break;
            case localObj.getConstant('Delete'):
                this.owner.editorModule.deleteCommentInternal(this.comment);
                break;
            case localObj.getConstant('Resolve'):
                this.owner.editor.resolveComment(this.comment);
                break;
            case localObj.getConstant('Reopen'):
                this.owner.editor.reopenComment(this.comment);
        }
    }
    unwireEvent() {
        if (this.drawerAction) {
            this.drawerAction.removeEventListener('click', this.showOrHideDrawer.bind(this));
        }
        if (this.textArea) {
            this.textArea.removeEventListener('keydown', this.updateTextAreaHeight.bind(this));
            this.textArea.removeEventListener('keyup', this.enableDisablePostButton.bind(this));
        }
        if (this.postButton) {
            this.postButton.removeEventListener('click', this.postComment.bind(this));
        }
        if (this.cancelButton) {
            this.cancelButton.removeEventListener('click', this.cancelEditing.bind(this));
        }
        if (this.commentView) {
            this.commentView.removeEventListener('click', this.selectComment.bind(this));
            this.commentView.removeEventListener('mouseenter', this.showMenuItems.bind(this));
            this.commentView.removeEventListener('mouseleave', this.hideMenuItemOnMouseLeave.bind(this));
        }
    }
    destroy() {
        this.unwireEvent();
        if (this.comment) {
            this.comment = undefined;
        }
        if (this.dropDownButton) {
            this.dropDownButton.destroy();
        }
        this.dropDownButton = undefined;
        if (this.postButton) {
            this.postButton.destroy();
        }
        this.postButton = undefined;
        if (this.cancelButton) {
            this.cancelButton.destroy();
        }
        if (this.replyPostButton) {
            this.replyPostButton.destroy();
            this.replyPostButton = undefined;
        }
        if (this.replyCancelButton) {
            this.replyCancelButton.destroy();
            this.replyCancelButton = undefined;
        }
        if (this.reopenButton) {
            this.reopenButton.destroy();
            this.reopenButton = undefined;
        }
        if (this.deleteButton) {
            this.deleteButton.destroy();
            this.deleteButton = undefined;
        }
        this.replyViewContainer = undefined;
        this.replyViewTextBox = undefined;
        this.replyFooter = undefined;
        if (this.parentElement && this.parentElement.parentElement) {
            this.parentElement.parentElement.removeChild(this.parentElement);
        }
        this.commentPane = undefined;
        this.parentElement.innerHTML = '';
        this.cancelButton = undefined;
        this.owner = undefined;
        this.menuBar = undefined;
        this.commentView = undefined;
        this.drawerAction = undefined;
        this.commentText = undefined;
        this.commentDate = undefined;
        this.textAreaContainer = undefined;
        this.textArea = undefined;
        this.drawerElement = undefined;
        this.drawerSpanElement = undefined;
        this.parentElement = null;
    }
}

/**
 * Comments
 */

/**
 * Document Editor implementation
 */

/**
 * export document editor
 */

const TOOLBAR_ID = '_toolbar';
const NEW_ID = '_new';
const OPEN_ID = '_open';
const UNDO_ID = '_undo';
const REDO_ID = '_redo';
const INSERT_IMAGE_ID = '_image';
const INSERT_IMAGE_LOCAL_ID = '_image_local';
const INSERT_IMAGE_ONLINE_ID = '_image_url';
const INSERT_TABLE_ID = '_table';
const INSERT_LINK_ID = '_link';
const BOOKMARK_ID = '_bookmark';
const COMMENT_ID = '_comment';
const TABLE_OF_CONTENT_ID = '_toc';
const HEADER_ID = '_header';
const FOOTER_ID = '_footer';
const PAGE_SET_UP_ID = '_page_setup';
const PAGE_NUMBER_ID = '_page_number';
const BREAK_ID = '_break';
const FIND_ID = '_find';
const CLIPBOARD_ID = '_use_local_clipboard';
const RESTRICT_EDITING_ID = '_restrict_edit';
const PAGE_BREAK = '_page_break';
const SECTION_BREAK = '_section_break';
const READ_ONLY = '_read_only';
const PROTECTIONS = '_protections';
/**
 * Toolbar Module
 */
class Toolbar$1 {
    /**
     * @private
     */
    constructor(container) {
        /**
         * @private
         */
        this.isCommentEditing = false;
        this.container = container;
        this.importHandler = new XmlHttpRequestHandler();
    }
    /**
     * @private
     */
    get documentEditor() {
        return this.container.documentEditor;
    }
    getModuleName() {
        return 'toolbar';
    }
    /**
     * @private
     */
    initToolBar() {
        this.renderToolBar();
        this.wireEvent();
    }
    // tslint:disable-next-line:max-func-body-length
    renderToolBar() {
        if (isNullOrUndefined(this.container)) {
            return;
        }
        let toolbarContainer = this.container.toolbarContainer;
        let toolbarWrapper = createElement('div', { className: 'e-de-tlbr-wrapper' });
        let toolbarTarget = createElement('div', { className: 'e-de-toolbar', styles: 'height:100%' });
        this.initToolbarItems();
        toolbarWrapper.appendChild(toolbarTarget);
        toolbarContainer.appendChild(toolbarWrapper);
        // Show hide pane button initialization 
        let propertiesPaneDiv = createElement('div', { className: 'e-de-ctnr-properties-pane-btn' });
        let buttonElement = createElement('button', { attrs: { type: 'button' } });
        propertiesPaneDiv.appendChild(buttonElement);
        let cssClassName = 'e-tbar-btn e-tbtn-txt e-control e-btn e-de-showhide-btn';
        let iconCss = 'e-icons e-de-ctnr-showhide';
        if (this.container.enableRtl) {
            cssClassName += '-rtl';
            iconCss = 'e-icons e-de-ctnr-showhide e-de-flip';
        }
        this.propertiesPaneButton = new Button({
            cssClass: cssClassName,
            iconCss: iconCss
        });
        this.propertiesPaneButton.appendTo(buttonElement);
        EventHandler.add(buttonElement, 'click', this.showHidePropertiesPane, this);
        toolbarContainer.appendChild(propertiesPaneDiv);
        this.toolbar.appendTo(toolbarTarget);
        let locale = this.container.localObj;
        let id = this.container.element.id + TOOLBAR_ID;
        let imageButton = toolbarTarget.getElementsByClassName('e-de-image-splitbutton')[0].firstChild;
        let items = {
            items: [
                {
                    text: locale.getConstant('Upload from computer'), iconCss: 'e-icons e-de-ctnr-upload',
                    id: id + INSERT_IMAGE_LOCAL_ID
                }
            ],
            //,{ text: locale.getConstant('By URL'), iconCss: 'e-icons e-de-ctnr-link', id: id + INSERT_IMAGE_ONLINE_ID }],
            cssClass: 'e-de-toolbar-btn-first e-caret-hide',
            iconCss: 'e-icons e-de-ctnr-image',
            select: this.onDropDownButtonSelect.bind(this),
        };
        this.imgDropDwn = new DropDownButton(items, imageButton);
        let breakButton = toolbarTarget.getElementsByClassName('e-de-break-splitbutton')[0].firstChild;
        items = {
            items: [
                { text: locale.getConstant('Page Break'), iconCss: 'e-icons e-de-ctnr-page-break', id: id + PAGE_BREAK },
                { text: locale.getConstant('Section Break'), iconCss: 'e-icons e-de-ctnr-section-break', id: id + SECTION_BREAK }
            ],
            cssClass: 'e-caret-hide',
            iconCss: 'e-icons e-de-ctnr-break',
            select: this.onDropDownButtonSelect.bind(this),
        };
        this.breakDropDwn = new DropDownButton(items, breakButton);
        this.filePicker = createElement('input', {
            attrs: { type: 'file', accept: '.doc,.docx,.rtf,.txt,.htm,.html,.sfdt' }, className: 'e-de-ctnr-file-picker'
        });
        this.imagePicker = createElement('input', {
            attrs: { type: 'file', accept: '.jpg,.jpeg,.png,.bmp' }, className: 'e-de-ctnr-file-picker'
        });
        this.toggleButton(id + CLIPBOARD_ID, this.container.enableLocalPaste);
        this.toggleButton(id + RESTRICT_EDITING_ID, this.container.restrictEditing);
        let restrictEditing = toolbarTarget.getElementsByClassName('e-de-lock-dropdownbutton')[0].firstChild;
        let lockItems = {
            items: [
                { text: locale.getConstant('Read only'), id: id + READ_ONLY },
                { text: locale.getConstant('Protections'), id: id + PROTECTIONS }
            ],
            cssClass: 'e-de-toolbar-btn-first e-caret-hide',
            select: this.onDropDownButtonSelect.bind(this)
        };
        this.restrictDropDwn = new DropDownButton(lockItems, restrictEditing);
    }
    showHidePropertiesPane() {
        if (this.container.propertiesPaneContainer.style.display === 'none') {
            this.container.showPropertiesPane = true;
            this.container.trigger('beforePaneSwitch', { type: 'PropertiesPane' });
        }
        else {
            this.container.showPropertiesPane = false;
        }
        this.enableDisablePropertyPaneButton(this.container.showPropertiesPane);
        this.container.showPropertiesPaneOnSelection();
        this.documentEditor.focusIn();
    }
    onWrapText(text) {
        let content = '';
        let index = text.lastIndexOf(' ');
        content = text.slice(0, index);
        text.slice(index);
        content += '<div class="e-de-text-wrap">' + text.slice(index) + '</div>';
        return content;
    }
    wireEvent() {
        this.propertiesPaneButton.on('click', this.togglePropertiesPane.bind(this));
        EventHandler.add(this.filePicker, 'change', this.onFileChange, this);
        EventHandler.add(this.imagePicker, 'change', this.onImageChange, this);
    }
    // tslint:disable-next-line:max-func-body-length
    initToolbarItems() {
        let id = this.container.element.id + TOOLBAR_ID;
        let locale = this.container.localObj;
        this.toolbar = new Toolbar({
            enableRtl: this.container.enableRtl,
            clicked: this.clickHandler.bind(this),
            items: [
                {
                    prefixIcon: 'e-de-ctnr-new', tooltipText: locale.getConstant('Create a new document.'),
                    id: id + NEW_ID, text: locale.getConstant('New'), cssClass: 'e-de-toolbar-btn-start'
                },
                {
                    prefixIcon: 'e-de-ctnr-open', tooltipText: locale.getConstant('Open a document.'), id: id + OPEN_ID,
                    text: locale.getConstant('Open'), cssClass: 'e-de-toolbar-btn-last'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-undo', tooltipText: locale.getConstant('Undo the last operation (Ctrl+Z).'),
                    id: id + UNDO_ID, text: locale.getConstant('Undo'), cssClass: 'e-de-toolbar-btn-first'
                },
                {
                    prefixIcon: 'e-de-ctnr-redo', tooltipText: locale.getConstant('Redo the last operation (Ctrl+Y).'),
                    id: id + REDO_ID, text: locale.getConstant('Redo'), cssClass: 'e-de-toolbar-btn-last'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    tooltipText: locale.getConstant('Insert inline picture from a file.'), id: id + INSERT_IMAGE_ID,
                    text: locale.getConstant('Image'), cssClass: 'e-de-toolbar-btn-first e-de-image-splitbutton e-de-image-focus'
                },
                {
                    prefixIcon: 'e-de-ctnr-table', tooltipText: locale.getConstant('Insert a table into the document'),
                    id: id + INSERT_TABLE_ID, text: locale.getConstant('Table'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-link',
                    tooltipText: locale.getConstant('Create a link in your document for quick access to webpages and files (Ctrl+K).'),
                    id: id + INSERT_LINK_ID, text: locale.getConstant('Link'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-bookmark',
                    tooltipText: locale.getConstant('Insert a bookmark in a specific place in this document.'),
                    id: id + BOOKMARK_ID, text: locale.getConstant('Bookmark'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-cnt-cmt-add',
                    tooltipText: locale.getConstant('New comment'),
                    id: id + COMMENT_ID, text: locale.getConstant('Comments'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-tableofcontent',
                    tooltipText: locale.getConstant('Provide an overview of your document by adding a table of contents.'),
                    id: id + TABLE_OF_CONTENT_ID, text: this.onWrapText(locale.getConstant('Table of Contents')),
                    cssClass: 'e-de-toolbar-btn-last'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-header', tooltipText: locale.getConstant('Add or edit the header.'),
                    id: id + HEADER_ID, text: locale.getConstant('Header'), cssClass: 'e-de-toolbar-btn-first'
                },
                {
                    prefixIcon: 'e-de-ctnr-footer', tooltipText: locale.getConstant('Add or edit the footer.'),
                    id: id + FOOTER_ID, text: locale.getConstant('Footer'), cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-pagesetup', tooltipText: locale.getConstant('Open the page setup dialog.'),
                    id: id + PAGE_SET_UP_ID, text: this.onWrapText(locale.getConstant('Page Setup')),
                    cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    prefixIcon: 'e-de-ctnr-pagenumber', tooltipText: locale.getConstant('Add page numbers.'),
                    id: id + PAGE_NUMBER_ID, text: this.onWrapText(locale.getConstant('Page Number')),
                    cssClass: 'e-de-toolbar-btn-middle'
                },
                {
                    tooltipText: locale.getConstant('Break'), text: locale.getConstant('Break'), id: BREAK_ID,
                    cssClass: 'e-de-toolbar-btn-last e-de-break-splitbutton'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-find', tooltipText: locale.getConstant('Find text in the document (Ctrl+F).'),
                    id: id + FIND_ID, text: locale.getConstant('Find'), cssClass: 'e-de-toolbar-btn'
                },
                {
                    type: 'Separator', cssClass: 'e-de-separator'
                },
                {
                    prefixIcon: 'e-de-ctnr-paste',
                    tooltipText: locale.getConstant('Toggle between the internal clipboard and system clipboard'),
                    id: id + CLIPBOARD_ID, text: this.onWrapText(locale.getConstant('Local Clipboard')),
                    cssClass: 'e-de-toolbar-btn-first'
                },
                {
                    prefixIcon: 'e-de-ctnr-lock', tooltipText: locale.getConstant('Restrict editing.'), id: id + RESTRICT_EDITING_ID,
                    text: this.onWrapText(locale.getConstant('Restrict Editing')), cssClass: 'e-de-toolbar-btn-end e-de-lock-dropdownbutton'
                }
            ]
        });
    }
    clickHandler(args) {
        let id = this.container.element.id + TOOLBAR_ID;
        switch (args.item.id) {
            case id + NEW_ID:
                this.container.documentEditor.openBlank();
                break;
            case id + OPEN_ID:
                this.filePicker.value = '';
                this.filePicker.click();
                break;
            case id + UNDO_ID:
                this.container.documentEditor.editorHistory.undo();
                break;
            case id + REDO_ID:
                this.container.documentEditor.editorHistory.redo();
                break;
            case id + INSERT_TABLE_ID:
                this.container.documentEditor.showDialog('Table');
                break;
            case id + INSERT_LINK_ID:
                this.container.documentEditor.showDialog('Hyperlink');
                break;
            case id + BOOKMARK_ID:
                this.container.documentEditor.showDialog('Bookmark');
                break;
            case id + COMMENT_ID:
                this.documentEditor.editor.insertComment('');
                break;
            case id + HEADER_ID:
                this.container.documentEditor.selection.goToHeader();
                break;
            case id + TABLE_OF_CONTENT_ID:
                this.onToc();
                break;
            case id + FOOTER_ID:
                this.container.documentEditor.selection.goToFooter();
                break;
            case id + PAGE_SET_UP_ID:
                this.container.documentEditor.showDialog('PageSetup');
                break;
            case id + PAGE_NUMBER_ID:
                this.container.documentEditor.editor.insertPageNumber();
                break;
            case id + FIND_ID:
                this.container.documentEditor.showOptionsPane();
                break;
            case id + CLIPBOARD_ID:
                this.toggleLocalPaste(args.item.id);
                break;
        }
        if (args.item.id !== id + FIND_ID && args.item.id !== id + INSERT_IMAGE_ID) {
            this.container.documentEditor.focusIn();
        }
    }
    toggleLocalPaste(id) {
        this.container.enableLocalPaste = !this.container.enableLocalPaste;
        this.toggleButton(id, this.container.enableLocalPaste);
    }
    toggleEditing(id) {
        this.container.restrictEditing = !this.container.restrictEditing;
        this.container.showPropertiesPane = !this.container.restrictEditing;
        // this.toggleButton(id, this.container.restrictEditing);
    }
    toggleButton(id, toggle) {
        let element = document.getElementById(id);
        if (toggle) {
            classList(element, ['e-btn-toggle'], []);
        }
        else {
            classList(element, [], ['e-btn-toggle']);
        }
    }
    togglePropertiesPane() {
        this.container.showPropertiesPane = !this.container.showPropertiesPane;
    }
    onDropDownButtonSelect(args) {
        let parentId = this.container.element.id + TOOLBAR_ID;
        let id = args.item.id;
        if (id === parentId + PAGE_BREAK) {
            this.container.documentEditor.editorModule.insertPageBreak();
        }
        else if (id === parentId + SECTION_BREAK) {
            this.container.documentEditor.editorModule.insertSectionBreak();
        }
        else if (id === parentId + INSERT_IMAGE_LOCAL_ID) {
            this.imagePicker.value = '';
            this.imagePicker.click();
        }
        else if (id === parentId + INSERT_IMAGE_ONLINE_ID) {
            // Need to implement image dialog;
        }
        else if (id === parentId + READ_ONLY) {
            this.container.restrictEditing = !this.container.restrictEditing;
            this.container.showPropertiesPane = !this.container.restrictEditing;
        }
        else if (id === parentId + PROTECTIONS) {
            this.documentEditor.viewer.restrictEditingPane.showHideRestrictPane(true);
        }
        setTimeout(() => { this.documentEditor.focusIn(); }, 30);
    }
    onFileChange() {
        let file = this.filePicker.files[0];
        if (file) {
            if (file.name.substr(file.name.lastIndexOf('.')) === '.sfdt') {
                let fileReader = new FileReader();
                fileReader.onload = () => {
                    this.container.documentEditor.open(fileReader.result);
                };
                fileReader.readAsText(file);
            }
            else {
                this.convertToSfdt(file);
            }
            this.container.documentEditor.documentName = file.name.substr(0, file.name.lastIndexOf('.'));
        }
    }
    convertToSfdt(file) {
        showSpinner(this.container.containerTarget);
        this.importHandler.url = this.container.serviceUrl + this.container.serverActionSettings.import;
        this.importHandler.onSuccess = this.successHandler.bind(this);
        this.importHandler.onFailure = this.failureHandler.bind(this);
        this.importHandler.onError = this.failureHandler.bind(this);
        this.importHandler.customHeaders = this.container.headers;
        let formData = new FormData();
        formData.append('files', file);
        this.importHandler.send(formData);
    }
    /* tslint:disable:no-any */
    failureHandler(args) {
        if (args.name === 'onError') {
            // tslint:disable-next-line:max-line-length
            DialogUtility.alert({ content: this.container.localObj.getConstant('Error in establishing connection with web server'), closeOnEscape: true, showCloseIcon: true, position: { X: 'Center', Y: 'Center' } });
        }
        else {
            alert('Failed to load the file');
        }
        hideSpinner(this.container.containerTarget);
    }
    successHandler(result) {
        this.container.documentEditor.open(result.data);
        hideSpinner(this.container.containerTarget);
    }
    /* tslint:enable:no-any */
    onImageChange() {
        let file = this.imagePicker.files[0];
        let fileReader = new FileReader();
        fileReader.onload = () => {
            this.insertImage(fileReader.result);
        };
        fileReader.readAsDataURL(file);
    }
    insertImage(data) {
        let image = document.createElement('img');
        let container = this.container;
        image.addEventListener('load', function () {
            container.documentEditor.editor.insertImage(data, this.width, this.height);
        });
        image.src = data;
    }
    /**
     * @private
     */
    enableDisableInsertComment(enable) {
        this.isCommentEditing = !enable;
        let id = this.container.element.id + TOOLBAR_ID;
        let commentId = id + COMMENT_ID;
        let element = document.getElementById(commentId);
        this.toolbar.enableItems(element.parentElement, enable);
    }
    /**
     * @private
     */
    enableDisableToolBarItem(enable, isProtectedContent) {
        let id = this.container.element.id + TOOLBAR_ID;
        for (let item of this.toolbar.items) {
            let itemId = item.id;
            if (itemId !== id + NEW_ID && itemId !== id + OPEN_ID && itemId !== id + FIND_ID &&
                itemId !== id + CLIPBOARD_ID && itemId !== id + RESTRICT_EDITING_ID && item.type !== 'Separator') {
                if (enable && this.isCommentEditing && itemId === id + COMMENT_ID) {
                    continue;
                }
                let element = document.getElementById(item.id);
                this.toolbar.enableItems(element.parentElement, enable);
            }
        }
        if (!isProtectedContent) {
            classList(this.propertiesPaneButton.element.parentElement, !enable ? ['e-de-overlay'] : [], !enable ? [] : ['e-de-overlay']);
        }
        if (enable) {
            this.enableDisableUndoRedo();
        }
    }
    /**
     * @private
     */
    enableDisableUndoRedo() {
        let id = this.container.element.id + TOOLBAR_ID;
        // tslint:disable-next-line:max-line-length
        this.toolbar.enableItems(document.getElementById(id + UNDO_ID).parentElement, this.container.documentEditor.editorHistory.canUndo());
        this.toolbar.enableItems(document.getElementById(id + REDO_ID).parentElement, this.container.documentEditor.editorHistory.canRedo());
    }
    onToc() {
        if (this.container.previousContext === 'TableOfContents' && this.container.propertiesPaneContainer.style.display === 'none') {
            this.container.showPropertiesPane = false;
            this.documentEditor.focusIn();
            return;
        }
        if (this.container.headerFooterProperties.element.style.display === 'block') {
            this.documentEditor.selection.closeHeaderFooter();
        }
        this.enableDisablePropertyPaneButton(false);
        this.container.showProperties('toc');
    }
    /**
     * @private
     */
    enableDisablePropertyPaneButton(isShow) {
        if (isShow) {
            classList(this.propertiesPaneButton.element.firstChild, ['e-pane-enabled'], ['e-pane-disabled']);
        }
        else {
            classList(this.propertiesPaneButton.element.firstChild, ['e-pane-disabled'], ['e-pane-enabled']);
        }
    }
    /**
     * @private
     */
    destroy() {
        if (this.restrictDropDwn) {
            this.restrictDropDwn.destroy();
            this.restrictDropDwn = undefined;
        }
        if (this.imgDropDwn) {
            this.imgDropDwn.destroy();
            this.imgDropDwn = undefined;
        }
        if (this.breakDropDwn) {
            this.breakDropDwn.destroy();
            this.breakDropDwn = undefined;
        }
        if (this.toolbar) {
            let toolbarElement = this.toolbar.element;
            this.toolbar.destroy();
            this.toolbar = undefined;
            toolbarElement.parentElement.removeChild(toolbarElement);
        }
        this.container = undefined;
    }
}

/**
 * Export toolbar module
 */

/**
 * Text Properties
 * @private
 */
class Text {
    constructor(container, isRtl) {
        this.isRetrieving = false;
        this.appliedHighlightColor = 'rgb(255, 255, 0)';
        this.createHighlightColorSplitButton = (id, width, divElement, toolTipText) => {
            let buttonElement = createElement('button', { id: id, attrs: { type: 'button' } });
            // buttonElement.style.width = width + 'px';
            // buttonElement.style.padding = '1px';
            // buttonElement.style.height = 30 + 'px';
            divElement.appendChild(buttonElement);
            let hgltSplitObj = new SplitButton({
                cssClass: 'e-de-btn-hghlclr',
                iconCss: 'e-de-ctnr-hglt-color',
                target: this.highlightColorElement, close: this.closePopup, beforeOpen: this.openPopup, enableRtl: this.isRtl
            });
            hgltSplitObj.appendTo(buttonElement);
            hgltSplitObj.click = () => {
                this.applyHighlightColor(this.highlightColorInputElement.style.backgroundColor);
            };
            hgltSplitObj.element.firstChild.style.backgroundColor = 'rgb(255, 255, 0)';
            hgltSplitObj.element.parentElement.setAttribute('title', toolTipText);
            return hgltSplitObj;
        };
        this.openPopup = () => {
            this.highlightColorElement.style.display = 'block';
        };
        this.closePopup = () => {
            this.highlightColorElement.style.display = 'none';
        };
        /* tslint:disable:no-any */
        this.onHighLightColor = (event) => {
            if (this.documentEditor.selection) {
                this.applyHighlightColor(event.currentTarget.style.backgroundColor);
                this.highlightColor.toggle();
            }
        };
        this.applyHighlightColorAsBackground = (color) => {
            this.removeSelectedColorDiv();
            if (color === 'NoColor') {
                this.highlightColorElement.querySelector('#noColorDiv').classList.add('e-color-selected');
            }
            else if (color === 'Yellow') {
                this.highlightColorElement.querySelector('#yellowDiv').classList.add('e-color-selected');
            }
            else if (color === 'BrightGreen') {
                this.highlightColorElement.querySelector('#brightGreenDiv').classList.add('e-color-selected');
            }
            else if (color === 'Turquoise') {
                this.highlightColorElement.querySelector('#turquoiseDiv').classList.add('e-color-selected');
            }
            else if (color === 'Pink') {
                this.highlightColorElement.querySelector('#hotPinkDiv').classList.add('e-color-selected');
            }
            else if (color === 'Red') {
                this.highlightColorElement.querySelector('#redDiv').classList.add('e-color-selected');
            }
            else if (color === 'DarkBlue') {
                this.highlightColorElement.querySelector('#darkBlueDiv').classList.add('e-color-selected');
            }
            else if (color === 'Teal') {
                this.highlightColorElement.querySelector('#tealDiv').classList.add('e-color-selected');
            }
            else if (color === 'Green') {
                this.highlightColorElement.querySelector('#greenDiv').classList.add('e-color-selected');
            }
            else if (color === 'Violet') {
                this.highlightColorElement.querySelector('#violetDiv').classList.add('e-color-selected');
            }
            else if (color === 'DarkRed') {
                this.highlightColorElement.querySelector('#darkRedDiv').classList.add('e-color-selected');
            }
            else if (color === 'DarkYellow') {
                this.highlightColorElement.querySelector('#darkYellowDiv').classList.add('e-color-selected');
            }
            else if (color === 'Gray50') {
                this.highlightColorElement.querySelector('#gray50Div').classList.add('e-color-selected');
            }
            else if (color === 'Gray25') {
                this.highlightColorElement.querySelector('#gray25Div').classList.add('e-color-selected');
            }
            else if (color === 'Black') {
                this.highlightColorElement.querySelector('#blackDiv').classList.add('e-color-selected');
            }
            else if (color === 'Blue') {
                this.highlightColorElement.querySelector('#blueDiv').classList.add('e-color-selected');
            }
        };
        this.removeSelectedColorDiv = () => {
            this.highlightColorElement.querySelector('#noColorDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#yellowDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#brightGreenDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#turquoiseDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#hotPinkDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#redDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#darkBlueDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#tealDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#greenDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#violetDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#darkRedDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#darkYellowDiv').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#gray50Div').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#gray25Div').classList.remove('e-color-selected');
            this.highlightColorElement.querySelector('#blackDiv').classList.remove('e-color-selected');
        };
        this.applyHighlightColor = (color) => {
            this.appliedHighlightColor = color;
            let hgltColor = this.getHighLightColor(color);
            this.documentEditor.selection.characterFormat.highlightColor = hgltColor;
        };
        this.getHighLightColor = (color) => {
            switch (color) {
                case 'rgb(255, 255, 0)':
                    return 'Yellow';
                case 'rgb(0, 255, 0)':
                    return 'BrightGreen';
                case 'rgb(0, 255, 255)':
                    return 'Turquoise';
                case 'rgb(255, 0, 255)':
                    return 'Pink';
                case 'rgb(0, 0, 255)':
                    return 'Blue';
                case 'rgb(255, 0, 0)':
                    return 'Red';
                case 'rgb(0, 0, 128)':
                    return 'DarkBlue';
                case 'rgb(0, 128, 128)':
                    return 'Teal';
                case 'rgb(0, 128, 0)':
                    return 'Green';
                case 'rgb(128, 0, 128)':
                    return 'Violet';
                case 'rgb(128, 0, 0)':
                    return 'DarkRed';
                case 'rgb(128, 128, 0)':
                    return 'DarkYellow';
                case 'rgb(128, 128, 128)':
                    return 'Gray50';
                case 'rgb(192, 192, 192)':
                    return 'Gray25';
                case 'rgb(0, 0, 0)':
                    return 'Black';
                default:
                    return 'NoColor';
            }
        };
        this.createFontColorPicker = (id, width, divElement, toolTipText) => {
            let inputElement = createElement('input', { id: id, attrs: { 'type': 'color' } });
            inputElement.style.width = width + 'px';
            divElement.appendChild(inputElement);
            // tslint:disable-next-line:max-line-length
            this.fontColorInputElement = new ColorPicker({ value: '#000000', showButtons: true, enableRtl: this.isRtl, locale: this.container.locale }, inputElement);
            this.fontColorInputElement.element.parentElement.setAttribute('title', toolTipText);
            return inputElement;
        };
        this.boldAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleBold();
            }
        };
        this.italicAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleItalic();
            }
        };
        this.underlineAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleUnderline('Single');
            }
        };
        this.strikethroughAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleStrikethrough();
            }
        };
        this.clearFormatAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.clearFormatting();
            }
        };
        this.subscriptAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleSubscript();
            }
        };
        this.superscriptAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleSuperscript();
            }
        };
        this.changeFontColor = (arg) => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.selection) {
                this.documentEditor.selection.characterFormat.fontColor = arg.currentValue.hex;
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.changeFontFamily = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.selection && this.fontFamily.value !== '') {
                setTimeout(() => { this.documentEditor.selection.characterFormat.fontFamily = this.fontFamily.value; }, 10);
            }
        };
        this.changeFontSize = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.selection && this.fontSize.value !== '') {
                setTimeout(() => { this.documentEditor.selection.characterFormat.fontSize = this.fontSize.value; }, 10);
            }
        };
        this.container = container;
        this.isRtl = isRtl;
    }
    get documentEditor() {
        return this.container.documentEditor;
    }
    initializeTextPropertiesDiv(wholeDiv, isRtl) {
        this.localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
        this.textProperties = wholeDiv;
        let element = 'font_properties';
        let textDiv = this.createDiv(element + '_text', wholeDiv);
        classList(textDiv, ['e-de-cntr-pane-padding', 'e-de-prop-separator-line'], []);
        let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
        label.innerHTML = this.localObj.getConstant('Text');
        textDiv.appendChild(label);
        let fontDiv = this.createDiv(element + '_sizeStyle', textDiv, 'display:inline-flex;');
        classList(fontDiv, ['e-de-ctnr-segment'], []);
        if (isRtl) {
            classList(fontDiv, ['e-de-ctnr-segment-rtl'], []);
        }
        let fontFamilyDiv = this.createDiv(element + '_fontFamilyDiv', fontDiv);
        let fontFamily = createElement('input', {
            id: element + '_fontFamily',
            className: 'e-prop-font-style'
        });
        fontFamilyDiv.appendChild(fontFamily);
        classList(fontFamilyDiv, ['e-de-panel-left-width'], []);
        this.createDropDownListForFamily(fontFamily);
        let fontSizeDiv = this.createDiv(element + '_fontSizeDiv', fontDiv);
        let divClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-left e-btn-group';
        if (isRtl) {
            divClassName = 'e-rtl ' + divClassName;
        }
        let fontSize = createElement('input', {
            id: element + '_fontSize',
            innerHTML: 'type:number',
            className: 'e-prop-font-style',
        });
        fontSizeDiv.appendChild(fontSize);
        classList(fontSizeDiv, ['e-de-panel-right-width'], []);
        this.createDropDownListForSize(fontSize);
        let propertiesDiv = createElement('div', {
            id: element + '_properties',
            styles: 'display:inline-flex;',
            className: 'e-de-ctnr-segment'
        });
        if (isRtl) {
            classList(propertiesDiv, ['e-de-ctnr-segment-rtl'], []);
        }
        textDiv.appendChild(propertiesDiv);
        let leftDiv = createElement('div', {
            id: element + '_leftDiv',
            className: divClassName, styles: 'display:inline-flex;'
        });
        propertiesDiv.appendChild(leftDiv);
        // tslint:disable-next-line:max-line-length
        this.bold = this.createButtonTemplate(element + '_bold', 'e-de-ctnr-bold e-icons', leftDiv, 'e-de-prop-font-button', '40.5', this.localObj.getConstant('Bold (Ctrl+B)'));
        // tslint:disable-next-line:max-line-length
        this.italic = this.createButtonTemplate(element + '_italic', 'e-de-ctnr-italic e-icons', leftDiv, 'e-de-prop-font-button', '40.5', this.localObj.getConstant('Italic (Ctrl+I)'));
        // tslint:disable-next-line:max-line-length
        this.underline = this.createButtonTemplate(element + '_underline', 'e-de-ctnr-underline e-icons', leftDiv, 'e-de-prop-font-button', '40.5', this.localObj.getConstant('Underline (Ctrl+U)'));
        // tslint:disable-next-line:max-line-length
        this.strikethrough = this.createButtonTemplate(element + '_strikethrough', 'e-de-ctnr-strikethrough e-icons', leftDiv, 'e-de-prop-font-last-button', '40.5', this.localObj.getConstant('Strikethrough'));
        divClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-right e-btn-group';
        if (isRtl) {
            divClassName = 'e-rtl ' + divClassName;
        }
        // tslint:disable-next-line:max-line-length
        let rightDiv = createElement('div', { id: element + '_rightDiv', className: divClassName, styles: 'display:inline-flex;' });
        propertiesDiv.appendChild(rightDiv);
        // tslint:disable-next-line:max-line-length
        this.superscript = this.createButtonTemplate(element + '_superscript', 'e-de-ctnr-superscript e-icons', rightDiv, 'e-de-prop-font-button', '38.5', this.localObj.getConstant('Superscript (Ctrl+Shift++)'));
        // tslint:disable-next-line:max-line-length
        this.subscript = this.createButtonTemplate(element + '_subscript', 'e-de-ctnr-subscript e-icons', rightDiv, 'e-de-prop-font-last-button', '38.5', this.localObj.getConstant('Subscript (Ctrl+=)'));
        // tslint:disable-next-line:max-line-length
        let leftDiv2 = createElement('div', { id: element + '_color', className: 'e-de-font-clr-picker e-de-ctnr-group-btn', styles: 'display:inline-flex;' });
        if (isRtl) {
            classList(leftDiv2, ['e-rtl'], []);
        }
        textDiv.appendChild(leftDiv2);
        // tslint:disable-next-line:max-line-length
        this.fontColor = this.createFontColorPicker(element + '_textColor', 40.5, leftDiv2, this.localObj.getConstant('Font color'));
        classList(leftDiv2.firstElementChild.lastElementChild.lastElementChild.firstChild, ['e-de-ctnr-fontcolor', 'e-icons'], ['e-caret']);
        this.initializeHighlightColorElement();
        // tslint:disable-next-line:max-line-length
        this.highlightColor = this.createHighlightColorSplitButton(element + '_highlightColor', 34.5, leftDiv2, this.localObj.getConstant('Text highlight color'));
        classList(this.highlightColor.element.nextElementSibling.firstElementChild, ['e-de-ctnr-highlight', 'e-icons'], ['e-caret']);
        this.highlightColorInputElement = this.highlightColor.element.firstChild;
        // tslint:disable-next-line:max-line-length
        this.clearFormat = this.createButtonTemplate(element + '_clearFormat', 'e-de-ctnr-clearall e-icons', leftDiv2, 'e-de-prop-font-last-button', '40.5', this.localObj.getConstant('Clear all formatting'));
    }
    initializeHighlightColorElement() {
        this.highlightColorElement = createElement('div', {
            id: 'highlight_color_ppty',
            styles: 'display:none;width:157px',
            className: 'e-de-cntr-highlight-pane'
        });
        let yellowDiv = this.createHightlighColorPickerDiv('#ffff00', 'yellowDiv');
        let brightGreenDiv = this.createHightlighColorPickerDiv('#00ff00', 'brightGreenDiv');
        let turquoiseDiv = this.createHightlighColorPickerDiv('#00ffff', 'turquoiseDiv');
        let hotPinkDiv = this.createHightlighColorPickerDiv('#ff00ff', 'hotPinkDiv');
        let blueDiv = this.createHightlighColorPickerDiv('#0000ff', 'blueDiv');
        let redDiv = this.createHightlighColorPickerDiv('#ff0000', 'redDiv');
        let darkBlueDiv = this.createHightlighColorPickerDiv('#000080', 'darkBlueDiv');
        let tealDiv = this.createHightlighColorPickerDiv('#008080', 'tealDiv');
        let greenDiv = this.createHightlighColorPickerDiv('#008000', 'greenDiv');
        let violetDiv = this.createHightlighColorPickerDiv('#800080', 'violetDiv');
        let darkRedDiv = this.createHightlighColorPickerDiv('#800000', 'darkRedDiv');
        let darkYellowDiv = this.createHightlighColorPickerDiv('#808000', 'darkYellowDiv');
        let gray50Div = this.createHightlighColorPickerDiv('#808080', 'gray50Div');
        let gray25Div = this.createHightlighColorPickerDiv('#c0c0c0', 'gray25Div');
        let blackDiv = this.createHightlighColorPickerDiv('#000000', 'blackDiv');
        let nocolor = createElement('div', { className: 'e-hglt-no-color' });
        this.highlightColorElement.appendChild(nocolor);
        // tslint:disable-next-line:max-line-length
        let nocolorDiv = createElement('div', { styles: 'width:24px;height:24px;background-color:#ffffff;margin:3px;', id: 'noColorDiv' });
        nocolor.appendChild(nocolorDiv);
        let nocolorDivValue = createElement('div', { innerHTML: 'No color', className: 'e-de-ctnr-hglt-no-color' });
        nocolorDiv.appendChild(nocolorDivValue);
        yellowDiv.addEventListener('click', this.onHighLightColor);
        brightGreenDiv.addEventListener('click', this.onHighLightColor);
        turquoiseDiv.addEventListener('click', this.onHighLightColor);
        hotPinkDiv.addEventListener('click', this.onHighLightColor);
        blueDiv.addEventListener('click', this.onHighLightColor);
        redDiv.addEventListener('click', this.onHighLightColor);
        darkBlueDiv.addEventListener('click', this.onHighLightColor);
        tealDiv.addEventListener('click', this.onHighLightColor);
        greenDiv.addEventListener('click', this.onHighLightColor);
        violetDiv.addEventListener('click', this.onHighLightColor);
        darkRedDiv.addEventListener('click', this.onHighLightColor);
        darkYellowDiv.addEventListener('click', this.onHighLightColor);
        gray50Div.addEventListener('click', this.onHighLightColor);
        gray25Div.addEventListener('click', this.onHighLightColor);
        blackDiv.addEventListener('click', this.onHighLightColor);
        nocolor.addEventListener('click', this.onHighLightColor);
    }
    createHightlighColorPickerDiv(backgroundColor, id) {
        let colorDiv = createElement('div', { className: 'e-de-ctnr-hglt-btn', id: id });
        colorDiv.style.backgroundColor = backgroundColor;
        this.highlightColorElement.appendChild(colorDiv);
        return colorDiv;
    }
    createDiv(id, parentDiv, style) {
        let div;
        if (style) {
            div = createElement('div', { id: id, styles: style });
        }
        else {
            div = createElement('div', { id: id });
        }
        parentDiv.appendChild(div);
        return div;
    }
    // tslint:disable-next-line:max-line-length
    createButtonTemplate(id, iconcss, div, buttonClass, width, toolTipText) {
        let button = createElement('Button', { id: id, attrs: { type: 'button' } });
        // button.style.width = width + 'px';
        // buttonElement.style.height = 32 + 'px';
        div.appendChild(button);
        let btn = new Button({
            cssClass: buttonClass, iconCss: iconcss, enableRtl: this.isRtl
        });
        btn.appendTo(button);
        button.setAttribute('title', toolTipText);
        return button;
    }
    /**
     * Adds file colot elements to parent div.
     */
    createColorTypeInput(elemId) {
        let colorType = createElement('input', {
            id: elemId,
            attrs: { 'type': 'color' }, styles: 'position:fixed; left:-100em'
        });
        this.documentEditor.getDocumentEditorElement().parentElement.appendChild(colorType);
        return colorType;
    }
    createDropDownListForSize(fontSelectElement) {
        let fontSize = ['8', '9', '10', '11', '12', '14', '16', '18', '20', '22', '24', '26', '28', '36', '48', '72', '96'];
        this.fontSize = new ComboBox({
            dataSource: fontSize, popupHeight: '180px',
            cssClass: 'e-de-prop-dropdown',
            allowCustom: true,
            showClearButton: false,
            enableRtl: this.isRtl
        });
        this.fontSize.focus = () => { this.isRetrieving = false; this.fontSize.element.select(); };
        this.fontSize.value = this.documentEditor.selection.characterFormat.fontSize.toString();
        this.fontSize.appendTo(fontSelectElement);
        this.fontSize.element.parentElement.setAttribute('title', this.localObj.getConstant('Font Size'));
    }
    createDropDownListForFamily(fontSelectElement) {
        let fontStyle = [{ FontName: 'Algerian' }, { FontName: 'Arial' },
            { FontName: 'Calibri' }, { FontName: 'Cambria' }, { FontName: 'Cambria Math' }, { FontName: 'Candara' },
            { FontName: 'Courier New' }, { FontName: 'Georgia' }, { FontName: 'Impact' }, { FontName: 'Segoe Print' },
            { FontName: 'Segoe Script' }, { FontName: 'Segoe UI' }, { FontName: 'Symbol' },
            { FontName: 'Times New Roman' }, { FontName: 'Verdana' }, { FontName: 'Windings' }
        ];
        this.fontFamily = new ComboBox({
            dataSource: fontStyle,
            query: new Query().select(['FontName']),
            fields: { text: 'FontName', value: 'FontName' },
            popupHeight: '150px',
            cssClass: 'e-de-prop-dropdown',
            allowCustom: true,
            showClearButton: false,
            enableRtl: this.isRtl
        });
        if (!this.container.enableCsp) {
            this.fontFamily.itemTemplate = '<span style="font-family: ${FontName};">${FontName}</span>';
            this.fontFamily.isStringTemplate = true;
        }
        this.fontFamily.focus = () => { this.isRetrieving = false; this.fontFamily.element.select(); };
        this.fontFamily.appendTo(fontSelectElement);
        this.fontFamily.element.parentElement.setAttribute('title', this.localObj.getConstant('Font'));
    }
    wireEvent() {
        this.fontFamily.addEventListener('change', () => { this.changeFontFamily(); });
        this.fontSize.addEventListener('change', () => { this.changeFontSize(); });
        this.bold.addEventListener('click', () => { this.isRetrieving = false; this.boldAction(); });
        this.italic.addEventListener('click', () => { this.isRetrieving = false; this.italicAction(); });
        this.underline.addEventListener('click', () => { this.isRetrieving = false; this.underlineAction(); });
        this.strikethrough.addEventListener('click', () => { this.isRetrieving = false; this.strikethroughAction(); });
        this.superscript.addEventListener('click', () => { this.isRetrieving = false; this.superscriptAction(); });
        this.subscript.addEventListener('click', () => { this.isRetrieving = false; this.subscriptAction(); });
        /* tslint:disable-next-line:max-line-length */
        this.fontColorInputElement.addEventListener('change', (args) => { this.isRetrieving = false; this.changeFontColor(args); });
        this.clearFormat.addEventListener('click', () => { this.isRetrieving = false; this.clearFormatAction(); });
    }
    unwireEvents() {
        this.fontFamily.change = undefined;
        this.fontSize.change = undefined;
        this.bold.click = undefined;
        this.italic.click = undefined;
        this.underline.click = undefined;
        this.strikethrough.click = undefined;
        this.superscript.click = undefined;
        this.subscript.click = undefined;
        this.fontColorInputElement.change = undefined;
        this.highlightColorElement.click = undefined;
        this.highlightColor.click = undefined;
        this.clearFormat.click = undefined;
    }
    onSelectionChange() {
        this.isRetrieving = true;
        if (this.documentEditor.selection) {
            //#region character format
            if (this.documentEditor.selection.characterFormat.fontFamily) {
                this.fontFamily.value = this.documentEditor.selection.characterFormat.fontFamily;
                this.fontFamily.dataBind();
            }
            else {
                this.fontFamily.value = '';
            }
            if (this.documentEditor.selection.characterFormat.fontSize) {
                this.fontSize.value = this.documentEditor.selection.characterFormat.fontSize.toString();
                this.fontSize.dataBind();
            }
            else {
                this.fontSize.value = '';
            }
            if (this.documentEditor.selection.characterFormat.bold) {
                if (!this.bold.classList.contains('e-btn-toggle')) {
                    this.bold.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.bold.classList.contains('e-btn-toggle')) {
                    this.bold.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.italic) {
                if (!this.italic.classList.contains('e-btn-toggle')) {
                    this.italic.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.italic.classList.contains('e-btn-toggle')) {
                    this.italic.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.underline
                && this.documentEditor.selection.characterFormat.underline !== 'None') {
                if (!this.underline.classList.contains('e-btn-toggle')) {
                    this.underline.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.underline.classList.contains('e-btn-toggle')) {
                    this.underline.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.strikethrough
                && this.documentEditor.selection.characterFormat.strikethrough !== 'None') {
                if (!this.strikethrough.classList.contains('e-btn-toggle')) {
                    this.strikethrough.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.strikethrough.classList.contains('e-btn-toggle')) {
                    this.strikethrough.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.baselineAlignment
                && this.documentEditor.selection.characterFormat.baselineAlignment === 'Subscript') {
                if (!this.subscript.classList.contains('e-btn-toggle')) {
                    this.subscript.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.subscript.classList.contains('e-btn-toggle')) {
                    this.subscript.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.baselineAlignment
                && this.documentEditor.selection.characterFormat.baselineAlignment === 'Superscript') {
                if (!this.superscript.classList.contains('e-btn-toggle')) {
                    this.superscript.classList.add('e-btn-toggle');
                }
            }
            else {
                if (this.superscript.classList.contains('e-btn-toggle')) {
                    this.superscript.classList.remove('e-btn-toggle');
                }
            }
            if (this.documentEditor.selection.characterFormat.fontColor) {
                this.fontColorInputElement.value = this.documentEditor.selection.characterFormat.fontColor;
            }
            if (this.documentEditor.selection.characterFormat.highlightColor) {
                this.highlightColorInputElement.style.backgroundColor = this.appliedHighlightColor;
                this.applyHighlightColorAsBackground(this.documentEditor.selection.characterFormat.highlightColor);
            }
            //#endregion
        }
    }
    destroy() {
        this.container = undefined;
        if (this.highlightColor) {
            this.highlightColor.destroy();
            this.highlightColor = undefined;
        }
        if (this.fontColorInputElement) {
            this.fontColorInputElement.destroy();
            this.fontColorInputElement = undefined;
        }
        if (this.fontSize) {
            this.fontSize.destroy();
            this.fontSize = undefined;
        }
        if (this.fontFamily) {
            this.fontFamily.destroy();
            this.fontFamily = undefined;
        }
    }
}

/**
 * Paragraph Properties
 * @private
 */
class Paragraph {
    constructor(container) {
        this.isRetrieving = false;
        this.appliedBulletStyle = 'dot';
        this.appliedNumberingStyle = 'arabic';
        this.appliedLineSpacing = '';
        this.splitButtonClass = 'e-de-prop-splitbutton';
        this.updateSelectedBulletListType = (listText) => {
            switch (listText) {
                case '\uf0b7':
                    this.dotBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf06f' + '\u0020':
                    this.circleBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf0a7':
                    this.squareBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf076':
                    this.flowerBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf0d8':
                    this.arrowBullet.classList.add('de-list-item-selected');
                    break;
                case '\uf0fc':
                    this.tickBullet.classList.add('de-list-item-selected');
                    break;
                default:
                    this.noneBulletTag.classList.add('de-list-item-selected');
                    break;
            }
        };
        this.updateSelectedNumberedListType = (listText) => {
            switch (listText) {
                case '1.':
                    this.numberList.classList.add('de-list-item-selected');
                    break;
                case 'I.':
                    this.upRoman.classList.add('de-list-item-selected');
                    break;
                case 'A.':
                    this.upLetter.classList.add('de-list-item-selected');
                    break;
                case 'a.':
                    this.lowLetter.classList.add('de-list-item-selected');
                    break;
                case 'i.':
                    this.lowRoman.classList.add('de-list-item-selected');
                    break;
                default:
                    this.noneNumberTag.classList.add('de-list-item-selected');
                    break;
            }
        };
        this.removeSelectedList = () => {
            let className = 'de-list-item-selected';
            this.noneNumberTag.classList.remove(className);
            this.numberList.classList.remove(className);
            this.lowLetter.classList.remove(className);
            this.upLetter.classList.remove(className);
            this.lowRoman.classList.remove(className);
            this.upRoman.classList.remove(className);
            this.noneBulletTag.classList.remove(className);
            this.dotBullet.classList.remove(className);
            this.circleBullet.classList.remove(className);
            this.squareBullet.classList.remove(className);
            this.flowerBullet.classList.remove(className);
            this.arrowBullet.classList.remove(className);
            this.tickBullet.classList.remove(className);
        };
        this.applyLastAppliedNumbering = () => {
            switch (this.appliedNumberingStyle) {
                case 'arabic':
                    this.numberedNumberDotClick();
                    break;
                case 'lowletter':
                    this.numberedLowLetterClick();
                    break;
                case 'upletter':
                    this.numberedUpLetterClick();
                    break;
                case 'lowroman':
                    this.numberedLowRomanClick();
                    break;
                case 'uproman':
                    this.numberedUpRomanClick();
                    break;
            }
        };
        this.applyLastAppliedBullet = () => {
            switch (this.appliedBulletStyle) {
                case 'dot':
                    this.bulletDotClick();
                    break;
                case 'circle':
                    this.bulletCircleClick();
                    break;
                case 'square':
                    this.bulletSquareClick();
                    break;
                case 'arrow':
                    this.bulletArrowClick();
                    break;
                case 'tick':
                    this.bulletTickClick();
                    break;
                case 'flower':
                    this.bulletFlowerClick();
                    break;
            }
        };
        /* tslint:disable:no-any */
        this.updateOptions = (args) => {
            this.updateStyleNames();
            args.popup.element.getElementsByClassName('e-de-ctnr-dropdown-ftr')[0].addEventListener('click', this.createStyle);
        };
        this.createStyle = () => {
            this.style.hidePopup();
            if (!this.documentEditor.isReadOnly) {
                this.documentEditor.showDialog('Styles');
            }
        };
        this.leftAlignmentAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleTextAlignment('Left');
            }
        };
        this.lineSpacingAction = (args) => {
            if (this.isRetrieving) {
                return;
            }
            let text = args.item.text;
            switch (text) {
                case this.localObj.getConstant('Single'):
                    this.documentEditor.selection.paragraphFormat.lineSpacing = 1;
                    break;
                case '1.15':
                    this.documentEditor.selection.paragraphFormat.lineSpacing = 1.15;
                    break;
                case '1.5':
                    this.documentEditor.selection.paragraphFormat.lineSpacing = 1.5;
                    break;
                case this.localObj.getConstant('Double'):
                    this.documentEditor.selection.paragraphFormat.lineSpacing = 2;
                    break;
            }
            setTimeout(() => { this.documentEditor.focusIn(); }, 30);
        };
        this.selectStyleValue = (args) => {
            if (this.isRetrieving || !args.isInteracted) {
                return;
            }
            setTimeout(() => { this.applyStyleValue(args); }, 10);
        };
        /* tslint:enable:no-any */
        this.rightAlignmentAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleTextAlignment('Right');
            }
        };
        this.centerAlignmentAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleTextAlignment('Center');
            }
        };
        this.justifyAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.toggleTextAlignment('Justify');
            }
        };
        this.increaseIndentAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.increaseIndent();
            }
        };
        this.decreaseIndentAction = () => {
            if (this.isRetrieving) {
                return;
            }
            if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
                this.documentEditor.editor.decreaseIndent();
            }
        };
        this.numberedNoneClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.documentEditor.editor.clearList();
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedNumberDotClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedNumberingStyle = 'arabic';
                this.documentEditor.editor.applyNumbering('%1.', 'Arabic');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedUpRomanClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedNumberingStyle = 'uproman';
                this.documentEditor.editor.applyNumbering('%1.', 'UpRoman');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedUpLetterClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedNumberingStyle = 'upletter';
                this.documentEditor.editor.applyNumbering('%1.', 'UpLetter');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedLowLetterClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedNumberingStyle = 'lowletter';
                this.documentEditor.editor.applyNumbering('%1.', 'LowLetter');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.numberedLowRomanClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedNumberingStyle = 'lowroman';
                this.documentEditor.editor.applyNumbering('%1.', 'LowRoman');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletDotClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedBulletStyle = 'dot';
                this.documentEditor.editor.applyBullet('\uf0b7', 'Symbol');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletCircleClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedBulletStyle = 'circle';
                this.documentEditor.editor.applyBullet('\uf06f' + '\u0020', 'Symbol');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletSquareClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedBulletStyle = 'square';
                this.documentEditor.editor.applyBullet('\uf0a7', 'Wingdings');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletFlowerClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedBulletStyle = 'flower';
                this.documentEditor.editor.applyBullet('\uf076', 'Wingdings');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletArrowClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedBulletStyle = 'arrow';
                this.documentEditor.editor.applyBullet('\uf0d8', 'Wingdings');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.bulletTickClick = () => {
            if (this.isRetrieving) {
                return;
            }
            if (this.documentEditor.editor) {
                this.appliedBulletStyle = 'tick';
                this.documentEditor.editor.applyBullet('\uf0fc', 'Wingdings');
                setTimeout(() => { this.documentEditor.focusIn(); }, 30);
            }
        };
        this.container = container;
    }
    get documentEditor() {
        return this.container.documentEditor;
    }
    initializeParagraphPropertiesDiv(wholeDiv, isRtl) {
        this.localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
        this.isRtl = isRtl;
        if (this.isRtl) {
            this.splitButtonClass = 'e-rtl ' + this.splitButtonClass;
        }
        this.textProperties = wholeDiv;
        let element = 'font_properties';
        let paragraphDiv = this.createDivElement(element + '_paragraph', wholeDiv, '');
        classList(paragraphDiv, ['e-de-cntr-pane-padding'], []);
        let label = createElement('label', { styles: 'width:26px;', className: 'e-de-ctnr-prop-label' });
        label.innerHTML = this.localObj.getConstant('Paragraph');
        paragraphDiv.appendChild(label);
        let styleDiv = this.createDivElement(element + '_styleDiv', paragraphDiv);
        styleDiv.classList.add('e-de-ctnr-segment', 'e-de-ctnr-style-div');
        // tslint:disable-next-line:max-line-length
        let styleSelect = createElement('input', { id: element + '_style', styles: 'width:248px;font-size: 12px;letter-spacing: 0.05px;' });
        styleDiv.appendChild(styleSelect);
        this.createStyleDropDownList(styleSelect);
        let indentWholeDiv = this.createDivElement(element + '_indentWholeDiv', paragraphDiv);
        indentWholeDiv.style.display = 'flex';
        indentWholeDiv.classList.add('e-de-ctnr-segment');
        if (isRtl) {
            classList(indentWholeDiv, ['e-de-ctnr-segment-rtl'], []);
        }
        // tslint:disable-next-line:max-line-length
        let indentDiv = this.createDivElement(element + '_indentDiv', indentWholeDiv, 'display:flex;');
        let indentClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-left e-btn-group';
        if (isRtl) {
            indentClassName = 'e-rtl ' + indentClassName;
        }
        indentDiv.className = indentClassName;
        // tslint:disable-next-line:max-line-length
        this.leftAlignment = this.createButtonTemplate(element + '_leftIndent', 'e-de-ctnr-alignleft e-icons', indentDiv, 'e-de-prop-indent-button', '40.5', this.localObj.getConstant('Align left (Ctrl+L)'));
        // tslint:disable-next-line:max-line-length
        this.centerAlignment = this.createButtonTemplate(element + '_centerIndent', 'e-de-ctnr-aligncenter e-icons', indentDiv, 'e-de-prop-indent-button', '40.5', this.localObj.getConstant('Center (Ctrl+E)'));
        // tslint:disable-next-line:max-line-length
        this.rightAlignment = this.createButtonTemplate(element + '_rightIndent', 'e-de-ctnr-alignright e-icons', indentDiv, 'e-de-prop-indent-button', '40.5', this.localObj.getConstant('Align right (Ctrl+R)'));
        // tslint:disable-next-line:max-line-length
        this.justify = this.createButtonTemplate(element + '_justify', 'e-de-ctnr-justify e-icons', indentDiv, 'e-de-prop-indent-last-button', '40.5', this.localObj.getConstant('Justify (Ctrl+J)'));
        let increaseIndentIconCss = 'e-de-ctnr-increaseindent e-icons';
        let decreaseIndentIconCss = 'e-de-ctnr-decreaseindent e-icons';
        let incDecIndentDiv = this.createDivElement(element + '_indentDiv', indentWholeDiv, 'display:flex;');
        indentClassName = 'e-de-ctnr-group-btn e-de-char-fmt-btn-right e-btn-group';
        if (isRtl) {
            indentClassName = 'e-rtl ' + indentClassName;
            increaseIndentIconCss += ' e-de-flip';
            decreaseIndentIconCss += ' e-de-flip';
        }
        incDecIndentDiv.className = indentClassName;
        // tslint:disable-next-line:max-line-length
        this.decreaseIndent = this.createButtonTemplate(element + '_decreaseIndent', decreaseIndentIconCss, incDecIndentDiv, 'e-de-prop-indent-button', '37', this.localObj.getConstant('Decrease indent'));
        // tslint:disable-next-line:max-line-length
        this.increaseIndent = this.createButtonTemplate(element + '_increaseIndent', increaseIndentIconCss, incDecIndentDiv, 'e-de-prop-indent-last-button', '37', this.localObj.getConstant('Increase indent'));
        let listDiv = this.createDivElement(element + '_listDiv', paragraphDiv, 'display:flex;');
        classList(listDiv, ['e-de-ctnr-segment', 'e-de-ctnr-group-btn'], []);
        if (isRtl) {
            classList(listDiv, ['e-de-ctnr-segment-rtl', 'e-de-ctnr-group-btn'], []);
        }
        let lineHeight = createElement('button', { id: element + '_lineHeight', attrs: { type: 'button' } });
        listDiv.appendChild(lineHeight);
        this.lineSpacing = this.createLineSpacingDropdown(lineHeight);
        let listDropDown = this.createDivElement(element + '_listDropDiv', listDiv);
        listDropDown.className = 'de-split-button';
        let bulletButton = createElement('button', { id: element + '_bullet', attrs: { type: 'button' } });
        listDropDown.appendChild(bulletButton);
        let numberingList = createElement('button', { id: element + '_numberingList', attrs: { type: 'button' } });
        listDropDown.appendChild(numberingList);
        let bulletIconCss = 'e-de-ctnr-bullets e-icons';
        let numberIconCss = 'e-de-ctnr-numbering e-icons';
        if (isRtl) {
            bulletIconCss += ' e-de-flip';
            numberIconCss += ' e-de-flip';
        }
        this.createBulletListDropButton(bulletIconCss, bulletButton);
        this.createNumberListDropButton(numberIconCss, numberingList);
    }
    createSeperator(parentDiv) {
        let seperator = createElement('div', { className: 'e-de-prop-vline' });
        parentDiv.appendChild(seperator);
    }
    createDivElement(id, parentDiv, style) {
        let element;
        if (style) {
            element = createElement('div', { id: id, styles: style });
        }
        else {
            element = createElement('div', { id: id });
        }
        parentDiv.appendChild(element);
        return element;
    }
    // tslint:disable-next-line:max-line-length
    createButtonTemplate(id, iconcss, div, buttonClass, width, toolTipText) {
        let buttonElement = createElement('Button', { id: id, attrs: { type: 'button' } });
        // buttonElement.style.width = width + 'px';
        // buttonElement.style.height = 32 + 'px';
        div.appendChild(buttonElement);
        let btn = new Button({
            cssClass: buttonClass, iconCss: iconcss
        });
        btn.appendTo(buttonElement);
        buttonElement.setAttribute('title', toolTipText);
        return buttonElement;
    }
    createLineSpacingDropdown(button) {
        let items = [{
                text: this.localObj.getConstant('Single')
            }, {
                text: '1.15'
            }, {
                text: '1.5'
            }, {
                text: this.localObj.getConstant('Double')
            }];
        let dropdown = new DropDownButton({
            items: items,
            iconCss: 'e-de-ctnr-linespacing e-icons',
            enableRtl: this.isRtl,
            select: this.lineSpacingAction,
            cssClass: this.splitButtonClass,
            beforeItemRender: (args) => {
                args.element.innerHTML = '<span></span>' + args.item.text;
                let span = args.element.children[0];
                if (args.item.text === this.appliedLineSpacing) {
                    span.style.marginRight = '10px';
                    span.setAttribute('class', 'e-de-selected-item e-icons');
                }
                else {
                    args.element.children[0].style.marginRight = '25px';
                    args.element.children[0].classList.remove('e-de-selected-item');
                }
            }
        });
        dropdown.appendTo(button);
        button.setAttribute('title', this.localObj.getConstant('Line spacing'));
        return dropdown;
    }
    createNumberListDropButton(iconcss, button) {
        // tslint:disable-next-line:max-line-length
        let div = createElement('div', { id: 'target', styles: 'width: 211px;height: auto;display:none' });
        let ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;',
            id: 'listMenu',
            className: 'e-de-floating-menu e-de-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        div.appendChild(ulTag);
        this.noneNumberTag = this.createNumberNoneListTag(ulTag);
        this.noneNumberTag.addEventListener('click', this.numberedNoneClick);
        this.numberList = this.createNumberListTag(ulTag, '1.', '2.', '3.');
        this.numberList.addEventListener('click', this.numberedNumberDotClick);
        this.lowLetter = this.createNumberListTag(ulTag, 'a.', 'b.', 'c.');
        this.lowLetter.addEventListener('click', this.numberedLowLetterClick);
        this.upLetter = this.createNumberListTag(ulTag, 'A.', 'B.', 'C.');
        this.upLetter.addEventListener('click', this.numberedUpLetterClick);
        this.lowRoman = this.createNumberListTag(ulTag, 'i.', 'ii.', 'iii.');
        this.lowRoman.addEventListener('click', this.numberedLowRomanClick);
        this.upRoman = this.createNumberListTag(ulTag, 'I.', 'II.', 'III.');
        this.upRoman.addEventListener('click', this.numberedUpRomanClick);
        let menuOptions = {
            target: div,
            iconCss: iconcss,
            cssClass: this.splitButtonClass,
            beforeOpen: () => {
                div.style.display = 'block';
                this.updateSelectedNumberedListType(this.documentEditor.selection.paragraphFormat.listText);
            },
            beforeClose: () => {
                div.style.display = 'none';
                this.removeSelectedList();
            }
        };
        this.numberedListBtn = new SplitButton(menuOptions);
        this.numberedListBtn.click = () => {
            this.applyLastAppliedNumbering();
        };
        this.numberedListBtn.appendTo(button);
        button.parentElement.setAttribute('title', this.localObj.getConstant('Numbering'));
    }
    createBulletListDropButton(iconcss, button) {
        // tslint:disable-next-line:max-line-length
        let div = createElement('div', { id: 'bullet_list', styles: 'width: 196px;height: auto;display:none' });
        let ulTag = createElement('ul', {
            styles: 'display: block; outline: 0px;', id: 'listMenu',
            className: 'e-de-floating-menu e-de-bullets-menu e-de-list-container e-de-list-thumbnail'
        });
        div.appendChild(ulTag);
        this.noneBulletTag = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-none e-icons e-de-ctnr-list');
        this.noneBulletTag.addEventListener('click', this.numberedNoneClick);
        this.dotBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-dot e-icons e-de-ctnr-list');
        this.dotBullet.addEventListener('click', this.bulletDotClick);
        this.circleBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-circle e-icons e-de-ctnr-list');
        this.circleBullet.addEventListener('click', this.bulletCircleClick);
        this.squareBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-square e-icons e-de-ctnr-list');
        this.squareBullet.addEventListener('click', this.bulletSquareClick);
        this.flowerBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-flower e-icons e-de-ctnr-list');
        this.flowerBullet.addEventListener('click', this.bulletFlowerClick);
        this.arrowBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-arrow e-icons e-de-ctnr-list');
        this.arrowBullet.addEventListener('click', this.bulletArrowClick);
        this.tickBullet = this.createBulletListTag(ulTag, 'e-de-ctnr-bullet-tick e-icons e-de-ctnr-list');
        this.tickBullet.addEventListener('click', this.bulletTickClick);
        let menuOptions = {
            target: div,
            iconCss: iconcss,
            cssClass: this.splitButtonClass,
            beforeOpen: () => {
                div.style.display = 'block';
                this.updateSelectedBulletListType(this.documentEditor.selection.paragraphFormat.listText);
            },
            beforeClose: () => {
                div.style.display = 'none';
                this.removeSelectedList();
            }
        };
        this.bulletListBtn = new SplitButton(menuOptions);
        this.bulletListBtn.click = () => {
            this.applyLastAppliedBullet();
        };
        this.bulletListBtn.appendTo(button);
        button.parentElement.setAttribute('title', this.localObj.getConstant('Bullets'));
    }
    createNumberListTag(ulTag, text1, text2, text3) {
        let liTag = createElement('li', {
            styles: 'display:block',
            className: 'e-de-floating-menuitem e-de-floating-menuitem-md e-de-list-items  e-de-list-item-size'
        });
        ulTag.appendChild(liTag);
        // tslint:disable-next-line:max-line-length
        let innerHTML = '<div>' + text1 + '<span class="e-de-list-line"></span></div><div>' + text2 + '<span class="e-de-list-line">';
        innerHTML += '</span></div><div>' + text3 + '<span class="e-de-list-line"> </span></div >';
        let liInnerDiv = createElement('div', {
            className: 'e-de-list-header-presetmenu',
            id: 'ui-zlist0', innerHTML: innerHTML
        });
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createNumberNoneListTag(ulTag) {
        let liTag = createElement('li', {
            styles: 'display:block;',
            className: 'e-de-floating-menuitem e-de-floating-menuitem-md e-de-list-items  e-de-list-item-size'
        });
        ulTag.appendChild(liTag);
        let innerHTML = '<div><span class="e-de-bullets">None</span></div>';
        let liInnerDiv = createElement('div', {
            className: 'e-de-list-header-presetmenu', styles: 'position:relative;left:11px;top:13px',
            id: 'ui-zlist0', innerHTML: innerHTML
        });
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createBulletListTag(ulTag, iconCss) {
        let liTag = createElement('li', {
            styles: 'display:block;',
            className: 'e-de-floating-menuitem e-de-floating-bullet-menuitem-md e-de-list-items  e-de-list-item-size'
        });
        ulTag.appendChild(liTag);
        let liInnerDiv = createElement('div', { className: 'e-de-bullet-list-header-presetmenu', id: 'ui-zlist0' });
        let spanDiv = createElement('div');
        liInnerDiv.appendChild(spanDiv);
        let span = createElement('span', { className: iconCss });
        spanDiv.appendChild(span);
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    createStyleDropDownList(selectElement) {
        this.style = new DropDownList({
            dataSource: [{ StyleName: 'Normal', Class: 'e-icons e-edit-font' }],
            cssClass: 'e-de-prop-dropdown',
            popupHeight: '240px',
            enableRtl: this.isRtl,
            query: new Query().select(['StyleName', 'Style']),
            fields: { text: 'StyleName', value: 'StyleName' },
            change: this.selectStyleValue
        });
        if (!this.container.enableCsp) {
            this.style.open = this.updateOptions;
            this.style.itemTemplate = '<span style="${Style}">${StyleName}</span>';
            this.style.footerTemplate = '<span class="e-de-ctnr-dropdown-ftr">' + this.localObj.getConstant('Manage Styles') + '</span>';
            this.style.isStringTemplate = true;
        }
        this.style.appendTo(selectElement);
        selectElement.parentElement.setAttribute('title', this.localObj.getConstant('Styles'));
    }
    updateStyleNames() {
        this.styleName = !isNullOrUndefined(this.style.itemData) ? this.style.itemData.StyleName : undefined;
        this.style.dataSource = this.constructStyleDropItems(this.documentEditor.getStyles('Paragraph'));
        this.style.dataBind();
        this.onSelectionChange();
    }
    constructStyleDropItems(styles) {
        let collection = [];
        for (let styleObj of styles) {
            let obj = {};
            obj.StyleName = styleObj.name;
            obj.Style = this.parseStyle(styleObj.style);
            collection.push(obj);
        }
        return collection;
    }
    parseStyle(style) {
        let domStyle = '';
        let styleObj = JSON.parse(style);
        let textDecoration = '';
        if (!isNullOrUndefined(styleObj.characterFormat.baselineAlignment) && styleObj.characterFormat.baselineAlignment !== 'Normal') {
            let vAlign = '';
            switch (styleObj.characterFormat.baselineAlignment) {
                case 'Superscript':
                    vAlign = 'super';
                    break;
                case 'Subscript':
                    vAlign = 'sub';
                    break;
            }
            if (vAlign.length > 1) {
                domStyle += 'vertical-align:' + vAlign + ';';
            }
        }
        if (!isNullOrUndefined(styleObj.characterFormat.underline) && styleObj.characterFormat.underline !== 'None') {
            textDecoration += 'underline ';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.strikethrough) && styleObj.characterFormat.strikethrough !== 'None') {
            textDecoration += 'line-through ';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.fontSize)) {
            domStyle += 'font-size:' + styleObj.characterFormat.fontSize + 'px;';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.fontFamily)) {
            domStyle += 'font-family:' + styleObj.characterFormat.fontFamily + ';';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.bold) && styleObj.characterFormat.bold) {
            domStyle += 'font-weight:bold;';
        }
        if (!isNullOrUndefined(styleObj.characterFormat.italic) && styleObj.characterFormat.italic) {
            domStyle += 'font-style:italic;';
        }
        // if (!isNullOrUndefined(styleObj.characterFormat.fontColor)) {
        //     domStyle += 'color: ' + styleObj.characterFormat.fontColor + ';';
        // }
        if (textDecoration.length > 1) {
            domStyle += 'text-decoration:' + textDecoration + ';';
        }
        return domStyle;
    }
    wireEvent() {
        this.leftAlignment.addEventListener('click', () => { this.leftAlignmentAction(); });
        this.rightAlignment.addEventListener('click', () => { this.rightAlignmentAction(); });
        this.centerAlignment.addEventListener('click', () => { this.centerAlignmentAction(); });
        this.justify.addEventListener('click', () => { this.justifyAction(); });
        this.increaseIndent.addEventListener('click', () => { this.increaseIndentAction(); });
        this.decreaseIndent.addEventListener('click', () => { this.decreaseIndentAction(); });
        /* tslint:disable-next-line:max-line-length */
        this.lineSpacing.addEventListener('select', (args) => { this.lineSpacingAction(args); });
    }
    unwireEvents() {
        this.leftAlignment.click = undefined;
        this.rightAlignment.click = undefined;
        this.centerAlignment.click = undefined;
        this.justify.click = undefined;
        this.increaseIndent.click = undefined;
        this.decreaseIndent.click = undefined;
        this.lineSpacing.select = undefined;
        this.style.select = undefined;
    }
    setLineSpacing() {
        let lineSpacing = this.documentEditor.selection.paragraphFormat.lineSpacing;
        if (lineSpacing === 1) {
            this.appliedLineSpacing = this.localObj.getConstant('Single');
        }
        else if (lineSpacing === 1.15) {
            this.appliedLineSpacing = '1.15';
        }
        else if (lineSpacing === 1.5) {
            this.appliedLineSpacing = '1.5';
        }
        else if (lineSpacing === 2) {
            this.appliedLineSpacing = this.localObj.getConstant('Double');
        }
        else {
            this.appliedLineSpacing = '';
        }
    }
    applyStyleValue(args) {
        if (!this.documentEditor.isReadOnly && this.documentEditor.editor) {
            this.documentEditor.editor.applyStyle(args.itemData.StyleName);
        }
    }
    onSelectionChange() {
        this.isRetrieving = true;
        if (this.documentEditor.editor) {
            //#region paragraph format
            let style = this.documentEditor.selection.paragraphFormat.styleName;
            if (style) {
                this.style.value = style;
                this.style.dataBind();
            }
            else {
                this.style.value = '';
            }
            classList(this.leftAlignment, [], ['e-btn-toggle']);
            classList(this.rightAlignment, [], ['e-btn-toggle']);
            classList(this.centerAlignment, [], ['e-btn-toggle']);
            classList(this.justify, [], ['e-btn-toggle']);
            if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Left') {
                classList(this.leftAlignment, ['e-btn-toggle'], []);
            }
            else if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Right') {
                classList(this.rightAlignment, ['e-btn-toggle'], []);
            }
            else if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Center') {
                classList(this.centerAlignment, ['e-btn-toggle'], []);
            }
            else if (this.documentEditor.selection.paragraphFormat.textAlignment === 'Justify') {
                classList(this.justify, ['e-btn-toggle'], []);
            }
            //#endregion
        }
        this.setLineSpacing();
        this.isRetrieving = false;
    }
    destroy() {
        this.container = undefined;
        if (this.lineSpacing) {
            this.lineSpacing.destroy();
            this.lineSpacing = undefined;
        }
        if (this.style) {
            this.style.destroy();
            this.style = undefined;
        }
        if (this.bulletListBtn) {
            this.bulletListBtn.destroy();
            this.bulletListBtn = undefined;
        }
        if (this.numberedListBtn) {
            this.numberedListBtn.destroy();
            this.numberedListBtn = undefined;
        }
    }
}

/**
 * Text Properties pane
 * @private
 */
class TextProperties {
    constructor(container, id, isTableProperties, isRtl) {
        this.isInitial = true;
        this.showTextProperties = (isShow) => {
            if (isShow) {
                this.onSelectionChange();
            }
            if (!isShow && this.element.style.display === 'none' || (isShow && this.element.style.display === 'block')) {
                return;
            }
            this.element.style.display = isShow ? 'block' : 'none';
            this.documentEditor.resize();
        };
        this.generateUniqueID = () => {
            return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
        };
        this.container = container;
        this.text = new Text(container, isRtl);
        this.paragraph = new Paragraph(container);
        this.initializeTextProperties(id, isTableProperties, isRtl);
        this.wireEvents();
    }
    get documentEditor() {
        return this.container.documentEditor;
    }
    enableDisableElements(enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    }
    updateStyles() {
        this.paragraph.updateStyleNames();
    }
    get appliedHighlightColor() {
        return this.text.appliedHighlightColor;
    }
    set appliedHighlightColor(value) {
        this.text.appliedHighlightColor = value;
    }
    get appliedBulletStyle() {
        return this.paragraph.appliedBulletStyle;
    }
    set appliedBulletStyle(value) {
        this.paragraph.appliedBulletStyle = value;
    }
    get appliedNumberingStyle() {
        return this.paragraph.appliedNumberingStyle;
    }
    set appliedNumberingStyle(value) {
        this.paragraph.appliedNumberingStyle = value;
    }
    initializeTextProperties(id, isTableProperties, isRtl) {
        /* tslint:disable-next-line:max-line-length */
        this.element = createElement('div', { id: id + 'id_' + this.generateUniqueID(), className: 'e-de-prop-pane' });
        this.text.initializeTextPropertiesDiv(this.element, isRtl);
        this.paragraph.initializeParagraphPropertiesDiv(this.element, isRtl);
        this.paragraph.updateStyleNames();
        if (!isTableProperties) {
            this.container.propertiesPaneContainer.appendChild(this.element);
        }
    }
    wireEvents() {
        this.text.wireEvent();
        this.paragraph.wireEvent();
    }
    onSelectionChange() {
        this.text.onSelectionChange();
        this.paragraph.onSelectionChange();
    }
    destroy() {
        if (this.text) {
            this.text.destroy();
            this.text = undefined;
        }
        if (this.paragraph) {
            this.paragraph.destroy();
            this.paragraph = undefined;
        }
    }
}

/**
 * Represents document editor header and footer.
 */
/**
 * @private
 */
class HeaderFooterProperties {
    constructor(container, isRtl) {
        this.isHeaderTopApply = false;
        this.isFooterTopApply = false;
        this.wireEvents = () => {
            this.headerFromTop.element.addEventListener('click', () => { this.isHeaderTopApply = true; });
            this.footerFromTop.element.addEventListener('click', () => { this.isFooterTopApply = true; });
            this.headerFromTop.element.addEventListener('keydown', this.onHeaderValue);
            this.footerFromTop.element.addEventListener('keydown', this.onFooterValue);
            this.headerFromTop.element.addEventListener('blur', () => { this.changeHeaderValue(); this.isHeaderTopApply = false; });
            this.footerFromTop.element.addEventListener('blur', () => { this.changeFooterValue(); this.isFooterTopApply = false; });
        };
        this.onClose = () => {
            this.documentEditor.selection.closeHeaderFooter();
        };
        this.changeFirstPageOptions = () => {
            if (!this.documentEditor.isReadOnly) {
                this.documentEditor.selection.sectionFormat.differentFirstPage = this.firstPage.checked;
                setTimeout(() => { this.documentEditor.focusIn(); }, 10);
            }
        };
        this.changeoddOrEvenOptions = () => {
            if (!this.documentEditor.isReadOnly) {
                this.documentEditor.selection.sectionFormat.differentOddAndEvenPages = this.oddOrEven.checked;
                setTimeout(() => { this.documentEditor.focusIn(); }, 10);
            }
        };
        this.changeHeaderValue = () => {
            if (!this.isHeaderTopApply) {
                return;
            }
            if (!this.documentEditor.isReadOnly) {
                let headerTop = this.headerFromTop.value;
                if (headerTop > this.headerFromTop.max) {
                    headerTop = this.headerFromTop.max;
                }
                this.documentEditor.selection.sectionFormat.headerDistance = headerTop;
            }
        };
        this.onHeaderValue = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.changeHeaderValue(); this.isHeaderTopApply = false; }, 30);
            }
        };
        this.onFooterValue = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.changeFooterValue(); this.isFooterTopApply = false; }, 30);
            }
        };
        this.changeFooterValue = () => {
            if (!this.isFooterTopApply) {
                return;
            }
            if (!this.documentEditor.isReadOnly) {
                let footerTop = this.footerFromTop.value;
                if (footerTop > this.footerFromTop.max) {
                    footerTop = this.footerFromTop.max;
                }
                this.documentEditor.selection.sectionFormat.footerDistance = footerTop;
            }
        };
        this.container = container;
        this.isRtl = isRtl;
        this.initHeaderFooterPane();
        this.wireEvents();
    }
    /**
     * @private
     */
    get documentEditor() {
        return this.container.documentEditor;
    }
    get toolbar() {
        return this.container.toolbarModule;
    }
    /**
     * @private
     */
    enableDisableElements(enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    }
    initHeaderFooterPane() {
        this.initializeHeaderFooter();
        this.element.style.display = 'none';
        this.container.propertiesPaneContainer.appendChild(this.element);
    }
    showHeaderFooterPane(isShow) {
        if (isShow) {
            if (this.toolbar) {
                this.toolbar.enableDisablePropertyPaneButton(false);
            }
            this.onSelectionChange();
        }
        if (!isShow && this.element.style.display === 'none' || (isShow && this.element.style.display === 'block')) {
            return;
        }
        this.element.style.display = isShow ? 'block' : 'none';
        this.documentEditor.resize();
    }
    // tslint:disable-next-line:max-func-body-length
    initializeHeaderFooter() {
        let localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
        let elementId = 'header_footer_properties';
        // tslint:disable-next-line:max-line-length
        this.element = createElement('div', { id: this.documentEditor.element.id + elementId, className: 'e-de-prop-pane' });
        let headerDiv = this.createDivTemplate('_header_footer', this.element, 'padding-bottom:0');
        classList(headerDiv, ['e-de-cntr-pane-padding'], []);
        let headerLabel = createElement('label', { className: 'e-de-prop-header-label' });
        headerLabel.innerHTML = localObj.getConstant('Header & Footer');
        let closeButtonFloat;
        if (!this.isRtl) {
            closeButtonFloat = 'float:right;';
            
        }
        else {
            closeButtonFloat = 'float:left;';
            
        }
        let closeIcon = createElement('span', {
            id: '_header_footer_close',
            className: 'e-de-ctnr-close e-icons',
            styles: 'display:inline-block;cursor:pointer;color: #4A4A4A;' + closeButtonFloat
        });
        closeIcon.addEventListener('click', () => { this.onClose(); });
        headerDiv.appendChild(headerLabel);
        headerDiv.appendChild(closeIcon);
        let optionsLabelDiv = this.createDivTemplate(elementId + '_options', this.element);
        classList(optionsLabelDiv, ['e-de-cntr-pane-padding', 'e-de-prop-separator-line'], []);
        let optionsLabel = createElement('label', { className: 'e-de-ctnr-prop-label', styles: 'height:20px;' });
        optionsLabel.innerHTML = localObj.getConstant('Options');
        optionsLabelDiv.appendChild(optionsLabel);
        let optionsDiv = this.createDivTemplate(elementId + '_optionsDiv', optionsLabelDiv);
        let firstPageDiv = this.createDivTemplate(elementId + '_firstPageDiv', optionsDiv, 'margin-bottom:10px;');
        let firstPage = createElement('input', { id: 'firstPage', className: 'e-de-prop-sub-label' });
        firstPageDiv.appendChild(firstPage);
        // tslint:disable-next-line:max-line-length
        this.firstPage = new CheckBox({ label: localObj.getConstant('Different First Page'), change: this.changeFirstPageOptions, cssClass: 'e-de-prop-sub-label', enableRtl: this.isRtl });
        this.firstPage.appendTo(firstPage);
        // tslint:disable-next-line:max-line-length
        firstPageDiv.children[0].setAttribute('title', localObj.getConstant('Different header and footer for first page.'));
        let oddOrEvenDiv = this.createDivTemplate(elementId + '_oddOrEvenDiv', optionsDiv);
        let oddOrEven = createElement('input', { id: 'oddOrEven', className: 'e-de-sub-prop-label' });
        oddOrEvenDiv.appendChild(oddOrEven);
        // tslint:disable-next-line:max-line-length
        this.oddOrEven = new CheckBox({ label: localObj.getConstant('Different Odd & Even Pages'), change: this.changeoddOrEvenOptions, cssClass: 'e-de-prop-sub-label', enableRtl: this.isRtl });
        this.oddOrEven.appendTo(oddOrEven);
        // tslint:disable-next-line:max-line-length
        oddOrEvenDiv.children[0].setAttribute('title', localObj.getConstant('Different header and footer for odd and even pages.'));
        // tslint:disable-next-line:max-line-length
        // let autoFieldLabelDiv: HTMLElement = this.createDivTemplate(element + '_autoFieldLabelDiv', div, 'padding-top:10px;padding-left: 10px;');
        // let autoFieldLabel: HTMLElement = createElement('label', { className: 'e-de-header-prop-label', styles: 'height:20px;' });
        // autoFieldLabel.innerHTML = 'Insert Autofield';
        // autoFieldLabelDiv.appendChild(autoFieldLabel);
        // let autofieldDiv: HTMLElement = this.createDivTemplate(element + '_autofieldDiv', autoFieldLabelDiv, 'display:inline-flex;');
        // let pageNumberDiv: HTMLElement = this.createDivTemplate(element + '_pageNumberDiv', autofieldDiv, 'margin-right:8px;');
        // let pageNumber: HTMLInputElement = createElement('input', { id: 'pageNumber' }) as HTMLInputElement;
        // pageNumberDiv.appendChild(pageNumber);
        // this.pageNumber = new CheckBox({ label: 'Page Number', change: this.changePageNumber });
        // this.pageNumber.appendTo(pageNumber);
        // let pageCountDiv: HTMLElement = this.createDivTemplate(element + '_pageCountDiv', autofieldDiv);
        // let pageCount: HTMLInputElement = createElement('input', { id: 'pageCount' }) as HTMLInputElement;
        // pageCountDiv.appendChild(pageCount);
        // this.pageCount = new CheckBox({ label: 'Page Count', change: this.changePageCount });
        // this.pageCount.appendTo(pageCount);
        // let autoFieldLine: HTMLElement = createElement('div', { className: 'e-de-prop-separator-line', styles: 'margin-top:7px;' });
        // autoFieldLabelDiv.appendChild(autoFieldLine);
        // tslint:disable-next-line:max-line-length
        let positionLabelDiv = this.createDivTemplate(elementId + '_positionLabelDiv', this.element);
        classList(positionLabelDiv, ['e-de-cntr-pane-padding', 'e-de-prop-separator-line'], []);
        let positionLabel = createElement('label', { className: 'e-de-ctnr-prop-label', styles: 'height:20px;' });
        positionLabel.innerHTML = localObj.getConstant('Position');
        positionLabelDiv.appendChild(positionLabel);
        let positionDiv = this.createDivTemplate(elementId + '_positionDiv', positionLabelDiv);
        if (!this.isRtl) {
            
        }
        else {
            
        }
        // tslint:disable-next-line:max-line-length
        let headerTopDiv = this.createDivTemplate(elementId + '_headerTopDiv', positionDiv, 'margin-bottom:14px;');
        // tslint:disable-next-line:max-line-length
        let headerTopLabel = createElement('label', { className: 'e-de-prop-sub-label', styles: 'display:block' });
        headerTopLabel.innerHTML = localObj.getConstant('Header from Top');
        headerTopDiv.appendChild(headerTopLabel);
        // tslint:disable-next-line:max-line-length
        let headerFromTop = createElement('input', { id: 'headerFromTop', className: 'e-de-prop-sub-label' });
        headerTopDiv.appendChild(headerFromTop);
        // tslint:disable-next-line:max-line-length
        this.headerFromTop = new NumericTextBox({
            value: 36, cssClass: 'e-de-prop-header-numeric',
            showSpinButton: false, format: 'n0', decimals: 2, max: 1584, min: 0, enableRtl: this.isRtl
        });
        this.headerFromTop.appendTo(headerFromTop);
        // tslint:disable-next-line:max-line-length
        this.headerFromTop.element.parentElement.setAttribute('title', localObj.getConstant('Distance from top of the page to top of the header.'));
        // tslint:disable-next-line:max-line-length
        let footerBottomDiv = this.createDivTemplate(elementId + '_footerBottomDiv', positionDiv);
        // tslint:disable-next-line:max-line-length
        let footerBottomLabel = createElement('label', { className: 'e-de-prop-sub-label', styles: 'display:block' });
        footerBottomLabel.innerHTML = localObj.getConstant('Footer from Bottom');
        footerBottomDiv.appendChild(footerBottomLabel);
        // tslint:disable-next-line:max-line-length
        let footerFromTop = createElement('input', { id: 'footerFromTop', className: 'e-de-prop-sub-label' });
        footerBottomDiv.appendChild(footerFromTop);
        // tslint:disable-next-line:max-line-length
        this.footerFromTop = new NumericTextBox({
            value: 36, cssClass: 'e-de-prop-header-numeric',
            showSpinButton: false, format: 'n0', decimals: 2, max: 1584, min: 0, enableRtl: this.isRtl
        });
        this.footerFromTop.appendTo(footerFromTop);
        // tslint:disable-next-line:max-line-length
        this.footerFromTop.element.parentElement.setAttribute('title', localObj.getConstant('Distance from bottom of the page to bottom of the footer.'));
    }
    createDivTemplate(id, parentDiv, style) {
        let divElement;
        if (style) {
            divElement = createElement('div', { id: id, styles: style });
        }
        else {
            divElement = createElement('div', { id: id });
        }
        parentDiv.appendChild(divElement);
        return divElement;
    }
    onSelectionChange() {
        this.headerFromTop.value = this.documentEditor.selection.sectionFormat.headerDistance;
        this.footerFromTop.value = this.documentEditor.selection.sectionFormat.footerDistance;
        if (this.documentEditor.selection.sectionFormat.differentFirstPage) {
            this.firstPage.checked = true;
        }
        else {
            this.firstPage.checked = false;
        }
        if (this.documentEditor.selection.sectionFormat.differentOddAndEvenPages) {
            this.oddOrEven.checked = true;
        }
        else {
            this.oddOrEven.checked = false;
        }
    }
    destroy() {
        if (this.headerFromTop) {
            this.headerFromTop.destroy();
            this.headerFromTop = undefined;
        }
        if (this.footerFromTop) {
            this.footerFromTop.destroy();
            this.footerFromTop = undefined;
        }
    }
}

/**
 * Image Property pane
 * @private
 */
class ImageProperties {
    constructor(container, isRtl) {
        this.isWidthApply = false;
        this.isHeightApply = false;
        this.initializeImageProperties = () => {
            // tslint:disable-next-line:max-line-length
            this.element = createElement('div', { id: this.elementId + '_imageProperties', className: 'e-de-prop-pane' });
            this.element.style.display = 'none';
            this.container.propertiesPaneContainer.appendChild(this.element);
            this.initImageProp();
            this.wireEvents();
        };
        this.initImageProp = () => {
            let localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
            // tslint:disable-next-line:max-line-length
            let imageDiv = createElement('div', { id: this.elementId + '_imageDiv', className: 'e-de-cntr-pane-padding', styles: 'border:0px' });
            this.element.appendChild(imageDiv);
            let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.textContent = localObj.getConstant('Image');
            imageDiv.appendChild(label);
            let outerDiv = createElement('div');
            imageDiv.appendChild(outerDiv);
            // tslint:disable-next-line:max-line-length
            this.widthElement = this.createImagePropertiesDiv('_widthDiv', outerDiv, '_widthInput', localObj.getConstant('W'), localObj.getConstant('Width'));
            // tslint:disable-next-line:max-line-length
            this.widthNumericBox = new NumericTextBox({ min: 0, max: 23500, cssClass: 'e-de-image-property', showSpinButton: false, format: 'n0', decimals: 2 });
            this.widthNumericBox.appendTo(this.widthElement);
            // tslint:disable-next-line:max-line-length
            this.heightElement = this.createImagePropertiesDiv('_heightDiv', outerDiv, '_heightInput', localObj.getConstant('H'), localObj.getConstant('Height'));
            // tslint:disable-next-line:max-line-length
            this.heightNumericBox = new NumericTextBox({ min: 0, max: 23500, cssClass: 'e-de-image-property', showSpinButton: false, format: 'n0', decimals: 2 });
            this.heightNumericBox.appendTo(this.heightElement);
            // tslint:disable-next-line:max-line-length        
            let aspectRatioDiv = createElement('div', { id: this.elementId + '_aspectRatioDiv' });
            aspectRatioDiv.setAttribute('title', localObj.getConstant('Aspect ratio'));
            outerDiv.appendChild(aspectRatioDiv);
            // tslint:disable-next-line:max-line-length
            let aspectRatio = createElement('input', { id: this.elementId + '_aspectRatio', className: 'e-de-ctnr-prop-label' });
            aspectRatioDiv.appendChild(aspectRatio);
            this.aspectRatioBtn = new CheckBox({ label: localObj.getConstant('Aspect ratio'), enableRtl: this.isRtl }, aspectRatio);
        };
        // tslint:disable-next-line:max-line-length
        this.createImagePropertiesDiv = (id, outerDiv, inputId, spanContent, tooltip) => {
            // tslint:disable-next-line:max-line-length
            let divElement = createElement('div', { id: this.elementId + id, styles: 'position: relative;width: 100%;', className: 'e-de-ctnr-segment' });
            divElement.setAttribute('title', tooltip);
            outerDiv.appendChild(divElement);
            // tslint:disable-next-line:max-line-length
            let inputElement = createElement('input', { id: this.elementId + inputId, className: 'e-textbox', styles: 'width:100%;' });
            divElement.appendChild(inputElement);
            let spanElement = createElement('span', { className: 'e-de-img-prty-span' });
            spanElement.textContent = spanContent;
            divElement.appendChild(spanElement);
            return inputElement;
        };
        this.wireEvents = () => {
            this.aspectRatioBtn.element.addEventListener('change', this.onAspectRatioBtnClick);
            this.widthNumericBox.element.addEventListener('click', () => { this.isWidthApply = true; });
            this.heightNumericBox.element.addEventListener('click', () => { this.isHeightApply = true; });
            this.widthNumericBox.element.addEventListener('keydown', this.onImageWidth);
            this.heightNumericBox.element.addEventListener('keydown', this.onImageHeight);
            this.widthNumericBox.element.addEventListener('blur', () => { this.applyImageWidth(); this.isWidthApply = false; });
            this.heightNumericBox.element.addEventListener('blur', () => { this.applyImageHeight(); this.isHeightApply = false; });
        };
        this.onImageWidth = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.applyImageWidth(); this.isWidthApply = false; }, 30);
            }
        };
        this.onImageHeight = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.applyImageHeight(); this.isHeightApply = false; }, 30);
            }
        };
        this.applyImageWidth = () => {
            if (!this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                let width = this.widthNumericBox.value;
                let height = this.heightNumericBox.value;
                if (width > this.widthNumericBox.max) {
                    width = this.widthNumericBox.max;
                }
                if (height > this.heightNumericBox.max) {
                    height = this.heightNumericBox.max;
                }
                if (!(width === null || height === null)) {
                    this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
            else if (this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                let width = this.widthNumericBox.value;
                if (width > this.widthNumericBox.max) {
                    width = this.widthNumericBox.max;
                }
                let ratio = width / this.documentEditor.selection.imageFormat.width;
                let height = this.heightNumericBox.value * ratio;
                this.heightNumericBox.value = height;
                if (!(width === null || height === null)) {
                    this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
        };
        this.applyImageHeight = () => {
            if (!this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                let width = this.widthNumericBox.value;
                let height = this.heightNumericBox.value;
                if (!(width === null || height === null)) {
                    this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
            else if (this.isMaintainAspectRatio) {
                // tslint:disable-next-line:max-line-length
                let height = this.heightNumericBox.value;
                let ratio = height / this.documentEditor.selection.imageFormat.height;
                let width = this.widthNumericBox.value * ratio;
                this.widthNumericBox.value = width;
                if (!(width === null || height === null)) {
                    this.documentEditor.selection.imageFormat.resize(width, height);
                }
            }
        };
        this.onAspectRatioBtnClick = () => {
            if (this.isMaintainAspectRatio) {
                this.isMaintainAspectRatio = false;
            }
            else {
                this.isMaintainAspectRatio = true;
            }
        };
        this.container = container;
        this.elementId = this.documentEditor.element.id;
        this.isMaintainAspectRatio = false;
        this.isRtl = isRtl;
        this.initializeImageProperties();
    }
    get documentEditor() {
        return this.container.documentEditor;
    }
    /**
     * @private
     */
    enableDisableElements(enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    }
    showImageProperties(isShow) {
        if (this.element.style.display === 'block') {
            this.updateImageProperties();
        }
        if (!isShow && this.element.style.display === 'none' || (isShow && this.element.style.display === 'block')) {
            return;
        }
        this.element.style.display = isShow ? 'block' : 'none';
        this.documentEditor.resize();
    }
    updateImageProperties() {
        this.widthNumericBox.value = this.documentEditor.selection.imageFormat.width;
        this.heightNumericBox.value = this.documentEditor.selection.imageFormat.height;
    }
    destroy() {
        this.container = undefined;
        if (this.widthNumericBox) {
            this.widthNumericBox.destroy();
            this.widthNumericBox = undefined;
        }
        if (this.heightNumericBox) {
            this.heightNumericBox.destroy();
            this.heightNumericBox = undefined;
        }
    }
}

/**
 * TOC Properties pane
 * @private
 */
class TocProperties {
    constructor(container, isRtl) {
        this.initializeTocPane = () => {
            this.localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
            // tslint:disable-next-line:max-line-length
            this.element = createElement('div', { id: this.elementId + '_tocProperties', className: 'e-de-prop-pane' });
            let container = createElement('div', { className: 'e-de-cntr-pane-padding e-de-prop-separator-line' });
            this.tocHeaderDiv(container);
            this.initTemplates(container);
            container = createElement('div', { className: 'e-de-cntr-pane-padding' });
            this.tocOptionsDiv(container);
            this.contentStylesDropdown(container);
            this.checkboxContent(container);
            this.buttonDiv(container);
            this.wireEvents();
            this.updateTocProperties();
            this.container.propertiesPaneContainer.appendChild(this.element);
        };
        this.updateTocProperties = () => {
            this.rightalignPageNumber.checked = true;
            this.showPageNumber.checked = true;
            this.hyperlink.checked = true;
        };
        this.wireEvents = () => {
            this.cancelBtn.element.addEventListener('click', () => { this.onClose(); });
            this.updateBtn.element.addEventListener('click', this.onInsertToc);
            this.closeButton.addEventListener('click', () => { this.onClose(); });
        };
        this.onClose = () => {
            if (this.container.showPropertiesPane
                && this.container.previousContext !== 'TableOfContents') {
                this.container.showPropertiesPaneOnSelection();
            }
            else {
                this.showTocPane(false);
                if (this.toolbar) {
                    this.toolbar.enableDisablePropertyPaneButton(false);
                }
                this.container.showPropertiesPane = false;
            }
        };
        this.tocHeaderDiv = (container) => {
            let closeButtonFloat;
            let closeButtonMargin;
            if (!this.isRtl) {
                closeButtonFloat = 'float:right;';
                closeButtonMargin = 'margin-right:7px;';
            }
            else {
                closeButtonFloat = 'float:left;';
                closeButtonMargin = 'margin-left:7px;';
            }
            let headerDiv = createElement('div', {
                id: this.elementId + 'toc_id',
                styles: 'display: block;'
            });
            container.appendChild(headerDiv);
            this.element.appendChild(container);
            let title = createElement('label', {
                className: 'e-de-ctnr-prop-label'
            });
            title.textContent = this.localObj.getConstant('Table of Contents');
            headerDiv.appendChild(title);
            this.closeButton = createElement('span', {
                className: 'e-de-ctnr-close e-icons',
                styles: 'cursor: pointer;display:inline-block;color: #4A4A4A;' + closeButtonFloat + closeButtonMargin
            });
            headerDiv.appendChild(this.closeButton);
        };
        this.initTemplates = (container) => {
            this.template1(container);
            // tslint:disable-next-line:max-line-length
            // let div: HTMLElement = createElement('div', { styles: 'display:block;border-top: 1px solid #E0E0E0;' }); this.element.appendChild(div);
        };
        this.template1 = (container) => {
            this.template1Div = createElement('div', {
                className: 'e-de-toc-template1'
            });
            if (this.isRtl) {
                this.template1Div.classList.add('e-de-rtl');
            }
            container.appendChild(this.template1Div);
            let templateContent1 = createElement('div', {
                className: 'e-de-toc-template1-content1'
            });
            templateContent1.textContent = this.localObj.getConstant('HEADING - - - - 1');
            this.template1Div.appendChild(templateContent1);
            let templateContent2 = createElement('div', {
                className: 'e-de-toc-template1-content2'
            });
            templateContent2.textContent = this.localObj.getConstant('HEADING - - - - 2');
            this.template1Div.appendChild(templateContent2);
            let templateContent3 = createElement('div', {
                className: 'e-de-toc-template1-content3'
            });
            templateContent3.textContent = this.localObj.getConstant('HEADING - - - - 3');
            this.template1Div.appendChild(templateContent3);
        };
        this.tocOptionsDiv = (container) => {
            let optionsDiv = createElement('div');
            container.appendChild(optionsDiv);
            this.element.appendChild(container);
            if (this.isRtl) {
                optionsDiv.classList.add('e-de-rtl');
            }
            let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.textContent = this.localObj.getConstant('Options');
            optionsDiv.appendChild(label);
        };
        /* tslint:disable */
        this.contentStylesDropdown = (container) => {
            if (!this.isRtl) {
                
            }
            else {
                
            }
            let contentStyleElement = createElement('div', { id: 'contentstyle_div' });
            // tslint:disable-next-line:max-line-length
            contentStyleElement.setAttribute('title', this.localObj.getConstant('Number of heading or outline levels to be shown in table of contents.'));
            container.appendChild(contentStyleElement);
            // let items: ItemModel[] = [{ text: '___________', id: 'solid' }];
            // this.borderStyle = this.createDropDownButton(
            //     this.elementId + '_borderStyleDiv',
            //     'width:120px;height:28px;margin-top:8px', contentStyleElement, 'e-de-icon-stroke-size', 'Solid', items
            // );
            if (!this.isRtl) {
                
            }
            else {
                
            }
            let label = createElement('label', { className: 'e-de-prop-sub-label', styles: 'display:block' });
            label.textContent = this.localObj.getConstant('Levels');
            contentStyleElement.appendChild(label);
            container.appendChild(contentStyleElement);
            let dataSource = ['1', '2', '3', '4', '5', '6', '7', '8', '9'];
            this.borderLevelStyle = this.createDropDownButton(this.elementId + '_borderLevelDiv', contentStyleElement, '', dataSource, 2);
            this.borderLevelStyle.change = (args) => {
                this.borderLevelStyle.value = args.item.value;
            };
            container.appendChild(contentStyleElement);
        };
        this.checkboxContent = (container) => {
            if (!this.isRtl) {
                
            }
            else {
                
            }
            // tslint:disable-next-line:max-line-length
            let checkboxElement = createElement('div', { id: 'toc_checkboxDiv', styles: 'margin-bottom:36px;' });
            container.appendChild(checkboxElement);
            let showPageNumberDiv = createElement('div', { className: 'e-de-toc-checkbox1' });
            showPageNumberDiv.setAttribute('title', this.localObj.getConstant('Show page numbers in table of contents.'));
            checkboxElement.appendChild(showPageNumberDiv);
            // tslint:disable-next-line:max-line-length
            let showpagenumberCheckboxElement = createElement('input', { id: 'showpagenumber', styles: 'width:12px;height:12px;margin-bottom:8px', className: 'e-de-prop-sub-label' });
            showPageNumberDiv.appendChild(showpagenumberCheckboxElement);
            this.showPageNumber = new CheckBox({
                label: this.localObj.getConstant('Show page numbers'),
                enableRtl: this.isRtl
            });
            this.showPageNumber.appendTo(showpagenumberCheckboxElement);
            let rightAlignDiv = createElement('div', { className: 'e-de-toc-checkbox2' });
            rightAlignDiv.setAttribute('title', this.localObj.getConstant('Right align page numbers in table of contents.'));
            checkboxElement.appendChild(rightAlignDiv);
            // tslint:disable-next-line:max-line-length
            let rightalignpagenumberCheckboxElement = createElement('input', { id: 'rightalignpagenumber', styles: 'width:12px;height:12px', className: 'e-de-prop-sub-label' });
            rightAlignDiv.appendChild(rightalignpagenumberCheckboxElement);
            this.rightalignPageNumber = new CheckBox({
                label: this.localObj.getConstant('Right align page numbers'),
                enableRtl: this.isRtl
            });
            this.rightalignPageNumber.appendTo(rightalignpagenumberCheckboxElement);
            let hyperlinkDiv = createElement('div', { className: 'e-de-toc-checkbox3' });
            hyperlinkDiv.setAttribute('title', this.localObj.getConstant('Use hyperlinks instead of page numbers.'));
            checkboxElement.appendChild(hyperlinkDiv);
            // tslint:disable-next-line:max-line-length
            let hyperlinkCheckboxElement = createElement('input', { id: 'hyperlinkdiv', styles: 'width:12px;height:12px', className: 'e-de-prop-sub-label' });
            hyperlinkDiv.appendChild(hyperlinkCheckboxElement);
            this.hyperlink = new CheckBox({
                label: this.localObj.getConstant('Use hyperlinks'),
                enableRtl: this.isRtl
            });
            this.hyperlink.appendTo(hyperlinkCheckboxElement);
        };
        this.buttonDiv = (container) => {
            let footerElementFloat;
            if (!this.isRtl) {
                footerElementFloat = 'float:right';
            }
            else {
                footerElementFloat = 'float:left';
            }
            let footerElement = createElement('div', { id: 'footerDiv', styles: footerElementFloat });
            container.appendChild(footerElement);
            let updatebuttoncontentStyleElement = createElement('button', {
                id: 'footerupdatebuttonDiv',
                attrs: { type: 'button' }
            });
            footerElement.appendChild(updatebuttoncontentStyleElement);
            this.updateBtn = new Button({
                content: this.localObj.getConstant('Update'), cssClass: 'btn-update', isPrimary: true
            });
            this.updateBtn.appendTo(updatebuttoncontentStyleElement);
            let cancelbuttoncontentStyleElement = createElement('button', {
                id: 'footercancelbuttonDiv',
                attrs: { type: 'button' }
            });
            footerElement.appendChild(cancelbuttoncontentStyleElement);
            this.cancelBtn = new Button({
                content: this.localObj.getConstant('Cancel'), cssClass: this.isRtl ? 'e-de-btn-cancel-rtl' : 'e-de-btn-cancel'
            });
            this.cancelBtn.appendTo(cancelbuttoncontentStyleElement);
        };
        this.showTocPane = (isShow, previousContextType) => {
            if (!isShow && this.element.style.display === 'none' || (isShow && this.element.style.display === 'block')) {
                return;
            }
            this.element.style.display = isShow ? 'block' : 'none';
            // tslint:disable-next-line:max-line-length
            this.updateBtn.content = this.documentEditor.selection.contextType === 'TableOfContents' ? this.localObj.getConstant('Update') : this.localObj.getConstant('Insert');
            this.prevContext = this.documentEditor.selection.contextType;
            this.documentEditor.resize();
            if (isShow) {
                this.updateBtn.element.focus();
            }
        };
        this.onInsertToc = () => {
            let tocSettings = {
                startLevel: 1,
                endLevel: parseInt(this.borderLevelStyle.value, 0),
                includeHyperlink: this.hyperlink.checked,
                includePageNumber: this.showPageNumber.checked,
                rightAlign: this.rightalignPageNumber.checked
            };
            if (tocSettings.rightAlign) {
                tocSettings.tabLeader = 'Dot';
            }
            this.documentEditor.editor.insertTableOfContents(tocSettings);
        };
        this.container = container;
        this.elementId = this.documentEditor.element.id;
        this.isRtl = isRtl;
        this.initializeTocPane();
    }
    /**
     * @private
     */
    get documentEditor() {
        return this.container.documentEditor;
    }
    /**
     * @private
     */
    get toolbar() {
        return this.container.toolbarModule;
    }
    /**
     * @private
     */
    enableDisableElements(enable) {
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    }
    /* tslint:disable */
    createDropdownOption(ulTag, text) {
        let liTag = createElement('li', {
            styles: 'display:block',
            className: 'e-de-floating-menuitem e-de-floating-menuitem-md de-list-items  de-list-item-size'
        });
        ulTag.appendChild(liTag);
        let innerHTML;
        if (text === 'None') {
            innerHTML = '<div>' + text + '</div>';
        }
        else if (text === '1.5px') {
            // tslint:disable-next-line:max-line-length
            innerHTML = '<div>' + text + '<span class="e-de-list-line" style="margin-left:10px;border-bottom-width:' + text + '"></span></div>';
        }
        else {
            // tslint:disable-next-line:max-line-length
            innerHTML = '<div>' + text + '<span class="e-de-list-line" style="margin-left:20px;border-bottom-width:' + text + '"></span></div>';
        }
        let liInnerDiv = createElement('div', {
            className: 'e-de-list-header-presetmenu',
            innerHTML: innerHTML
        });
        liTag.appendChild(liInnerDiv);
        return liTag;
    }
    // tslint:disable-next-line:max-line-length
    createDropDownButton(id, parentDiv, iconCss, content, selectedIndex) {
        let buttonElement = createElement('input', { id: id });
        parentDiv.appendChild(buttonElement);
        // tslint:disable-next-line:max-line-length  
        let dropDownBtn = new DropDownList({ index: selectedIndex, dataSource: content, popupHeight: '150px', cssClass: 'e-de-prop-font-button' }, buttonElement);
        return dropDownBtn;
    }
    destroy() {
        this.container = undefined;
        if (this.showPageNumber) {
            this.showPageNumber.destroy();
            this.showPageNumber = undefined;
        }
        if (this.rightalignPageNumber) {
            this.rightalignPageNumber.destroy();
            this.rightalignPageNumber = undefined;
        }
        if (this.borderBtn) {
            this.borderBtn.destroy();
            this.borderBtn = undefined;
        }
        if (this.borderLevelStyle) {
            this.borderLevelStyle.destroy();
            this.borderLevelStyle = undefined;
        }
    }
}

/**
 * Represents table properties
 * @private
 */
class TableProperties {
    constructor(container, imageProperty, textProperties, isRtl) {
        this.isTopMarginApply = false;
        this.isRightMarginApply = false;
        this.isBottomMarginApply = false;
        this.isLeftMarginApply = false;
        this.borderColor = '#000000';
        this.groupButtonClass = 'e-de-ctnr-group-btn e-btn-group';
        this.initializeTablePropPane = () => {
            this.localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
            this.tableProperties = createElement('div', { id: this.elementId + '_tableProperties' });
            this.initFillColorDiv();
            this.initBorderStylesDiv();
            this.initCellDiv();
            this.initInsertOrDelCell();
            this.initCellMargin();
            this.initAlignText();
            this.addTablePropertyTab();
            // wire fnt property
            this.wireEvent();
        };
        this.addTablePropertyTab = () => {
            let tableHeader = createElement('div', { innerHTML: this.localObj.getConstant('Table') });
            let textHeader = createElement('div', { innerHTML: this.localObj.getConstant('Text') });
            // tslint:disable-next-line:max-line-length
            this.parentElement = createElement('div', { styles: 'height:100%;overflow:auto;display:none', className: 'e-de-prop-pane' });
            this.element = createElement('div', { id: this.elementId + '_propertyTabDiv', className: 'e-de-property-tab' });
            // tslint:disable-next-line:max-line-length
            let items = [{ header: { text: tableHeader }, content: this.tableProperties }, { header: { text: textHeader }, content: this.tableTextProperties.element }];
            this.propertiesTab = new Tab({ items: items, animation: { previous: { effect: 'None' }, next: { effect: 'None' } }, selected: this.onTabSelection });
            this.propertiesTab.isStringTemplate = true;
            this.propertiesTab.appendTo(this.element);
            this.parentElement.appendChild(this.element);
            this.container.propertiesPaneContainer.appendChild(this.parentElement);
        };
        this.onTabSelection = () => {
            this.documentEditor.resize();
        };
        this.wireEvent = () => {
            this.shadingBtn.addEventListener('change', this.changeBackgroundColor);
            // tslint:disable-next-line:max-line-length
            this.borderBtn.addEventListener('change', (args) => { setTimeout(() => { this.borderColor = args.currentValue.hex; this.tableOutlineBorder.element.focus(); }, 10); });
            this.tableOutlineBorder.element.addEventListener('click', this.onOutlineBorder);
            this.tableAllBorder.element.addEventListener('click', this.onAllBorder);
            this.tableCenterBorder.element.addEventListener('click', this.onInsideBorder);
            this.tableLeftBorder.element.addEventListener('click', this.onLeftBorder);
            this.tableCenterVerticalBorder.element.addEventListener('click', this.onVerticalBorder);
            this.tableRightBorder.element.addEventListener('click', this.onRightBorder);
            this.tableTopBorder.element.addEventListener('click', this.onTopBorder);
            this.tableCenterHorizontalBorder.element.addEventListener('click', this.onHorizontalBorder);
            this.tableBottomBorder.element.addEventListener('click', this.onBottomBorder);
            this.insertRowAbove.element.addEventListener('click', this.onInsertRowAbove);
            this.insertRowBelow.element.addEventListener('click', this.onInsertRowBelow);
            this.insertColumnLeft.element.addEventListener('click', this.onInsertColumnLeft);
            this.insertColumnRight.element.addEventListener('click', this.onInsertColumnRight);
            this.deleteRow.element.addEventListener('click', this.onDeleteRow);
            this.deleteColumn.element.addEventListener('click', this.onDeleteColumn);
            this.horizontalMerge.element.addEventListener('click', this.onMergeCell);
            this.alignTop.element.addEventListener('click', this.applyAlignTop);
            this.alignBottom.element.addEventListener('click', this.applyAlignBottom);
            this.alignCenterHorizontal.element.addEventListener('click', this.applyAlignCenterHorizontal);
            this.topMargin.element.addEventListener('click', () => { this.isTopMarginApply = true; });
            this.rightMargin.element.addEventListener('click', () => { this.isRightMarginApply = true; });
            this.leftMargin.element.addEventListener('click', () => { this.isLeftMarginApply = true; });
            this.bottomMargin.element.addEventListener('click', () => { this.isBottomMarginApply = true; });
            this.topMargin.element.addEventListener('keydown', this.onTopMargin);
            this.rightMargin.element.addEventListener('keydown', this.onRightMargin);
            this.leftMargin.element.addEventListener('keydown', this.onLeftMargin);
            this.bottomMargin.element.addEventListener('keydown', this.onBottomMargin);
            this.topMargin.element.addEventListener('blur', () => { this.applyTopMargin(); this.isTopMarginApply = false; });
            this.rightMargin.element.addEventListener('blur', () => { this.applyRightMargin(); this.isRightMarginApply = false; });
            this.leftMargin.element.addEventListener('blur', () => { this.applyLeftMargin(); this.isLeftMarginApply = false; });
            this.bottomMargin.element.addEventListener('blur', () => { this.applyBottomMargin(); this.isBottomMarginApply = false; });
        };
        this.getBorder = (border) => {
            let lineWidth = (this.borderSize.content.indexOf('No Border') >= 0) ? 0 : parseInt(this.borderSize.content, 0);
            let linestyle = (lineWidth === 0) ? 'Cleared' : 'Single';
            let borderSettings = {
                type: border,
                borderColor: this.borderColor,
                lineWidth: lineWidth,
                borderStyle: linestyle
            };
            return borderSettings;
        };
        this.onOutlineBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('OutsideBorders'));
        };
        this.onAllBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('AllBorders'));
        };
        this.onInsideBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('InsideBorders'));
        };
        this.onLeftBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('LeftBorder'));
        };
        this.onVerticalBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('InsideVerticalBorder'));
        };
        this.onRightBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('RightBorder'));
        };
        this.onTopBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('TopBorder'));
        };
        this.onHorizontalBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('InsideHorizontalBorder'));
        };
        this.onBottomBorder = () => {
            this.documentEditor.editor.applyBorders(this.getBorder('BottomBorder'));
        };
        this.onTopMargin = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.applyTopMargin(); this.isTopMarginApply = false; }, 30);
            }
        };
        this.onBottomMargin = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.applyBottomMargin(); this.isBottomMarginApply = false; }, 30);
            }
        };
        this.onLeftMargin = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.applyLeftMargin(); this.isLeftMarginApply = false; }, 30);
            }
        };
        this.onRightMargin = (e) => {
            if (e.keyCode === 13) {
                setTimeout(() => { this.applyRightMargin(); this.isRightMarginApply = false; }, 30);
            }
        };
        this.applyTopMargin = () => {
            if (!this.isTopMarginApply) {
                return;
            }
            this.documentEditor.selection.cellFormat.topMargin = (this.topMargin.value > this.topMargin.max)
                ? this.topMargin.max : this.topMargin.value;
        };
        this.applyBottomMargin = () => {
            if (!this.isBottomMarginApply) {
                return;
            }
            this.documentEditor.selection.cellFormat.bottomMargin = (this.bottomMargin.value > this.bottomMargin.max)
                ? this.bottomMargin.max : this.bottomMargin.value;
        };
        this.applyLeftMargin = () => {
            if (!this.isLeftMarginApply) {
                return;
            }
            this.documentEditor.selection.cellFormat.leftMargin = (this.leftMargin.value > this.leftMargin.max)
                ? this.leftMargin.max : this.leftMargin.value;
        };
        this.applyRightMargin = () => {
            if (!this.isRightMarginApply) {
                return;
            }
            this.documentEditor.selection.cellFormat.rightMargin = (this.rightMargin.value > this.rightMargin.max)
                ? this.rightMargin.max : this.rightMargin.value;
        };
        this.applyAlignTop = () => {
            this.documentEditor.selection.cellFormat.verticalAlignment = 'Top';
        };
        this.applyAlignBottom = () => {
            this.documentEditor.selection.cellFormat.verticalAlignment = 'Bottom';
        };
        this.applyAlignCenterHorizontal = () => {
            this.documentEditor.selection.cellFormat.verticalAlignment = 'Center';
        };
        this.onMergeCell = () => {
            this.documentEditor.editor.mergeCells();
        };
        this.onInsertRowAbove = () => {
            this.documentEditor.editor.insertRow(true);
        };
        this.onInsertRowBelow = () => {
            this.documentEditor.editor.insertRow(false);
        };
        this.onInsertColumnLeft = () => {
            this.documentEditor.editor.insertColumn(true);
        };
        this.onInsertColumnRight = () => {
            this.documentEditor.editor.insertColumn(false);
        };
        this.onDeleteRow = () => {
            this.documentEditor.editor.deleteRow();
        };
        this.onDeleteColumn = () => {
            this.documentEditor.editor.deleteColumn();
        };
        this.onSelectionChange = () => {
            if (this.documentEditor.selection) {
                if (this.documentEditor.editor && this.documentEditor.editor.canMergeCells()) {
                    this.horizontalMerge.disabled = false;
                }
                else {
                    this.horizontalMerge.disabled = true;
                }
                if (this.documentEditor.selection.contextType === 'TableText' || this.documentEditor.selection.contextType === 'TableImage') {
                    this.shadingBtn.value = this.documentEditor.selection.cellFormat.background;
                }
                // tslint:disable-next-line:max-line-length
                this.topMargin.value = this.documentEditor.selection.cellFormat.topMargin ? this.documentEditor.selection.cellFormat.topMargin : 0;
                // tslint:disable-next-line:max-line-length
                this.bottomMargin.value = this.documentEditor.selection.cellFormat.bottomMargin ? this.documentEditor.selection.cellFormat.bottomMargin : 0;
                // tslint:disable-next-line:max-line-length
                this.rightMargin.value = this.documentEditor.selection.cellFormat.rightMargin ? this.documentEditor.selection.cellFormat.rightMargin : 0;
                // tslint:disable-next-line:max-line-length
                this.leftMargin.value = this.documentEditor.selection.cellFormat.leftMargin ? this.documentEditor.selection.cellFormat.leftMargin : 0;
            }
        };
        this.changeBackgroundColor = (args) => {
            if (!this.documentEditor.isReadOnly) {
                //Handle API for shading.
                this.documentEditor.selection.cellFormat.background = args.currentValue.hex;
                setTimeout(() => { this.documentEditor.focusIn(); }, 10);
            }
        };
        this.initFillColorDiv = () => {
            // tslint:disable-next-line:max-line-length
            let fillDiv = createElement('div', { id: this.elementId + '_fillColorDiv', className: 'e-de-property-div-padding de-tbl-fill-clr' });
            this.tableProperties.appendChild(fillDiv);
            let label = createElement('label', { className: 'e-de-prop-sub-label' });
            label.classList.add('e-de-prop-fill-label');
            if (this.isRtl) {
                label.classList.add('e-de-rtl');
            }
            label.textContent = this.localObj.getConstant('Fill');
            fillDiv.appendChild(label);
            this.shadingBtn = this.createColorPickerTemplate(this.elementId + '_tableShading', fillDiv, this.localObj.getConstant('Fill color'), false);
            // tslint:disable-next-line:max-line-length
            classList(fillDiv.lastElementChild.lastElementChild.lastElementChild.firstChild, ['e-de-ctnr-cellbg-clr-picker'], ['e-caret']);
        };
        this.initBorderStylesDiv = () => {
            let borderStyleDiv = createElement('div', { className: 'e-de-property-div-padding' });
            this.tableProperties.appendChild(borderStyleDiv);
            let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = this.localObj.getConstant('Border Style');
            borderStyleDiv.appendChild(label);
            // tslint:disable-next-line:max-line-length
            let parentDiv = createElement('div', { id: this.elementId + '_borderStyleDiv', className: 'e-de-border-style-div', styles: 'display:inline-flex;' });
            let styleDiv = createElement('div', { styles: 'width:126px;height:126px', className: 'e-de-grp-btn-ctnr' });
            let div1 = createElement('div', { className: this.groupButtonClass + ' e-de-ctnr-group-btn-top' });
            styleDiv.appendChild(div1);
            let div2 = createElement('div', { className: this.groupButtonClass + ' e-de-ctnr-group-btn-middle' });
            styleDiv.appendChild(div2);
            let div3 = createElement('div', { className: this.groupButtonClass + ' e-de-ctnr-group-btn-bottom' });
            styleDiv.appendChild(div3);
            if (this.isRtl) {
                div1.classList.add('e-de-rtl');
                div3.classList.add('e-de-rtl');
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            let btnStyle = '';
            // tslint:disable-next-line:max-line-length
            this.tableOutlineBorder = this.createButtonTemplate(this.elementId + '_tableOutlineBorder', 'e-de-ctnr-outsideborder e-icons', div1, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Outside borders'));
            this.tableAllBorder = this.createButtonTemplate(this.elementId + '_tableAllBorder', 'e-de-ctnr-allborders e-icons', div1, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('All borders'));
            // tslint:disable-next-line:max-line-length
            this.tableCenterBorder = this.createButtonTemplate(this.elementId + '_tableCenterBorder', 'e-de-ctnr-insideborders e-icons', div1, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Inside borders'));
            this.tableLeftBorder = this.createButtonTemplate(this.elementId + '_tableLeftBorder', 'e-de-ctnr-leftborders e-icons', div2, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Left border'));
            // tslint:disable-next-line:max-line-length
            this.tableCenterVerticalBorder = this.createButtonTemplate(this.elementId + '_tableCenterVBorder', 'e-de-ctnr-insideverticalborder e-icons', div2, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Inside vertical border'));
            this.tableRightBorder = this.createButtonTemplate(this.elementId + '_tableRightBorder', 'e-de-ctnr-rightborder e-icons', div2, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Right border'));
            // tslint:disable-next-line:max-line-length
            this.tableTopBorder = this.createButtonTemplate(this.elementId + '_tableTopBorder', 'e-de-ctnr-topborder e-icons', div3, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Top border'));
            this.tableCenterHorizontalBorder = this.createButtonTemplate(this.elementId + '_tableCenterHBorder', 'e-de-ctnr-insidehorizondalborder e-icons', div3, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Inside horizontal border'));
            // tslint:disable-next-line:max-line-length
            this.tableBottomBorder = this.createButtonTemplate(this.elementId + '_tableBottomBorder', 'e-de-ctnr-bottomborder e-icons', div3, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Bottom border'));
            parentDiv.appendChild(styleDiv);
            // tslint:disable-next-line:max-line-length
            let styleTypeDiv = createElement('div', { className: 'de-tbl-fill-clr' });
            if (!this.isRtl) {
                styleTypeDiv.classList.add('e-de-stylediv');
            }
            else {
                styleTypeDiv.classList.add('e-de-stylediv-rtl');
            }
            // tslint:disable-next-line:max-line-length
            this.borderBtn = this.createColorPickerTemplate(this.elementId + '_tableBorderColor', styleTypeDiv, this.localObj.getConstant('Border color'), true);
            this.borderBtn.value = '#000000';
            styleTypeDiv.firstElementChild.lastElementChild.lastElementChild.style.width = '30px';
            styleTypeDiv.firstElementChild.lastElementChild.firstElementChild.firstElementChild.style.width = '100%';
            // tslint:disable-next-line:max-line-length
            classList(styleTypeDiv.lastElementChild.lastElementChild.lastElementChild.firstChild, ['e-de-ctnr-highlightcolor'], ['e-caret']);
            let borderSizeButton = createElement('button', { id: this.elementId + '_tableBorderSize', className: 'e-de-border-size-button', styles: 'font-size:10px;padding:0px;', attrs: { type: 'button' } });
            styleTypeDiv.appendChild(borderSizeButton);
            this.borderSize = this.createBorderSizeDropDown('e-de-ctnr-strokesize e-icons', borderSizeButton);
            parentDiv.appendChild(styleTypeDiv);
            this.borderSizeColorElement = document.getElementsByClassName('e-de-border-width');
            borderStyleDiv.appendChild(parentDiv);
        };
        this.initCellDiv = () => {
            let cellDiv = createElement('div', { className: 'e-de-property-div-padding' });
            this.tableProperties.appendChild(cellDiv);
            let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = this.localObj.getConstant('Cell');
            cellDiv.appendChild(label);
            let parentDiv = createElement('div', { className: 'e-de-ctnr-group-btn' });
            parentDiv.classList.add('e-de-cell-div');
            if (this.isRtl) {
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            let btnStyle = 'width:' + 38 + 'px;';
            // tslint:disable-next-line:max-line-length
            this.horizontalMerge = this.createButtonTemplate(this.elementId + '_tableOutlineBorder', 'e-de-ctnr-mergecell e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Merge cells');
            //this.verticalMerge = this.createButtonTemplate(this.elementId + '_tableAllBorder', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Vertical Merge');
            cellDiv.appendChild(parentDiv);
        };
        this.initInsertOrDelCell = () => {
            let tableOperationDiv = createElement('div', { className: 'e-de-property-div-padding' });
            this.tableProperties.appendChild(tableOperationDiv);
            let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = this.localObj.getConstant('Insert / Delete');
            tableOperationDiv.appendChild(label);
            let parentDiv = createElement('div', { className: 'e-de-insert-del-cell', styles: 'display:inline-flex' });
            let div1 = createElement('div', { className: this.groupButtonClass });
            parentDiv.appendChild(div1);
            let div2 = createElement('div', { className: this.groupButtonClass });
            if (!this.isRtl) {
                div2.style.marginLeft = '12px';
            }
            else {
                div2.style.marginRight = '12px';
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            parentDiv.appendChild(div2);
            let btnStyle = 'width:' + 38 + 'px;';
            // tslint:disable-next-line:max-line-length
            this.insertColumnLeft = this.createButtonTemplate(this.elementId + '_insertColumnLeft', 'e-de-ctnr-insertleft e-icons', div1, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Insert columns to the left'));
            this.insertColumnRight = this.createButtonTemplate(this.elementId + '_insertColumnRight', 'e-de-ctnr-insertright e-icons', div1, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Insert columns to the right'));
            // tslint:disable-next-line:max-line-length
            this.insertRowAbove = this.createButtonTemplate(this.elementId + '_insertRowAbove', 'e-de-ctnr-insertabove e-icons', div1, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Insert rows above'));
            this.insertRowBelow = this.createButtonTemplate(this.elementId + '_insertRowBelow', 'e-de-ctnr-insertbelow e-icons', div1, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Insert rows below'));
            // tslint:disable-next-line:max-line-length
            this.deleteRow = this.createButtonTemplate(this.elementId + '_deleteRow', 'e-de-ctnr-deleterows e-icons', div2, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Delete rows'));
            this.deleteColumn = this.createButtonTemplate(this.elementId + '_deleteColumn', 'e-de-ctnr-deletecolumns e-icons', div2, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Delete columns'));
            tableOperationDiv.appendChild(parentDiv);
        };
        this.initCellMargin = () => {
            let cellMarginDiv = createElement('div', { className: 'e-de-property-div-padding e-de-cellmargin-text' });
            this.tableProperties.appendChild(cellMarginDiv);
            let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = this.localObj.getConstant('Cell Margin');
            cellMarginDiv.appendChild(label);
            let parentDiv = createElement('div', { className: 'e-de-cell-margin', styles: 'height: 60px;display:inline-flex' });
            if (this.isRtl) {
                label.classList.add('e-de-rtl');
            }
            let textboxDivStyle = 'width:' + 48 + 'px';
            let textboxParentDivStyle = 'width:' + 50 + 'px;float:left;';
            // tslint:disable-next-line:max-line-length
            this.topMargin = this.createCellMarginTextBox(this.localObj.getConstant('Top'), this.elementId + '_topMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Top margin');
            // tslint:disable-next-line:max-line-length
            this.bottomMargin = this.createCellMarginTextBox(this.localObj.getConstant('Bottom'), this.elementId + '_bottomMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Bottom margin');
            // tslint:disable-next-line:max-line-length
            this.leftMargin = this.createCellMarginTextBox(this.localObj.getConstant('Left'), this.elementId + '_leftMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Left margin');
            // tslint:disable-next-line:max-line-length
            this.rightMargin = this.createCellMarginTextBox(this.localObj.getConstant('Right'), this.elementId + '_rightMargin', parentDiv, textboxDivStyle, textboxParentDivStyle, 500, 'Right margin');
            cellMarginDiv.appendChild(parentDiv);
        };
        this.initAlignText = () => {
            let alignmentDiv = createElement('div', { className: 'e-de-property-div-padding', styles: 'border-bottom-width:0px' });
            this.tableProperties.appendChild(alignmentDiv);
            let label = createElement('label', { className: 'e-de-ctnr-prop-label' });
            label.classList.add('e-de-table-prop-label');
            label.textContent = this.localObj.getConstant('Align Text');
            alignmentDiv.appendChild(label);
            let parentDiv = createElement('div', { className: 'e-de-align-text', styles: 'margin-bottom: 10px;' });
            if (this.isRtl) {
                parentDiv.classList.add('e-de-rtl');
                label.classList.add('e-de-rtl');
            }
            let div = createElement('div', { className: this.groupButtonClass });
            parentDiv.appendChild(div);
            let btnStyle = 'width:' + 38 + 'px;';
            // tslint:disable-next-line:max-line-length
            this.alignTop = this.createButtonTemplate(this.elementId + '_alignTop', 'e-de-ctnr-aligntop e-icons', div, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Align top'));
            // tslint:disable-next-line:max-line-length
            // this.alignCenterVertical = this.createButtonTemplate(this.elementId + '_alignCenterVertical', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Align Center Vertical');
            // tslint:disable-next-line:max-line-length
            // this.alignRight = this.createButtonTemplate(this.elementId + '_alignRight', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Align Right');
            this.alignBottom = this.createButtonTemplate(this.elementId + '_alignBottom', 'e-de-ctnr-alignbottom e-icons', div, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Align bottom'));
            // tslint:disable-next-line:max-line-length
            // this.alignCenterHorizontal = this.createButtonTemplate(this.elementId + '_alignCenterHorizontal', 'e-de-icon-merge-column e-icons', parentDiv, 'e-de-prop-font-button', btnStyle, 'Align Center Horizontal');
            this.alignCenterHorizontal = this.createButtonTemplate(this.elementId + '_alignCenterHorizontal', 'e-de-ctnr-aligncenter-table e-icons', div, 'e-de-prop-font-button', btnStyle, this.localObj.getConstant('Align center'));
            this.alignCenterHorizontal.addEventListener('click', this.applyAlignCenterHorizontal);
            alignmentDiv.appendChild(parentDiv);
        };
        // tslint:disable-next-line:max-line-length
        this.createCellMarginTextBox = (textboxLabel, textboxId, parentDiv, styles, parentStyle, maxValue, toolTipText) => {
            let cellMarginParentDiv = createElement('div', { styles: parentStyle });
            cellMarginParentDiv.classList.add('e-de-cell-text-box');
            let cellMarginLabel = createElement('label', { className: 'e-de-prop-sub-label' });
            cellMarginLabel.textContent = textboxLabel;
            cellMarginParentDiv.appendChild(cellMarginLabel);
            // tslint:disable-next-line:max-line-length
            let cellMarginTextbox = createElement('input', { className: 'e-textbox', id: textboxId, styles: styles });
            cellMarginParentDiv.appendChild(cellMarginTextbox);
            // tslint:disable-next-line:max-line-length
            let cellMarginNumericText = new NumericTextBox({ showSpinButton: false, min: 0, format: 'n0', max: maxValue, enableRtl: this.isRtl }, cellMarginTextbox);
            parentDiv.appendChild(cellMarginParentDiv);
            cellMarginTextbox.setAttribute('title', toolTipText);
            return cellMarginNumericText;
        };
        this.createBorderSizeDropDown = (iconcss, button) => {
            let div = createElement('div', { id: 'borderSizeTarget', styles: 'display:none' });
            let ulTag = createElement('ul', {
                styles: 'display: block; outline: 0px; width: 126px; height: auto;',
                id: 'borderSizeListMenu'
            });
            div.appendChild(ulTag);
            let noneOption = this.createDropdownOption(ulTag, this.localObj.getConstant('No Border'));
            noneOption.addEventListener('click', () => { this.onBorderSizeChange('No Border'); });
            let oneOption = this.createDropdownOption(ulTag, '1px');
            oneOption.addEventListener('click', () => { this.onBorderSizeChange('1px'); });
            let oneHalfOption = this.createDropdownOption(ulTag, '1.5px');
            oneHalfOption.addEventListener('click', () => { this.onBorderSizeChange('1.5px'); });
            let twoOption = this.createDropdownOption(ulTag, '2px');
            twoOption.addEventListener('click', () => { this.onBorderSizeChange('2px'); });
            let threeOption = this.createDropdownOption(ulTag, '3px');
            threeOption.addEventListener('click', () => { this.onBorderSizeChange('3px'); });
            let fourOption = this.createDropdownOption(ulTag, '4px');
            fourOption.addEventListener('click', () => { this.onBorderSizeChange('4px'); });
            let fiveOption = this.createDropdownOption(ulTag, '5px');
            fiveOption.addEventListener('click', () => { this.onBorderSizeChange('5px'); });
            let menuOptions = {
                target: div,
                iconCss: iconcss,
                cssClass: 'e-de-prop-bordersize',
                enableRtl: this.isRtl,
                content: '1.5px',
            };
            let dropdown = new DropDownButton(menuOptions);
            dropdown.beforeOpen = () => {
                div.style.display = 'block';
                for (let i = 0; i < this.borderSizeColorElement.length; i++) {
                    // tslint:disable-next-line:max-line-length
                    this.borderSizeColorElement[i].style.borderBottomColor = this.borderColor;
                }
            };
            dropdown.beforeClose = () => { div.style.display = 'none'; };
            dropdown.appendTo(button);
            dropdown.element.setAttribute('title', this.localObj.getConstant('Border width'));
            return dropdown;
        };
        this.onBorderSizeChange = (value) => {
            this.borderSize.content = value;
            setTimeout(() => { this.tableOutlineBorder.element.focus(); }, 10);
        };
        this.createDropdownOption = (ulTag, text) => {
            let liTag = createElement('li', {
                styles: 'display:block',
                className: 'e-de-floating-menuitem e-de-floating-menuitem-md e-de-list-items  e-de-list-item-size'
            });
            ulTag.appendChild(liTag);
            let innerHTML;
            if (text === 'No Border') {
                innerHTML = '<div>' + text + '</div>';
            }
            else if (text === '1.5px') {
                // tslint:disable-next-line:max-line-length
                innerHTML = '<div>' + text + '<span class="e-de-list-line e-de-border-width"  style="margin-left:10px;border-bottom-width:' + text + ';' + '"' + '></span></div>';
            }
            else {
                // tslint:disable-next-line:max-line-length
                innerHTML = '<div>' + text + '<span class="e-de-list-line e-de-border-width" style="margin-left:20px;border-bottom-width:' + text + ';' + '"' + '></span></div>';
            }
            let liInnerDiv = createElement('div', {
                className: 'e-de-list-header-presetmenu',
                innerHTML: innerHTML
            });
            liTag.appendChild(liInnerDiv);
            return liTag;
        };
        //tslint:disable-next-line:max-line-length
        this.createDropDownButton = (id, styles, parentDiv, iconCss, content, items, target) => {
            let buttonElement = createElement('button', { id: id, styles: styles, attrs: { type: 'button' } });
            parentDiv.appendChild(buttonElement);
            let splitButtonClass = 'e-de-prop-splitbutton';
            if (this.isRtl) {
                splitButtonClass = 'e-rtl ' + splitButtonClass;
            }
            // tslint:disable-next-line:max-line-length
            let dropDownBtn = new DropDownButton({ iconCss: iconCss, content: content, enableRtl: this.isRtl, cssClass: splitButtonClass }, buttonElement);
            if (items) {
                dropDownBtn.items = items;
            }
            if (target) {
                dropDownBtn.target = target;
            }
            return dropDownBtn;
        };
        this.createColorPickerTemplate = (id, divElement, toolTipText, isBorderWidth) => {
            let inputElement = createElement('input', { id: id });
            divElement.appendChild(inputElement);
            let cssClass = 'e-de-prop-font-button e-de-prop-font-colorpicker';
            if (isBorderWidth) {
                cssClass = cssClass + ' e-de-border-clr-picker';
            }
            // tslint:disable-next-line:max-line-length
            let colorPicker = new ColorPicker({ showButtons: true, cssClass: cssClass, enableRtl: this.isRtl, locale: this.container.locale }, inputElement);
            inputElement.parentElement.setAttribute('title', toolTipText);
            return colorPicker;
        };
        this.showTableProperties = (isShow) => {
            if (isShow) {
                if (this.prevContext !== this.documentEditor.selection.contextType) {
                    this.propertiesTab.selectedItem = 0;
                    this.tableTextProperties.appliedHighlightColor = this.textProperties.appliedHighlightColor;
                    this.tableTextProperties.appliedBulletStyle = this.textProperties.appliedBulletStyle;
                    this.tableTextProperties.appliedNumberingStyle = this.textProperties.appliedNumberingStyle;
                }
                this.onSelectionChange();
                this.tableTextProperties.onSelectionChange();
                this.textProperties.appliedHighlightColor = this.tableTextProperties.appliedHighlightColor;
                this.textProperties.appliedBulletStyle = this.tableTextProperties.appliedBulletStyle;
                this.textProperties.appliedNumberingStyle = this.tableTextProperties.appliedNumberingStyle;
            }
            if (!isShow && this.parentElement.style.display === 'none' || (isShow && this.parentElement.style.display === 'block')) {
                return;
            }
            this.parentElement.style.display = isShow ? 'block' : 'none';
            this.documentEditor.resize();
            this.prevContext = this.documentEditor.selection.contextType;
        };
        this.container = container;
        this.isRtl = isRtl;
        if (this.isRtl) {
            this.groupButtonClass = 'e-rtl ' + this.groupButtonClass;
        }
        this.tableTextProperties = new TextProperties(container, 'textProperties', true, this.isRtl);
        this.imageProperty = imageProperty;
        this.elementId = this.documentEditor.element.id;
        this.initializeTablePropPane();
        this.prevContext = this.documentEditor.selection.contextType;
        this.textProperties = textProperties;
    }
    get documentEditor() {
        return this.container.documentEditor;
    }
    /**
     * @private
     */
    enableDisableElements(enable) {
        this.textProperties.enableDisableElements(enable);
        if (enable) {
            classList(this.element, [], ['e-de-overlay']);
        }
        else {
            classList(this.element, ['e-de-overlay'], []);
        }
    }
    // tslint:disable-next-line:max-line-length
    createButtonTemplate(id, iconcss, div, buttonClass, styles, toolTipText, content, iconPos) {
        let buttonElement = createElement('Button', { id: id, styles: styles, attrs: { type: 'button' } });
        div.appendChild(buttonElement);
        let btn = new Button({
            cssClass: buttonClass, iconCss: iconcss, enableRtl: this.isRtl, iconPosition: (iconPos ? iconPos : 'Left'),
            content: content ? content : ''
        });
        btn.appendTo(buttonElement);
        buttonElement.setAttribute('title', toolTipText);
        return btn;
    }
    destroy() {
        this.container = undefined;
        if (this.shadingBtn) {
            this.shadingBtn.destroy();
            this.shadingBtn = undefined;
        }
        if (this.borderBtn) {
            this.borderBtn.destroy();
            this.borderBtn = undefined;
        }
        if (this.borderSize) {
            this.borderSize.destroy();
            this.borderSize = undefined;
        }
        if (this.topMargin) {
            this.topMargin.destroy();
            this.topMargin = undefined;
        }
        if (this.bottomMargin) {
            this.bottomMargin.destroy();
            this.bottomMargin = undefined;
        }
        if (this.leftMargin) {
            this.leftMargin.destroy();
            this.leftMargin = undefined;
        }
        if (this.rightMargin) {
            this.rightMargin.destroy();
            this.rightMargin = undefined;
        }
        if (this.tableTextProperties) {
            this.tableTextProperties.destroy();
            this.tableTextProperties = undefined;
        }
        if (this.propertiesTab) {
            this.propertiesTab.destroy();
            this.propertiesTab = undefined;
        }
    }
}

/**
 * Represents document editor status bar.
 * @private
 */
class StatusBar {
    constructor(parentElement, docEditor) {
        this.startPage = 1;
        this.initializeStatusBar = () => {
            let isRtl = this.container.enableRtl;
            this.documentEditor.enableSpellCheck = (this.container.enableSpellCheck) ? true : false;
            // tslint:disable-next-line:max-line-length
            this.localObj = new L10n('documenteditorcontainer', this.container.defaultLocale, this.container.locale);
            // tslint:disable-next-line:max-line-length
            let styles = 'padding-top:8px;';
            styles += isRtl ? 'padding-right:16px' : 'padding-left:16px';
            // tslint:disable-next-line:max-line-length
            let div = createElement('div', { className: (this.container.enableSpellCheck) ? 'e-de-ctnr-pg-no' : 'e-de-ctnr-pg-no-spellout', styles: styles });
            this.statusBarDiv.appendChild(div);
            let label = createElement('label');
            label.textContent = this.localObj.getConstant('Page') + ' ';
            div.appendChild(label);
            // tslint:disable-next-line:max-line-length
            this.pageNumberLabel = createElement('label', { styles: 'text-transform:capitalize;white-space:pre;overflow:hidden;user-select:none;cursor:text;height:17px;max-width:150px' });
            this.editablePageNumber = createElement('div', { styles: 'display: inline-flex;height: 17px;padding: 0px 4px;', className: 'e-input e-de-pagenumber-text' });
            this.editablePageNumber.appendChild(this.pageNumberLabel);
            if (isRtl) {
                label.style.marginLeft = '6px';
                this.editablePageNumber.style.marginLeft = '6px';
            }
            else {
                label.style.marginRight = '6px';
                this.editablePageNumber.style.marginRight = '6px';
            }
            this.updatePageNumber();
            div.appendChild(this.editablePageNumber);
            // tslint:disable-next-line:max-line-length
            this.editablePageNumber.setAttribute('title', this.localObj.getConstant('The current page number in the document. Click or tap to navigate specific page.'));
            let label1 = createElement('label', { styles: 'width:16px' });
            label1.textContent = ' ' + this.localObj.getConstant('of') + ' ';
            div.appendChild(label1);
            this.pageCount = createElement('label');
            div.appendChild(this.pageCount);
            this.updatePageCount();
            if (this.documentEditor.enableSpellCheck) {
                let verticalLine = createElement('div', { className: 'e-de-statusbar-seperator' });
                this.statusBarDiv.appendChild(verticalLine);
                let spellCheckBtn = this.addSpellCheckElement();
                this.spellCheckButton.appendTo(spellCheckBtn);
            }
            let zoomBtn = createElement('button', {
                // tslint:disable-next-line:max-line-length
                className: (this.container.enableSpellCheck) ? 'e-de-statusbar-zoom-spell' : 'e-de-statusbar-zoom', attrs: { type: 'button' }
            });
            this.statusBarDiv.appendChild(zoomBtn);
            zoomBtn.setAttribute('title', 'Zoom level. Click or tap to open the Zoom options.');
            let items = [
                {
                    text: '200%',
                },
                {
                    text: '175%',
                },
                {
                    text: '150%',
                },
                {
                    text: '125%',
                },
                {
                    text: '100%',
                },
                {
                    text: '75%',
                },
                {
                    text: '50%',
                },
                {
                    text: '25%',
                },
                {
                    separator: true
                },
                {
                    text: this.localObj.getConstant('Fit one page')
                },
                {
                    text: this.localObj.getConstant('Fit page width'),
                },
            ];
            // tslint:disable-next-line:max-line-length
            this.zoom = new DropDownButton({ content: '100%', items: items, enableRtl: this.container.enableRtl, select: this.onZoom }, zoomBtn);
        };
        this.onZoom = (args) => {
            this.setZoomValue(args.item.text);
            this.updateZoomContent();
        };
        this.onSpellCheck = (args) => {
            this.setSpellCheckValue(args.item.text, args.element);
        };
        this.updateZoomContent = () => {
            this.zoom.content = Math.round(this.documentEditor.zoomFactor * 100) + '%';
        };
        this.setSpellCheckValue = (text, element) => {
            this.spellCheckButton.content = 'Spelling';
            if (text.match(this.localObj.getConstant('Spell Check'))) {
                this.documentEditor.enableSpellCheck = (this.documentEditor.enableSpellCheck) ? false : true;
                setTimeout(() => {
                    if (this.documentEditor.enableSpellCheck) {
                        this.documentEditor.spellChecker.languageID = this.currentLanguage;
                        this.documentEditor.spellChecker.allowSpellCheckAndSuggestion = this.allowSuggestion;
                        this.documentEditor.viewer.triggerElementsOnLoading = true;
                        this.documentEditor.viewer.triggerSpellCheck = true;
                    }
                    this.documentEditor.editor.reLayout(this.documentEditor.viewer.selection);
                    /* tslint:disable */
                }, 50);
                /* tslint:enable */
                this.documentEditor.viewer.triggerSpellCheck = false;
                this.documentEditor.viewer.triggerElementsOnLoading = false;
                // tslint:disable-next-line:max-line-length
            }
            else if (text.match(this.localObj.getConstant('Underline errors'))) {
                if (this.documentEditor.enableSpellCheck) {
                    // tslint:disable-next-line:max-line-length
                    this.documentEditor.spellChecker.removeUnderline = (this.documentEditor.spellChecker.removeUnderline) ? false : true;
                    this.documentEditor.editor.reLayout(this.documentEditor.viewer.selection);
                }
            }
        };
        this.setZoomValue = (text) => {
            if (text.match(this.localObj.getConstant('Fit one page'))) {
                this.documentEditor.fitPage('FitOnePage');
            }
            else if (text.match(this.localObj.getConstant('Fit page width'))) {
                this.documentEditor.fitPage('FitPageWidth');
            }
            else {
                this.documentEditor.zoomFactor = parseInt(text, 0) / 100;
            }
        };
        /**
         * Updates page count.
         */
        this.updatePageCount = () => {
            this.pageCount.textContent = this.editorPageCount.toString();
        };
        /**
         * Updates page number.
         */
        this.updatePageNumber = () => {
            this.pageNumberLabel.textContent = this.startPage.toString();
        };
        this.updatePageNumberOnViewChange = (args) => {
            if (this.documentEditor.selection
                && this.documentEditor.selection.startPage >= args.startPage && this.documentEditor.selection.startPage <= args.endPage) {
                this.startPage = this.documentEditor.selection.startPage;
            }
            else {
                this.startPage = args.startPage;
            }
            this.updatePageNumber();
        };
        this.wireEvents = () => {
            this.editablePageNumber.addEventListener('keydown', (e) => {
                if (e.which === 13) {
                    e.preventDefault();
                    let pageNumber = parseInt(this.editablePageNumber.textContent, 0);
                    if (pageNumber > this.editorPageCount) {
                        this.updatePageNumber();
                    }
                    else {
                        if (this.documentEditor.selection) {
                            this.documentEditor.selection.goToPage(parseInt(this.editablePageNumber.textContent, 0));
                        }
                        else {
                            this.documentEditor.scrollToPage(parseInt(this.editablePageNumber.textContent, 0));
                        }
                    }
                    this.editablePageNumber.contentEditable = 'false';
                    if (this.editablePageNumber.textContent === '') {
                        this.updatePageNumber();
                    }
                }
                if (e.which > 64) {
                    e.preventDefault();
                }
            });
            this.editablePageNumber.addEventListener('blur', () => {
                if (this.editablePageNumber.textContent === '' || parseInt(this.editablePageNumber.textContent, 0) > this.editorPageCount) {
                    this.updatePageNumber();
                }
                this.editablePageNumber.contentEditable = 'false';
                this.editablePageNumber.style.border = 'none';
            });
            this.editablePageNumber.addEventListener('focus', () => {
                this.editablePageNumber.style.border = '1px solid #F1F1F1';
            });
            this.editablePageNumber.addEventListener('click', () => {
                this.updateDocumentEditorPageNumber();
            });
        };
        this.updateDocumentEditorPageNumber = () => {
            this.editablePageNumber.contentEditable = 'true';
            this.editablePageNumber.focus();
            window.getSelection().selectAllChildren(this.editablePageNumber);
        };
        this.statusBarDiv = parentElement;
        this.container = docEditor;
        this.initializeStatusBar();
        this.wireEvents();
    }
    get documentEditor() {
        return this.container ? this.container.documentEditor : undefined;
    }
    get editorPageCount() {
        return this.documentEditor ? this.documentEditor.pageCount : 1;
    }
    addSpellCheckElement() {
        let spellCheckBtn = createElement('button', {
            className: 'e-de-statusbar-spellcheck'
        });
        this.statusBarDiv.appendChild(spellCheckBtn);
        spellCheckBtn.setAttribute('title', 'Spell Checker options');
        let spellCheckItems = [
            {
                text: 'Spell Check',
            },
            {
                text: 'Underline errors',
            },
        ];
        // tslint:disable-next-line:max-line-length
        this.spellCheckButton = new DropDownButton({
            content: 'Spelling', items: spellCheckItems, enableRtl: this.container.enableRtl, select: this.onSpellCheck,
            beforeItemRender: (args) => {
                args.element.innerHTML = '<span></span>' + args.item.text;
                if (isNullOrUndefined(this.currentLanguage)) {
                    this.currentLanguage = this.documentEditor.spellChecker.languageID;
                }
                if (isNullOrUndefined(this.allowSuggestion)) {
                    this.allowSuggestion = this.documentEditor.spellChecker.allowSpellCheckAndSuggestion;
                }
                let span = args.element.children[0];
                if (args.item.text === 'Spell Check' && this.documentEditor.enableSpellCheck) {
                    span.style.marginRight = '10px';
                    span.setAttribute('class', 'e-de-selected-spellcheck-item');
                    // tslint:disable-next-line:max-line-length
                }
                else if (args.item.text === 'Underline errors' && this.documentEditor.enableSpellCheck && !this.documentEditor.spellChecker.removeUnderline) {
                    span.style.marginRight = '10px';
                    span.setAttribute('class', 'e-de-selected-underline-item');
                }
                else {
                    span.style.marginRight = '25px';
                    args.element.children[0].classList.remove('e-de-selected-spellcheck-item');
                    args.element.children[0].classList.remove('e-de-selected-underline-item');
                }
            }
        });
        return spellCheckBtn;
    }
    /**
     * @private
     */
    destroy() {
        this.container = undefined;
        if (this.zoom) {
            this.zoom.destroy();
            this.zoom = undefined;
        }
        if (this.spellCheckButton) {
            this.spellCheckButton.destroy();
            this.spellCheckButton = undefined;
        }
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
// tslint:disable-next-line:max-line-length
/**
 * Document Editor container component.
 */
let DocumentEditorContainer = class DocumentEditorContainer extends Component {
    /**
     * Initialize the constructor of DocumentEditorContainer
     */
    constructor(options, element) {
        super(options, element);
        /**
         * @private
         */
        this.previousContext = '';
        /**
         * default locale
         * @private
         */
        this.defaultLocale = {
            'New': 'New',
            'Open': 'Open',
            'Undo': 'Undo',
            'Redo': 'Redo',
            'Image': 'Image',
            'Table': 'Table',
            'Link': 'Link',
            'Bookmark': 'Bookmark',
            'Table of Contents': 'Table of Contents',
            'HEADING - - - - 1': 'HEADING - - - - 1',
            'HEADING - - - - 2': 'HEADING - - - - 2',
            'HEADING - - - - 3': 'HEADING - - - - 3',
            'Header': 'Header',
            'Footer': 'Footer',
            'Page Setup': 'Page Setup',
            'Page Number': 'Page Number',
            'Break': 'Break',
            'Find': 'Find',
            'Local Clipboard': 'Local Clipboard',
            'Restrict Editing': 'Restrict Editing',
            'Upload from computer': 'Upload from computer',
            'By URL': 'By URL',
            'Page Break': 'Page Break',
            'Section Break': 'Section Break',
            'Header & Footer': 'Header & Footer',
            'Options': 'Options',
            'Levels': 'Levels',
            'Different First Page': 'Different First Page',
            'Different header and footer for odd and even pages.': 'Different header and footer for odd and even pages.',
            'Different Odd & Even Pages': 'Different Odd & Even Pages',
            'Different header and footer for first page.': 'Different header and footer for first page.',
            'Position': 'Position',
            'Header from Top': 'Header from Top',
            'Footer from Bottom': 'Footer from Bottom',
            'Distance from top of the page to top of the header.': 'Distance from top of the page to top of the header.',
            'Distance from bottom of the page to bottom of the footer.': 'Distance from bottom of the page to bottom of the footer.',
            'Aspect ratio': 'Aspect ratio',
            'W': 'W',
            'H': 'H',
            'Width': 'Width',
            'Height': 'Height',
            'Text': 'Text',
            'Paragraph': 'Paragraph',
            'Fill': 'Fill',
            'Fill color': 'Fill color',
            'Border Style': 'Border Style',
            'Outside borders': 'Outside borders',
            'All borders': 'All borders',
            'Inside borders': 'Inside borders',
            'Left border': 'Left border',
            'Inside vertical border': 'Inside vertical border',
            'Right border': 'Right border',
            'Top border': 'Top border',
            'Inside horizontal border': 'Inside horizontal border',
            'Bottom border': 'Bottom border',
            'Border color': 'Border color',
            'Border width': 'Border width',
            'Cell': 'Cell',
            'Merge cells': 'Merge cells',
            'Insert / Delete': 'Insert / Delete',
            'Insert columns to the left': 'Insert columns to the left',
            'Insert columns to the right': 'Insert columns to the right',
            'Insert rows above': 'Insert rows above',
            'Insert rows below': 'Insert rows below',
            'Delete rows': 'Delete rows',
            'Delete columns': 'Delete columns',
            'Cell Margin': 'Cell Margin',
            'Top': 'Top',
            'Bottom': 'Bottom',
            'Left': 'Left',
            'Right': 'Right',
            'Align Text': 'Align Text',
            'Align top': 'Align top',
            'Align bottom': 'Align bottom',
            'Align center': 'Align center',
            // tslint:disable-next-line:max-line-length
            'Number of heading or outline levels to be shown in table of contents.': 'Number of heading or outline levels to be shown in table of contents.',
            'Show page numbers': 'Show page numbers',
            'Show page numbers in table of contents.': 'Show page numbers in table of contents.',
            'Right align page numbers': 'Right align page numbers',
            'Right align page numbers in table of contents.': 'Right align page numbers in table of contents.',
            'Use hyperlinks': 'Use hyperlinks',
            'Use hyperlinks instead of page numbers.': 'Use hyperlinks instead of page numbers.',
            'Font': 'Font',
            'Font Size': 'Font Size',
            'Font color': 'Font color',
            'Text highlight color': 'Text highlight color',
            'Clear all formatting': 'Clear all formatting',
            'Bold (Ctrl+B)': 'Bold (Ctrl+B)',
            'Italic (Ctrl+I)': 'Italic (Ctrl+I)',
            'Underline (Ctrl+U)': 'Underline (Ctrl+U)',
            'Strikethrough': 'Strikethrough',
            'Superscript (Ctrl+Shift++)': 'Superscript (Ctrl+Shift++)',
            'Subscript (Ctrl+=)': 'Subscript (Ctrl+=)',
            'Align left (Ctrl+L)': 'Align left (Ctrl+L)',
            'Center (Ctrl+E)': 'Center (Ctrl+E)',
            'Align right (Ctrl+R)': 'Align right (Ctrl+R)',
            'Justify (Ctrl+J)': 'Justify (Ctrl+J)',
            'Decrease indent': 'Decrease indent',
            'Increase indent': 'Increase indent',
            'Line spacing': 'Line spacing',
            'Bullets': 'Bullets',
            'Numbering': 'Numbering',
            'Styles': 'Styles',
            'Manage Styles': 'Manage Styles',
            'Page': 'Page',
            'of': 'of',
            'Fit one page': 'Fit one page',
            'Spell Check': 'Spell Check',
            'Underline errors': 'Underline errors',
            'Fit page width': 'Fit page width',
            'Update': 'Update',
            'Cancel': 'Cancel',
            'Insert': 'Insert',
            'No Border': 'No Border',
            'Create a new document.': 'Create a new document.',
            'Open a document.': 'Open a document.',
            'Undo the last operation (Ctrl+Z).': 'Undo the last operation (Ctrl+Z).',
            'Redo the last operation (Ctrl+Y).': 'Redo the last operation (Ctrl+Y).',
            'Insert inline picture from a file.': 'Insert inline picture from a file.',
            'Insert a table into the document': 'Insert a table into the document',
            // tslint:disable-next-line:max-line-length
            'Create a link in your document for quick access to web pages and files (Ctrl+K).': 'Create a link in your document for quick access to web pages and files (Ctrl+K).',
            'Insert a bookmark in a specific place in this document.': 'Insert a bookmark in a specific place in this document.',
            // tslint:disable-next-line:max-line-length
            'Provide an overview of your document by adding a table of contents.': 'Provide an overview of your document by adding a table of contents.',
            'Add or edit the header.': 'Add or edit the header.',
            'Add or edit the footer.': 'Add or edit the footer.',
            'Open the page setup dialog.': 'Open the page setup dialog.',
            'Add page numbers.': 'Add page numbers.',
            'Find text in the document (Ctrl+F).': 'Find text in the document (Ctrl+F).',
            'Toggle between the internal clipboard and system clipboard': 'Toggle between the internal clipboard and system clipboard.</br>' +
                'Access to system clipboard through script is denied due to browsers security policy. Instead, </br>' +
                ' 1. You can enable internal clipboard to cut, copy and paste within the component.</br>' +
                ' 2. You can use the keyboard shortcuts (Ctrl+X, Ctrl+C and Ctrl+V) to cut, copy and paste with system clipboard.',
            'Restrict editing.': 'Restrict editing.',
            // tslint:disable-next-line:max-line-length
            'The current page number in the document. Click or tap to navigate specific page.': 'The current page number in the document. Click or tap to navigate specific page.',
            'Read only': 'Read only',
            'Protections': 'Protections',
            'Error in establishing connection with web server': 'Error in establishing connection with web server',
            'Single': 'Single',
            'Double': 'Double',
            'New comment': 'New comment',
            'Comments': 'Comments'
        };
    }
    /**
     * Gets DocumentEditor instance.
     * @aspType DocumentEditor
     * @blazorType DocumentEditor
     */
    get documentEditor() {
        return this.documentEditorInternal;
    }
    /**
     * @private
     */
    getModuleName() {
        return 'DocumentEditorContainer';
    }
    /**
     * @private
     */
    onPropertyChanged(newModel, oldModel) {
        for (let prop of Object.keys(newModel)) {
            switch (prop) {
                case 'restrictEditing':
                    if (this.toolbarModule) {
                        this.toolbarModule.enableDisableToolBarItem(!newModel.restrictEditing, false);
                    }
                    this.documentEditor.isReadOnly = newModel.restrictEditing;
                    break;
                case 'showPropertiesPane':
                    this.showHidePropertiesPane(newModel.showPropertiesPane);
                    break;
                case 'enableLocalPaste':
                    if (this.documentEditor) {
                        this.documentEditor.enableLocalPaste = newModel.enableLocalPaste;
                    }
                    break;
                case 'serviceUrl':
                    if (this.documentEditor) {
                        this.documentEditor.serviceUrl = newModel.serviceUrl;
                    }
                    break;
                case 'serverActionSettings':
                    if (this.documentEditor) {
                        this.setserverActionSettings();
                    }
                    break;
                case 'zIndex':
                    if (this.documentEditor) {
                        this.documentEditor.zIndex = newModel.zIndex;
                    }
                    break;
                case 'headers':
                    if (this.documentEditor) {
                        this.documentEditor.headers = newModel.headers;
                    }
                    break;
            }
        }
    }
    /**
     * @private
     */
    preRender() {
        this.localObj = new L10n('documenteditorcontainer', this.defaultLocale, this.locale);
        this.initContainerElement();
        //Prototype
    }
    /**
     * @private
     */
    render() {
        if (this.toolbarModule) {
            this.toolbarModule.initToolBar();
        }
        if (this.element.getBoundingClientRect().height < 320) {
            this.element.style.height = '320px';
        }
        this.element.style.minHeight = '320px';
        this.initializeDocumentEditor();
        this.textProperties = new TextProperties(this, this.element.id, false, this.enableRtl);
        this.headerFooterProperties = new HeaderFooterProperties(this, this.enableRtl);
        this.imageProperties = new ImageProperties(this, this.enableRtl);
        this.tocProperties = new TocProperties(this, this.enableRtl);
        this.tableProperties = new TableProperties(this, this.imageProperties, this.textProperties, this.enableRtl);
        this.statusBar = new StatusBar(this.statusBarElement, this);
        // Waiting popup
        createSpinner({ target: this.containerTarget, cssClass: 'e-spin-overlay' });
        this.setserverActionSettings();
        this.renderComplete();
    }
    setFormat() {
        if (this.characterFormat) {
            this.documentEditor.setDefaultCharacterFormat(this.characterFormat);
        }
        if (this.paragraphFormat) {
            this.documentEditor.setDefaultParagraphFormat(this.paragraphFormat);
        }
        if (this.sectionFormat) {
            this.documentEditor.setDefaultSectionFormat(this.sectionFormat);
        }
    }
    setserverActionSettings() {
        if (this.serviceUrl) {
            this.documentEditor.serviceUrl = this.serviceUrl;
        }
        if (this.serverActionSettings.spellCheck) {
            this.documentEditor.serverActionSettings.spellCheck = this.serverActionSettings.spellCheck;
        }
        if (this.serverActionSettings.restrictEditing) {
            this.documentEditor.serverActionSettings.restrictEditing = this.serverActionSettings.restrictEditing;
        }
        if (this.serverActionSettings.systemClipboard) {
            this.documentEditor.serverActionSettings.systemClipboard = this.serverActionSettings.systemClipboard;
        }
        if (this.headers) {
            this.documentEditor.headers = this.headers;
        }
    }
    /**
     * @private
     */
    getPersistData() {
        return 'documenteditor-container';
    }
    //tslint:disable: max-func-body-length
    requiredModules() {
        let modules = [];
        if (this.enableToolbar) {
            modules.push({
                member: 'toolbar', args: [this]
            });
        }
        return modules;
    }
    initContainerElement() {
        // Toolbar container
        let isRtl = this.enableRtl;
        this.containerTarget = this.createElement('div', { className: 'e-de-ctn' });
        if (this.enableToolbar) {
            this.toolbarContainer = this.createElement('div', { className: 'e-de-ctnr-toolbar' + (isRtl ? ' e-de-ctnr-rtl' : '') });
            this.containerTarget.appendChild(this.toolbarContainer);
            // tslint:disable-next-line:max-line-length
            this.editorContainer = this.createElement('div', { className: 'e-de-tool-ctnr-properties-pane' + (isRtl ? ' e-de-ctnr-rtl' : '') });
        }
        else {
            this.editorContainer = this.createElement('div', { className: 'e-de-ctnr-properties-pane' + (isRtl ? ' e-de-ctnr-rtl' : '') });
        }
        let propertiesPaneContainerBorder;
        if (!isRtl) {
            propertiesPaneContainerBorder = 'e-de-pane';
        }
        else {
            propertiesPaneContainerBorder = 'e-de-pane-rtl';
        }
        this.propertiesPaneContainer = this.createElement('div', { className: propertiesPaneContainerBorder, styles: 'display:none' });
        this.editorContainer.appendChild(this.propertiesPaneContainer);
        this.containerTarget.appendChild(this.editorContainer);
        this.statusBarElement = this.createElement('div', { className: 'e-de-status-bar' });
        if (isRtl) {
            this.statusBarElement.style.direction = 'rtl';
        }
        this.containerTarget.appendChild(this.statusBarElement);
        this.element.appendChild(this.containerTarget);
    }
    initializeDocumentEditor() {
        let id = this.element.id + '_editor';
        let documentEditorTarget = this.createElement('div', { id: id, styles: 'width:100%;height:100%' });
        this.documentEditorInternal = new DocumentEditor({
            isReadOnly: false, enableRtl: this.enableRtl,
            selectionChange: this.onSelectionChange.bind(this),
            contentChange: this.onContentChange.bind(this),
            documentChange: this.onDocumentChange.bind(this),
            zoomFactorChange: this.onZoomFactorChange.bind(this),
            requestNavigate: this.onRequestNavigate.bind(this),
            viewChange: this.onViewChange.bind(this),
            customContextMenuSelect: this.onCustomContextMenuSelect.bind(this),
            customContextMenuBeforeOpen: this.onCustomContextMenuBeforeOpen.bind(this),
            beforePaneSwitch: this.onBeforePaneSwitch.bind(this),
            commentBegin: this.onCommentBegin.bind(this),
            commentEnd: this.onCommentEnd.bind(this),
            locale: this.locale,
            acceptTab: true,
            zIndex: this.zIndex,
            enableLocalPaste: this.enableLocalPaste,
            pageOutline: '#E0E0E0'
        });
        this.documentEditor.enableAllModules();
        this.editorContainer.insertBefore(documentEditorTarget, this.editorContainer.firstChild);
        this.setFormat();
        this.documentEditor.appendTo(documentEditorTarget);
        this.documentEditor.resize();
    }
    onCommentBegin() {
        if (this.toolbarModule) {
            this.toolbarModule.enableDisableInsertComment(false);
        }
    }
    onCommentEnd() {
        if (this.toolbarModule) {
            this.toolbarModule.enableDisableInsertComment(true);
        }
    }
    onBeforePaneSwitch(args) {
        this.trigger('beforePaneSwitch', args);
    }
    /**
     * @private
     */
    showHidePropertiesPane(show) {
        if (this.showPropertiesPane) {
            this.showPropertiesPaneOnSelection();
        }
        this.propertiesPaneContainer.style.display = show ? 'block' : 'none';
        if (this.toolbarModule) {
            this.toolbarModule.propertiesPaneButton.element.style.opacity = show ? '1' : '0.5';
        }
        this.documentEditor.resize();
    }
    /**
     * @private
     */
    onContentChange() {
        if (this.toolbarModule) {
            this.toolbarModule.enableDisableUndoRedo();
        }
        if (this.statusBar) {
            this.statusBar.updatePageCount();
        }
        let eventArgs = { source: isBlazor() ? null : this };
        this.trigger('contentChange', eventArgs);
    }
    /**
     * @private
     */
    onDocumentChange() {
        if (this.toolbarModule) {
            this.toolbarModule.isCommentEditing = false;
            this.toolbarModule.enableDisableInsertComment(true);
            this.toolbarModule.enableDisableUndoRedo();
        }
        if (this.textProperties) {
            this.textProperties.updateStyles();
        }
        if (this.statusBar) {
            this.statusBar.updatePageCount();
        }
        let eventArgs = { source: isBlazor() ? null : this };
        this.trigger('documentChange', eventArgs);
    }
    /**
     * @private
     */
    onSelectionChange() {
        setTimeout(() => {
            this.showPropertiesPaneOnSelection();
            let eventArgs = { source: isBlazor() ? null : this };
            this.trigger('selectionChange', eventArgs);
        });
    }
    /**
     * @private
     */
    onZoomFactorChange() {
        if (this.statusBar) {
            this.statusBar.updateZoomContent();
        }
    }
    /**
     * @private
     */
    onRequestNavigate(args) {
        if (args.linkType !== 'Bookmark') {
            let link = args.navigationLink;
            if (args.localReference.length > 0) {
                link += '#' + args.localReference;
            }
            window.open(link);
            args.isHandled = true;
        }
    }
    /**
     * @private
     */
    onViewChange(args) {
        if (this.statusBar) {
            this.statusBar.updatePageNumberOnViewChange(args);
        }
    }
    /**
     * @private
     */
    onCustomContextMenuSelect(args) {
        this.trigger('customContextMenuSelect', args);
    }
    /**
     * @private
     */
    onCustomContextMenuBeforeOpen(args) {
        this.trigger('customContextMenuBeforeOpen', args);
    }
    /**
     * @private
     */
    showPropertiesPaneOnSelection() {
        if (this.restrictEditing || this.textProperties === undefined) {
            return;
        }
        let isProtectedDocument = this.documentEditor.viewer.protectionType === 'ReadOnly';
        let allowFormatting = isProtectedDocument && this.documentEditor.viewer.restrictFormatting;
        let isSelectionInProtectecRegion = this.documentEditor.editor.restrictEditing;
        if (isProtectedDocument) {
            if (this.toolbarModule) {
                this.toolbarModule.enableDisableToolBarItem(!isSelectionInProtectecRegion, true);
            }
            this.textProperties.enableDisableElements(!allowFormatting && !isSelectionInProtectecRegion);
            this.tableProperties.enableDisableElements(!allowFormatting && !isSelectionInProtectecRegion);
            this.tocProperties.enableDisableElements(!isSelectionInProtectecRegion);
            this.headerFooterProperties.enableDisableElements(!isSelectionInProtectecRegion);
            this.imageProperties.enableDisableElements(!isSelectionInProtectecRegion);
        }
        else {
            let isReadOnly = !this.documentEditor.isReadOnly;
            if (this.toolbarModule) {
                this.toolbarModule.enableDisableToolBarItem(isReadOnly, true);
            }
            this.textProperties.enableDisableElements(isReadOnly);
            this.tableProperties.enableDisableElements(true);
            this.tocProperties.enableDisableElements(true);
            this.headerFooterProperties.enableDisableElements(true);
            this.imageProperties.enableDisableElements(true);
        }
        let currentContext = this.documentEditor.selection.contextType;
        let isInHeaderFooter = currentContext.indexOf('Header') >= 0
            || currentContext.indexOf('Footer') >= 0;
        if (!this.showPropertiesPane) {
            this.showHidePropertiesPane(false);
            this.propertiesPaneContainer.style.display = 'none';
        }
        else {
            this.propertiesPaneContainer.style.display = 'block';
            if (isInHeaderFooter) {
                this.showProperties('headerfooter');
            }
            else if (currentContext.indexOf('Text') >= 0
                && currentContext.indexOf('Table') < 0) {
                this.showProperties('text');
            }
            else if (currentContext.indexOf('Image') >= 0) {
                this.showProperties('image');
            }
            else if (currentContext.indexOf('TableOfContents') >= 0) {
                this.showProperties('toc');
            }
            else if (currentContext.indexOf('Table') >= 0) {
                this.showProperties('table');
            }
        }
        this.previousContext = this.documentEditor.selection.contextType;
    }
    /**
     * @private
     * @param property
     */
    showProperties(property) {
        if (this.toolbarModule && property !== 'headerfooter' && property !== 'toc') {
            this.toolbarModule.enableDisablePropertyPaneButton(true);
        }
        this.textProperties.showTextProperties(property === 'text');
        this.tableProperties.showTableProperties(property === 'table');
        this.imageProperties.showImageProperties(property === 'image');
        this.headerFooterProperties.showHeaderFooterPane(property === 'headerfooter');
        this.tocProperties.showTocPane(property === 'toc');
    }
    /**
     * Set the default character format for document editor container
     * @param characterFormat
     */
    setDefaultCharacterFormat(characterFormat) {
        this.characterFormat = characterFormat;
    }
    /**
     * Set the default paragraph format for document editor container
     * @param paragraphFormat
     */
    setDefaultParagraphFormat(paragraphFormat) {
        this.paragraphFormat = paragraphFormat;
    }
    /**
     * Set the default section format for document editor container
     * @param sectionFormat
     */
    setDefaultSectionFormat(sectionFormat) {
        this.sectionFormat = sectionFormat;
    }
    /**
     * Destroys all managed resources used by this object.
     */
    destroy() {
        super.destroy();
        if (this.element) {
            this.element.classList.remove('e-documenteditorcontainer');
            this.element.innerHTML = '';
        }
        if (!this.refreshing) {
            this.element = undefined;
        }
        if (this.toolbarContainer && this.toolbarContainer.parentElement) {
            this.toolbarContainer.innerHTML = '';
            this.toolbarContainer.parentElement.removeChild(this.toolbarContainer);
        }
        this.toolbarContainer = undefined;
        if (this.documentEditorInternal) {
            this.documentEditorInternal.destroy();
        }
        this.documentEditorInternal = undefined;
        if (this.textProperties) {
            this.textProperties.destroy();
        }
        this.textProperties = undefined;
        if (this.headerFooterProperties) {
            this.headerFooterProperties.destroy();
        }
        this.headerFooterProperties = undefined;
        if (this.imageProperties) {
            this.imageProperties.destroy();
        }
        this.imageProperties = undefined;
        if (this.tocProperties) {
            this.tocProperties.destroy();
        }
        this.tocProperties = undefined;
        if (this.tableProperties) {
            this.tableProperties.destroy();
        }
        this.tableProperties = undefined;
        if (this.statusBar) {
            this.statusBar.destroy();
        }
        if (this.propertiesPaneContainer && this.editorContainer.parentElement) {
            this.propertiesPaneContainer.innerHTML = '';
            this.propertiesPaneContainer.parentElement.removeChild(this.propertiesPaneContainer);
        }
        this.propertiesPaneContainer = undefined;
        if (this.editorContainer && this.editorContainer.parentElement) {
            this.editorContainer.innerHTML = '';
            this.editorContainer.parentElement.removeChild(this.editorContainer);
        }
        if (this.statusBarElement && this.statusBarElement.parentElement) {
            this.statusBarElement.innerHTML = '';
            this.statusBarElement.parentElement.removeChild(this.statusBarElement);
        }
        if (this.containerTarget && this.containerTarget.parentElement) {
            this.containerTarget.innerHTML = '';
            this.containerTarget.parentElement.removeChild(this.containerTarget);
        }
        this.containerTarget = undefined;
        this.statusBarElement = undefined;
        this.editorContainer = undefined;
    }
};
__decorate$1([
    Property(true)
], DocumentEditorContainer.prototype, "showPropertiesPane", void 0);
__decorate$1([
    Property(true)
], DocumentEditorContainer.prototype, "enableToolbar", void 0);
__decorate$1([
    Property(false)
], DocumentEditorContainer.prototype, "restrictEditing", void 0);
__decorate$1([
    Property(false)
], DocumentEditorContainer.prototype, "enableSpellCheck", void 0);
__decorate$1([
    Property(true)
], DocumentEditorContainer.prototype, "enableLocalPaste", void 0);
__decorate$1([
    Property()
], DocumentEditorContainer.prototype, "serviceUrl", void 0);
__decorate$1([
    Property(2000)
], DocumentEditorContainer.prototype, "zIndex", void 0);
__decorate$1([
    Property(false)
], DocumentEditorContainer.prototype, "enableCsp", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "created", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "destroyed", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "contentChange", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "selectionChange", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "documentChange", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "customContextMenuSelect", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "customContextMenuBeforeOpen", void 0);
__decorate$1([
    Event()
], DocumentEditorContainer.prototype, "beforePaneSwitch", void 0);
__decorate$1([
    Property({ import: 'Import', systemClipboard: 'SystemClipboard', spellCheck: 'SpellCheck', restrictEditing: 'RestrictEditing' })
], DocumentEditorContainer.prototype, "serverActionSettings", void 0);
__decorate$1([
    Property([])
], DocumentEditorContainer.prototype, "headers", void 0);
DocumentEditorContainer = __decorate$1([
    NotifyPropertyChanges
], DocumentEditorContainer);

/**
 * export document editor container
 */

/**
 * export document editor modules
 */

export { Dictionary, WUniqueFormat, WUniqueFormats, XmlHttpRequestHandler, DocumentEditor, ServerActionSettings, ContainerServerActionSettings, Print, ContextMenu$1 as ContextMenu, WSectionFormat, WStyle, WParagraphStyle, WCharacterStyle, WStyles, WCharacterFormat, WListFormat, WTabStop, WParagraphFormat, WTableFormat, WRowFormat, WCellFormat, WBorder, WBorders, WShading, WList, WAbstractList, WListLevel, WLevelOverride, LayoutViewer, PageLayoutViewer, Layout, Rect, Margin, Widget, BlockContainer, BodyWidget, HeaderFooterWidget, BlockWidget, ParagraphWidget, TableWidget, TableRowWidget, TableCellWidget, LineWidget, ElementBox, FieldElementBox, TextElementBox, ErrorTextElementBox, FieldTextElementBox, TabElementBox, BookmarkElementBox, ImageElementBox, ListTextElementBox, EditRangeEndElementBox, EditRangeStartElementBox, ChartElementBox, ChartArea, ChartCategory, ChartData, ChartLegend, ChartSeries, ChartErrorBar, ChartSeriesFormat, ChartDataLabels, ChartTrendLines, ChartTitleArea, ChartDataFormat, ChartFill, ChartLayout, ChartCategoryAxis, ChartDataTable, CommentCharacterElementBox, CommentElementBox, Page, WTableHolder, WColumn, ColumnSizeInfo, Renderer, SfdtReader, TextHelper, Zoom, Selection, SelectionCharacterFormat, SelectionParagraphFormat, SelectionSectionFormat, SelectionTableFormat, SelectionCellFormat, SelectionRowFormat, SelectionImageFormat, TextPosition, SelectionWidgetInfo, Hyperlink, ImageFormat, Search, OptionsPane, TextSearch, SearchWidgetInfo, TextSearchResult, TextSearchResults, Editor, ImageResizer, ImageResizingPoints, SelectedImageInfo, TableResizer, HelperMethods, Point, Base64, EditorHistory, BaseHistoryInfo, HistoryInfo, ModifiedLevel, ModifiedParagraphFormat, RowHistoryFormat, TableHistoryInfo, TableFormatHistoryInfo, RowFormatHistoryInfo, CellFormatHistoryInfo, CellHistoryFormat, WordExport, TextExport, SfdtExport, HtmlExport, HyperlinkDialog, TableDialog, BookmarkDialog, TableOfContentsDialog, PageSetupDialog, ParagraphDialog, ListDialog, StyleDialog, BulletsAndNumberingDialog, FontDialog, TablePropertiesDialog, BordersAndShadingDialog, TableOptionsDialog, CellOptionsDialog, StylesDialog, SpellCheckDialog, SpellChecker, AddUserDialog, EnforceProtectionDialog, UnProtectDocumentDialog, RestrictEditing, CommentReviewPane, CommentPane, CommentView, Toolbar$1 as Toolbar, DocumentEditorContainer };
//# sourceMappingURL=ej2-documenteditor.es2015.js.map
